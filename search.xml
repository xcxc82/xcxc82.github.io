<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2022/12/2小记</title>
      <link href="/2022/12/02/2022-12-2%E5%B0%8F%E8%AE%B0/"/>
      <url>/2022/12/02/2022-12-2%E5%B0%8F%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="02bba5906fa0d9eae7a880daaadec74e1e37788df1b7925dbe2d82118b41df5e">4630436162ade97ba2718b7d0c4b3b63aaf3284bd84dca750135f04888824a77e283e4531aa01e932a8b1815ad26da52fcafa1b7191e5f2d2ec783fdb51149b0058f7a41d5f4ea39d0bfae46dbc8f60888601bb7d4c0b47abd8e0bc8e7578058986e86e7097638f4309909e7c26df805625ad6ba4515480a358e38891b6a418435cf23485976cc41008e0ff9758055c1fa2b7a680a1c0bf74af8e5ab5620272de8ddb634cd93b47061f9c7ab35ad070020d201a85823852254585f11f53a97e0d2f18b88beb29a7dfc98c8364ee3cc597dee85a58943dea1b4bbe4834f029066e89c4a0c28d7f74de51c83f7f841c4b9e55243ca921bbc310428abb380f610366a66c9b50a1f48e5665d4b5e59b037737f741542ab72962bacf45fdd199138b66f099b52c03afb451bf6f5e3f0c124844b743773d7d9da1d26befdf24e62780e4e4545ea5cd9cae85623a877d63e8c6c31a1c70264fc4bea1e70d11461611fefd6925642821744963de7f0f84af61699e7deacec2ebe8b31198bc60da88423fd7649ccb9fc92015a43e350b738b01029e0315b5e5ded7e5c298779a717249b0c26dce8c9ae3dfc0054405d79bbf7f1295c63181a277d5ad36e7e7e4a190cba2612c9075d85e133312b9db208ecb9b06c2ab5c4638dcc64533539c725f7c6ed21ac7fccb389677e38664e35aba16cc6b19cdabc2400577b7453afc8857bf8a94f9b9ce054a1fd71dedf688fe57df238969ccfb974a1b3aca426370679e69a1d081d6ce54a239ea81be1ebf37d423e1d6df36631921415ecbcde296684a2fc54bb215448f64cbb07e10a6fadf21c7ef4fbb97119cadbb1e3391f8728ad9dbf5f00cfc7a02769ec2bf401c2cef9da4701e55672681214e39b0af7220bb8bd52b9e0582948fb164b6ebc1f75798e6679b5c2138139ce7d0c0393b080314b818f8deb39b6ea6dc3a19e75447871fe39e476c208053d01acfcb01e89564098d0732ac82a40f0f2d25ee5c29c88e2f28069bf595699c2ffb64c08ba78d834928760270825e2ff01805eec213358b60c7d0d2c3455867a49e0cf195b206c78bbdb168bdd8ce7f432cd8f8d54f9ba3babbd12127c39e1806bed583d66e9125144ec4e5a84132ec52a14837d2618dedde58921dbe02020fe9c24c0c558f169c0646e86d4dc49081123164900734b76d80cdb9b6d1b6a37d63c0e3ab07f71d0b396be77d51aeb6da458476d08e3e56b3ff324023e93c628005eed566edb16c0b973c005115941fa03c3bde7872ee2b5cf9676336b813514094823a2a66ef8fcfcf22028939543650000c2013f892f1a6ed9303ac58aafbe9e8ef809f2621672af83e35b5c12dc278ffd955ddd5a97a8e3ef567a5847ad6e72fe7a8ee90e810806edbd9d61a6189ed35140697f10a6489acc1eff74e0e75363a5cd978ae9fe2bfa003036b20d2dd894fa13262d81b32d874b21635706b9ded5ad852dfa6a400c2ddcfcd133942641cb3ae38a5e2a2bc89c7e465ec6bcf2993a14ed9640a1e77da5454d392c1ac88773c8f0f0d23fbf90f9ddc0c2c4eda0b05c513bd6a6f431a140da1a1d1167324582daccdd182830c0f84d61d7648b9b209e7747580d82833d968b05826c311b72006214f02a7eb7673b0d92c6bd2c9b62f273e21fd61391d6762e36719cbba1bed59772131ad2cbfca7bb0f658ddbc194be0f5a402181174212457290a74c8bed24da5b46a98e3e2b3d9d3175d5d0482a5119bb2e91d12d448fda8c3a381783ef6f0730aa62f8562102b6e529fb461051de20923ba71e76c114acf7a52660e3ae8e8dc578f834d1f5a2fd0a633c0153702c04fd84a3156557fae7c2502f027cb44be80b25dbcada3fb1692f8592b1f13bab3c719ab823074fd3474545d5a0c7a32d71d1fde522ac92aacf56e59a8efad86d53d50ae00191225e70760d6650901ed5d790557586c1db847cc30eb46c8a5b6c2e4e2eb5d5ddeb70c29ab6daeff479dcf8c191b3f3735a202b65c2adb822f10dcfe71524adf0f64c03f07cbcba97fd9c3d5084c02e2e286c4ae241f0f83def09edc08bf04641c18a3948af9c0d08d77044a87746f3b414a27e58ff1d426b43f1ba0bcf4acda82003d847a5d2e50e48caa83326d1cff8ed3d3dd17bbe975db32ab868ecbcfae6d306bcba283831f72841b6267888796fb91f4951606d98a8c0d7cf9060689ae863b2c372a4d552e808f05fcd730dd7480cb8b88ced59535c6f78a1eb8651b48d1be5823f4767688551245a876aa0883840063d1ec79c17908e86a418397a6607fb1e06de8b75e4808dc13eb45bb01f47d7999302811b99efa88405a2b3d84040c5fc57ed3dc52ab0b899b3e204806203f04611252bc97847d56433c14cb8a40dc909d317eca876ba95876596b0a4889024896b605b7c5caa2d5c260b15960b6a9d5a69759411a889c7c48d358d4dc0740be3198f5ccfd42c83d3792e289bed9230d8dbde85f79944af553202181e7aed38e9e7a06f10a71767c1d2f7c6fc612fd8c07471f0e8228aae4be5114d1737e0e4f7e0c299e8649888621c63abd406256e284943043e9557e5be4c9ba079481df76d67e97d21707958f05ea2ff85d20adba099decb261674b55ca7b60a987b59293b24b08ee7477e0830fbec9c97204892873fd1f83d1cc27c4bfbeff4ca5df3b0025ccd6c5955ada973ffaa66d1f8c7fd6c32103075c74b2ddc2d9dc009b4b11e7ce70485c621500829697bbdf2f15a856844a1422f5d06d53c35a5f32b693ce75e7dbe626750a3ece2a175eb10b9e9ac082ce284745882ba3410427d1ac0b7267d20d99402e2a2071da084ca1120806a620fccfd8b1dead46c3d5fda7a7f80930f7513d16de166eb56c119181b249a79a01ee95d309c18d558266ba29b854806e486191aaada40491e6c7940d67a8afb6121d6393a3c28a6b4985a59b39eca6e4fac515777bad791578595850612d1072327955113ca1217d7f68affc9c6e8f49e22e9400b89efb94b78e83e93726732fb8391390b88928832b08d27bf72159781f11a53fa236f968475ca234ede111a38ea34f5ac251da4c45c5e5d2ecd5553964a8e89a9e3811d5137a4637deeb414cce44196b997595a1b3b3c553722e37985fd804f50dc2c7544772c72b3de82f86b4df627b406caaa085ea6a9fcc8b3872b2863b1cdba62fd8c64d82a6c5204e69838a310810c16a157620523bcbb6aadc00340e45552a932cdb27da0946c7ce7d08427b7eed49366817204943adaa9645a422590f6815d66042cf3d97713b3d0cfad87c15aa809eb2ee22328e9b6a32f76b03314c8fe6565f24e09f9bff183cef1e925223ae861cd3786b0f02e440a78eb1e3b9edd5e6cf73f0ffaa2c9ebc20214f27fa82452592fe6bb434a035ab2f647051c71b41af261f2042211477f3b075d1eb938d0b5d989965cc19faefd81124fcd45737a4bfcc322702b6684136d15efb3e3bddfdc852d2ccbcd7b11da1f927957fabaf091f79ac7df92b0ba991d7ac6952e358af425472dfc1cc58f7744a2bee19ee71141ff6e2df0daacc1b3d0f10fcb58a425ae7ed9f2d5e7947e0bee2b83858a70323a9328f38a737b31b9877fdff24edad64f66f8573a9dcc286c943600286ed696aabcf7b97589935eea6f2d7004ad3d88783d50d4faf0dfc43b9514279d49256c98c75e3c1fe4df92979d67536013ac29928d3bec611acc6fa8f9ddc5246cee33b24f4b3bb3959c7896448059bda98ace98e217d9e5b5601b0141cc38cc900e488cd99012f7c9b44c55c61977bc9db00a39</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模板库</title>
      <link href="/2022/11/26/%E6%A8%A1%E6%9D%BF%E5%BA%93/"/>
      <url>/2022/11/26/%E6%A8%A1%E6%9D%BF%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="dc0525aa316736c1d840217958312abb6b8d49d899a515bd2feacb577b11bafb">4630436162ade97ba2718b7d0c4b3b63501b8b0e90dd70c68cacef77fafaa69c364c0b82b55d0944338e588058a5d0dcf479293eb2757c76fb3467e13945d28cb6c5cc8e81884fa142b107c68e8e97ad0f53802c203e951a3bfe271407c110e462d703f269b6808039448c0db7b67a7be92bfda08e83cedf1c3301dac78b1e8cf86df0de2ee8878204ce0f5a40f6f6d446b069ae8de5c224c3ab66f56e4abfa3129821f23a092a32071626aff9c07d3c45b5b913e48070c482c548c1e3b815fbc3f7d2d05b6d1a7d7a03a53c0f0c22ad8d17e426c6ee46f436f5b112a29059d56968c14f18e16a94f6e93f864a6ed402589fdcf42f8fdf939d0614139923affd61b4323e06d468de353d551db6b42c00c3d2923b1497befd8cc28ab1cee6809711a3ff8fdba5d78dac02d9e9a43f211a44f875b4fd052bd4715957b5f14378456a551a4279223038f81b6b6aa8a06280ae0348ddbdaba3c346b59ecaffb9c74e1dda7ad872dc18c438464123c1ec1b5cbe5fabf8e30d7f83b38ccf19d478def584bbd6ac455944f588c6ce879111eeda30dfbddba194f0363d696dda518cb2badb970887cdb7669e1b9187f650f4b870c42c9690c70c7d3096fa61cde44a39470e9ee65226a4ec7e05ba69757cdaebcd88257dce8205ea68cec58cba7870ccd0758e1c1e8b3aecac98961edfa81db7955f65b2509d0dd86c9ae0211f5d80f14e70799fac846b92c527f481e05bd2d3953fd0cedfa96604428762ea3d3584249293d56451b4cce7618324117146f4658f4244cd1546528a7f318f2a475d570c94308b0324b6dadd6d10c5056e5d8fe17ca81a927714d9a74c8c778c214a6c3ac7ecc925bd69be190fd654a59e6739bcfa86b01f79742545e88a218a2f0809d67d244bf3a6c3a8720c18f8748f69494ff96ed3f0f7e6a862d1557fbc522300a739516d414186e298608122cfd70c1352757fd10d8bf8a74bfa4d41b5f6e0a1a948afd94aa214cd699d3a8d0573175136064f54fcbe64a49217c939a9ae02d6ff449248ef646aa3dc3883b504260ab5b7db6567dda17db6a4cf24cdd813a76009cf2a7da0e8e78108ea4ef986975e39787aa1dfcef12b16730bd69d05686a3ddc5c65871d6dbd75c6a772430e27f59895d9053b2a2ffc85a6fc08274d91294686254b84a540edbfb801f2747382047f1179c3636b10d29b017c8ba03842cac164b243d05c4062011c80a481bbabb03b479b8438d02d81762b93f0e87b3df2a8fb1d60f1d7f7c4976be7f26abb8537ad7113bd8668ce85d94564ccc74d17e4fa1af58aa6af17233cf17f620896f1d691b1399c70d9c86e0ad028e3b8c70ddce28ba1b6c8ee06cbab75724ab5b4f3a65d0297a610f5225fb5aa43d1a8f1d6a826a962a5f2d9eab0899563a4023c6cde3c2c954c5272a0d358127f8c803c42a25b183f538718f3b9ea82c23515c236f5cf351841e2e708df43d2aff00892670fefb4e8bbf64d2994c47f0f29be411017ea6bbf76fa1bde154e81df13356d88235c56225ee9877efb8407c724cbef4ee0b5a6abeb473a61a7ecd29c1d4a4af7de879c4ee0f8f889c67a0b5c2fffb9f4d2869a56b56e4bd7727445667ddebfdaf4bff8177b96bc2aaa05cb99ee24ed133407c6f9374ac2e8e4ccc9684495edcc4d173930c60d0c2f69369090e12622f23490f3b9466852365480fba303794a983e9808aefeea81de0f1b4497beadc5d7c9817f2dc7eb9be5e608f605dba1f87ab8375f015ef9310c53f36aeeec81b2f7cb9abdbd008065619c2ff5ac3661252e1570028167e9c98361e330a966a4baced2ed829bfa5779de1351d6af300465faa73e26874821e31d0dde2136ec5be295067994e0e15c2576f5fb27ea56d992fc16d8f5e28a989ce3254db9af27738c9e97aadbed366c29c43db5da2038baf9f6db4233be70fbebfdc8aeb38d6a74623e5311992788048df2fc6bf900fee08a45d834a5396c0778a871a452df267cd37b918949113bcd8464136f68ab6f66ba54aa2614b09258b25095b16013ece211d913c7e6d980615cb354b870e88ec00c0f54e82fae04215903d1e64072575a978a9dd95bc13a2385b684106ebd517d93b2e70b5cdf6986e8236a15924c44c872723ad85cf9d6ece3db91dba3a3660ebe755e71dee24fbc02b432c5a88c377a4bae73c834af0bcda56a90f619113ad8f10289129296b7b9ecfd25b0bdc4c926f4e413ea40adcba2d74b6fa1249120bd2bee016f8ba1b6f594ecca49efed9e762c0482bda4924dd46b0e48486c940b1d6ae6cdddce5b62c8b7afa45486ad189bfe521ade3b21d000447b7842a6acccce9740dd4d6e4b5b14d555afa8a6eb32bfe6e06b1399fb4e83c94572e81cd607f7858087ba2d20392e0a0baa6ee17046ba212cb36fcd9270ff71c2b52477806e67b7dda517ce9fd9e0ee8a30c0c6928af8b11397dc114e160e09f80429589e635bfd7e2e2f94bb0461397c414b02aa455822e8c8602bea3b0d7c34ab2140f4ea6d547c7eee7e2fe10fae55a66a8d65d233dbf18599137586781fcf402dd7239b9fb5059096a41d190195cfbde772ed06eafbbdad864359c626e661e22c3bb79fd9e8a30b490744f98a2d47a8a36075a78ee416b4ab5ef3fed1c960e15939b1257ae1c7d6eeb6d8ce56ff218b7eaf6b19db67657e60cbd758c4fc84437c2b051734ac918f95263e71fbbc79376ec5e4b734081f06495f586701d434b75532223116d9f8b8031409979a529265340319772c2ebaeea08b9f4abd41d59898a37894478b24d68c245aed235ab49fc2f9bdd3f89cdd0651f9c17b46c17b959e1fff6024ec78ac394ae333ae7804bf42e8fd322d72d646afabd6ae534aebb4fc1612be65dedd0e5bb3d3d5842366f5cd84da90d2a1c783559f97cfd1d2c87c15b983a752a1141f13e594749aea8e25a021671e06c04e5a02109cbcc479854e3bdde1943d00fb0e56c3010ba7d60db1550b610683e55e0dcc7dd7a1bccb41af5add5811ae3d1467a8f7f34964b531c4dbce06c342b75211006ab47138a87c859f3edf85c15c51e4ad1803f2060bb1dbd20e1081c8c602283e9d809f0886005a164cf6b4d1ab52fc81801aa14c9105fefbaa7642b7981a4ead48241385847718464dbe95cc614e81a5d7460ba3bf086f32f4d3432ab9929714a61d92cfb7b3979a53b130e23bfed839f83017cc642d27e87e510a0c86358ea7795f9413a6175b051bfa5a2a5ee8929459d5abef52f61506ed9e34fac52321eb94e16fb180d0bca36fcadbc3133930042cce8a05b9b55d2dd45a675cb9b0765211896f7b00d6cb3585de6e855daac271d998c648b2d2eadaa054a19f9ea9b1163590a2b8799954290da77cc6a3d57d5523f559c761f53bb6808ea690cdcbe994a36c297925ae58d2384b1e6a397f3b44872a05769c372700f7582763344f459aa89cc69e1b17e2a1cc0212df051d84e973f274b7e21d202ebf703c00266a8f195c6eaf1490a86e2f1592b02f85b7ff000e3cf45545d2354220e7695e8c7080dc901f87ba5d92bc91a46ff14218fb5055b231141aaadb2cb85783ac303e66cb06b9dba6f97dd777eba62ad208a3baa26b2f12f481f16e0a86c6e3fe2fb810168ae029e5547ed5a4c00e43cc81745257182d8d76448989705bdbc02049a5502b35afd5721161fc4c120d8d5601ed7a3dd7a7a85741f3b040d54d7127f35b22bc39c75f7acfc37830466908fde67db08d24f8175a93b0439d5adb15fd8d13f348da1dfac9615cb3ffd54d1a5af5ef973d40b2cfb6a441fe05c283313add860096d826ff18c235ce942899439c36110a4113df4ac93f601edaf86aa84efe7509b4cd15bea482cedd92787fe4279513765d035b4aed95e346abf83dd0659edb75fe90f63f7155fb6f841b22862042fc68ded2198f001b4bd02c2504980b86d7577605d01125492d822766beb23af874c2ef947e7d1989a3d0e70b87c4eb87021f2141a1081cf47bb6db598fc8046b5af76c5d60d7b588c663b152caf4667a1b3bf920d72c50103626d0ec5ab28628e79da92aeae517d169386a70539d4570b8a6e0807597c6a5a0e697f87c9a3732f5eea6e7e1444f837a9718c2777b611659836b46dbec6011d6603e86e2e198a47dfb54fc61f10809876c1e0a185a341bbe73621678e7adf857003995dd75ed4c286224338ce646b39fbbdaf7fd135360061b9d914d73ce95d9dbd0a83bcfe1274054227c8b206a098a7b84a928578e95acb1d3379a622cd497ee78518a7a8d4b82fccd6a9fe6f30277a8ad5ee362d307a38fc11ad430acad8487c5a91f4c70dac5636bd87465a4c58c108e58f3ed0a6a605fedf998a622ff35f0f4570177f8ad616fa9ca0200d36f9c12cb16d870b9f53c0ad65ed1a0ad98dd64b69adb623fbc584a289b3a639385d2b2bb91fcf99d82045fc76be8b6dde81426fddd4cf692b7c79a5075185d7c5ad6e168468699c25bc8d3fe3b61b254c8b8806b1046863d50bc9e2eec26ccce57a911af65a30f9c6abdbd52e63c22f218d9137f3a7c0a4c6ed560bf9ece6a9e1348404aa6dc3fa6987d5542513892d3426ce414e402446bc30641118ed63fe582318db49852692050937d408b3275a90479902ae21c26bce96e60e1a488bf49cd255d45d158deb67814bef925c5a4a6bd718b39ec4956717201f7d27c139a47e51777b085a4999913e4ad65fdbc9e444233c650ba8f640cd13b57174ffc8234c7f0eac88a47f4c60560017ed4f81b9d5621cb432c91308dbf491a4222e83524b6bddf48b4d0f5a68ffa2e4612a1d0e5c87a01e77ce58efc609f1cf42908a82cc513042591f96115d25f1e43a7e133b3a72e52b3d38e19c553c575592cca6b20f8c09545756bcfc12dd3bb242ac2dfda5d47cfdc33010cf68d0a665f1d2392f7c736a0c45677ab6950c5274333501185e82055fafec7551919e9641699a18b48999f632481d909e0d224b5fb105195d40712ed53cdb5dda1349152c100894fd3d55d1d39841b92f49da1a7650cbe1190f0c1c171a464f5e71be856757123d75f80ddafdce1d681bc67e28ecadf80995622a675bd1848783ee78cb4daee564234a2f11ab3ac76784087047c6c0881055f2c1585aa6392c78f67a4f1816f6c4d1d7d536531de6dadec5baca6f74b787e6601ec345b8ada9c2b9485e61dc422d19782ba8c31fa840127c0731fe31e283c8cd25ea34481a79c6e5533d28d4a08ea8916c4d0309dc3914dc07433f361056b6f6d6301e6c54a3e446ecaee65564080cc261a93e6393b0ef53fc78648ddfb0bb941c63148edfad8fca979381f2afe0ad378b1f744665750001d9daf8e1a5f44a5f7630a76c6b428d9555cb09337f1b15185d28e4ca523ccb7c8458f188c23fed636aed4b146b7d1b5bc1471cbbae84b48cc0746739617681f84e9c1fa57fe523b59e285e6d150ee075985a50706d784284310848d667879f14cc375e122aef0732e0e8e1393d3d68316e5c8685f1c9aa3aeade36f9c1d61cf8325ae487ef917d7570f3b2363429fa9ba7ae3c84b72e8927e8f3c977c0559b666cecad5895eafc2879711889d664371a1bc53deead847a9a6e4f95fce7a99bf9db9197745e00dccee68b59d7f766ed08089f9afdf4f53f00e8ae8e5049317c3236fba2e2bf84d2299d59c7ef72c255c9babfc64e18ab538ca0adbb660f845644e95cef80f700bd3165c4c44d5f88c56ab42b6c4d13412ca3a1222bcd66b85623cd7e47c77519c117158b17a4c7b758617809adbab87482e4a0a38030a17f7ed10273cd34aa54e745599077aee8af6783560ca3043be07a052651fa3682b5bbfd50ef5687b0f9c1a9cddcbad4ed9981c38129b6fb21430f8e813aec007ab59ac23ceab532ad411dee2c051a2b604114791c10070c4e7c22586362ae9b192dfb27acefa5fb6f9fb4a0afd9d94d796a08bcbac763bd9d2e22ecdc7c64b715a86715d3877922e084e0e9cdc8d085d2381d8cfa980362ecdf42705713059f09800981932fc7786a379ba11294fd32e712addbc82d9a6064b7d3535f6a53bbe8a51fe1ae7061365a159e174d98f5b1217e8d4f4b2181fc1eddb12528c825a82099229fb0dd8b64424af0df985aca5ea24198b0fbf33bb04199aeba633ed5a4e956cbd4d6d5d56783e8aff1a03cf837a60e7dbc113cdabe86f71c8157b10d73e991b346f1e70c5a7a1bebd57b09f902671f292bb4823ac7f974a9a5704bed8d47687905864965a7e405cdaac8508af11d8871a21a5d58497b83cc1811d8149e12c41b4ca907bf97066e95f6d43c1a4b95b43b40e312999d667b0c7b301032d90498171d2c6273967b0a545b48a3dc858083551836956f944931efd3f84658544cca4ace60bf12ad2a72dfc5c760469ffea166d17e7b0a2d501e2b8acdfc6bac45d62b61d2b8e270fcb7cc87e4a36b758f33bf600ca0b93bf66fbc4e4ac16de703f762f7f21283bea6ca5c847f10d988fea4751c26a80ea6db1dc6b712a9baed1265fabdfae8286055e56a9b5fc588dbd663e39de33c4361d5466b9dba60c63fdca4f8bccdebc8d743611e14c47f327bd771366fd41339881c9eaae42ba172ebd18f56fdf918d0866f8423026bbbdad800a2db5937cb71e3d407d9bf9713171a8fffe5e3e333b58e90a1a394540abdb303a47920e176d1ed8e8b4aa4851062933cfb87403204182190ac1186108214b76a621d5a439b571046a1369131746c62abe87e2d63ca66a8544578f6915354279b72638702bccd0c734acb52c0a08fd4c30f7f41337bc8607a1e80514ca7c50f2cf7e67c33fd72f0d6be0c4a38837e26fc5f48f2aed082dcd2051896e0904e55e0dbe9018807696deb72d16bb9a3a6dd24d84db24c20a3282e1130bc4f30a046b1858db6e345a6b6772609f0773f3802b9af6ea8b66876b294f0f5617da61e0429cd89f55a720908d09a580298595e26ba6a5f1953043f5dc52f1f2beaecdeb6dc35a62ba452bae9afd8da743853656a27ef7b837eb0c8757a6fa1c5e233dcd32c5711975709c1f1b35e183d41190bca435fa518c322996336b27e96fbf9731c6988d551691c0e88c9363cef13b48c948c9bad851e4c6853796069d1fc61665d2cda367bd6e48f77dbb63a224733d3cbf98e7e9f981c8aa8ee7379ec3bf16573e1859654f4ced52b93aa97ebc7a46a52d18fecb9b1e73f7d542c2889de42380f7eeaaada54fcd96ee7fa5a94cfb3c3e81878b9eeec183bc416525afa6a90875fced87db11103b159ba9a61089f5f0b55642f3b48f3036bfa086b8e3c4b40c7d78f3f5f9cd0f40bb225804800b1b25918c7dcb1cc1ede6f5dc604f4f5e24d06e4eefc56fdd8eaf378ceb0b3d442b636859d862447dca2c34b47117c49471f2ffda6fc90c173fe42cd4c840a5c32c6d909a164e39581ef04208ca360237a61e7aa7a6d85bfd73f9c2c1ba3c87a78846c150960547df78bf75ee3509757575ce0fb47deb4b5ee0f7c0a0fc956f952de463fcc09bf83b489f2cee1dd41961e574e8a975490e41ba5fe7ae65dc2b1cf2afdbe6596104cdba88b43549c15ac33b80749c887aef421ad6a811fe733c2be6b70f99df62481a136c2ce8a0f0836dcea9882097c0105673e47a3e179cce2b8e345d7e0964a31c1f752cda9192298ad0cbf9b6945befc507d7c778ed2157b2fd522a9239cf014c48f28b11ab3ab2196fa34e73326bb61169ec77844330459da71550a4135ac273054f6bac03ab212388a3d78469d81e3e1ab3f4c441e3b7cfcacd72dc58128004833b7161980346dff5d8fa0fe32088bf520e35ed994660745d4d362ea741d58b96f210842631cc5dfc634ee5eb7bdc8e6b6d7784b7923fe47a61bccad365d6c282826847fc5d397ff057f0cfdd3042ad811175c12e59db0f73674c013adc4d593ffa595f5dcf18e56ed6860d22577054f5ee88b51bf27e0c52547287a3969500a958113728014dbb4168c9a42b33c71caad893462283525888c1d27a7ee56f7ebb12ac42186c44300ca6f341746099bf88e157188099e1171ee500030e108ba767d330540683f4cb8d9ffac2bf208914d29c58eb49160ca39246d63f485568a7eef3b81d77b34d61de9406c6e1b9251b490d39af4bee40d541760c12e67db9f2065be4543e97d9bc444b92909d84fe210f7a106c3b21b4c03c9daafcb27892742f62b5f1a18cdffc2eca46c10e076503e779c3871b740b19fb18b0afb1d898d6c2ccaf26ca11d40c27b9cbdd93ef42cce4595189fb1d51ce6cff6bdda213e260fa2fdfd2147ca915232b9fe0666d4d81967ce804afdcdd27dfe1a081aa6e9cd0db20faf7d3f480f38cd9090a6b84911abe8ec00fc3efc62d0a1e6c5ffc61280fc83b0f317fb33b9b5c60b6d1dcb5a3bf33214f270861008200a94c63c9a2c555fa1235264caa7912482e735e0fd9e89b54cefb4e992574cf7ab1010d447defd2b24139cfbee234c239a12c8be50ed295d6f3db437d11520d2c24904aa6360621000faf0582ec38cb2cf5531279481d8eab8a10b87208983e3fdc3785db2081e514dd50688fb798cb7860fd1c6aa55872f4577e242f38b19406c2997d6a5c9a9d75ccd8082ad8806987ed6d612cdf8abde3fbfaa40384fd12da66dff1fff50e13eb5eb269399b336d8315a3a7964f6063e0f46d6b25aef02beca2e9444993fe57766d7c63b64dee0b076409ae69e0fb674b77a40b8b15ea09273c9fc7c596599f4ad3ee101a9a54cf674f8441c4b151a49a7a04bbd0790915809e840526f75217f52f0e5e3345571cdc8722c93e16622826d5d4e3e401f0485c90c7b8d515760c3aad19e17bdab2b2193e1f14638b1bf6dc0aedfd4a9282174424751271aa6281c8c0243299b48d777b5fbb4ab262a74d9f7066354043fedd6ccadd512f0669a4d89792472fdfb6d2fb0d408c2f6abdfee34eede014d86a5e642652af3fb6ca7ce2886d96366f01d8cb664b6debb7665fbd3b3ab77ce00165cd3125d4495387528b61ddbbf9c285a965eca2d1e23e10905f8d4ca13117a8d11bf76b26d05f573423722316fb178985a4dbfc27cf3667b20c6e4473a081ad938ac74dcf548cc6ef6807525c2ef3666c36046ceea9f68fe85be481fabdb2f26bd3b2c4417ff5418bbe42324d28c670e62ec29cbbb31f7ccabfac2a92e2f4f66ba3e51aa1ace68ac201c3eb7f5a1b122bdfa87b944157e27b37db5267341555a24e769817871044331890b2ced8348bb4d2792276eafb4a8d6961a429f480851f3fbac3c70682cc541a881010ae0f5dd84c873468f192e97d88a2f17b34176f4be0daa3896a05c94bb668231acae263f951bea09826d5939b1bb533b00dc7fe76c993e4b65f4445c191839e74b8da58d14391251f90ef5aabbd2735b697f236c3aeffe31a3d086969bd0e7a56ca7a369253184ecd72be1383ea0ae3b829117fe9b6fa429f8ad8d44e0b87038f24a5b53cdf062459e38dbdeb5877dd49cdfc839bc9fa97d0d78a60674707933abf5db7da1877af4f483736d27cc42412015582acbc89ac9ba4b02af43e939e9a67da43b7ecb37f1857958e320393cb2dda857638e9d579ec0fa52e56ed00c7f33b3cb10cdf0946ff44926f65550ae7d5eb0fa55f48f9dd3c4d16a36ade9a2c97d5d9c8ee858061850c5089856fab218408021bd3af5ae7273c8bdabadc84efb8655aa1010871d5bc35cade8e522455e2752286deaceab47aaa45b6941db31ec649545ff2a1168204f9a7bd53c28068394679941d4a266ab6033f793a4f863f8f3139172b8b601cbb192aee8c567ad8e38ead01a16ba2ff2cb2bbf64d811968af39139515938bec212be0a338bddf2df8faefb9f2d26befa666a4d2e64aab8712b0cf10a2ee60b7e77634ce128c11638d9c8d38d672feb2cc86dff3ceff78a8b12e7484c55b6e8428c5464de39e75ee40aecb5ddc396baeafe5f8a9a0ca0d9d6debad71c191d022ae21c7d8df9af8894a15cec448c943d9bc12919f3b6cd900a8425722b2cdcac6b4a8c88e2c043b83cebf942bf414d2d357f671f0b47439c2ca62ab4f69347514a7d6e2150edc71c5ad96a43e65f936b9fe20e20dd861e606a79be480eff53c22d5e442f2658490ca8b3df183d636d61e65261ea1dc3df6891557d37ddddb9ad99c34444f0ada1f9c96090037662f3e0261c3335756647709b359d20fccddc86b4366e0ca1b62b0b489cc659e147491c0fd5052bc3b04d14c8e4861eabef75c058cea8c18df77ff43ceea6cb9e8aec631926eed862eaff1e861f85e1fd2653b5d20d18cbdfebc2fe3d2d42768a39a8f12eb154cfd444a5d62b7c7912b854d0cf0acba655131c9c649d52b624f1edf2a584bd5650d4b3f362dd4feae5e1343eb88276031d9e1e17b599fecb5ad32a69114bd2fa5952071f84f96b7d693b51fce1426077bdf107e032fde70f4611dda7c0272c74ed9c0bb01e5e5a33ed55a9a2dac1038a8065751bf6674855d3d4835d69ea4656a7d47e6fe2122846e8c4b4b139b09d3686340163d198095fa4266f8033e34d8f15f1b85ba179c77ec31bad05c5e747c05773a0129a5801b0cab5315435cb3685ac1e7f7b89713b9b85056ed7c49acfa199ca9631c467d0a1ecc00be41091a65e689fdcaf1eb7fb991f53171ec7f7ffadf1128d3f870804a11d8d7ce9b19bee929a710a50710c99e7f6d23df61d4bdcc9ada6f4de5250c5f9a166fa02ebd4aa55857aab8f067236642ed4e047697b6456963a2a631e3d574a3777d1cad9fa9664f39ca1918314420e6eca78c7419a9cd3783ab4eca1eca1d56d9b64e9cd3a4aadabe0b3ea289281314079ad189319a567fca23bb393a5d03f5c937e0986711a56ffe18374b27a7c6e1143239fa842230d56e231e4b7237afa791f804fd1c87c040d621188e348e508f909e1853127c75ea0de5b46c06fef739a400624af24766532211ec31ff5f5fb4c8bf92ef05842da47cff2f190f81fa517bc800e9cd1582cf11bd57775bd62b7844e002ba77d903b85804efc4d76854fdc229bfb93db40914e746e006700f727017f99eb6cd2618138ae8e50011d8207ce60d41fc16c4a95358ba72ec66c4061cf06bc7103ec0400480457a8acd4a3860fe0a4e737d4b2efdf33626cff87795431ebc2d56b2b88330f255805604d31eaca1b81da80852ac88ed68e09ef2389012c18c4e83ae8ded507f07dbf196ddfc69c67510f791725811379728d9d1aee44a274f46b397a922071c14e4ba636aa9a78f512ef631d91a7672d6752da93a81ab7d6bcc83a26d8857cf64dd16768b844de3cbb8569f72c0a9b18ef2667214d444992b5c73168579d81605fc379d1a13511f9a3304b9eb265212bf235f100633cbc21cf6f125fde077e5bd52eb46256a4dcb08d90a2896c3314ae36f9e1d63c50a933e4e8aafae8a6dd9122abf243d4e929bdf13ce0a4427fc8fcdd5b7e34ff519abe29a450e8adcbc4a6c689f98bb7880803c48fe48846d5f85325bfa64e005036da773197818fc186ac43fc897cbb8ec7e4d496bdc630fa84024658d7691dbe382deaf8bb3a49f8494ab7d184b01eb3126110437743f2d9320000fa87d4133d03a0cd3f0871b712cec3700794b4cbebf04835bfff27327d1f6969d07cf6776fbf7e843abff9a57bc8a46a97e105fc2be1d728211fd7ce3ba94a51051ddae2bd894f21fc9c1dc51d05261198e0e7887d81c1745024d343294a2e5be5e206847a2f1114d4cad9bf4cc08dd4785f5bb6e8a43f2dc4c6b50e3a74505e22d4494d318fb877a7f763221e3f6e29ff3e85e93bffa7bda184de49ec8db3cba81c5e0020c6594ef35afbea7e0180ee453f7d09ed5037dc6314b6b76d4249f8fb2946448fd9d0e084745fefeab08305e7e7a128eb8afdd7faac026edbb92143674ce8b6034aba0b1ff05ea0e4e4129d62922ca3039437dfcededcb1a04a210d91dd59cc619fac566acce96fa995aabcd1a1ff791f3628dbb89178e9e6e6b768e75d2aac21c00566eb22a34b8d52ccfb31721de19e528c9dd8b474dadc46aeef3a43120f1788136a58597664ba95e6c3f47c66ad73ffc4e986694ff42ca08d606c48a51b5ffe0e021c14875c2e83480f3500d403bf338b189b0d0f2b031cc9798698441d79087fbc688b6c57af1269d51d2f6eb1566815cf1556434d7db51eb77d42b0072c299527f285bd96ccd147029408548f36192cbabbf1eaf630670a7fd3701821536a651f4bd1e72be88ec72db9e396cffb71a1bd629563ec4eeed40e8ead0830eb7bfae84bd7101641c36d60322dade9e7931fdf11bd9375164e9a85d19ca25d98802dba1a7c867cf7627455aac27c995371385e18b7e757b8d9683de7085eeb41394c28bd5c9ee115e7132b4568ee3dd5ad84e0b72766888a22bdea0e00876273e3c32073325321fe7b0204d39219b6b926a23e9858a988460f312cf8f81b148aac06a8ac07406f3c5741fe55a3bc29b25e3cd205aae98b22c7a799c1da365c48d266f044906a9523bd075008245427847263003137336cb611aac6435f79d57bd13565648ffedb69a129186b92c11062259c4336c19ab2334a1fc9fda303ed1326a288f8c2b6302640eda86aaa98b52169d780a306ef7ad668a9ff4a3b91f377d5407743c9099b8de01f71222ace1437f1d2a2c2f607edabed0ee5c0afe35b4f1d0f3c07491ee158e9eb5b333c180a3c6f5f45a764fd8ddea0d5059d57dc6c231b178ece6787fc50376b1b81017d89dcac69e552edb4bd894753c277a2f15c19201b1febe403dbfc77afbbdf06d164c86284bae6215a20f9e96c8e4e988625a0a11032b528fae8b6f04901b6f61845693201dd772576b9319a75a7b07bd30c4fcad535e2028522b74fb88891c529565c6ee74b2a8143cef74d479a1a87b4f9da792e593704fae8f75feae8b1ca9337dbd9c552a4709150e7408e6ca081914374a6aea85ee4370f58ff8b56d90828c4c3880a930645b5ca369eba95bca23751609fcff30dfdc6c252a0ecf39746e92cb155ad8465fbf72449e65e8d74f65f799200d775e65a02994ef20164a8848454785196f5eb066ddab464e5fa182811b9787eae9cfee0767e372fda43819e3b3d64f05e17fbf388c6b6ae3e2db6b48c177b9a17285da281f2a79edd3baf73bd7a0668aa198920716cca4251ec1394a12346caff8330165deffff0fb13baa1b5bc8117b9a52c11a86e4a6d848ede88a68f9f3458ccc4127d22dfd0f731aa18d6d65b677ca1a9c95fb7731096b37df2312f42235abbb2c71bf07942649abc853b582808863a079150bcc6986f4f76f8bdb04c99b192da7a00cf52562312a5c00b2b31d0df71c126f708c5a896ac962324781f91566fdae165b4b105ec6aaf0a65762ae80dd6361274fc78c088aadfd133e2657b0b3c0bf03680538f2372634d4284602b1e96ce4c5ab19f33b72012d2593b9965a07f88083714683366eba886ff5d877a9a78088aa96b3500bd76de9f9ec63b04e0d93c7132b4efa52e802d089af513315d7c037c87b1b4a94749eeebaff521aaf7187dfd3fc9f776d432b705203197f71da7bcd44484507e063bc5add8ef3881fedc422aa7ee2c6d2d4678bae0a9810fa19cc1273b88eb2a1cc09b8adf6e0683cb322c464e3a95dd13f3fc62edbaabd48b588ca37fc05b61b1b36306c913b3d4030d6ed674f61822def6dfd061d86803a8d1d35e3fe5ea6e99c81a54057462f00863b2f2f2b875bcd9d7ada02c7a3016d1dae6d8e5cc917bdd692538952e2ef6bed2f12017035110e5f23d5dbd1d3bf0c1d0af5ce2b236f09b2dfb21767dcf0a702231a917ac6b78a80ff1f5c33ad3f1b3440d2c444495769bad2fca69cb08ec97456205cb560d70a7abe523afb44209ca71fe5c9bea13e792b3ce210edd58b454b5960e76225ed8de6c6ebe1d2eb9c4344745a290c3e37140a05f5d279c7b8fe50382c366e64397ceed8b7933e2a464c35182e46feb2a0016184407787812a4312030f94efaafdc6b09b31aec09926cad58714aaf8e27e7237d1304648ecb96b475bdee0281da426de5f6ca25c21babb43fb0a0816fddb364cc87a1271e5398029f25134dd5e3be3c323487a9785226c4d1d07f0fa37d9a8afb668d4dc14108e4566d7c3e70a81c0b76de77063e9ead2c00f0a58e85b3d00e2818e4cbd294ec2a05172852d37359bbbf0ebf5104f475d18892b6beed3c7cdb6cd4bb1bb8f9efb24b67493c70746aa5cf61522d750597d61094869f65ecb6a10ee7679f95d6d2225857595613de1f23272bc5b8cf3527b1263f3031f214c48568fe3094b2a6d10f67535dfe57e761a34de01aab45a072c628a3776abc1da9ef4b78d59064275d074a352c0ff5c00667052b85977f6cee0632de346b23e14dbe3351dd8a5040be5355feb24fd4b1fa113f1a4b768a152c79d51599c35049d98789dde8bc520fbdaeed386be1b415fd0d25c0264b018a8593a14ac55fed4d3141506ac20b01d2fdedc8a97b1ed8de833a22a5647daa8f552ba9a65bce69a601c9c5154511cf8e6024772f2d3a7b9da65b6201f4287a03c86d0cbb5235daad07dd101dfe63ad35076e91ed5bee0c2b8f391bac123f7a787d6d1b5574da3f377dca5d1ae7e0230b25bf08c532414ba30ada94947a412bb06896c2e88ab941b5cb960db476b92722590a07bb99bd5f21c5e57cbb3807debd8c884baa0df2256a8b2905611ac782ee1bfd9025479ba4c67421a6589d74c225d06e914666d23b1ad9c428173addc1bd9932a6c6acf2b313c2a113528d8f96d2f02f18cd79efa0a36e2aea78b43ee44d0d603f43cd4f86629cbd3dd34be082aaa5d44c7c4306505f5a2dbbb90b536174eda95afbbd32277ec36a15b8a9ca8e5dea99dc6618c73de1fc6e9988af2f1fdb5571697e264f6231c85d63b9f9a83865f07a7b94763d28cf3d9aa8b59c002c1894ca82bb38fd250153a708833edac85982fce9f1faf4443dd832682d7dfc9231dab99d7a929c20bcea005d9579c559da2fc9974e84f778a8559ce34120de95df29a49cafc215721acf105203d5f4a5698bec38031fb3d74902cfcf601f7f63b04fd0084280d9d0da7d35babc5966b5f4e6c682177bda067294e5d6d1fc46e069d4b0dd727e7b07a180c95c44b6dc43906a7f59b36cf50142802d875f01917290bb26b48c3ddfdfb220ffb6f7d5ac895ae6cadc7272d743e55e25ed8e944feb61469035cecab086e5c41f08586882e14fb40dfc68564a3cbfdd9324b03091039409291d6a74a65e4c4d46083d99ee14b397a3152f66a9ef1f2e9ab20b441a4abdda259eb60c09274449ea44a1bb9a2a329cb9eef60e7c130ce0bcdda747b04af6b563d78784fc450dc6309a8c885509742a1662afb76cf6e9303db14bee80326a4c2a81ae1d7c44f0e67b83082b6bcc7f59442ac22dafa53765a777118b6523b2d239a9ed6eb21a1e4b920cbd6b802827b2f008993fece00bc4f4c193b62b4e47cd7db47e16061dac7a9e0f4ab0604637b6203346a24a6d000576c29bb29a841fbd6fff9d39c499d0a888015c3d7ef62c6f7874ae5d20456119cb47c77c0f2e0a33dca84bdf3c529b53ad2cc1a28c70e41b85bd138dc2c9f7fb68e80e87f387755967def6128fc4b6dc24c81aa38ef265974b16f9130ce1f488eb5a1d844876e63046ca0909440acbf87528fda69e0d49f2aeb31da3f9c349b065e50ecd4188f0c34f49b7e7aa4f307a880be7f1ee553fd3b86ea951e3d0f16f3df541486299d74952f8e0132aafda34576d10a0130346b4412e9d4c4f369120d37600c90a046dce1bba31bcc91a8de70d8d211d5562e78f5558cc5a899da611c836fecb737eaa93c233b86069a83354f69453d38c94b860358c4dc36e44e8519e0eb692da56d8e66ed77e1baba0fd5c72bddcf30d7da75707694387ec5a3999b1de71a6a3aff3fd6b2f34200b00aa15cc82edd40aae1f5ca81c15aa1641f17c50f22173b6a9ca79acc026d3146552f743d399efa63928b8f29e38a3cd1ff7bfbe6065d4aa19520ddbf6e1e49deb9db98044ef640a195bca0fe1a6707279eb8ad2c6fd54c5743aa8eb347c978cb7b4624ea8546e8df4ae2f4c56c67259650b8c9ef2928ee397e744ca5f0500492fff7cfb76fcf022e0f8c241446316e866bd8e61a27d6e966191da871d18defe0b4bc8cd1c8fb5b7cd81c5ad05bd4735e1d6534de526f3a3c35f482c5adfeadc82aac8eeb6d01485ac1422099597ff7d74ccdda4eb64be2a6aad0380a8d5170bdfa25a6c5a2b9aa789b861004ab263587a0afa03a171e6ffb680dd8d34ed5f15742cc763e99fb8d88b5594686620d1bd26ca3b23d2bd8dfaf2acf4fd36d0db11f7ce461bc8df6d736f5ec1b50adceb53e6a1e058b697ca3f615400409cf5a5d8ca07a737a25a8a6075e2fb4195becdf81263db5bf252bebd3a37af19150ff813a8e9607a6f46dcc73a183bfdbde1d27b1cef4a6afaf9a2fefe0eb3303fa1503dcc2b598e4f417624b6478166921255d5bbf28d24c149c4b4584b7f951efba50c638ddd62f65c12297567e513a1806be1766644348667d6eb5268d1d50b4a86f2cca495f663ddf9c932b581d833fdbbe790a3ac8605afaf785e6700880e3226818d1f34793597c87305a4ace2d7fb2133c23c28adf5f52044dfe8db8ac0645dcf24a2a40c740722784b740fbab8fee084ef7919142dabcd33378d00662e5c67df219641c0dcc8b8b4f8817c62b81c57b1388c7eed07746fd484e6773a49f5c9f3821a2fcb15089fdd8fb0b4d117780455e414caad69c5b3590d14949f5631fe55d3116ff6d50f0fb91bfbefa4e38d15c7663830859298d7dbfdfce0fc6a3d18af5f5b4c8232c74650683ee0cf8965cac6de4e60ea352b552c104421336d71f496cad66ee06fbbcfb720cd98155737414de93214946609ba2e6d65ecff5e472165ff4b2f59a9f55a0bdd96db9975ebc50dfc7ab13bfce0670c496f4e16808713db7734b81cbf8c5a781d3dda971264905408b59f86843e7cf746133372082acfdd458472ce42d18cf0579f147cb87c116d95360b9d523f3ee0e30a997c9482b20d9edf5d25a7934928cb7a519f67b273e23fe90476c571103081fe3f1c8e0863fe4bb4f28a99cddd86265218c32db6d60dab0508c0db3b621b9a0aa0a78d3e056467fd83a5cb6ecfec985aaec2b15354e72adf77d8d058f33f2b5e3b44d1367a442823d9f6c4f805d296731176c9f0498522f73397be671ca74b6a70aa5b6a4f493a067e2645ba6d5425fe84750d39bbde91aaeecf6ca4b086a19c07ead47a34217679ed966a5fc835cb5b8fb54954d9793cf3c171616f2b8604a9aa4e5f3ec31ba2ba74b429dfc215ef8980463de4e5a10b66780ee54bbb60977a3bd1485fa0276c5edf8c1bbe4eecc16318098fb9aff662ed8d53a4b87ee6ec704388f19c791189139097148c4ac344b7c57f6f84febe377981809ccf493f2cf2dd6d23b18a1b564045bd3535e12109a46211242ce2676cfa23573a90efb4f15356c2db23544a095c5f13b521db86a956d9b892693748d98aa0d0af5362a7c6c79bc2772f6efde38ddfd6543c7d5841c46ee2689532a2d12eaefff62152be5716affaa1873c4d56cf5792a56525897ceaea813ca80052f4bb927b4e5eeb228641493edd082c3c898625078aa19daf28cd450e353d95e510759ee3766726090fc2ce49c7c90642b353973c753b63ce8268e0e45d41b01cf3f7d137f42f1af5ccfa91e8605774eef926cad3205a640eb3594f1993fe09c2c2d967e54e3e0731e0e0f9924e2019aad9403a11e347b1fda36f5683444fa4d58a5c6b45e3b96c1b5cc21e230cca391250bbb16326f43bde92724a89576ed21a6a29d2b79be82319c29025742d67c5c587564f46e9313ad0b96ee485814eb0b77470b0af545ee884d9314ad15f400175a225a38cfda63492424ae25dd07ac7e877a9d85b12448f4f41e129f33e1b12e70b0a4b498554e6c7d66ad99f9012ed3768370ce27ad703496a0ffde477d0c3bd8de522dd71f6f6991d1872e2f7e8e6c1bd845ddf2a06fd103870c0bc4cddddb74c93ee967fc2671630cf71821fb041ada1328e16a918697981a9c76712b5383f269df2e624b529912c7434afbd5ccd06d9ac7eee0b2dfabdf372b79aa963679b06beba3c7181d24564c0b082fc7b0054d58783670ebcc93daa61b64ae16585467b54f2d57c3516b8ae0447ee91963ed3b9a30a70548f9558615929c83212b947c52b4ad8bc976e97033e6ec4e8a55ea567851e7fa86bd866cda4b40c7abf3a02c1ac715f6fd37e86e4b7cf3b69687608d701efa32ec9f44ee7f3f4e2ef70958c8f146de6e46e3c53120d430d2f53765c74f3af80e90e3e9d7cabdc950744660068ee11a18b2f84943f1fd2893499acba59c2db4804fb13744207998ac2dad828c78e9f229ab51ad9a8478ddc9de2ebd83ef42189b7cf2c8ada886ad29cabb6f87d516f1ecd06c243aec4bed575d22f05c8684f26528205018256258d1b5ef5ef088c1b7192824725ad5bf5aa4dbf330f44aa41769fc243bf2e21c274416a20635bf7e896c6c23efed6da8d5e7439a0797732eda3c0426de20b4e1caf1b9491fc99932c60e716b51497d2cd5d712bf23ff3418c05a46ad520fad97fac5489a670469538a68428197b7c07814a64f7cdc3fc4558a0c584173727a3735ffe4be1dddf68a7fa90bf67026c0d9ffb3b47612c37b4f7ae8d14e1134c3fbe9896973908b25111407319762a58b572c92a1f838a2b455acd67602fe31e9af2666f1c99349ad842f4e4db6f0ac616f3e9e79a5e2a7e459c4064a593dc5977ac6a24cdf0fb67d14ecb332dfd05ac901a50186759961267aded8a47307ede6d2411a623d387fb8b4349e7e3c64db1889614bc143a6d68411212358d5308b804d0a689991f37b9de8b9d902d3b03c929ae8f0fa4009325022a1f428f70b0219185ffc458fef5979adc2c87308a536e0d4d8c8e41b702c7c8a64f3dfdd782121db8829b0e71641dc20ffde833cbe331cd807876c51b514928da03edfbc4aca9e41d98e75fedf56d66c280f1c42230a9cc490efdc741c02b4600cb3eb143461577ba0010de2b17331115a5fb7989f2315eb8a058913f93e2932b6f129a5a0c7acd5bf5fdd0a52d09fb33ad81d269362f5faf288a666d71756821940a5e573294bef3651bfd40f42ffa535dc85f169027f9fc7de8a6dc3cd4989954dc0e02bab6cf53298a08a6ac3c3ba04de7c96075843d8ed252b33d77e7e792b4885abcf74de845ee681081ffae89470f27fb12a1ccf792f1d89968eff364cd8c9eabdea623f2142116875a38285473c7f1849c1b371753efd8011db8f8fa321489b5395fedae7e726c204b474f6ee65048ab2dcc081b6d9e701a699fa6e48829c0832185b55656ed69e79b6ab1ff9f8a77fa378364895f4b110639a42d522e3918b9ba6902dc60f1a6b583b165dcf2979d89438be95181261fe95948ce08998783b5cb49fb20d046f29bdea3edbac8b7ea350448f5071469cd73c0a2575b676fe0cf3d23522738394bbfb290ab6e1fd07f82f98bdfe3d14ccb13e265a117e17a45979225dd2796db8fe729ee9d2794c85fe422dee4223690479a9538e0e4db7fd83692ac9097da5a24986f081488d7a02d650bd7573b4f14b0274c1f3817d2aa651d8327af50711d1dc8e8202274176c21e88c01b5694a4e945893bd17d426967d5a106387b71d321f504725dfb094306e04d05f15754b3878181b509265a0d73b825fce32d73d022e58ea57e8a47abc61b4ee10a9386cf865325a31a6d9bb44bf53ab7b73d8ebfd585e5b532201008c1ae5a8bf65abb3924004df9b962e52aa6e1a92a7b4b4e26ba343957f65bfb13f4c079e1b643ac2e7f74b140f7821e2b9297db0fcd47f5553ba76340cf9c73117ab340bd6b744d4bafff575a33548bf39936d15325dbacc18f9e54ad0841395f268ce62522e1333de62285d4f21ce2202464566b2873490511cf83f2c490b1b194ff5891f58ecd5724cd8f50e4dbb862908cb94471a779b4cbd3a6598d0dc33ec8452c2b61c9ede929e0b25124c9c6a08eff7d29f11bef6f97c7d70f10d6f85aabd480fbef5ddcd4152dd3c9ab2eaa318adb6df87159a6a8b698a7841b5b8f1f56779c552f0a1775863d6c43dac608e433630650618f93d20b24cfbb87ec50b5359def94e3f30a803653daba97c4a9b75c3769d993c227f322ec06861436d42a45ae94712835add51eadbd3e34b3334ffc17079a5f5bd53461b60dd5f8f0bbf9fdd702762cfa31aefecfcf1867b63e303008521c714a56434db5866a9ddd4ac37b57f4893321a6a17bf92dc5c95cb8634a368814b1c61ec1cb15e5618eebefd1aeb40b83bd5893f2dce4fdade0d9a4e6d1cf4383e9fdb22a5203db3f4debd2ef5b5056e01e6913508797daaedd6ba7ee1ea15663ab6844e9c83f7106e4cbbeaeec7edd0581048b2c758a382f0f365ba6d94bd22ec11daabfc2521574f7d2371db9d65e44d108eb59572bcf14bafc9a5cb3d9a4b4091d27565a75f6d5d6a617d4831dad1f4ac476ca8054d467ad976af697cd60625df21352b003764a0db994d314449a184184f9339f204ecc896815b27e378d8c107d7f79a876de6c9ca9ba61f5a886d5a471c707988121fda3018ad0b3f27863b2c370a7fc8d44a56dfbb0ddcd9f0d1ff312f77000ce047ce16aecc620cbb342dc4e203690dd9816e380aa9273435527e3ae25533885699b89623116f89468465d54a988cf4df3cc42c89ec804b1449b1dead9ea6c6a719d040eddb91eac8d745f426410da51f32ef6087a8d62df9889b4f2951e5b083bcbbda99c569d8a73bea543da8d1ffeba4bea56635ad783a1e542ceea72baa5742cd6a4312e5e7ced46001449b2a0e57c4f1eb7b4b751f3128e8aa94634137ce284aa2088fdd58648b943452144c02546092ea79fb759fa9f395811ef2ef78c56fc96c8944420136d61cebd0922ed551dd5f659d40b5af611163b4e35152c8c5f2a872535082a9fbe3b8b225d06aaae6691176e8f1bddc31f59687cb58177d7ea300bdaaa06b8383671384f0dd5e09f4c0ecc4f6eb5b4a802082b1c02dcc7ae850eb4efcd1006b0edf8e6788f796a883f06b2f49bca4f1f68e9caf2677b08b82b16f707fe262582ed397ff941c865164ea4808b69849a9aaab368528d7967e22b141ca656bdd82494b4f5e5aa3932b671283e8d9cdcd42a9eed7ea7c3a62d91615ca60840ac6fddc219bb1a381269872bbf62f1444f673d19dba2b83453fbd4b67a5aff510ead1d0b3adbe96aab84f7e25af3c5828d09e5d53bf66763d08945b4755bf27881e742d271329e168f0cea43d7508f4aa76c530b50bc57885e0c3e44a973dd471294ef0c0e903affa5ac398b32ff6d0a810d874da28731654fdfe6f0b6c6294d8eb4f5c049a084c37e015e234b66a048d891bdca3256725e49ced1c101293217e551ba42246aeb6744d092fe371c23a3739361b8528a46e6c7f88da115405e6ac1f2d8ec4431a9a1759f2b8329b6cca53460d6e747031fc50962855dea6379476357d59a133d65d7473a32fc5a2e2f43a1fd12c63d0b8c5c26b98fc06b714663d8bf40a57ed71deb3aafd76def8b411d8dc696a3a1c7a479bd3e647fd7bd344deb72839c928d549488dd04ca54ab769523d1d9496e9cba10beae278ed3b5a9a4e42b87db4392fbff57db68d8576503b0d912e99833003e0f3d36126fad423cef13539d1b3397593f0f6117c6a17d905394aca87b6ac5a12da44fe7fd403d3eebc2819db2bd98ad47b404fbac1f63e274bbc99b40db18b15e28560a33e83848dd961daf4fb2325990fd3ce648c7dd89c56a5ca13d382556b8b07ee56f11d0c857162c0874077c3f5f7ed0f1eff3440df408d271ef2922a0c91007cc08634fc2bf53512d1a3eb1f440ed047f1507bed3c5382ca391bde5fc10156a2b0e819d3c5461b4a84058b6e714d8e2bef8630f5267489cb6c704313b4bfd304607b06f2269a0ede9f32e57122b2f2bf8f497dcb419c4bc7c649d96c91e57a04bf6cccb6204330608615d186540429dd2ece1da73bdd7eeb1c9d29e35e7314b77a4b26a5c2b1ee8fabb832ebc556d1aef004a978df8dcfa8608dd32175b293699d5531ff1d5f49d9a2e23c50b73d592468347eb29d57fdd1959140d0c234623160ba27ab0d81ea7cfdd08e583f705aafb3f26aa44bd2677f7a011941684c8c813659f292c06e138372a75339ff4389a9e828b3e2a2079fbac7319bc3385f85866104abbe0e35c98004444836c66d1cf8576c5e7ab0a4ea52417f3f53c70e43738553c088a5d5c9652e19ff2fb10b0a7c057dc89066feb59bf5c5bf44a55761c4bd7c0c049aabd1e7e6fc56b447f7a74885de9b46609c07d170f17c268047da6023bf93bfd3b9739638e587b74ea59ee2b30e7eb5446f0754bbaf54e10e1f346b56051164630a7ec35bb286a0ffb189a42a03bf1cc8838f99e1b4015edce9d523297029a4f252090501e61815d9ef91d5ed3c057ccb7d5499daaf51ee48ffadf1a6c7305a1b6f4ed6edd2f4e65bb1458678fb497854bcbffa7da698882b7914930e201a1bca9656877eb83236f23770b67e5f8f8dbe67d9882fc04258fafb03a123fc0724e4fde6cd0f184d5b9b8867a51a02e54de8912e44024f800a75d46110e5b2be0afe7214ef690ad3bd95ea9b5b49d5ca576ac79a5a5df0b496bac0a377ea783bcd0ef851950f4e0e41ca28e72429a88a8a03f3af613b746fa602c8a18227aa92fcf6dcf015363136cf5bced3723631ced63a0b8f9d3a2917dddc554817648d82a9f434cb887015ba9be97b7c9d0f333d55a998c3adb4cb27d3dd508f9a4fe34c709e3e9b8e8e8481dc19764a7152033d5c4be6993b541859692e7c9040eb8eb4310413797a2bab354670e6fa507bda02e7a57038a7195872d196a0fb08a39ead82586af6a4e5b946f336f8333072370985bfb717dc6ab6c6d0d0c43b006d1873c5de20bb248b746d1273863df31a3f3c6661940399add72d92f93ac66755a02ee418b4cd4ffb4fd9b6049c5de99ac07f0135ad549d8d014820007bb212e0a1e23495e102462ac2087c6e5cae4f0e0d055791a9da603253f2bbecc4a986e8c750b84c7d1c14e37fbc1ca99389a5bb1753a18a706f306568bb5bb0f29689b92e35b9d1355928bc9a7cd9cb3692200b18ea46a6b36e801074ed304203a915f4e5107e6aab13be49f10e60cb43cb812ca12b21781efc781f2be6cf5a22151975168d7f0ae3ff3c384e67d7ed6b517fc51484ada2d14b4296715f6128fd4d0cd351e635c4a899002964558018d7e90581c1f5ceb49513f7e4514b7941840662cb6709a3bb86f89ba4014677575d58d509ba2b7bebca88865d9089aae55abaeed1261b038bc7271b0fc34be3cc05113c9d1904e599b2616e93b44a3436ac68690d004b296e4e6f7601b724fbe6a0d0597a3ca341da22dfe56e099797b01b6b2a875cb8cc3dbbe89dd0fac54a435309d817b662355a049a93b885ac66b03ba1ed9352c444314accc7988d338742608626ae6ef27c4f900fae04ce55b82766810ee54d5fd24f8cde74bde61135d57920b16f46f9efcaa2848ebeec114004449dc220164836a383e84b91214076de29504ad5ac987c01339862b3b369c6f39dedfcf761e1806d6e094399d928ae4c238886ab9789786f1f3ce55d04c29098594719fc40f7d39994d041b3aae71b166146cd429baf90053813b5da94d2474a5f8580e7ac53b6f5bc0fca7a8cb2a52f22990c93d4b067447c287501a33806eb0b33b474a662b1b4b603a4b5066749f327298502df74e8115f5c1951419b2dadc11a7581222b8639c6481a2735321d16dd7f63b71a5655ef735d83ee8b401b16702e22b9aab09926e0bf059d5ca111dd6dbccac905019dea1ca545536b2f0249da8f986ae52ae7a8171644bfd137fef28686e8479c895580812236dcf8f6ebdc0cebb52bf977648e6c24ce4b4ebd4c882207d6264559a9509ec2a747ef45b96831d8e63b7a19e6098bac2d34ed648669b736850a3ad6fe873603588f4d0349a1dfacf14dfab368375ac9ed30a36869fd2aa13fe3f924a27da687a09365b9b31d24f2b72dc4dbcde90ff7c87319e337faf504fc222c5156b9b55c40dbf3d0def246613de01fb56f815a7ec9536c886e904c1ab398af105e149c045b3d6f8e2e81594e43228633bf9959764bae150a1d9b13f5100f4b57515127f1ba1a2bea03d3bb2c8d8c72cbba2af9fdfaa3ccb12b0fb5659c2548bf1d95ab3474e430b93e84bf7ed63481c10ae7c60a116698fb8cf6518619037361878854ece038899142c07e3be434f7caf6066d1bdb074c5acd35bdb49e14bcb95d11584f1a9acd31d4cd00d644dbc0f1378812ac07b06fc658e5f5dfa43de8f43eedd3e4d5e82a454bdc75c907044da3830340cbf54e91cfce11fbc915f88fb2d5f262879571bb4ba992f341d00e350fb542d6e6b9a5a75d1f31a4ec6702ee0bb03051e1f5913c7730f643f367adcb4ed342b191611864178f39474d1727aed00a6264745bd76bda4d0c240f25264ae953a70793fc2af662e4751a18492402d819bb327f6d56f10bb78d8f4a2aa7bb512d6ae5ef20558cde33af8c490b96e8681476a58bfb2611c1779b43102b6e2742789c9513f64577a91b3b18bec616b6ad019b7f8b896e081dd0cd75f33ddfb956a9a7719c036c87d12f6efd20cb1b217bd0132c34e48858cf0ad6428d2dda35abd58362a9bb3316e8cc4717162569c65b64171a40f5c001f8f54a02fd9ccb8c2aba486633a41bb7c7063d4e5b2aef60188e31ea0699a0a7789c76ff00c215bcbad441a84ee93eef900244fa8ca57b207e08ae18a06b4b18b55d5e85681039fba5c97d06f7fa161ede85c1a309c0adba41d71e41f0c37513428127d867d37ea9d136226bcd2ec1fca9a80e4b35a8dce0b505a9681af3ebd6930cbdc45ac665812ddc25978d31b21de63953c6dcd9725db8603923a0edc0cbe6a69152b95c42a76aeba35a8e4147bd013354bf108bd0da987e8454fb3bcee76b42cddea4353cfbc148f0068aac8c7fa3153857a49a0cca693931e10be4371a6f0f0355d87a42b37fd685b062e9f766f661f3ba51f1c524c9ee3c79981fda1a2207cc771329190655a31cdbfffe7c411913e1d62817544aadeab1ee36c2d5f3493010fb08db05eee5d6ad9e66d9fdb2406f06f42429a564584eabac928d80134bddd91ab99e03ee390311706d34d53dd3b7d5fec4591ec2d28c96331831e454e4d6d75d7df753c4db9539cd1857b457dd275053ddd6dd5e2941a8f92e5420dd6284167f35af597270019735429621a388fdedfc2106abcbf451b1573349842aa67dd8d935c7ab4f0e90453c03bf480b087d77e4e07e30ab51271bc69c8f2a9d3fc94d4c249b19ea619da9ae754c30824bdf8361e9d5c287d20ca1d96bb874f81a368c517f7d06bda0f735d5b7b0990236e9a5fcdeee780b694f29da0fa017593d5c686752d53893c03c2e900dfbb97aaaf09837414d58171709cb295545f53bbf77252c3b59180fe88aa19e251cc293a617b3a0327115d0cf4e8216befe32d8223c7f6d1717c59e253b59b54a65ee8998863ae7284274e8e844e8ec051bed697bf1a4c07b0b1c5104289ca5c3a63972422be6e2c3a695be7cc80795693bd194aee6dce1337c0c7ad7eb7c6bf14defeefdcb2cd30e259a21ff25190729f8f16df135d273b920ad01c834ec00725878537f9cf4bc9124a84c4d54179ac74a6584fa3de22d921855db16c89099fe174e2202f67b7d6eb7a4a0300e6ea918b6847e0e66cc865cb765dfb08c4e70c92bc1ae53143d6da15aed24a6552216bf8a6ba85f5d2fe17cdab429c7cb2ed437ffe63b3c3b23467a4250eedf34c7aa7bc3e4fb4b3aee9b9f492618cc2e9f0e99c546ce915d81716f3039cfb5208b89a4ac54f8dc02f26f43436d6e3bf867ad2f3304e0ed8ef1598e74c6d3c5da3b15d200989b43cef769f6284c435b44595d47fc890dafc65d4643f76df2440abfa5cd6fceb5ada57da466f6a2911a6bcdfcb43cdf1ce5f3f5c3c5eda1d8c4c07fae03812cbacf34af5c82bc72c1ad9735f1247ad6b8aab77bae3212f0e8c414999628e816fb52e366eb8f3985a49e97d6b814fef3f0b89c789362641f0650975d0b63b25b353236ced48ced1ac3f34a090887fa094283256338b9b932383c5b4e2ba5ac03cc8b8a99f6a946dbfa3132eb157d901c101827b57f91d793077cc9719a1517905bfbe37083bc5e5450e4519db583c0f6efd86d22166e5d454b7875336dd57548d8ec14dee55e61b12b5e4a2db031b898cad730373ef248bec0dc204c454c94f7602f2785c3cb63c36787b1441e3b0b03c8bf3cea2cebf05e5579f8c81fcde7f9f138103c3aa8600894741bad1e8f25c7320b077bd81f44f87c7cd64a72726e8f6417cfc76772918268c5768c838436281cb09697ca733f54795ade5d7227ea76fe367d2f6ed8888ffb7722837510ff0b39589dca8af4500c2b75881b16945dd3b04f10eb830a65572067435b68b0630af3d75ec78346e997043f6c316c3134095cfae406572f03dab40e03c638dd50c870244f3625c439b4949e67cb056291133358a10e35ba4d2672adc2d60f8a1d2cc517ee38465c5f516d3f61c306f9b0c5bd59831ab5a9abd2058ec0dc209a90921f28423aec17a9581ed3037eb42ae7599102b5092ddb2d86c64a987ed63aa0078e429f106cdedef797bf505d90e3a71d0ccee49257f212a5d0064df9772064fffa97eb96ee8a2ee6df036b5d2588f889937e3fbbd1f963a06038ac37f2483d314e337def907ba6c76e8c643e347b5c7d85bac5b414774f27a5a28ef9186e411a74a2fa399b70c2bb38120b2643ed690399538511c325e9db488e0aff65a9f3418c2acd5dc4dff62032900cee2426e75f5f89258669200ac4903ff2db89403c85828fb60b5ec35d5ad71d0628328eb4d1bd9bac018ea15032978c411783301d2fe64f2aee54a6e2b81ff4dc6a2959cc7aa7ae80934e35beb5bf414ecab5cbdae50071e9a9407cb3007b80bf4c02687d0ee76835ae5cf6761b5090721f064f1f4a7c6670c870c469023622230aec406222d57ee174b19d998029f6a4aa2b54242dd5a88f93acbaad84f76ce0678028140f8540ae7e6cbb320a3e0f1d72e9c1134b7ac9a86b6975b338e689554c1c71cd648cfb0b7c696ff0a1317d27a88260371e32fb89384626c50077d111c2e3592c625a74aff6efa5eda5c6e885c4952bf1af920a51cf70b211a3420d097666429ee2ef11e273540258c5bd9a1bfb5e5c52c9a8592f9e8253c2e77c12076bcf62dcf391768021f76541619e32b8aa0075775c0ebeebae6a04025ad1a2fea779ab53c98b51885606f4b3bba5285ef3331071d87280523afbf1290eb5e7bba1147c0ae357c9ff1861edc0ce62913b6dfb81ea1c2950d651a45fc5f056ae436daa0965fc77127b32d999e4bc0b53e17d669c00b269e93aa3c67fcdfc84a8292e03e316f8816a82fa42a0735b42ea8c4427316f0fdf315d94d8a13691853b5e46dff29b69c12005e617e56116d6068187eef122baf9e750024b04d7988b3a925823eba5be34d64e048314a14bee79e3cfd76b52b2e3a11852d1bd5220cd3e40bfa4f2c3c7f066137707b21ef7b12706644b8fbc78180721f87bef3a4a4e95baae9fd108f26793e091952c41340d72436cdd851daa0be22f07f2fb7a366d288ac295af3eb17062abe113742f404fd73b73120a717e1a21b61950700cd8a994552b3e019af8c1093f719c8cf920c2dd713485b5c444661b9cc9af15655579e87ea5eca536b3625ea554843da4bea370bab15af6e4bf064062160b335e17798c9ee6282cfc3ba5fb9cc796e4c7d67a08f662f41fdbfd9d15f35ef2f45a60103e2c6d6759ebf2c2477e2ee3831f8db55c73f199b4a925b1e80d68806a1ea8ee5c8e458c6fa321a5cd34f279f072ec8fccd74d146d3b9702d435c50a467bb201b89bc8f7e3db391e79bd1831dc7fa1e0a21f5724abec4ea4cee3a9b7702e5e162b1b5d2c2f1968408e4c2ddbf87bea0dbf0922b9700a024656955ec15d517eebe603b2d11b948a88fcbcb7f8e157762ea17561d3e13064ebd4f0cf1fe1e471bd59fdfa8dfb39813519a4975157d9426e006370923d997f7265af222c77af4312343eff75e90c42671d386c4619d0601fc41f413b40ad16b8dbf24e60ef66a94dbb44b32bfc95206e761932fc944439fca4a4bb85ab259c9f473f91a527ac86210904d2b46dd7b6ac37619d5682da18cf7e607d4d762b7abd55bff01b75bb5ac61607ed87e3180e010fb69373868e9d71f2f1df8c4916c5fa578d69b56887f04b127175b7b752610b123d7ef65899c8acd1e5911203a22b36aab3fde48ca2da07fbb8f9dc027ee38c81e53d928f2fadda40b83f3e17e9d66278102db52373b5f6dac3992b37de29de0f3081ec63f18825fd0d747bd6bd08e44760212ea644884e6a94cc2dbce2420d24863fa57ce58e38b0dd6e9e1723d70e0b78c8b8eb6f44849e0c17151e62a7882956d02c0c9e173aa28a0fb3f42ac0b8c14a343374b5ea16b8433602e50d752eb7895be4127a9e531f1ff64e9e69f1ed0cdf0a46c0084d57ed3f18d0bd48b6f1223f0125a3f8cfe689eba9dbae876269ade38cb4ad832e8366be9fd7efb022b8d16f2eb64845b2aada7904dadd29541e9fe2b23216c76750bd3505cd3d9e78e379a7e2f75e4bfd99e0beb94d5b61b58c0e0962fe15b5619af6cbbaada4f6b4cbdb4a6efb6cb5feb3676023fc69182b8ff022ec5849d37d83d09164dca78a8bb1f423890cc7204605dcac1bf968e5c4094a021588858a98b5f774dc4cb884d66c3bb4ef8c1d8257c3ec067df38ab2885063f0a14ae34ae3614938089cf86ba9d7b9722fc7057e749fedbfa7964cff953674cdaa70f3ff104bb9e782f77cdc486ace83b142fbd13086fcefe6d6a5cf9b761915ece7c1b60063c1362f0c2f09f17a94979137490d7432fb42472edc50b515be8304ac6ef5eb076471184fedd442b64e9d9deda033e376b738b8af66843361d8be74c77cc505f5f503ca87790f1c18a2ddf3782020013afe0f24325244983ef8f139d84ec2c817d23c4a9c6243a3e870793c458f93daa16b25e800cf08ceecb4ae9a4985134161300ff745046d84514e9504e21ae7056b7332a6e8e83f9a31a005baa34c306858eb2e45d44774b2f6ed0da7a49ae78824c8de066d780a3675c44de5907471f9a596a4678822492eb99187eefd97d4f2e369bdcfefc4ef3fa1a61c80ab1ab3ed131164356916447565c18bce51977e7be47a80dba6e9af3b07ba688a81332bfa1abbfd9fb30162bf367f906c4eee8df8e44a5af14b392f4b5c01920c48512ad8ac119f7f229268399687eb0695a0ed66cb14059c38ef682a8ae603739501183212db2acb107cce82cfa8869a924dda2c43578cbc089911c5df1d2042c2065833e74d3e7bf5a8c70667dbefe704a7d1d0e2918d2d8d289de5c65e9862fbb7c87403bf499bbac60128ff97a45a1f094118d9e3c011f25ae9e3bc25ed8ee86195302e36b6e88653e49a2b01beecd7406699b78988eabc180ddb45af3cf6c093ed3685a25c936b0afa6c75eb2699763e7d2617c25c67a6156f0e6c05b639b169f7ae5aaeed3327a9f358e1d9ffb435830c94fa72179002eb23f7e2e4e7d9fc5801144e9971dd8523a12d3bb6dfec5b2b74e0df78e7dea5cea2c6159a5366c649dc4031187f92c4a70400a9837f153baffdc8a80fc2693bd6ee521b6affbd1837ddf0a9cd629f52fa3e90735a835f95c09c8cbb19a909a851dfaea8d1b7061b865aaf056e61feeb1e1ec8b6948c541a232d2cb4c15795d7d4e69b90d6fed42d103d68428d47eb6d6a50cd87e680fe67ce4ed62950e15b2069704ae57d7e6ae67f609ad9e48f201e46a34e5808e14149b2427be98a5d10b370436899b830eb5f27dd0937caa2a783dce2d55a1c2769b56c28ade68e87a5bc95d897f0b30a147c50ab5978f7a339c16f9527d645ee040a3beb6426d2dc96e2ca11c19e0d29c19258500b5f343be81330b3f010972856003f83645a6e1078ccf6775e2f91f22ec5e54b9eab2fac85fa5992d659fd592edaa6acf1d5272e40ed8f77b9eb741f4c6170f0f80a2af8fdec1fd321159697b65f8f9def5abbc93c83bdaf954e83392d67ee272f1e959fbec9eca6797fbd7d0afa82d31e4d318b318ac5f90a6a09b25ac4ddeca1eaaf646e579270b44de7dedce8589fe1b33e7b9bc923c7ba51b74416a1a39f304a4f97095088927f3996fef56aca762699634043c5a1f51d4e5470885f93c3b9910f5fcbf07820555b3b93579a15a71f8ceaf37a2da574a356c0d9061123778310c8969f176dce5bb572523464f5f8e255a940e627fb28cf4c4c8cfdec836ccf9779d183e3733d0fa442bac009ff70a5b5c7b2737c81a64f9b74fc6ac9a248bf787ac00fce8e7c519a8b4ca62f60609157831c1b0254d2996a72dab843ba14ebc921e86de6db1084701050723b1bf6f6c733895fdaf94e643597da80fb156f3b5c8eaea4b586a7282a4e509a96bd999cd7747a37faec059c72819124c1786ab39d56d64a2a0b7f6ee8a6f62265ea604f5de748052089a722144558bd111c525f07ef88f114617f810b4fc60e08d165d5652081a440e57cbec86636ca5be76fc4f3a40fa9746addbe5b3be9ead2a2267683051634fbd9053b24d4112ec532d4445147844b83c93c9dd937c02f7eefc27859a081574e225ddf4ebb6e149b7339c689bb7d29ce769f4d066fd2430acc18554a27d17117ca13296348d3d8fcdb3864412f13b329ee3a937ada7508d72f09fcb11349ce92c3c12be6d4992b1ef3a6b1bdf97f01e9641bbdbca7c3dc1354d3ff427d25b187b6b67f300d1f0f6bf8d8939cae237e12ac2ef45d8c2fd08b3ba7e573af4773b2e1048b731453c0b992194509d679697d3aa4054c4cf82c80823bad9e869b6373f4b15aa760a828860fed994d9282bcd30c01544325556c13ae2cd3f12beb4d5775c6e259f89380362699f5e10df07f73b6c0cb68487d5f0ad452ea700237fe66d662db7ae46b36b8684bf82e1d44f9d34551cd7a51960cf57fd00e884feb6e0c112fda0733eeb559aed8cfa72221eb5a2ddc0d36dbd3ef59300c7f0bd1389e65d1a0bff8ccee623789d2baaa2d7beae26f5da4b5df25a7e33b12f2a501703ed460785b167d0aeafa0baebe55ee425b6c37dca4fd2c4171789633c237060fd2458897aa5f6655b0f586f58aaf1071b0d33bdc59d3322baa5ccb7eb25e2e3aa21c684dceb1b499089a86eb8546f2cae706e4c99b4a680e11a5705e3f7ef4fdb5fae1c0dbcecc6d23f0fac75a76d4139df5f81f5b12649ce3964297a9f19daf0297781fda3ba972c1d4d632b05037ab8968567368a203cc4b286bf44a9a7ec639e0348cfad9e8de45911914aef956fc3a236ddef1bdba77e2f47b3180d0b6da442292fd7b7a26a2e309ebcd993dc20880eb3f2e17376e57f85ddd9d16aa0dad35e7659be8c5876c01691c3b93f2773e4c30f69e15da8e4400647e622d791db8698e3a288294ab60a74bf48fb0c4eb780b11a1fdb15a5cc43a8d63c42eb1b82ed06e4de9be94ffcc92017b83577efd14d38860ef85e8a91163cacea043cca3a58a38eff31d347dcd5d4199c154dde5f2929b2300ea4a821d851db071197b916b1bcb9a29e82f041287989dbe94e020829e1985ffdbcdbe9fc674ac2f9320d0d179ddad9bf88dad339a91e0d16d3cc7b019b1df89bb378115425af7f351cbf173d0b9a7938f9d8e72c887d39ba0adea3907de22e932e7dbe80efbc071fbf8c92a63e84dc7def4879d271ef247bd37d0c2140404d71403bf6bc576e1cb7fed89cfd7824279ceeb932eb25c9ef81ce08b7602e74d4390103f486059b4fb7c2f157aca7115c97708420b1f2c7e2c3b35461c787bacbf64b9bff7e149a24802e97ded3f66ad1f9f0f04c0d675cd59f89872fed9561c8911a3070eeae4e26b262205f149e6d959269a1845b84ef385f48fb4b40bc3014ec9d7891373a9fdef40d931b02277a97995c4913b68fff9f7ac303e43e4089ef4c3e04295872e13a8792565322d5909a252e320c365c7c23cef16e8bc5933d27bd0db23a85b9a61f937bd6d092aba3139580764ff323b241fea872715669669dd29f7b276ea12b2dc23da18822ead039b1af3a0648c9750eacea681d68e88b1998134b98b94bb2c945c644744d760edecb70e46ad467d1a1701e1fd41053dcd3def041954b89be3f9bdbd720694b0449eb49f1b887a3c7712dda24927bad996bd2cd79537ca414229e2869da11d154a4a2f382f6a4bf4caaec6ecd7001087274c8cfd6e0245e89d1b17c1e6fa39d8c91e2c852bc73be422ef53a448e5e5b4ab1b4409857ac114c71d93086b86de8c337442d1becc499749881e7dbc711bc487d2358abfc52e627a7df0ba9ced359420e474237e7f52ce63bdd1a2dc7698f35afac82d9e6f521a7179360307d26ee5324dd239c979b818d6decf5503ad2559c17b0c69daa6f3a37a4aa23e5bb50994a9615d1845b615d5ddc6ba54289ebf0231f2886d8eb8e48a28d8410980e02265abc71138839571cd834a975468f89efa4abc796060f9768b91f9f65688f63ab3056c4f193521c89560b2f1302af50f53d72190d6063fa31a9e44e6b96215d2f4f3909d01682466698ef32f7aadad7d6df4ba0c93aee522143697179a47310158ecde5f51157a1f2f85a0b32d6fb21ddff0b62f3bc409407ec8d1ff4217e56dfe7402299ce8f1eb3c8ccb577141024dd0fb82b13cf30507e306098524d9bab96f7e178bc681e63896791226b9035f4f98453505737bf47f2e7e350bff52adca43c9bc68febebac4f2b84e50a82a92760cd0bbaf66029bade8179d3e2fb2069060389055c19b82d01ae92501cba45c83bddb552554aa854d3dfadf319a9250e2f46e57f11ed196ffcaa7e44f59f437be65c242c8a1837ff0b3df2a08619c70001a54b843448c02a2f89da02489785b05999a862f9d57cabf3ff4e54d349a18eb23f6c012815e3f45eb661f1367c85d0e83e588480b052e9d51fa9bd05b8254b01a030b9d1c2df5bc3325257de2a8f8ca0df0ccc1fdc78bdc8bddf0b497deae4ab312c5738ea1726df78c7ef111d126be21fc3d6a7f48d0a50ff4140b7e858361ae66cdf68cdced8d38063a81294bcc2543f1d5f41cf1648a0cc38a588a0d3158ae5f09ae2aaf22b6707d525f538cc81847fecedea105dedd8bb919223dbd9625e70faabfc824ab5bc94c2a33723a57d0804215c23608b47aff307b7b46a7695c12034f4e83b667227473a83a6dfff434b87c313096370c3ca483ab25c83183aed97c7ae759b1c1ade1b871b5fccf03c85dda6ffc72214d022bc714e14cc17fc57eee548ef1e380c94420b05822b1029f9de9e76dba698edbe9408c40ad6a416ebb7bf5353c471bbda7a6b3e93dc304b7b4fd4dd47595685500c2454bccf2177a94a687bd9b6f276ff8de225dc53f10c9ec0f86dde9afe391d1f6efe2aa8df3d0e8097c6136753996e7d95a314d98814271ee8a594348b7c17e586b798033cf6b0282a4a7584bfd6fea6650be974726fc00ca7bf66061d5ec1e2ceca0bfee9d99103148fe78514b045aa8e631aabc6187a321a85bdf56a394c6a91f820830a969319f783238a26d2ac8eeb2215873fd3a8adc38bce8660f7ff306a61c770e1503f95131889deeda39fc156fc71e0b3b11e4846d55e386dcffb4b1239198a5cdf10d36f91b29816ab91882e43b0789585915d634d88ac4f2d99f32b6f5f43677afafb0f66134834450c59a9262c43192ff915ddfc15883693b50e9810b533da5d85d369a2ce74a709fe2ed39e847ed53c26787078d3313c3cad0fd5fbb14c18afbb3672d152a3d4bea629bb39058e2cb4c8f65067cdd77cc874b63464f8db04ac71c10905c760cebdf35f68acdd2fae935ee9d47d95914388a9a5f6a7f46c7cea6231c9a8fd04eb9506c7c3263003ce0f6c5df767586b64013a3df7213118691f707cde69b337623c16bd85dd59d43339b7645817593e86762bde6843024b91d11a176dc4a0182e553ec9b20e25d4be8cc7c28d77c224a6b9e14a3f2bcd18bd9c29c7d6e8c138b2e3f17deebb7d461baa9413cfca6c359a87cb23093ab5646cb7a444978bbea48d95cd2ab6660c89ddf0d49b409e6f5e34c814add7dc985eb0b9003dfa732d6ac599eaeb60f4dbdf5a966164cefd962d80f4aff5169d824eb53b1ba3883ac7ee358dba1f070d58797e55cccc1c39365ef023a91a8eadcc5dc33914e8c81dc23d904d9caf7d8f34db97e6202a21fcf41a396bd811ef62f138cab617b35b33d1c1d7ac3f93ecd48f3ae05edcedde6d38f156584182b1abbdf7ebed89f615d62afec6181f23636ffa4f2d50285a63417be7305f0af0a2d868b8fbea166f4c901fb9da0f8a0d69b4544d059d0e0f399ed543973cbd4548ecd32b4ca7ad58b1757af5c22f58c351600d16074c10eba350a4335ce69afb9dfd7eac7d4de2100a40c9f768e092d47b493c9bbb1d80a54ace3525b51248977ff66c7e1e77c1071bddccac008ccfeaf4797f0678fb7125787448b958fc4dcdd2f047dd8844775980c47d6299afc3d4340bb06da2caafd8b16479645f04106845b448fd683222a874a1545bc2d26c0f932ae67f5f710827f0d530f97d0b8e0e7805cc35386b6fdf5103cc7299dd62ace0ad183b2406e7d328f3cfafa82f58e4bdc8416419bc7bb14ca2602bb7063af5e1e7c1a52b9498899edce87ffd601f95c7858dee742a26ba44f0a8f7b12de5819c226f0d00f67f49e309e065d5405e61a266b5bec466bc19a629bf993ee0234e2f1613392c37e67848a89cfce0b5df667aee203b58029e990b227147f721023f3b9c03a1b84d9c966298c2a179a2a56f191334782bcfe9c7f9594a5b3c7447792938584351f5b613541dd7b5aa4c4077732f2032545b101e1848b3fb40338932ff1cba023603d2234653b75a9d16be6220815cabbf0716e3badcdfceab1e9912a4b0aeb13e4dbb9e5973cfb07a4b4469216e5621972f0ccdcf41fb004a72203e09752b951baceebf98584d7805cd4ddf1dd00859b4c82dc09e6ab6dde1401910b195d096b0fb56b6cc5bdc7f8ff671bfc9b9baed556c2491882ff6ae57fdb3b99d15af4985738d2c768769c938421c23213ecaea55a0e62a1c7cbf4f3b7a2d442754a29f8b7cb66edd91f72f6e549e8f4f45e48829c57df5e707181777a285e300a83d1508cc60685f8d756b1ad98d853e5117dfff2d4e1027093e4fccb56ddd4ed0e9546b21c79f456c7213607f31cbbef1601a08dc317af3937193c425d0fd48cbeec683acb5c844a96cd0403b72eec6cc8704ad0c537eab172352ac58450677a6ad237cc9686c5787efdb8f33c57468c58b84ef8f496d99fb78d795deffcd6579cd1ffeb321b27fb8841311b89f40d2c543e1f1117ff41cd228a4c09b15e9e2c9f3fdc0bde0e46e6c2fdfd05a1287f79fdbafa3bc90555de1b3f0939547a75d513d5c2d98d959172deb526c214ca85e1fc342997a92b4f951f61e8ce5f62f28088813d312a0646a31d7dc2c6d3ce491758ee23a1e7dc47f0efb765b9ea618398e48dd20e93c4deb01cbcddc90db2003e0ffdc03e8c24d1e06e79b176bf51f8afd32dacf0c8336746e989751bd8e9ba340c2815a12d613eb0cd7bbfcfed708b6ca3b55d5992680afb32b18ecddce414058d7b8ff1a53965b2a389e603632697ee4ea8105a1381dd293c3e8e40ba396d39636e4a8502de5a358a65b4f11fcfd85badb4d4409d8180bbfd289bedf791f10253ff86f9b4232d1c9755fb592ccc52b01f9b5ac711849b1d0c6c245a414c610b1dd4109449908216032f4bb0af076ec281892493c709cc3612c0ca7f46c364a0b23a0822fbf594b14a2f5724a99ca90f7a57bb995053744f92d92d035a833dd7ffb1cfc36440a56df4b781ca9d6bd6e454f94abe921e3cdeb0bca53ea9d5595905cd1439ebebf2bfb9646dc1c2e412c23b31a97e8b53dddde4f99c7835199651fc7a314c7c2571cfa7532b06385b7ea802702d00e534fdf1a0e4f27bfa27147c3e10fa79f248d782aa0ebb8e98941f83cbe2e122632df7bd8c08ff4e8a6b2979e0f33a8b046d7f1607d6430c85a789f93b50216e918fd328a4860520decd0c63f24c5790ae04042ff4a1d45a65e57f0e3d42516d60d231609c1b24b29a6b61568b657874dc7515d53cc3ed418f124372491d89051dc7497b0787814884fc15a79bf87ad3d3543bad057c881ef8f267c2b43db57790f9ea1c399c6862d285228ba3f4a7e6bd157ff0e0e9ef933f0a111ca3a78e91d2e32fa93d384f605de6230ae0da1e6b1eb80926b48a58ed6fc864ebb69757955e28c11e18413cc6662f77463e48babeff3b7879cfaf47e16ce0ff6d7c01f44fac986935d3ccfe6698a240aec3cedd735d6c9ada8b6af9e81ec532fb8bd310e6886b141fff1998a1a25427a727397e5d66ed47a1dcedacc55cba1f6e5cbc5f0d06bf0092c49ec61c36c281de15ca3c761c03a87e02b25eef0abb8a0e143fae3eba57d6ec543ce10ead50bbcafa9f493adeda271d3c87f0edbffd9e9606c6061a7831d663730f4994a7557e35a5fd389432f74632d0df43793d329a55265299879d58792d9240ce5282a41e96e05648f2d8180b7bf3f4b49881f16871701c8e2b09cfa738e688ac88da9c381e9209d37e0fce7dbca0d632a537a50f68a33cbbc7dd57ea921e7efa874f39326f2a123b22a54735ef8d4042e2caeb8da15dfaa63e6d40dff525f8c639f77953bcd9897c37148e95064c186e2d2c69e625d328afc5ba2bc81fcb34c6ee2e8a7f4ab63b49e4689f5c48f59243ee00b66290c231600c1e00115d08978db77f46666af559e1270223a784c0e5d36111d80b8d33c608fe9e583520747293b21f36c4d75b3234f4a894a01bd34673aaede1c166010f58221b43b650574afdcc3cb10fee9f01d40b6d14e1d6b40c07765fc743196aad82fbf8e81f282da64adf2a1bdd37205328db011e5d17854a1385838021f22bb22fa1fe31ac95ded9d00c2656ea419b5d68829161f14054756dc25d8f7e3ba6ea165752f5a155159d9f4cb1665ff6a899942b9a3ad97fcec09bbcaed807012a6d7d5c9f7faa51750173d5371f0aa03521ea8fa148ba585baa33b46a98f2947f8b82d40d3a9ac21683e099dfabc7cab983ef96ffb039f39393edb8d680be5ec5992ec513a3665215f88946f89be4e19868c3403c98cfae1b152572bc83797ff8ad91135aad732d89c56ce811608eb24a6c4aa495f03714d19927cd3f8a8bfa13b4ccc0dc6a7a391ee701ac6781380cf7d204c68c3f1d82e291c731bebf4be57c8460c67b520f4907595265680c8eb66b87e8f4f8e11d75cf45f9ae7c0771a68b50a8415fcf9ad58bc36f55227ce01d5cef9e42e723de0e795cec6b18d4f43758c225703a75030c6d99818c4315e1e762b2a3b40f04f2d15519ffdcadbd265344e218de3c630c182992cd226a45f734aa1d4c94b2cf779cc56e3aab48c7c8072924bca31e9b390827e56eb0217b4fc4919bf93c28c0dc18b5c19c8163e467c450905591d5aaf7c4a408fddc805cf562299b323db08d210fb4116d312b4228881af709f37ddda0717ff7d6f38904143b870fddd85d64b13052dd3adc8cba16fc0843817f320b9052dc6a0ebee1cde2788055478f97a8817324ce8ec43782a8fc064982fa104504de8c908904c2cb10fd1690d21322d16731e86579d8faa708861df2c4c9e8673f6b536f29152be34724d1eafa7f62fa2cb37e3030074449e9cb3f17cc967588a9b2655288ab8d33e3e6410c36fee8ce4864951a8f7357caa86c5f7084dd7703c8542aeb29750a7fa3f32e700c9fa65de47fa2efe3c08cbe7a935a2b9025ee907d5cf713f3adfdcc6b2e02a65a2055923afb1eaef6f3c49dadb7094403f67cc995df851d3998e34c4900be8b1dc84092b82c344b90fa383d27469c2be8c9db7e2ebd3b45fda49f88df0e1cd500ae32df261f44c319b34268ace742eb581bbf8de23f6f25276f85f597c81ad7c9481cac8a7b9edcb413ad2301428a4270102592c11988daa79ee4f6f46b53a5aeacd63431839b8ac377c66e830e71f87080c322627134035c03079111d73b15389606640fe3533b411f2e6f21de76616e56fe271c603af7f832fb35bb1ac59fba2569fd89475583e623afe3aa71342941597ae69d77373996ff0b30b62907022c3fad45313effeefd83363a88d1ec5246ec99a0d661c28a37125fb876a86bed3556b9b0596a93c99e3252d17cbb0f236cf09d71b53140259ca3ed5859337d5c7b0ff90e5ef8c7f9adfda1d0b48043d503921fc21f2e8674c2c68fab2039331a6c461a651628586568f8b6e06517ea8505ce5b62da24da918827cbfba3bf0cd195bea4b452beaf35299bdb5efc1e0106a09b101304cf80b15f68ac6bbb8fb5d01844de74b64405091dc83c19b310e82cfd291025ec94b24a47964991ac46dc54e13afef14977f237289e6b0593a241cfd62d8f7320dceec0e2256c854f286e10c4901a214931ac2bdd5961a47f4c94d0faeb6dcb1cb7423ddbfd4ef1085fd5f13209fd24af47d20d5eb0fe65220150952fe08003f5ab6e4d67140a091d9dc975645dba576b0ee10f48d4d11ab7fe0f72088d0af5dcf0f2bb3fec00ac24cb933119065d34050f983094b67057711386a50b0ff7280ec3628cef9c7362cab2470f4b6d109d8cc8336358007780d561c428f5fd881ec40d2f54ba7d441626666ad6fc063e52c22d9e91faf74ca7418f64bc89578b017c7f6b8260efa18be71d3a9b7e5cb80b756d19428d408f9d14764fa2e127541703f80122fceba5c56747e6b245682784b24ef92651a170e402f65953c01c2bb153b7ad2745d44183876040c01d1c5230b42fa609392c07ccbe261d3397e968005a2bc44f229f28ba4f3f07e7d6f62d9fb2fa9e76cb7276e5bf6a12c49c89aa51c98698ca2494472f93bb3695809ce1e5e7bc7461a19c313f42a29efcc01cb320c8cb5a388162c972526e7dd4e92669b4234c3373a2910201ca36567118e2fc6ccc02cb1af420003abf10825f6982e3f97eb27fe4c4b424ecaaf4c7a428b4877f4f0e6a2375b8cab713b0781fc2e2e6fd1e3431e1fa27120e902ebd022948b79fbe2bde2228a7f677882b8232b1621d8fcdb8eb6e7d9d69b8a9c3fea292bdaa497ef1ba4baf7769440edd0ccaf43fa58e84458d8578f088963baac5d9620a329563c3a60bca60bdf861b3897ee5a2358c7ac0fdc7f901d81a9532013ffa036a9b7079814a0cd4c798f5bdcf7b6ae404d8abfb401c9cea63cc0c7f17c1d5d08772dd7a986377f649552c41520986cbc6b200f3d70e0fde026fef1cc3c32d4bc92a535cb8116e5274ed68e15521684969e43ddf81b3bb573a26794df5a47448ef4f547077cad75d5fcc88aff65a417e7899340b8967e97898359a6bf33cc8830afeb51b2a48aebb1565a5a574a4f6e4028464e72945d0c798bd093aeafd7ab848e2b654ea0ff55bcacf63318f7d5279c458427ed030fca149fb49fbaa6b1a1663e37761a3e77cb0b42783a332a48987b40396317f432d4524a2930a6a249efde6bf7609e4ee9bff1a5198d67f743951e8db6d5baa6ed274dde0325cf578af2512583fc128a5a5ced934e36f29919009429ecaca8cc82d4e6e8710756973d78c8f97eeda6cc773616cfc609163542fe2b5d3f30da9796bfd0c80e13a4e6d3ee7ab5b996a67b95fa873e0a5e49fabc0bf3cde902f19949a20b10d548fc6884e309a2705a46afb56fce1dfcfd72f9ceb496d6504d1d90f7e7f69368eaec7c2ecb61b57dadc661c356a37eec98f23313a8d7d9ecd9b7258bca439e3618ea87a2c627857e5ed5c0c8b1586ec351cdcdb83c7759e7d491c34e9d4a01f2961d0e3e9a5f2a6f928c0b3a07fe3cc532dc221d62e4451800b2df4098e671b96658dc8a1e7be4f190e819658e1ecf4429ed13a089e1a01c79cbc6c2f67534ee3aa88e41009bcd71a64484a3d0423d8867ebf4c66a51eac7ad4eb0ee5531e33dcaaf3c60b3022d8dea54bcc9e9d0675325d6ca8190a1ba891cd4bd876103b2d2c4a9a85cb2074e72f312fbd672c25a744d8c5d8d6a63ba7a6ce5b07bf8cc3109a71e1b6e5f3c4eb83daaa39cf8bef31b3a84f4475ab8c8a3c92fdf12bd61fac90fdaaffad7e89d44aa8b53e7841b7c7300db2844f6e8f6cf1ee0f124a377aa28f0ccac7a84819878ec6ca3ac299267f3e52ee5d391e992a00c7388f79b79982e80eca05b02b6bb8dc9d2735fdfd99d3b36cdbe2d95b178e8fd7e17e3a1411f54b05c25a55bd58d20085f18df9acad0cf816703c9dd77e1b7a4eab5f8aa193ded5d667ba1e4a49456ea14b0412d5550f5243daf30b28335d5747d8afea63c72a083fffaf579af51b0fbc7af8352604f00fd5aaccb8d60d001152607d4fd1584021066089023b23192c872a105fcf84c53aeb6a8e879bc1abf477dcaad0214d39ee2b471af042bedd4b080623c79917452cd4f53a850d3af15cb982f525d1b8cb5bc382fc34038c25d640e47318e70c7935d23285f9598255bc8cc39d314f1ba468cd3e94d58bd851204c05c8ad591b7f01a1d3f1372b11ce43dbca9f729a37ea9bf68ff60792bd20795075705327835fa84eb0fae8d144005d989df36c06c2cf35387205cb31652f1ddbd486cfd7d3e08386ac44756a9c0abe032a581ef0349780b244af3eaf65f54b4c3edb8211f48ed646c9e39b72d7cabd8df610ae443611df63388f683e3c750831f4c4925eeb52564c7209a9faf75857cc9f89b38447a7544d84b942dd036bbaa1c908ccd2656d0663fbf3e45c041ee0cf99267777a649a18bf11842e341c7684d868f4e944f6501c83cf41626f4a69e1c1e14619b4eab87a10909b8b3e569fd308f593f689fe4acefbf6e283b78e24e249f711ec5cc1ea7c9e64cdda5a2ba69465a7742ae9ddafc20d9b8071158fa3f7564100dc36a3367f7ce2ba3a13560cf85384c3bed6b3df413d7249199b3aa089714665e74b098a2357406097f2d530be30629cca01f04b7b705cc8f5bcaf5e8957eb476d54cbe6a7103ec01f8b53388935123b5eef774539e36b63eabc8ddc5effb7bb89d74a09e7a46cfe422c89b0a4ff9944d1ad5027e7217b7e6a17dcbdd61d83fcf3ae00843513f66eec666a498c4d5666f5efba60d7b12d768f516d73cba3bcaf413189b3d47aface977d114481b735acf36c931a17d7b07c677fb97704994f92c2eef1566f8adb27969d9055d193c6f87275ad42028453338233e96a16353ef7d45b886afd11d231253f96d6a1d01403d2b3e9ad15af9f3528e3e7ad906e05c6dc8ad3ec77522d2e199134e21d0e2873a2701bd12a558e86da6aeba63db10330e7de802b175928a34ccc9c79d4cf69ed0faa8325d4b26b803caba97ade0d3699904644d59288a46da1290d68c3af3ce50630d0b1bf4f515e4ef88869dd3f64590b57753ca96690bfa878833aec05ce77e90ab5e62a339d439a00cc63540eaf03a5c854d488fbbbed0c7d275f20f4f2d01a8525c97b8ac6f1c46b3f26bdc1a32c0edc042f82e2178a573d594fa8c3728a5b2c104dbfeaf589badb1c4d053d7f010ab621ca24fe7a922ae50d16c593ad22d08b3f70b3f11d6967ca196346d693b4fd57aa1c3afc60a55375746730ef6deace45737997fb6429faaa2e60384f47c85bd9a53c2c9d98bded9cd07bf015fda95a44d8259277b7c2f3123d18d97078cc1aacbc120ed2b1a7869ce8116729842593f544a4c03bfab4061fa937dff16207d3310b44f31612cbe4bac96d3ee13d4598ad73ea2f067080167499e3032d61baf7e3a69688d3fa74b192233e9048dd48f71b78a358664d503ecde01d0ea22138d357ee927edf5769f9b145a78a52929df11202dac14581bb0a47e792446cfa9d9c6de2ca5ad0eb9e88e04f4387e63b25259b42aa032bc3e7f89d7d6ee78ffc93540ecae76f1c46af2118ac0341ce0ae1023c90b4a9fee6e1d08fd64790ef915a16c987f08d93b00499042cf8e0ab5e8a7fb847dc3638307129822318af998ff4209a012459841266f5c96c3738b80942974edc1164474573fb35fad2de4827c565ea1fa9ce8a50d5aeba280da0c838f5c04497ae3948378366d67c320d46f62ebf92eb7889492069d17aa9931d58a9ea42773df9109ac77e38e1cd9791b02544645768b7a85987fd9cf5a877e6b4302242995b6276da16c003e78b21813da41c12dca4cee586a45c9fe1e4d44c6855e2e18ad3e9b13c67506eed114b49ae4c2c4107467ea4107ad4c45cbbdf31ecb050dc4fafc3e667afd4184dfddca4fe21c28b2dbc80d60ce103058beb72178c6bcf4c020d9094e59211edfbdc57660e5d05fe923d72d79040752b3d73dacb6ffcaeaf8b7a0a82690d2256e26b79b4564fd74e433ba79153246a9cd11a7faa7fee699441fc0ef14957563b47d65aef53e1b3d30b8697fd775d4007826ee8f81ec4a840fbc5515e1e822abe1f883b13f63a733b2f0ba87094bb6a7a96322692be48e5dca8d582512e370e8c42f21f555df0b6416ab285761f7e4671aa39bbc50d4f27ba102c3e9d7053a511c8fb79a0a1c0e03360dd395974d61898a62ba895e965a28bfb2aa7c30bf956732aa533d7fb883e20b0bb0efc690463b30f7335d0968122b4edbe69fafeb653a8ea1c50105a826d9d0bebc0bf901e249dab9ab91d2bfb6e14d01a0829b22a43aede9c9d2e4a1eb8db11d9a9e1a7cedb87bad0b34ec189eac8b67d04d3537129b527b3eeed034f896dd56b829fdb0607c737b24a053d90345c0dcd5cce7b2cc0ad579111b9cdff6934f8a990146a17270a0422173a8a3ea981f613791a58f5cd34476d62832ed84d05df0bc03e79ebbc7638857b5a4ef1b2d4eea800281b4cfc0aedf740e07ff37cdf5e5a1fd3799fb2e7a22b1d3740f6ccbc48b6825f8c52118eec6cd7a3501926d5c10c705e1d49e685b7f23d1d3ce8f0dc6342ae19a65d92cef473f7ef04f01e84eff2a5964bad67c1e4bfe701a27fe248d5c946ae291ef740686e1a0b15f74a4cd2c7de70bfa945e2976a9325ef4d844c3e1a1d2c89f980bc44575b08bbe3a1f27f89145d9482e18440d91e3309eac4e2d1f5e83e23b1d64201d5a897cb1d8a73a86cd457542da55b52064f15d75941678e359b01c137ed6d4f792a6f31b9961adc3439cc24cc3e35f51b42809555651fc8d6a509db89675950de192be00fd848f19b8511d5311d49e147f287f506a9e5ea6b1421312ecc5b00f10dcd3053d1ab0087aabcf7f30d5fed3bbb533cbbdead89b4ae87bcd4652d8776dd84cfb9425741f56b65395691bfc7111e993a4705b345d630c9909678f3f03a6ad93fc4e0a49004bbf4dd14da2fe17b350fb0c691cef62285fc74543dd84f6008906ff0692f9f63eb8d05ea95ab86a18e6026c172ffbc40f14266cc4da28d1899894de380d73683dacba08b6a0783014cfd1bfd81d94ffcba74beeed6497555f328b787241c295327333b00f233d8faad860e2f3c4437154e7dfb1ef665b965237498013fe6d1267ac6d150f60f833e41c1b2e4e31f866d1298ec207088ed120ff5e8719e9daba57d5886933b5d56998a98ad49f9303a8d90dfb9ef2947e429220a7041d6eba783fb12cb2a45c52dbb834137de7e75ad7d4992593e8907aa3d21c07fcb7d50e34002f795dfbce3c64c93b86732c1781c3439b3656ef2db2590d775c6f389c99f1234ed0f15cc23725667becf7a88f59622bbc7ae960feffc390eda0a059b76c23e338e12a5b3747ac0f364e47abf6896feb276a9fa1ac10f5551e7144594f6c8cf187cf6a57aaeec3f6202cfc76c735cc90006e4391521ef239698948dd904bfe71d38afdd08a05984fd056134c664756c05ae3a7c8866a9a91b480673bbeed064c8023715a2ee299dc5efd24d7c4dbc8f6e7622051253ef9375d8a96c7a733cc0e0b8c1997c3b2f852434727b33ae52927f4aa670fa6cf2c829a6c43bc231032aea265ff1cfbeb25ac104fc4d68922f633c26071257674e6f6d5cf9d5b57c13179d9d87da51a3db9803de89313629ce9264e11ce1705d68984abbc238657183e99d9660b77d23009d0641f9b9ca39edf09fab766384934063303a3965c814fa21762386cc8eb66e46a1ff9609965c2d69b7311363f73370b393a91079d12fe88fae6744fa94f731b2fe67d8af97e5d34112ec458ea70f049ef39ef174dd6a247ac96e5cc787bd1f800053da2554118ee1c6fcb81c366479e589faf4b46aae229b2e8011e406c58b28bdb5080c400f91879d952c4629540a9da10bce796a63cc7cd4e75ade2f06ae64019ec84cfd408d20610519e16c92b21e260372adf5bd580f340b03f796a31b002572feee5ef3640a305200b7a526bb22df8254389b3b6f048686e3e6fbaea7f8206f1dd02d1a75a82f668183df4c8527e6ef794c29cf7091d48357c24fde8ad46201d871458d5f715c3a520aab291ddd50088fe1dfa2b3a89a86d43cc4d5117c2ce83cbbddbac1cc8a274d96cbbdc0b2f06a4f85b1987c3895b5aff2a9050ce18c88ce024803f069db7fd8f4e9583eaba082029c811b17da823edd11fe46200801ee5817ab70092b3078d8f454954e253062d6964d72a10bba62cb82873dccdc5ff3b6273168964dcc6adc9304bfe477ab64416a0a04550f91745e6cb93f70c869ee50ef45f1c6c11b89b3d567c30012a0265b658db57f37c5721ba5109b9fabea0af5331ea77e73f23cd61bc5e205e55432ef0e17a4df8da85ea26e4ced20fffc746c92dedb55204b77747847fb334a14dd97d7c4fba87c92dac2e2b673400c9ed83029e92fde402a89666ac79f8472a55d70fd2a21f4b29a7d8765fefdb4fd6516ef7e3868ae3e6c0a96a50bf568e3948bf838acc94b208c25fda0a75d82aba1b1555e03ae02893f73ded7e7fb12c7f1b2b7f297cafa1b179d150d57aca1b8dbc87804c66860788bf1a7e77a5cbcc2428b09d48e3fcc3331e98e19d5b3927de21eb124f7b724b438ba469ea64370d7acb2a6d841cbb3975cf896e87cdfbc57ffe60892fa667ad1d6ea966c7b2f683bebd01819039ab723ceabd77a6a93fbbfc1e21cabe6eea758193bf3b3bce67b1be536227ae8b692e567d17b2368eabeeb30d4be3581aa4736c6b058ed041db2f8ea642759a23febc5393fa817882d08ce5ff6d70830345484b685f2c4477111f38604d2f637afa46f1b2c968a28e0d88503cbd647cafdfe2603ecb4ce536d0f2fd1767f3ccc556f5b82c3d5fbacda396fa75dcdb12cc9c2b8743b358de1549cd81c1a6c2f9b086ce6bedd22d96c4d380208ba6b956b2e97b412d5ad15f787f48908ea59ee324b201ae07055b07e1858aaf178f82658b5cbc27a1b7b34c44abaa19e43585e4402796c4b8546ad87c53573725205dfdd4c45668dbe70d4b6a113a60a746b743cd3a0e3bbdab7cb1f20e7877c290e0fbd5c572ffa4f93e98c4103cc1bd4bb1fe0af824ce2492b5c000bf12d2292db56e0dadae7c042c75330ee7e359091376e53a48dfab60649d1f2128f8d3efa47b8af8467d9338d53255995dada03787aded3768d366eed45e5d92ec74c77053eb9355b5fef07e627dd289a2018c5e47e81aee4d900e48d5b403f3dde25ed93c996f90dc8be989c7d5faeb3226d22c33b8873b9c90e6b72627e9edf1d232b3ef628b2b001c0bbd1eb353f2595ef1bacbd6f7af01f53b373b19891a6c967b31ac24497fbbd998fd9f74dc3a1e796f9bd8cbbb3dd222e84a844f1570f6e5a0300ed1f854090b810a7ef9481211467a2470170a227c87f88510b20f5c79bc0998695f811e8f28ccc7a959725744d9f6fd042e47c0fe7ac016161d46e62e63e23c4b9dfaa12c4ed6ad8fa26afc2f8257da3a3aa8b4b375ccd0c216a302fd9d8449b21275403dda05fddfa816f0cf176d3bc53dee6205210d9d249948e0c18729fda3a0259f10bff4e62d104558b894d092a2d54d1fb53b90a292eba51d75f1745d58c93cf538485ca1c681cf01093112fb44f76b0807e5c59021d2a35392ba853c0974e6476469cf13f3b55b65fa491de71614e039f2aced14dba6fbae28e6fd9c18c7603cc81057b404f2c8599928f6c825bafe91161235674cccc4a79ec3ac90ceb1a5b7a9d40ed4db84a1dfd122f2d663a8f2d399f5cd1f0cbe8a6d02f9bbc41dd9876fd5dc653593a80724b2df317939d7fc3ceffdea5319e06eecc6252511d306aaee347e4e1dc31e31747670e1cfadcd8a2dffb1daec4d421fc807688f5452c0ded79c84fa62ea71cd25ed9fd0a3720c5831af16f8bc39cc456e8c1ac1fc895927b2a99a90a3807f451e3c53803a22c88cb09f70b7c6dfeb0483734ae0d7a2448a5072c6d04d61822543d245172415f2d5a0fa989a9a862b7a8e77471918cc72ca012d0bab77540e09e2c6e7f5e23fac8513d12b86cd8ed5e641b6ce70835c2d3c517d4995444c0d210d2c066b4419d1534148879150ec431584d8196a52481638f154cefa114346acc186fea5a2907d590befe6a6dd28c19b9edc4e7e212504629d99cc320094b866882894cbee3b894f0033f59d94090419451f45b2b63205be61543577bfb0a3f80e674a1032eaf38f95045bac1ae7acadf502528646af6f045f12b377db39075dfecf607e64bec4dcfbced3276a183fe71937d072eaf4f28e8b690e75a7dbdc9e41157615c2c7acb83d254cd4923061bf1271717ec7fd316d1cade57cfc006130fff47b152ebd79e071062c9ebc5e87a51a219a5db4d6689ea5367d7630093f4a216bacaee756e49690974ae2f3c3b62ba767e7c178fb6b46200552d3b254260ac1b73c61c0228a4e7358b6b75916d8cd54c357cde0abba9fac86432f0085dbdd52d3e612c909c48c823799609cd65fca5acfd7fcb54d618c83c65e0ad7ed358f8ba71b76262cced82041a1687c8250611381a417c2e59f21e98b1aebcb0569a58b7a6b1c9517d0f0b649698e3e1dc9f04e962bc0f6f766dbf5f54576547c40acf19fd90a6a92815234bf7d423a1faae7cf4c354932878fc1df916763153ab39377109e84a0fc9cac05615b3ded789c98517211b474052588b540913d88e755aba554796f668c94846ba8866c5513e8295100cfb922b547921ca6814b3f9ef5849d012b5fea30860d9106d52de36d480d805298556e11a27bf37ed38265094951bda1823563f859162d368b560adc7fc566483402b1c54d9aff63b32fc3d4686a802944df27f81ea67486287cf1c426bf74f15eeef64b1aca70d56723a2dd0e5dc185f6a2fed72ff3b3b816b833401d860c3604e2f1ec6e7af1972fde7fe9421c1ec8b4999669c5f21f68be1950fe2d6fb2a73fcc7ffa9e3e7b47f2fed50d7f983e003af5e9fa83c8548f923888c5a7c0c290bd846c93f4b4de8f4bd593fa920f11b146add8b31cdc70c5b592b13e693cf86e148c04d0277c5270c26028938df0c585aff67e7a9219275a8c12ca8679febf303d1158e4fc49851dbf6c7cbc68bc2622bb960d688aba9a613a776567d14c1ccedd176f6fe18b61242df8ea9fe62f0dd4eee86c6b98fe8c3703aa19763984399a5d4a9c9dc52e19481162870309e03595c34bfb793e61e35913dc947e2d452b38be05a3de473b777c6f308a06b7ebaa166d49fd621a074260e2d8bfcccbbb4ce9af0d8d51b6ee4c48e678d5e196a3fc35645fac9052524e827b3c049ebab86a7aa1b63a9bf8e204c832d9d001632206e3768d453bc29bb41da714a9f58dc30eacd31b759bb32520a1f531ac70b5d437a50744e4f2b8ec06798e65985659e7d3262902cf96d68647dd4ac07cd45e3d6b59f40b9ad0067717e8a5f1c33cf1452ae4910adbbe3798c8b96fea118ef8169559c22d00a08e9321b52dc21ad3d60f3b97c54fe58bc28d48c99bfcf8b05e2b2b983bb1fbfa4d58ab86379ea37e314f3c52164596186d02a20a45259e949899f15d511f8cde166b8ae26b686478fa508b9a50f07908a95715823a82d680ec672350aa6786f7c36a7165232429007b913fbd428ea286ffe89db5f1875201ab60a969785cc76f55038983c358c2abf9297192455f0a274642c0b09ea2cc5ee21a8072dba766734ba13293f1df796ff65faaee31833bcaabf921704a55396c0b1bfc0024583d0db9fe30f823b5f30f430dfabe8f9a2611bbe070cf6d1d2b2462d4190158467a0cd79484b78000960fe63f5bbd5a6a3cea0ad8ffc9ba4e045b5737e8bfcc711a85cab8c1b8fc5d3271cfb238c8673482f9cc6b65da8110f686f2e2b4214a2f0830934f0f7781dc77d2e11bb0271d6ed15af99245dc2dfea686e4dbbd6ad1eae506e99faf4ec64b429c3a69d0741915e7a3919641912f91f5232e71badc1855b0861b8836cfa2f557459cda6dd1fd1efc4207bf64a596aadbd72eb9589fc91d717e3c33fb3b0f9a6b9433dad01595eaf00e860dcfb0b7b127ebb4299b6ffc941d9842041f589f4a29b56411869e65982850d24a85434f3b8ee234ec7ca0ceb7f794e48e85185f83aaaf04d1cbcf0f31a3c1a239ccfe68314830bfe4e7f9b735bfec0442ab0b55374743e22ad29787eda4d6e9e34715968c957eddafe8801205014183f1b0e87852b7c4e54007c1d35156aa2bebdf716382c4abc338a29ba3413187d20a8ac201ab7be51619906543eac6478d6e651890362799a4f56ac9ccf3e51fa1ddecd97e550cc2c5476488292b1e9eab71582ae0aeca48387d5e3a91ca119511d592dba8d9e01bbd4e094ce58cc36c957cdc9455e8eac5b22becf0cd274dfb44c7a4ab05e2faa77d4ba59ce27c8fd85b3b8c7577e083a996aff1f29072a92cd59d67453364608405a22fc5543c43b0bd221b254102930630d83a7837ce25329674a6f9289f2fc0f2b44b0b0db7d6a4e85dcbdab27f7ecc969553222fc4ffa2e3df4f05a2fc01f1b4d0116d101479f2b9f80555d161e2c2f78b978c02d43ac8b78420574ad9fd999fcad40cabb8588140256459c130a52229785207127a9f9c2f6f756dcf9d344d26074cd385842854595d4bff8599506674cb49edd0663db8ee2d4109a76706a5b7a9a1a0ed67426a7e842db5d59bb9d8b31908bf75b7d1b841e6dc126900906811bf31602797122afda6a1bd01ca1513e1c2e6b65f44ce917c807da62332550d3e4e83db83bee2cc59233f0904eee42bb2089219a6c0cb73f73342462c56e23af7969f2c45f266ce8861f07d2ed31b895f77abb767cd63b26da7c510a3755377ffbd1acef7a22225ab1397caec971173b7da3fa8dde076c4036f38e311ecd60e27b2fc1d42ab60576fd4f00b27a67941a977f7e8d6231036cc304d0e36e5cc860c0e681b557748e09345bfbd4037fd92969ce5a5ca500ede1a3c39f197999c8c348a9fed9ef10ee705c9e6fdc91f9fd3dd115fb85730db13e8c6b18f5402316301e72dcce8ccf3d466b6040a3a142ecb66f6169138e3bfbb5b3211f01e3ec693b3f157fb11fac08606a4baa482a5f4657593ae2bc33fb1454a7f0eb750db3d236a95c9d227fc13bf2021602fdd29b0b6c599f2263ee1fa009695d14de5ee89da781f621d201d2f5ec7082430b43edba27d68eecea7610ae05a88b4c93814d42aed51bf035335e023ccf8013a2e6ecbbf38ed0987bee5ba0dd424a96d25b7509e7ada930571548882ac76d057cb423ddff9d34f4d449fafa911230392ba19fd676401feb0cf81ce324a5fead9f9f84988198575e78e7dab73c8742b757425e15f92ecc2bf8031f9d6b81c5125dc40ce4cf7364d4e576e87b50e8bb706a9420f297db23e07b245dfc843451c6cb5173f49e73a5081d5ca4cb7badc1212434e59bace51aec11d6db46f04fd5059c9b35d279c9ba20af623f42c96888e21c266c120fdf840f3e7df4c7f64818402e6bc5e92443d5308ee1d85842cd79c9bc89358e39e5e1e54a4a679614fff8385b0e3decdca5378ade4d76ae88d1a8d082ea01a9d9e710dee924ab6d8b6ffd35655505367a767b498c1feb314066e463b0e24e6391b7bb12c10bec28378e7b154c598a4412d4fd2d8329d0b12eca45475fa322cec14d30a82c0ab549f601b2c13491475bac398c7b57777d67e94f50b79ecd4ed0a79c9d3dd99a312266e349ba528400477793f1fc4b64c67654ceee717ea2ae1df47c54e3b462c5dea99c9fde4b4040a72eff05dfb2802323e0ad63fe6b2ad478e5708fbcf0b9862c92db4e65095112c8472058865fefd1403d33e506c39ddf7a505bfcbe95651dcb46fddc450dd0f89c863807b4693e37798edd07d35d60eba2e58a888c05a1e76779667db34553b383240035e6e767db2ccbb0206d33ace75a55ddfd3afab89e6cdd9c693c575eecbdb5a48abc188c8e6185afe21e13e24a5274d199bd0c0e7b85790505d821eeb031c2eb9bf2b817187215393e855a270fd677b050c90a85d91a7d4f004faa8b43ba398074219d5f1077a492df5058923d8ab478ed20be750208b226c1c102c6d13d464f18c766de36d41621db72528143d99f70cc03aafad5ac4721a1de2969ac5eb00d2568e5d87ffe8b6503c73067a9a654e0979a71167017584e503a8c13e46e841cb0c658a474e1f77e5f16d5133ea95ce1f4f9f687f04ad8a9dc082dd3363cebdf7b4187ddb1e09cba3e28ff83514781168525aad8b165ca55f0647a7061b1fb835fc4fdf3893b61c3f198b367232c18495e55adbbe385ba14f439e68ee9772c56fd34fee15c454317ee9dfcab6c8634188410d480365b12929049e39f259a0b132b4f2806728315de475424160992e0e17dc60ffb72863e1097eb41f8b6a5c6b3a2ed00a8b3adabd3e0c7d4c5db1c1080ed16f8d423e44cebe0efb7781e37a25de6692d2dea0a794433756f4527bdea530256221ec4b5fa6c9da1de076247a7379e67979a1b0424cd00406eded76c45bd1052876cbf503ada6946f897f2f05d3bd85fcd37b8a20617b973c4c1b4e46d1746b9e5d7b968851f50941839cdd1b89946eb40c61a79b97d75cc6d69bfc5d42d0a1032f1972d1d9bfd197e0383d5e48bec86a15664733d9772327ee09caae717bd0949093baa95b1b1f5d226b9e2ab836b26e2bd40cf88411308058a470688bb56060260540819248089e18e026b1beb37a05b51bfc50b97cb24a86eba72b11c5c8971863aa2fd74a30acfa9398b5bf55983fc10574f1859e5ae240e976bb0d91d3cd6f2aab1a13c4fc8bbfa549fc9b484d5ab8816c56e3588a350ee07744104db6039b985f9d8295b7c9c28b25c816a5f0a135618df26eff79525d8ede83112cdda4a4f5cef894a3590fcc00824d948bcea15ce5899b9d534aec8215d0a337c0008b92d917be4322294b7d838a1272b55adea33e79122819bcd1054fa91b1ec71b7a0aa3583e7dde0020f93ba28131d29792f6fed7d3be99f5464911c7ed8d527ba2bb865a2fd15ba5f645acee441104a01f119070da666f9736d0e03ffd1461dab6d6941c0f60998408c134dcb793a2694c3c920942133703735f8a5aa70e32b6f9a7189848fbe9db5fb62b4a702a2ec85e6fbde183d195d4b37a68cc9daac92698721eb9d967c12afc780569df215b0aea004d904991fc02c843f2db74cfe7cdcd7f8f7725761e3bdd3d7d6d78c3b703371b7390e830a3207183c22363a8e2e985891297cf9e63805abdbd57a3973b6d1787a809de2235dbba507acc5746e83acb9664b9e27a3c8d433a0626f616c62d30d93da8098755afe5387c046ec61f9a79d1ea575348fe194c4a217694d2b6b2b772a47cafddf4dfc6a20e3c03336d111ee1e23ae9d31f45fdc7ed973058bcaf5bad3d0cccc9efbcc33086be2506fe70319ce42d09004c91e883892769ac831e702560755cfe1ad35c18813b25be3f7cc504e028b9fd537d0bf515ae14dd0c8dfb983bd2f45e8d60eee759700d4ae819fde093cff5fbd7a58458bfea4531cb95b99616581cce07f019aaf6bd9e796c4973983ba97948b1f7e8fb442b7d205ea2262e11443204db064f9ce9771bd836118c1566ade85606608738165d8a0fe8fbb88d1743700b798a146052ef59c3ee26dee28101c14bfd2d4f92f31517fa3ababc4e39ece8b1c2edea2341d8e930bbe9877282a32847ae0f866c3a106da2c7e50ee4fcaa8cf9679726b2795f33ffd742a1840d04de8147e4e728fbbce7ee454758329ea4f8e001e11839f40af088d855692be3dbe3cd8dd0a8a3b884f9bebc08b7e935bf8468ad7fff171cdfe5623bdeff8e26f4acf4ac3eb94186ca2af0a0226b1cc1229afbd6bc162896e0b1b69edc7cb3ad6672fd4c0dd33bb1be1b9fe3cabb57874afe19389662d0191d737128d8f7dcb9abda171b2d349240af2da6512d5e9b274cae83740f20801d544e84acba88808240d2eece6d27a8f9a2ce4e13a738fd93fe5fdb0252d39f90c457ac671d47aa3db37bffd328387b4c3129d68b3930240957e364a9d1924cd977d1f57ec2124d64b1c60febb78d6af4e6a096af21e020c248bd747ea1d3d74e77782abf130eae04d90b142c5c25e5205993a417d2adeb73ff8c8c922d8f30e3c52822a649d72729121f124b42ad4351aec39aedf834039b9b0c1d878020319a3cdcb3ddabc794793df6e61be6bd70be101a77cdf910f51ba632c9170d8618222bb16df44b936b668b06c252c5a2d46c3914a267b42445c7bc8916c272d751053556be6257e835d1b95ac3995175234773156e5f163057ea98083a0289ced1924fac3a7c3ebccc3f13ace84775ec4b67445a60528320df01e9312b5a99cb390806b91b47c24539d068e303bb08d74db2a50ae48a82c2b1fdf5587f20c3040a09c1a7b59e016cc197dc0c8193ef59a02171f7a4df0fb550e5d13cf06ad5c3a0b07d7e1e218204ebbdf9ae08dbad3130bcf344eccba115ff930bd2315405fbc33a021c3052b55742c3ac1cb06ea48b432e39d793988227dccbe908837bf6e3fbcba7381d8729ab1eb4d5148a3240371a864f4d2241bd60c0610ea438f0ad7fdb2a621bd99e34c9044046cc69e926210d4d720f4a48fc64178adb52852c462f2ffc1356539ddaa68e5c46611a9f924dc89469ef91d05bb6bf32e1ab067893d19bdcf75eea3854e1e5ba48ea986886f42f9a52958d4f387d3fc8681da3b1630529b34f4cdf511442d7964a954eaa82e1c3dd3bdf48772181ee06bfedf8a62b4208881d6c96ac6fe10e1683ae64ab161a8715ebf1cc54d7d37b167435fb12bfdf3ff5f39a6192a9c9028ae7ac9a00f3078abb67497498a5627e3c64da4ffdf7118c8b733d5b55f9c613f37353cb4df57dcb79b755c36a4e83ef4ebb04e1f784982e811d9887d5a586cea3feac1cf994e9237e32998932ca4f7f4e31f0d2b5ec99bfe4d6708e886dd3965ab305a881868b640681f4af5ad77698e1a697c86120cb2805533bb206071dfb8664387b90bbea8a54631bac78963e22f0e1218f24752f5dd1718088487955fb64ff5b196332fa713b8744582a93e87c75d141a41fc38d27f083fec2d2d0f7f9b85da875fdf5ef1748aaef5a454872a60a9072a249a91eda9081f548f469340eb0a241b6d38eb69f9b5fb9bd1211528e1b776c9e1556339e6408ec61a3c50791a865bacc83959fb05f74f020aebef5dc02befb980c1e6c348792580720cce3ccfa7de1d3d4d9a625ee87159e19726dd46ff2a532a4afd8b747f07cb9ada5052df6719ee1c14be02253a1a6c23495862c505b0abb40b74a877b0881aaca64e30867ea86226361d0d5b093298b1295c7e0ea9db8a773578a34b02b7e8f6efec97687846728925749111e563de6f9aa4d34b9606685b15205c2b10f0f324d60fd82a54520265d2ad55fb7facb411d1621537ee2d27e26940c592198aaa553c74f90991ee7ec116fb59bbb2dabb8119f72cbfa00b67c21d920df43b964204a7f3c5dc6a4f5f85963b310dfc64143bce60d32058e93cdf27c0514038ffc635fe48aec9508ae710eb56ad59273a81347e1be7dc5e09825f816ec8756f426d44a6ce8bc14bbb6845855dddb47824e4f0acbd13589edc0e48637a3f5a0979feaba4051a8a5ee6ff105e414b388225987a40c4ce22a6574ef170123706c1697d01ed30fd56021f22a0f45a8cfdec5501bdb73f19968242a0758ea9b05249316951e9e0989cc5e84f9aab4b09449ba76fa56f9b64d87adddc78e83343f7aaea69dcf15bd5ad79a15893a6014051639ca910c4f314520df6d0fe48b73da05edd52676dd1825a501054d00984784629eeecf4d0f12d44b988dd8794a7554a24f1d9f766910ad994cc82799f15af136dc6650adc16f3c0795fb2ec0ec496eabe6f61409e333c20550c9b5ea916eca3396c8be7222331cda757c39ec0aaff3a01aed2eeab98f94a3931717dc9cc544dd57a45fd7804b5288a5d4a8b2539c77b5306937a89973661518713d40e83102bd3a3dcecc358c81f2a1a9f91bc2b3985b9eb071032416424b9d72eb11daa5adba1a1cc77a8e841affdc1cee355c07eaf1e10f1e96f7251e54555f18ee76cef4304341e9ceb855c75c89401d118ea8f0ffd66037f184f5837923dcf2b726d9eec38824717e6ca6a55a8ee8981e23488f8e0af63388fbb5f58bc1fc70fd676e342514dad1a5057afa04eca8dafd9a8732217dee617b501c49307ddb1b3fa5489526fdf0ebde777cd9b8557be65b96d5e71eff49fb40660a2dcc935e6581e7bf61d2228a0f5254ebd7da53cb6ac59630815aac26a84aec34e26d2dbda9c63fa0595481fc9a07dfb5d433bfcb3018ac3c9eaf3518c659682d158f2d5092e5f01b7907acb7fdece1cf8d6a277bc715729cea80ff6ec405961e90b2adc242fe1badd0be83909f8bc64495ac10c48d4b71712b5d0f313031536def67facc1c72fabb06270f3eed63202772aa13e91d25526d9f0dd7a1fda7df2770bb35652d16ac2c4d0cf9448475fb1420558d357049347ae77e205e72f58a52cd0c71125ecff5b806fee9fdbe86788cb1fdc9a257cad0ed5bd76a50c5cce3311ccef82548f144f245e00d6837db0ad4fe7123b853a28491d77e8e8d5a0acaab1f57635abaefaa75f982b7f5cbac8f0bce8ce92ad0e849b8a6aead02a7baac2b1b380f02444948722aca2bac5a463c7a7834771474042ea9b1c9b6966e148bcb502bee0d606aa80e28044bf23aeb73728c12b8fb0f5d13e4eefb19edbf3ced45807e5ed5fdff5054d61f274975013742128c6a393ceef3de0f5ea09732718a35dbc62df219976dd263abdf4c59f4e5396f41c700fb20cc2833de07abf62fff290dc92118657ac1cfe934701b967e19dd0518db68c90715b50e2932e6ffd8e39d9b66c3fc7b6b2e679d8e3385824f088e59e6dfdfbaf4f1c3fe9d305a37f4ac428ff1a857c1dfa23f60e3c483529a1cc688b7c0106816ad1687eb1f3a9b823a51cec19943c4f29e56d43203b8e22e87de8372e5c636634ecb70fd2a153370a05c48116b872bdc45a53c79caed102bd9c7ff83ab958867395f6f43e35ce1c573c3f3482c6616721b9c56824982fc5be257ecb78f368be8401ec36449df680f2483a5a6d4525b7b9c8175d16a6521066c27dfcb77626d51b1c7c44dd519d4d02edd326b9b91be65bd5c4ff9ddda5256976e782166ed2297d5a748c033a8e4a9d63d948c9bc29d2f836e16d75d03ffc60a700606cec3db56e1fde6500dea96bcbb1c7eac8ff2f7bff45d700544b6c28596f9576a23b3a57321127acad3d3464c40c76e95634913efa56dffc68a39ab5db1b1cd37d1533ebfd406caee1360e356c2155aa5c8e570cbab72f0776d3db70e0951b7b75c61ae5470a11ff58d118c681807d8ec605b9c62487f28d7ad3f179e24ee5f5b1113b4916a9bc00611de524e074785b97513c8df0b3526abf64ba739adfba837e425a4363ffb30861a76682daac1afcec38af872df8eb2248c873479079c2131160d609ccd8a51770969cca29069a11f792a6822761779065e6917abf1c3230bc4a14cc3f8252379aaa5bdc521ad0d568f4896713afd716a31239fdd4fa923ab4f91f059b15020750aba862f8ccba6a44615ec66b307c3c56f6aeb509d7148aab7fb3a7f680db510da7043472beae4a91c047f7516fd86d70233d06035b284d479f73002f6e5a8d29691d741c790affa82b831edea841a42cf82f03afe1c82cae5f6157462e61745d08740c2ab79461b5ee89d1f361900f6e3422cf4d9b74c39d90a6bcbbf903336211a580ff4476a4a0d8acf7097c9e3cd57d72e711489d760918f7159db5d80cf5843c9c621bfd364c0c0626eb7601bf50415829d12cf09939268c4d8265f72c3ff61c077b37eaa8f745e579b9cb08ba717b4dda25f53f5e0f92b4f723b5a602eda970048dca0640c0e0be2d2b094f3166c587dc401a9b5012b13feffffc6e5a188adbf70503aa9fad32f784e1ee4a661f94141273aadeb06a08baefd27758648183ea55df45417f6e199ec8c58c67858b3261d300757a4436bfc82f90cb7651630beb85fdf96af2d9124c33b522d3fd0885fbd0bb3dc439b8eb66bf0a645f5e9c1f5a0ea4976b4c333387f5676ee2df362cf303a8120fb854456bb05cda2bfde55d916f59714f93743a373c3e7fb35e409d4cfca4393f41fefe4e8867e251830cd5f452675bfd7afe00c0d5ef2265cdb2e5194e88bb014bd40c902bfcbd741fe4517c1cce165c3805720c1cd6995324be710db818839db5616ebcf42ccecbd2fbbde26c0a0b21b9c9525551dad37e5a8e75735893dbb4a20bab34e5dbb342592916e4d21fcdc4615a9dd5194c35faf63731724211968f457b5f24d16d7b4eaebc2f0db0e5285cc234b729ef4670d1e73adda70fa6ff46421fb41749c9a5ac676b42e89f503431771bb36f857f7cc1d585ab73108f97188f84b2707de1a2e75c3613478a178e54c74bb100e55ac7fba55d585e55b9203e5783d3e3b74dabb46df5d28fdd3dae5a798ba407718974f5843a4f476f1b785ad2e060574db63609e27c5f1d4fe3c86c7f0fe0ca010cae7f204d4a5731679f027d68fec8ef0346708861a9348f2684cf2676e329863dde9e382ae5bc32d9276ee3e8a6353377c82d1dec3e3d8730658090021f7e60785699f1584e6efe932d3af0249de60d8e9dd8886bb075789a710edd62004ee9188b85b5e48878eb87ba3c62d8a6e4618c47ee09e570314a12bfab37cfa19f60d61aef87f4aa426ec9d68f62c30078e36f9f3c9bfbb55f27d3c7562c0abf2eb247d41778d44abee25e175af881b654ebaaaef3c1ef9b9e4064977146dff53db36ebe186ad8153fb5a38b24cf90fc7eefcceb660ade2873ba3b7c03543cf6a3b59fcf16993d1a8772a38481bb611557e3395fbf78c0bbf5b433182ee6e93bed741352f950ec8409fa76617fb91053dee61c20b292cadb3d7b04a8fc822ce4fb4db5c50bc296987d2748c627637bdaee6e9ba6550864f076a120e836143d073ae36d34f28633c317df10e0a1c609f941bd6c68d259cc99cb5e6b02949fa63703ed81f9d8733f5296e5ea84de38145025795fbec463be5ea43c207a4243ca1bd222ee8c24dce6e7cd9503b76fbc791bd382869ffc4d3c414b3b3fc719de75eefa5a3f6f221b624649e668b50aaedecb027c83dccc2ff0a2fe3bdfeccae7555813a963ccd6d47f72e7df08960aa6a168b79b5aac5e786f09dd4d4c3e946ca9467732fbabe9c07a91024d8079c71496a66283475d3024ec422cb57d9d5d88e416d5394a802cc4f988da1e437c2d7fff321d509823a92102e055824c12e82141b4eb5b88ab0077393cc98077d99b06155e5f8517ba278db022805efb95678af74c05401aaa9cb44bb127c15f64761f1f7b1e630b288d753ed744c82a1373bdb5fd51e3bf31350eea6483baab78b77b3828bc8ae9903390c176acd8ac077f98dec8f102d1777b7f6f6a90f322d207760f4343a014e13c7e46927d03e90b635402fd2c167fa782956555c38e0afcedc29c0f024b5c1604b3bd4e7a9294f8b5d4009131aa7ee3b896289c1be0121e483fc502eedffd6d4e0afc5c510cd2529271a03c00cf6fd4bdb12f8a6782abbb5809fbe879f6537e37bb1490b9f6832e11a6cec75825ce977553c42300039433e130c108727d882f33f588ceafde7634b0f955357f7871718acd07b5161b4c52642cb75babfd7a3e1ab50f7ad5931e13600cd99d3f4c7a3b63b88707e41a54c2e125b1465e5ba7631891a07ce80502ac18e9897759bf7f538519986a1fff34ea52f604398744262c56872d9a902dd3c1c36a849731ee4835bf256cc5482a173aa977ac84959eb471b34a91b1a0f5146e3568db27d682f3f96bc6580f809ba0a4079f4793803fe8976fab434cdc7ba4b97c97a793103696975a370f0933c431bd427841c6e11306300ac9e9d0b8f51a94179c77bc8cf54d8e17834b40b856ce95954a1e67647d5e7c9354dc8705d15093cae73fa1d3491470fe0ae63fc02c4f49f0ea2acdf9de213174f25d86e6682313ce1fb504ba0d161cdc9dd36373f49911e32120d1d6dce1db19813d1a098f25e4477b8ee2e8cf6a71d67766af60d91482fca5b721dd97dacd9d859326c587c22e7329b3fd0ef258304fbaf8242b2129e64f4b9f4818d84b933dc26ef55a8a53c92f4fe08f382b13168bd45902dcaa42d9a8cd6f8925fa2dddc97775e7703c82d81b9fab7958a5c2d180ebc9a1c42e38d14f500f736c29cd061fc7aeea21c160927a9bed99fc9fe035d5a932ba29d70897581bb21310c2fbf155e38b4967eec8793b8fe975124f87fb5550b8f596078fe69286bc5c9f43ebda760f57e44ae4418c53cf053c230c5b9cfa341b91db755a5ccd7d1a7f201b264cf83a8cb688bbd95deceb93d86984f49c699e831c28f520649d1ff9b880859fbdcb55d2f45b940140b30d457d8495667f26dff93d7d05306eded51d37aaa4b750bb582ee1ba58bf5ae34d9632d9e524542fdee3ed4c335b1957a7acd7f2221f2bf0b71039991c1145b392bd4548bd5fb16d3666fc78a935e7db13eba5954abbed8341e4b45357ba31d7a3aceba27617de046e2642227859cd796a896640bdf8b54be0576900fd03e42bea7ae71bd69cc29f67d63a12cbe515b435bfe859b7a0a4ef24498c7502d3ad7b07bceaf0433de83f672d444f1c90cda56ca0bd69c4aa583d6a50c79602232e072ca3992a531f3d0c6110ddca0d40692b40b17fd48774bf217b8230dc1b216be92b3dda09c0c66b322bec84736e3a95cfef12b0a7e591f5a30425962e00f09bfb025733ac67477f057514bd50f4812f64fe5c3eddb77213f497e609ee048b159e680cdd510a30a02069ea6945d9ea676941d606ae2af08268d058f18df4ec9a1e0ee165c70054bc17c7cee0d92100673a5b22a77221a4e2f2dab75533d8f8fa24b6abd1e13319cb4893713d8472659b1f208d3bff01612df4045ec4da9cc647d7adc4e7ac5ee48590a02c9b02594aadb513a5eb5e7c51c8072fd54005d1bcff545511dab87ef3af262e165ae11995d1bf5366177c2ef3298ed5e35cf95919d64b6bd4b779a0892ecdef941edf12505038060a307b98d00d16c435be691b5beff28e2d3c09301dce097125675f1635c368490a7c849af41845db00a027e969ea922a720228ba21508e23d922ce04ef1c070985959e6e8278f630fdf20e8343e1e0337b3d09561851fbfc51a296a2a2b139d9db68aa02bef1829af526eb1947fcba3c58655793825d6457e6ed0e662c4f3473ca38e84b4a2a9955b1712466154b0040b679b6736dccb2425cc7580ea97a0ee06556a7c27fbb3b9b23bbf4049e92a9f30b52618c46d9d50e68a0f19b03dc14b786731e0f8d859199a1213d0948c6939f209cf15664b57064f291279e8e713fa3bc6bc19a9eccb73c6da59ed19d9ce5a24b3a65c2a5cc7dd861c6f598e80196df0649b5b62942119f66c775260940e57012c727ceede9cfd079e6c09930203c5adf3b760c78025c666c4c954096fe2cbb14047ff8a7caa549dbb60c1b9777b465e10f14278f6dc1b6c7a34b9c612207a5ce3a9a3d1e0203796af8d407a08d133bc880dddc9bb19e6fc67499ee904ba98f1d7a6dd2bee54c77cce3b608f007ec410bb12f273ba57c191148dbdc6e25d919647d547764c45a2e66e8967e5a064d9b684d36741c9ee89c207c406d6e2fd20bcf1d1e80e95da6c5a688a631171d6bdd594e14b662cf1c9dd3aa18ed18a6ce13bc5d78f1538f120a56854696de22f3c11d5748555d68f6545645bf93c715f223ef39d531af696d89c26733ba6f52639a82e8d36190a67f46686747c6632aa84a71d17eae2d3fc72be53c3bcc9769d588f3ae0c62c14fab79b453707680a310677c80e2da3c26f8ef84ab25daefcfaf0bb43a06b6509e473090141750f2adce732fa4c950e100102a628d46715a67c376757d121f523323e855b682d6474ede5f71df29dd1982d2766c6f9449437e22d694fd7794a8da7c2517a168688e3ee7226646ac13bae0b72b4a9af1103a5e4c6e47d1b52ebfd9c01f842e48c5ccd4b2d31aada6e647843bf047c5808668c61e6110076c2761e0768d6c0f604757918a6735309e699a4a7cb5e2cce1eea6097af68573f0d274c1865084851a2a5a57ebe8b3acd06d6a710462365d44fe299ee09431d8f857b2c73ac0d24b76061024716837936a4935d6f9257294a49bbcbe68e1790d85573747e6c6fb14136ab807d23ca413ed97fed56f03ca8327f22739107a74052a855b66885d09d6c2e2c04b493e1d2189f9efe59ad0b879881686dde7d6824fa0af42502e3c3b2e96545f098334a01c0454d67e5704314046e39829a5d8e5495aa0008f121077f97123ae04dcdc24ebe02e649e3c98ffab905dc0678b7ee466b6d4692ae073fcb79c8d853dbc14cef842569c119f772fc5e01fca9b7cab186dfb5f420659252fc6180cd366325aa690a357c58d7aee10eb29485e26b3162e014859cc630ad0af02bb4dfd0edc571ae47a1a493d94e83b021063d4dba0ac4b8785a41f5f4950959c96bce72b81e94ba5337236b88bad59b3e648771c1b037b327dea7daf438a4591ab22ea5bfec186543795d050557f76fad23c32577d16f96aa9109c223de7068098cf7fda6599efacc1081a24be8b6818778147cc5005feb696645196824a0df7bb5029dd97f20f68814e1aa2a32699bec7c2b874c51b058dc994c680db03ff3a6dda1c60a2137301698795d7a97e883ac858c55afe74e40369beacebea99d1d5a975653234f78ad551a57fc482223995045efc21ab86b935a65edf3a315ed04e74d3be40dc851a1019a3b2db957764983f8727b20b1f8a5e2bf399940f091775e77e36008faddad1ea947b80f0b202bf2bf5c228befe351b5669d8c77c2186fd46d98ce6d35c616a01aab30f72ac0b5aeb5aa111046dd2107777cbfa4bd4c4ffb99980c2ccefba23b61023be1322be8e890659faf1c8f4340bbfc02d98579d24f6cc6d96804d0557d0037dc0df4b445541f38614fb6d1bf3a622308f60b953794c197c3de51a01f8cc992ba401621ba6d3d218779a033038cd99270d67d67317870526e620482d8a1d64aaaca5cb3d83da907ca0902d7ef7b7bf1ebc762c8c5d9843777a7ec93c83aa609c46089f34a6351aaf813cc351387f413eec0881e0a46345db15579c8f5b5c9af5fd5162b7f492768c0b754ce0a0c713b8f5528987a8096ddee663fb0fdab32e92ddbe323244640725e7f684c5ec63d7778bc538da6a57a54bce09908044ae4643fe49f444782cf0cefb6c70490a80c8291189af317dabe9e67da5049ab2049dd1c2bc7fbba783760f0ac4ff05d9735f88b7315395a3389e6b6242287cbaae45eda442ee15b67134d50e1601e4e5d1b12e5833493b4df17547f845ea2c3cf7180d13659d776a38d8580e1ddb67f14b26c7efb05a59c51c6e2335d48c1aa8839758a454de927e8961c23539bf7ce2f5ccfaf62e3dc78864e676e320142d172e50fdc6194d9a1ea911710330ae4f4fa586ea9b56290c7e2bf0450e79d20f57313fa32a0b55952e86b0d1b5bb277993ec9cf38bc1d0093916f25a5fc1b5d6e621c16296c3460c358c6bcdcf1d5cd1ae76b6d5631f8fd5622c058fa42203e4966a1d6a2693c59e190e51337a401ad98ab47cbec178c1a9f1413035b79d6bcc0ec82961bde18b7ad851246ac7e1eeab6e338d3f96881635a8a2e99b29d5cc50927a8b813c3c0662b82790e5c2d730590c2e16b26589362a1a53ecf487d7963e9af4c0e88d64896714400243fec7bb43d08a7d1834a92318e03f6539d2c665cea4f1b008f68df0237e014601bc97ed07753ea96a8d2859dfc831b7d1bfea3959740f1bc6200501be66eb7f85a0d2635cf655f381c9376fffe218b079d6c94414f7951c32bc8b0be14c49264948403cc2f4755c3c9c6f793479746da34ed9b025a39023292266d360bd2343c2a3ac6d184b7da2766fc0b68b80016504bd231e227d6bd1ba9ac1a0824b046873e5e1df4516f6165ddaaca338819dc403e55f3a9199c03dd49c8280bb7fe59b5522ff3fc3bc73716be1d1d27bcdc37d7e942ff139d17ffb0e3ab193b604f78b29935b32cd5c74cf399b807b2d4a712c8edfe068ac323f8b11417392d5df5f6b6606d7aa7e3177f18b2712ffea84217149060c46cd30029d9abe8bcfb27015eb1cbadc1b606523239dd03f2c073d95d5155d23753e04f5ef5823bd0abeabf6a789c3e08a7d8921142cb496643907d5bb5c3918d501570ce564884744b388c97b1b9e04893f6449d051d9bb2af00f6a3f5c585061f6ad3731517b4dde0e932bf94a564b1bee8931f59af0c601a09eef945ef73c15bb1319aa2b7b2ba0312ba3d0f48f97b4a0434451be780fdcf45fe2064ff448820adc004738b987c10c110a6d5743791d2df7bf535e8dea248c4a0626641098a8870f0671b2e0c3ccb8ce71414d30deb5d46f48031987807bcc667757a8d31872f4097939e6501c170907f6c02074eb16f850035bac672e0ab22b048f69dccd74cd3c37f37d7fd9542718b7eeb68f51aa51d704c07b9822fe0ecb69fe5d59ad847f958156a2b812bcc52c23145113c941183f0b85332b8d0ad26aa16f42d65a8644f71a3797b2ebcb5edff67807540f43d401ba6c399a99e559a1917b562c5f6b7a720c366635d1e2c52e3b4984ae223dc7bd75184e0395bcb4e8654c609e3cc374344c38c8d9a61ae05e38718c6f08d6bac48871231ab543442d0ed5a04b9574f0fc9c68e2c58aff4cb5b6539969e7428289d03c1e0add8167f0f5779462d1bab51a1d4abcb14a33b9b1aa3a45b8e5cad34b1d2e4a13fb35da99ac974cba0e6c4886ef391afa11c6b94a31837b73ed0c0c9dfb5f89f32ca2fe73fe61a580005f8c8b76df7f2140b8768fda284064288a609523e1dc5c433600635185dcd357dfa3709361c830ab5784e2a16721dfa7a428164b141161462f6775ea0e71697e5c2bba5239984203c9a571b7293275d11865a69395c87305980f0d24a4b6118f0af77c9a22f1d6d774a0e994cd664baf554fa0f206c444f8cfdd9ba9e8bc330944bc97e14e802363f5371cb940ddb524d76c3b7e1bf20a36bed4b3dba050da21990e6d85816db2b49700cde31f167d8ac75879785b3cf9ef06e2e567222634be7a40f7a157049e2006f91c49791a12057bd71764fe83ad556ac2b9c3431162e9bbb2460bfc1f15cd4cd1989f1630087425b1af275094debd7455e3ba00f17884b47cda162d0af2962a4f8be4892b103c745bdb64e873392fe9243a3836ab760fda1097c6d34722e66b9177a428914c114a56bc798f76ab7689d32495e108aaeeadeccd2c8e7b43ed89c7cf195acb728ed3f8900edcf25920ce5d0fc3515b47bc458f680f0af725a6788d03daf9a8b6e35347f25850a33389a0ee34f6ab5aec421a2e9a47b8a7552b7838fefecc9fc37289d3b7147754911f2ea91cc7ee956a5cdf4c928efe4a328e826c1f30122f40a43ba5ac5f838323aa53019aac25c82a7448af16e0398814ae965e40b37249f55d1a5f036a8ae9601b86f43064b6dd81bb40ab41deca801db0b072973d416cea6c0b786a0f46f2fa634ff4558f71769833b5584cc07a8d9dfc9d0b0e5e6631a7f2b904ffaa7d14e0f6a8388df012de608c77af275524b8e6c1b0e2b349cf5356a984efddc6c0e473c55dcd4a1c52ca0468d1ee3c4bc86526fdb668bbfde79193bc0ebf137cf19599fd122f836affd64772b8babee1f13f241fafcf72de64ce27d2e661f5e5a5536abf39c040dc69aea2b825f12ee64a50401a095f005fa15b8b9d2c5e24e3607aebdb674a3813efc4add58c74ea54272a64d5261c8a16ff1e9511282003f2a4e87e788139acb3912255081e4c01c0347a92dc96f92d0a620702f8f4ef8026d2ea5758cb16892bf1ba36809b59c60ce62def50d1667edddba59a0177da5349c42f71d6f5d2d45d500ecd94965ec8b923d8bc6ae1e4feefe19834f5724fa27cad4d837863d7c4f7f3622f34f56d25eb40d9c07184fd49739ae67c7032fba1481d69f0160bed2e4437ef51b473f2fc2619a60df167ae5d658f30b07e859ebeb5cbc11ab199150013761ed6363776882378bfce9088ec0fc25f2653f1b117200e42d79a0a7ca86ebcf6ddf574a827ee59d2df46b571440e83ed6610c04f9aa4aa6d8903a044c70f98c16e56c6f923ce88d0dfc4233488bf1d0efb8f3402b16a858d5abfb9656a873a4b28a9c41b823967dd113723ce35696550fbcdd1c0f206d1c3fb8e848dd8d8ed437d6097058d0421a7429d4f329911b632e10f0577c831a5326e5a7caaa5f82e8cfcb9e87ab69e4ec25d051c9ecb1da9c6da0a11f8341a0582f23db148b846f8b8414c44f51f0c0146e1b2b9aebfe4ed24db47bac0faaaee159fb178461ab45765a25440602b3ecea6a76f284fa1293df9ee652113efda8806c56d2063655fb2bc648d9e272f372a589059580d22942d327d468caed421bef123cec0892d2c0187439a1e635e3ffd27e6809133bacaa41ab65e30030f7e355c0004dbe5af1bd369826359d10ae81d39782f97f100ea44986621d5771fcfe0aec81f30b68348fca58c36f62422613dca48621b4c2e95eed726c31fb880be212bbda72340e044d28fdd7f94faa9ed7ac7b286272974e04f8d66a31e1b534f9c6d4a69bcba8dce10921b642daa9d1c2a7d972400c7b1765ba2cf3e541ba833a5a081d2b9e56e7710ed9bd6d5fd614f409ca25f5bef8a2ae3a2ddcf696b081ea030dda962e67a02f74c34046b42fe3a3fbced50d5c4ccc331d94414bc2e9cbc4efc4c028f4db7ea35b50cbccb932ea85abf767f83328854b96bf39213ce6dab23ecfd3d94c274bf122497088f897fe43a8b0c2c579b82e19765460fcaeb975c05c7d33ce9b4216c31b42355b747b1fe2849e895e0f5a5b85191bb2473ae8d1bf050534f8c45c17260ddac853d85ebea6f3fdf386a82ded42c8d40ae3dc181993b8de2ee0e5ce245a15372f45f4ce004d03669d157679472d1c1324a867ae882bebd1dbf4021c4b851ba49826bce1af4dd57f3d2686e255c07caea9300cfd58e077446c2dec44fe98fa131d7b705662daaee3b0f0d7917611cb14277e3f83f3bf5997be883c2be5af0009bc8c94ce88a3d09b3509ecd5bd699b34ad9f09c7d011f77b0b7ffb4d85d3f4a326300bee8c98b3494c6f394499fc072a264728279cb84fcc4290d4e30120a919535489a70aba735578360f4fe7c0f669a8bd2fd8c42a97d654afc2daaed1fcbacb92f8a6afe4fe04f33ac902f8e47a9a109a9161c0a216151b0c96cd2e6baab5b2021b8fb3c99ede001ab31d5df464df852c06d5083ea3ce5ce4546a869fe6ef1230837802e703a9d5c2cedaa57dd739f359d50facd5c2a2ac994a72e619ab871ebf20ee206f119321cd1cd912b1224145b60509b6a94daa87575f6921d1400d71002cc3e8e99eec70d022e0ee9507dcc098aa58016ffc5175a9c73b8389e7d074d0370bd1cfdb0612649408d1f7c73aa2b247dff2c566a926fb599354fdc4e17c82300440ab0af29170c3c0c7444560e6a5a4592e7fa34c5b2718c1c70a49ebdadd25d7e7d4e7019fffcfec5a2c894c580b4c0009e22bc430a283dc8e07ba8d67b75d5cb71884796cc16d1ead1e7cdc07d2f420bd6d2340e5e8a2129da4e40597faebd6c7954b48a06463be905786a5e353e9c220aa769fe18a499063fd5bbed660b8a50076024ab22e34cb28697d219c503e42cfce3a898096f6ccef7ceff9f0d18ca35e0d14b947a3e0fb98d85e5d1a10a20ac252b8edbd874d5d70a5690b4ab28c748243ec247b69400defa6b51b7a2aed60ad36209f10760e0c98971d62b18f5954c96c2122f46dcb71edfe0abf3a1047c03752d0be2a20cd9b2e901a9dd7d31a396cf37d915e980c9cc07c1c09df77882da16eac6369b4f9001efa497ebd831566158225525cf306435d97fc8e29481a5b859bf5d212c5eabfa722fad0a1c2cc892efc9082d99226727cf80fc2433f8b39439e497f3dffd49aad9b215117295c705875beecb381b0c4ecf6f116fbe06a7d2c6a0bb4a932565a7df8cd55fc01b95cb3292f6da732c8a1be110a8e23b3886785aa24b55b777418008273dc81f49034102c0d46c02fb73146bdb04c5236c9d563680f2b50374c8783adf76b275bbf2c11463fdcd80bc3cccc865d6e440d3247111dbc55684ac26aa7365480305b160e9c24467fd3e714f1961279d4e2908a0111dc2f6449cb08f338f34c29ffc129a7429194587edbc00be33a388553698e1ceb2e4e9b609a09d61224b4b345bdc2704f5c9b680131f14a4811f98954edcad90ac5868158db5c4a3b86ea7570bae4b2e01c9b69e219a134dcbb908408e0f9b9cba8b223caf6ca81adeb33a4ea4ee528039390226fad78a30d9ac65900639378ce333157b7fa1a155122fc6d4403a9d7cdfe7ed4e7b867a18e647c0176e47d2566bc834a5d42db722cbfd3f8bdf6e01bd97871b37077783fd898e5514f124ff18fbd094516cf584bb0deb03268b5986d9e3f3cb43f85b3b90acc15ca545ed788e4545058611e1eb57303f6479200ce01b64a562ce008f7553260028ff5cb38aa8f42454ab9cc38afffd0cecc549903825b6906640e9aebb96e5b3f2a55e07d80cd389beb159bfb0f442dd982ffebe80de0eb35f6f93e0eb8138a0a03931413fd2c2fb1f2cbd59b6ee33d127f5bffe885fa5d23c462f926376f79154b88474d9e098ff902bbd6a778a208afc78c4960fd82fb1a32454c66d5534e4d89047d7a54b7886d045876beecfefde850fc9877a8af22aa68960cab8495157d4532198e0f08a964628367656496108f68612391610fe89d548d26fb0ce07cf5aa8f80440d94a58978c7b049a8cb5dbf4da558b9dba654b055830121ca8890d8fe01f25cbb0b8fb4a5f6830ce6ca29cd52c99925839ba3fbaa4a44ec6eb234731a57dde2a749c7de1f8f645650fdb06f5d0e7f6c38296d8293e4318bd1e60ef72d4bd089f1224eae325184afc0dbeefa783949ae3bac3f4abe7c009cf4addd15944ad3bc29f2ec61f18f1c6d92788b3aa2425ffb7980ed72d9800e8955f8522d2ffc4030b9a2c4dc9bfa91eeb23d93111b2b5eec1eb40ca3792476c63d0249d6e835214242499f7180230342ff9d432f010fe2be71e3f565ae15fa897861433ea6daa5feaedb5f7ff9adfe238762e4fdf62a540dfca2fbacc0f4e427ce9562e95c2bc21cc6f520d0d77252a378c192afb4c8d7a58dbf541cfaebc144d1d839486003a1c2355da11abbdcc4130a52948580799b9c3869286c08951d8a6440ce196f8352a9d13a99e9215e914f827d670c7bf9e8479448fad7b91079da32a125b5b0727370da86e0072030054cd2a858878e19a2f84cb8afb6a8e1f6ca692da3bae11afddf859d066a2e4439555e6405556fc8945dd85ae8bfcadfc8c43150735d80dfd4ed7f53186eeea4643d8d9c5cb48ff9f815a82128a89a345c37c8bfd95c2524b8e1d170780e7fc4b3584a72db45a5d4f639ba33aa330c65fd6496ca545ae0822a348036b2bb01e145249fa8cd1723c264c11f3c044f566244d36fb6ed3eeff9660ab903c7098e8060871a6454e4b7f17ef5e6e394b52cebf55077bff73277f441d43b525e57996f0e262e2cc53ef6b5cae4b529d2b48c60e5eabb800f8f536b38524d8b11988a35d0b5bacbf1a31b97c791efa15d41ea28252634ccd191c808be04f58a8db3b1ec91058e6b27018507ea49704b8cdfceec7f64c7abda6899e7b4f59ebde220cc1b220099c5fca493ddabb174eb700c5d92d9cf288fad09f6211eb99093b0975c85122ce103ca38ff4083646b7e5ac56010c64789a02b174ba43b096cef7589df7777b43617fa7a60ca6a5f9e18a625eb4077348c0147fa13c5aa9893a4c5a837509dd471188545553799c986499cc286bf8e337c03851cad3ecb1cbf97d69089e8ffebc56074dfc4e562371cc33a72828441515bcbe2b511c2e735806a5863f4f009e703a1434a68f2c4b73052ed4ca39e16305a7e35cb58ca667f560ebadfc36589d01ee4b483674b0213972c6394770764280dbf789c446e2c8b603dbae067375f7d7c18a0cc6fd94045d1b4284406707bb18e5d36274a9e4a858ebe7f15b168ebaa25e1695178abe5b507af500200548dea35de89fbd866451a6e41fa97ddffb7221199e18f1d52c7b9b41460fe2cd834fcc5a4205fe93dd5f185a423a5d394a5f176b08397c412684ba1b1dd890e34fe39f6be2e307b8ef206b81fc345a7ed84f037f92ee4e9e2f3327010074eb83ab6f6f50083384f79a3274c2056141ec684e3216cddf0b4faa156944c0e561e591afde4044ac5f689875fdd94f3475d1924fb56f7fb524e1a7a0a630eb6f0ef020762a046025119d66d1d3f256130a0e8066866831a8f2a73c7bdd397ec31f54a89b854ced6c5c45b3ca33e27385aa5a35da436b2e1845cf25984f4cde98626e8bcd12d2d46c241d897bcf42e989bf870e975264688378bdaffce554da71499e6bdd4248bce61c128ab8e9fc60dd25b08aa8052ab8f71d56acbebc9d39b5a570302c95978b63040ae22fb79c28f13383c7e687a22df1cd82ea65887c8a7f29a28e6c7652eee2e9389f4de1e7a7e83f28e34fb25d866269cc671248b764818cd4f928469dce4e84f7d459774ac90def4ed1d62c97021cdcc772ac7ace3ff1bf55c224e5c00a277f46587c855b221f114be6f775379d6c30887de8d74a60f1d75965dde69e70f2b770a89f7d5aa86c07918f3d19ea0f4e5b0a6f7aa4a7c35ec7af2de2a62de13d376b5d7c52a87b4621e50c442ff6b215921fef36d4ba63ad8088bd64db1d36be4a4a0032c91df95ebc3206c86799f51639cde526f78867fe443559f19ae31fe6e3b27e0bfb57e826eb840aa02119e88aea1bab92bebb4d314f47eb1be0abf88600cf18f20aca24d8d7be93870b6a477cf3f26f16059e70e0342eeb45f45ca362004ca195386f3d8a32fb244512500da98b1a4a4e4c398e52b946b8c5c2eb98de6cafaea77ce8b755451bc1e8b3abdcf32ae0631d50b63e88ee6995073de5d73be83419ef0f57fca9855c2b09b0b44decfe42deda5a3838747d5a1f3656eb27e5be973506270bc42b189ae787598344dc23f3e2d6c4ab27ecafd82375cc0019dbdcd797c8edd4360d5fdfa9e9837dda1afa1f0b736372504b4bea0baf42988dff2732672e7e0e3f51fc07e7a5a93364eb4faf3edf0a7639a2594eaf4466289db1c3d92bc5ef501b8eb53a33437e5cf48913723f05dcba13b3c1d064e9aad3afe28f1969488620c97d8549acfe5580796066cc3ca7a65c39f04018373c6df73c5f47138a29addaa66cf85af032425f87906ceedc917dbd2aac1d93865860f1675f26afba630e657ebcc048fab0c7f9a2c70655672653dafe2c1c023939a588172b848329db34df90b171a16b949b9ab8f34401e7eca728e16b32519c5bd5615d92c3cc0f768a30790e22359f6c36bb40d22f90da0a788df43fa023225dcc7be4d34b0d8f29d245c1b1c38f58d6d55f757bdf0f3285253c1296db71e0a6396f2231d7bf778b438398c6c6dcf99b5f5403602b4a10962ed5e75e656e6fefb45f7a12c93487b71675ee779e9fdb35372ae5161d7b14ab98b6fd25ab061bd827d77b78d3a3d30f5247f9585b04fc2eaecbbd4103cdcbd9f0d023923bdcaadce77b4f3a49b82dd595536adef21988b4fe4baf03b6d4ee3e8d12585fb3f26c098ea3afce4e9263cac56c605e56c9c63dbaab02173e4e72e97841f1d6c373f6ee789f21eab8619946413364116642cbfc8294cee636ef415dfcc33b628141a610e04eea9ad5f4bc6bde79d579f784aca76c236840500f5b2bf03f8c4b6d7dd3b1ca10302b8198aac2ab217e98bbf62b247501dded963698b5e108932bb1b19e611139066fdb367fb4425affbd46b460f0805fb38c742102405e1875cff36252a0d84e44e9dc703941ea3313e0b6ee6fc8a24e769d79b44ab9983e51832f49afbf7ec8314af5891be019d1a2e3ed19d565c845675399f3712b699d036dd0aae507d942a460c245ca07af571e0898d7fb1ac67d31e2ebb492f2d41e99cd0a3122ed61ab4a0abd50742cba671143d1bb44ef9e642d11ea8171550f4de1d043beb0c0deb06a5cb2d1b99027218d9c5b75da211a831b14e0d848e6848033e88c35ac72eb34e120e09aaf8d2dbc94ada5979581482868a7b2a01bc1628996267a8f715e90f13b754dcf7a5484deedc10fb72ee3111df855915a226d65bf49eaad1a8a0f67abedc41baebe436b6f50df410bc5c0b05e6d4b7bc8ac93aad8e1bf3e4832adcbfa50248c199264e995cddcfc7de5c45be03d427f0dedee73ff7fb758ed55d63403f90253cff29fe96fbc5535592e7300f675e7afd5fb30d9f72f4d890de1a2cd6e511cbd4ad26b60d8b95fd24d084161a4a90ac123947fd114411442f0b5c4d0c4313d44eb5fb9a6aa3c40d0534ec29ca73e7ddf924d03d4b3f320ebd627163b8ebbcb471ae1b67bae342a7b2f9cbdbed664ab38196dc03c97dbf2004a5c60d6fc6c11b5b6ce73453c89e4ae102282ecc365687ae1cb67af94e7b27830e3e29ec62f4368ea02dcf7662aa9c69db54e4abab47596314842f12a56f4c53a66a88eba623abb2bd02a777191adabfba6a425bbec54577eab124bff01e61aace4302669636d07c5dcd7c90f9a49dfcfb3be63f49b12222e5e355c71051c3662b5bd0442b465b442031d0c4ce83e2d02b03f5851856bfd79e06b8448c1d83c6ae95461f363fe47fccc1042e1809b459ff9db981606e8f776bea1c990ed7ed158468cdf4ace38487b703479f926d3d5fabb057cde6af4fff3b46438a1c4791183997b9fb20517516ff9c77247dfaf73cb533f2822ada64420a39766c529f59184cdec6f3136a293f6e4fe7bac0bf91cbeaf4ed634b8247d87cca50f8f151bda9b2ac54cc27f2ef75753012bc9817f31eb5ef68f9bc9210c57afa6b4733167c3df55d0f8f4e13e58b32397d676df567bf77fe0cd0180658a20989a47185fb2648a4088024b996fe64fd5c9d7cf0042917e71257d0860dead3d1e032eca12ceecb567e7cab882bdfb6f541b74a8f005700e2769279ad6f585a848e780561a4d7ba9be40d2ea79e90711ed379dc29f2e824279b631cad053c4e5fb61aefb8775921158af9298c680c4dd1e1587e85e57d7665ff86f58fd3979b9076e840968ca069c1f33ca3a8d3d7dd5850a55b5cf7381e1bbb3862ccd4828c57513548a354bf838063d4a370adab500f056519dc67cca5e7efa79aacc3fbc29af170df9b337ec2611f1817cd9b4a09e49367201cbc9ff0a7b56911dd2a63d213f6b7f11c3a9dd618a61111b00bdcf3a585d3b0ff5c75c36845aef1a748ed5b50630104c3f4d1a94de70fabcec818cc92e5ffe9f7765a8bd85331155dc69d3904b6a0971267de5fde9c338e7acad7ea7fd2a19d287bea2506dfb3b7f5cee6772b7a9244b0f77324beec4b940300695e6db43801ffa49a9ebd55689b1cb1222fb3cf86be0cad476afef9b20fd6a3eb9cf40de0945fd90f257249e75e9d101231d5bd986ec2dd45ee2d946ef4e20c4338ff16512224faf4e9117b3184b1a35cddc4bc402e6195e9ab62e1184cfab77ded510cf86594bc346dc9fb31204b62830abe9619f31248e3286547745aa572c72eb0b60d5da14cd7b14311f5c832816dba110da72b523c84f15eb50ad804b65fec83a8a79172a2db6873280fee4e74510ed760c271d7e9932ade8aa82d93459daef8acbe742fc068d169c3b654f94b8dcd568d103dfc90d58faa361179ffb7307c7911292f8fdb25a7e9bb3c1df2c438503a8641e7b440cd20e3e932163fb9fcbbef889343d5478f3c20c926338465e4ba794475e19052287cbb31941c789444009f1872355a99cb3d351b917897ffb5e3f5e5608a8bd24e201722c31e9700121cbc3782401dff08b36bcf0ce64716696a5f641e9e31c38e0080e7be9d1d592afb9a9b5f11a58dd19d7f75cee4662d6da0c8b4ff7793fcb413e65473563b611fba27b952c00ec4cb141379c72d6848944e238242ff63076a59315e54beea075f12d5f25e703e12833ef002b57a2ffa0aa436632cdee8f09e4887fb6216bbd2195fdca342de10570d5dffa83fbc89512a563bfd59b3bc9bda55c190aa8d2485fbc5924e9b401b67268e763cbd5329887c98ec82270e9e3fe24ac9d82cf0038a71233003c075b2f3d3e43680eae88e0551564f9fc1a6a252ec1aa7c7f8cb39734fd6e01ff60ef842bc99416eb99b8a654124cc03c4782addf56d12984a758f9ed37720757585c74ea3df2466ac9a6aaf965f98a89356e1c3aae724a1a2708d6127d0766fb6d6d6e939d4280a482454a876dbc78423b2e828a1a4a2d0dc405bc2d9498a170ca14685a1bb4b0ca515adfb65f59b42a1fe0ed9463c42633ceec23f7aa18446dfb17cab50fbae6dc8250feb8822caaef157e98651dfd64ae39381d3c6c00f0bd58b7c2910c17974d1752b5ca3073e41a8fdbe29cf62db236f96268b2fc078f70ec6c698337b6f62b1c01fd5bd4e1e76aec3721376239e2350e23887600cc8e7266a582bb69f3c12a143382f9334f5ad1e2a140c4b085c806487223cca1f90da41abd68eeb95ca4b86f9eadce35e1611c302728ddfffc234d331dad287ab4ac8e940bdebda4173ea62b55548a4d98921b65871c00b17ff29eb9f83b11f06ab4f9c57cf1915b1b9337c3b001d67bda92c652a07998e23f25a1ce6392f5904473ddf454f03c36be60de1d64920a69c0ddd39bf43efe5bd1b8134aa060697a4da1f36979a9a0b58c4bf520b08fb1c6835b01a616271f752a816a55f556768d13213a04c005065dab9821c65fe456d056b68f70680c03e8d3ac1a7d86adf0191ee976247153c6dfc5e39a5f6c803933d4cbe377e8309a81ab76ffddfdd974865458e844928488cab457d2aed19dba9da8eeb5aa4a990df0298e7a20ec366863c5cb4b60e0f4a46617cfe02222dc5ab3bb45ff97f46b85c4382fff290dfa51fa8bb5c11bee1f8bdec4a079b3263a85eac385cde57ba9ca450c8a44b222e4ef37efd11555c29362356012609ac7c03e95cb9518904d47eb2abf5a663ebcd9a0df01ae3a4ce0ee0bb69ee8ed8b932ca785d69d89ba8dc245bbb2d95ea57af3ef295e77da798eaa02ededbd176dfbd97db873318d686f7c96e1ce2ffd8b906028a26c7520178df57ee92d1bcf0e01ebc4dcba603614a930b5b93e8dc723e2d7170dbae6128c56b31274871dffd1e48c53a6d351395efa03dc40e7169169f6e64885723e1354a301dffb7bac4a4137d38d4db7b2e6ec1464dfaa335a02fbace9a0c3b3a20777831ef076b8db83de8a4ad5d5b38eb83f7818d7019eb99ccd9b442fdfccb30b1b403f7151cf804c2519b8ed4d4a0de56730eee2a27b467a941541031fdd3b3d7782ef4c1869a6c4c5cd5424d44c0fa0829f199f2111f2ce268a25274a79a1e70b487caf3c98b82a5e44c78586a3c4e0dd513f9c3d5381426f8807c1e72436741ed918c9b6457996c2b7f50c1bfff9272b45609381cedf2e705b5ccf4604ff86d876fd003b7a08beca2615b48c027247fe45ca99dac06ba955edce581ff2027333abf1bb940859cc0e1d3a53e9b2b04be7bb834602f42c8aba6237a43496631fccc89454db2012a35201a46cb23ad290261c192924676fc5017910d9b3484b6a77e4f37f129dea5c66dc403f07a310aa5c15a94e5f6c2fbf85c417b972596d5c547f5cf99237adf1234556c4d1fbd5a71e268b82557bae4ed06238fa4d8452b8a65863332015f1b55054ef836b11d32b5095771599478b2cbc1e4aae764a3eb14dfd154b174a57060b3a1738d800a926d7e9db8d88ba556abc3e74a283f010fcb11b487e0a403f04e67de88ea9d7a1db5f47053aa99a133b2a0db8d8cf8e3a42753bf0ad4293595dc3fab7963ead081521043ef3af3a27bb6e63be84fc2e6ead4733c6a9dcfa1f989663e7c9d47bde51bac03f5faf489e6bdeb97abb8d80dc5effbe8511278598cfe8abd0e8b1079590beb06d685a5b3d0d62b5f5bd1dee4b325fd42acd5f79becff1e58fdf808735c60807286bd0ecb974e53ccac84f9bb6a66ef86ff5f9d4fd7681c50ab9fdd960beb11d3f660dc183a5307c65e9495205bfd04f04a883801e13cd05c0e2e451324af6f081fa7a9fe88387ef4fa6c3fbba00206756ce9c744b39fc91a3a2fc23f3085d1621c40690743662be84419f48757e3cfed1b7782ba9eebee69817f68893e4d609937fda3b6be13cbc3c4243ac3c5019556ac295c0121765aebaf8e4fb4499badc966396e7c7ce05349b89cda84b730757f34202f25009d2bd63e0feeb56c34a82bbce08712d41a573060af59f7a9f446d140b6d8cca1938194191c4e7b68febf12df52dcb6da54537730a8acfe87f66f29698e08d31b9aa727a40555a12089c425294643b7fab456edb9ad9fd021333318dde015783dc51a5978eb1768f1b77d0e090e7a8917d5f3eacbd6fd87863af57f3849fd6fd071cdc2dd57461db127bb1d9e59fd8d8f769831f7ede5ee11d8ba9c9a7ff7ec86316852b15f97f965244d3b88821d81735099a6be4aec1ca864c80acd9063407db593ec129b6dc8fae22c9855403ccee4f75bc47c8393b1f35a5583b2193bce1614d6bae4b5722b63bf6a4ee1f9b6ab49be2a8e87b7b5c1400f3d54ac25b9654632e8ed58fd5c5987b99ea7379303762166bf7e998f2b28a4fb16d3348ede0f30601cf881a70da00f912b97790dadbd765a5dee0824b32eebb6ccbaa0c36f8475aee3e4fbf9204f6799a6770d20e23601c2860728688d2144960a361ec5a202ecd3ece7165711c66497de35f3e3ff1881e5ec9ef43f7966d732ea9b7fb86cba633e12f2641b00675dd1535ef15c11b1436d799f6e54b35dfa0fae8b775b855b74d2b6ef1c1afc2326849030a70b049c4f8e20e585536ae360f83b372928f4a8faf32897940c1ac9dd694775fb23ef504a8568cbd6bffa2f9c9e632f1107b84e9cb04dea04d5d418858b906ba9a24c7f1fecdbcdbc12d268619a8896c0b72d1796f37ca04d55cf0b34aee016fb132f7ac58e68c105da4a8f23b2f8092554aa5bb3cc45b12694e78aa2fa8021543de8efcd4f6487c8ea2fdc5ec7d970bda64bda346edf53315663511c3b7c111dcf6c347d8f5e91c5210be4b8419b3c8203beb241b85de93a4ee4a23c19536ffe3feba1cd80acf2d061085a3626c3aaa7e476178215bb1c9ae1d7af9d2248bccf4ef0fa4a6461af8bd3c16b9d9150f9cb962e2ad1b6734d18aad52a2617a2ffd78f7a972f3bc79e6ded4309cf905b38b6c9c7f701d47089d5cb71fb82b5b2904376b811be1ea916b1b4fa302b02bd4c54c11ea38446b1a623999f07f932c5eeeeb9e79c17ab6b74631ce6cddccd049c31aa8729eb3a0fa1e8d0abfcef65da9db22bde964601001898cd810d0835121bfca335190962090df9de14133ab1b49447d4ce6dfb2129a9510d2fddbb3eb123f8b9b266d13ca8c624ade8993d84dbce2db22801e105113f71e90f24892f3e82edaa6fbb3cd998b126672d0b5f9341a7bf9fc17b6f02a73518523efe180be3df5ecd85449eb924e7b7d629e2b6c86bc40ee0045e77cb18fc8dd49ccfa5a0805c0c98be58ff0f4af533115c47d53f5d89d57710d677b83cbb0ce6c887ec270a0fb520017004beeca2bf64fbd7301115f32b7f80f725f6df4a5db506e618abf42019755443f42698785de17e1d60a1ff22d8493ea86318f75bcfcfec6b9176c3d743186955fc3ea6cd69f6c46a38b2bb570fef88655a011f9be4624bb70ec941d9ae58658edf5aa48e67f77198bc6d0d02dc4e2bc07478d41ae85aef1321b0007113e2bc40ad970b19c4178624e8412effcd40bcbec0d5cd355a069fc80dd4d3ccb67966500bf4970d5ec79081ecf384f0b9ea0e608f03661b6b59b0910c773a5a82ebb6da9641ceb65502be4f64476ddeb295e36130372b90436c4cbacc770d70066d4d0136ed964ca0da146aad1f5d3ece89db4bf5d7bc21aa21769c20db1d8dd219b759319a04822e2c69c033d69d7ec1f7cafb2d5093025eb1d60e81954467631d3c9b23cae6f13ef460c188f62c78fccd02a735cfc996f8bc63b815f8b98c05fca7ba71bf81e45a398ca5c03d3315de474a86975013364b932c37c2bcf6556bf0377422ab9ffa369f6da0f2ff9a82f9f8f0e759b6c2d782d180bfcd5d53a0fb773e7a9a7bf9a27a08fb62a24d14debf0aa482499b33d9bda0833cfffe060b9af13838c0d751f2cccb45b7f18530fbd4dfcdb0846c54c7b6cd90d5f6f44219876c2501ea4d3d4ada6529dae37ce8c6d27fba7a08423389e35a8f36567d9063d17a98c313a7db6be610d5bf308a2d8d6b0978d4e2e9ac1306819fe5a777e6910752950cb31ac5a0727cabb3f9f78933e93fd0cf33577085a9cc238e03b1e597143acd51ba5a8dcb7898e28a1f0cd534e29c1f09e45127f1f66046a9c488946e30608b30079da9e77d357c1221def27e3ebc0e0012db5015e19af1d7101cdf723869c971d25c6381d7e61b185875e7e719edff555088b32b8b3ae4eed337d8ac80c67da2fadb0133e96e40ee52a442655dd95b7de1fbf928b1c177d42e22c5699a0e6aa61dae469266d3bb5cc9c8b082198c5e715eb8a423ada7020cd9a4d4f946a8838ff0f5d99f3b8742905e7c5b556d261d3f2031d45bb7bb6ed6c90b1fa697de7f9bcfdf1335f53db2f1e20d52c0eebc5d733c09a1848f9c3d55562719039815ee1d44fa4c577cbf1949ee88107f05450045308500cae4c08235d9fa487238503c45dc1d857d49662e6fe025c59ae0037a2bfc3bae6734a7f92cee581d6a0b3cc2042f22f78628f1dc215e10cc88f1397fdb487187db26055b23c4f5dbb45b8cf951533eaa7ded3d5d65a24f00cff88519330e9295e1f9486bc7d8f625dead09014e9198d5eb41dcac6fc6c3cf8810f5015b445336c08c1d0270bd2f9cd5fcdf33a3f5d9506fdebea1c1ace841794127334c91cd2720f2bc88232b7baf40908b3f09a964a497ade5f1fa561071104198a4c6c7faff0c563b898e337a848df89af0c53c878c842cc2d588461b778a3230ae92f5c9109156f1309bf525698352699e87f66f28347e548def50c04b4e7cd5823c2c527282429c20afd1ea5bbd82ea1db4cb6991894b0fcad4109536e09c255b0c7299acf949dfdff02383f253b782cb0b8db474a8ae94eef3fb08e0838e353d5414cc613477b53a54eefba9c4a40a42415e5ca69c9f8c9c5cc2af7e62a12d752cee997b338b039e8ff86b9c2b36f097b46637e7ed4881a8d352686d1be0f5368434e11cd8fb2047e38a6561205ff62d0e8757041d1a802c311eeb969fe08a3ea7157e2e25fcd5b8ba88e9e6edc20b9fce10356e5815f659741411450e9783274e5c3d2b19a29e02ffa1377c2c50ea229c80b3d17e14f92e01e2b57db1c16c7569c80583ae9c27e4f9efd1132cb32ad987cb755a7c07a82977f7cbde12a80ca8923c283581e632412d8e7001ff0cd3d36217b1973d5f35213abeeea3bd3bbae2caa5a3eac404d06de23c91c69885bd3b25a087cc60dbd66a2650537f10b7af6bed3f0603a65d8ca9cd7450d9dfa667b2bea78a7268d7e6aca1efe8eff89819bcff7f2b94fdf50b0c573c8c4d9d88b39f7fea1e5bbba50e8525a14d35b69dee1e4a519c355b129e3ca4b21fc7879072c6553e1d61f7a47dcbf6d0bcfff7d237626f633dc3a5bec67ac766a4be0b7b6f2ad8299a634bd55d3ded98d1524e46aae509af8c5733f216295015353c42084453818977338394788e902cb08b83e0dcdc99e090422b4bc5d993e8c167896f00b61f23c09aee4faca61948c5ba9582a3d99e7be4809c9c39c6650cd20501fe8888bd2907d4283004e9f2d2ebe009aed3ecf50e8df0ae5ece52522fd628c1bfd52931a9776d7d34ca90098ad498130c42c7f770782fbe84f4d72af3343115e444c1830bac5dd711c84f6c37ae04715433141982336b60e1d0b9aed3ae58a3a38025ae50af29379b10095d2e96a0fe2469cce349701754acd4648a857e5c4e6e02be9827c1a2da8348eaa5864c2b7a59630758803fbd6ca9adcd4b3d83f7ea4508e0c2088197b96da61bb6b92a48ba49db5ccf47ff3498c2196bc0f1d1b6f7cb08f2827fd86a781f65f82910762087b96e88494ae5ec4c58bb8109eaae6cfbc04a300c114679af73be9ec6597bf557253b022c6dd79868a4feaa9b4f70cf5b325b9359485c1129f1bd919afbfd91c9ca33e697654e46fd8414ba7be67aa81c2ad11ccdcb9d247d1369fa117ffba95dd78d5829904dea04a460b84f4a5d7788e5ce7b7e13fb137a3481d078bf93d5de69c69d997685392a162344b4d54339516dbe445091390a39dfbaf09beee4713dbbe6869b9a68d92d3dc1a3023df354d8ca4cc45d55fe898a529cc430e2098846a22c66289d49f27fcbdaed24fef8c69bf1aa51dd1a6813156ca6182ed4ec2fc84e5d3d8dcc7460ac9f43991a2a96f1324dded977aa4f44554c86ffda3465231c2cc9a53263dfcd32e7ff95974f4cea652c5dd6f396679f9a659728a4c18de7037e446742f275523f4780dc3e6e4a7b53fc3a8d635920ecf3943bb6c655dfd656dbbc7a5654b9b3e34e72c51bbdb278e4adb6e90029a348a9ae42ee039d706cacab5bb3a5a981376ee771cc9a5ac074c47c4134ce3b837c678735b8700c5844f03de925964b6dae31b2c87064f8d867d7cb8bd8b269bcf4666d2ce5cc701810084aedf8e3a62f6469ad71932a63afffabdd7d1219d76a623af4f9ab1995693217c4c89668ef3b2d3063286350eb8c8170e7c657e1069a6cb8c2d78a63c99a8bb443e7a0b15f0c3626e2327dcc14eb20f6bcd2370227beecf162760a9b948f3d0cf577f9b952a925875743b6e7103d6416fa60654a47c2fc411e7d9d6a06f1ca3358d020fb9c7b241c9f608bbe399e0f3d07bf3d5542f8478adf0f8357336ad841b4e45f717e0552be11eb9fda07426b22efa2162db2bbb69fc9691c03d12044ee8a61dd4dba3c1d5f657af367fb24b65601c444e357010973e48fd40006b35d9ab25eeab45b6c87fdb553d88fd439a9a9ff404cc01499cd06ada9920b610d7bbf2087834657d505dc53ef10dd22863d1c95d77b9d96c351975c24d610f1e0b075fe52b2d8ca3a81c195a6649618078b96698902cadca9bee0aec859d174b9d5b7af202f50f7e1af7e72b76c6d3ab640d1201e099c3eb2e960e1679c39fbbc57405a9901beddbfa73c1c561fcc8406decc3d46e7e3508c05c9358936e4eedf763f513cd07b3c4f52848d74417eb9d39c2ec44b559809215101beda774588975bba6c31ec3bbfdac641359fc24a0df7d771df59133d280922fad030dde977952b486b3d07849ab9cfd6273a772689801f932d644142e887f2a7bab78b505a0d528dd9481bb5785821d57c107aa7f16fec0ad6c85cbcd4a8dd2e8ef76af1305ceb4a09c1546c68b54aa40e18d6c446ae676395166b979a5b9bbb4da432970859d7dc5431fc8980cec0b70d982e58cd2367043ece57cd58cbfdd00afd0c8e38916e1ffda3d4c81554258fcbdc6e795864586714c386a3d02b78c613a2af823177131a7c87f6edc815d4532a5ff533b3dff8df2d8db7f41ae80b53f959cfcd864060ae90577ffb643a5619cb0456b8891c3b98b1cae5cf81e030b4ed66b24fc855445e869d1384d5dd68e4c2119bb1ed2a4d52804a22af9ce6c88e78f75386fc324417fb0595931a98d68aa7b143689a8a1dc09c95322c7f42513f86e6ced5a7c5443fcbf9e16cd2395d9f3c027604de474da7a2be2908c3c0a5858c7027ab1f6baa326652fa18ea583b7752523132b477f07d72d5a5dc960de94bbf781d5165c3a85a14fcfc08079cea262e33bc52d9cca0507d49fb95ae594499e36494f7b7ed2b66a2bd66f48f6d68d6e36ae6f65e18547b1dd6fad240e6237f87b95d9553e9f5ef172169d3ba074ca0e9e2de05f22790a799531b8e9f544be4472b4416580a14923b118c4ef2662d47abdbda7fd2c7a8bd6ae836ca82ecab1a66fa262e914ffb80d9fdef57d60e624da67b983e268bb4ef70c2672621dd6d73ecb53cc8737b996c8c0209d347305bca92295c3eea6a91e3524ee008c3029bf5163247f082e5d1f9ea05825ce362a83582fa43795a366553d20720df3979db46e0e72410bdff0118be881b715b54dc2c8844d8c0ea7469f95db36a29170bc1b08c4180982376ab85a4555c36e66c7a1c4d9d012bfb506432a1a00f8f1a8ff5b41eb6397cd7db9d47dd232d1039ca62a8a6be8f583103050b81f186499d8c86e3f68c1ba1294109a987015eb85d14f2a0403551dca2253d4cc279adc2fbd0d6ca050cd5a155506656fad1764dc4ec56c776fcd765b704b471dad03e2ef685f158852db8506c851128cf22ae857fe4638e0f94c0378cfea9502a1e3e07e2dc3f37b6c3c96419e547ca8b16649c4e1d4853e332a5a02c86e141d8b9f329a6835bafabe8269e03e09936bd62cb79fd87db69780f9c502afce216893a36b62f5c1662c2ff13ce70634b66f412e27a84fb55355a3042d32c03c3c5e8407136d8eed802ad2e091dcf62fc3fd8023cdaa62583d68f802045e7563d265bb2133fbd4821b8e0a39133180c35fab9b742cfaabce20b8a1d4e892ab5168385f6ab35da19e31535ac6ba50e04be75641ea93dff607a4ead6f13edafcad823d6d06fc2af4a5fbfe079ac216a63e838de2156a4f60271c1dd4f4d1dbbed8a9a131e6044ad7305ed4592ed3f372fa7e83e275c3ca62fe954cc5b380b4216da7224cddd9d7d004ae8b68000de50a55dc2bbfafac00c260d534cc33ce3b7988d03af5067e5fcfb6da864caf36a0725b94fa4e3dcebab21ba631e9d63da32ca5375ef62d8562fc50ffc5947d66d2993bff128376ca6c0053e48057eef797cd83b92c88f9e37fc266d2d7bac92879edcf315150de31b64768e30c4e1b7458d8740c117dd4258e84c303b956f80f6a79050990fecde5b5842481e8021ef7c71673d4f3d6b920d331c80584909fff7c2c8cd6434ee29d448d2e25437bad20151426e7d77635c1385e04636ae4814e371af1a0237785dc845fc0236c3640e508b740e5dd98342d45bfdec7182b2b85028bb2d83905c58d203c73a101c71a4ae3383ae818d886bbcae370b142b1410e50bbcfbc52e52001933d01d8502d0ebf4775b89d99476467625fbb4e377d89675605259f673c5be940f11d9a6b9985b785a214983d1e8d2570f7f59e0a215fc6eedfa74d70ff5989a6d607d7de45704c4cde4b6abde165e806b7f85934a8afce53f518445aae7cc158992f8b4d73998a72f85ecf99d283bc2199f334be5c15acf58d4ee03f1e22b2fd40bf80abdaa3edd02172bb13a796263f31187d51a8c7a1e9591959ef91b09f602a31603ae3d96e213d699c801b647746adb5c5e1bf4ec23dac05d7d325e2ade241b14ada9e2e59ada5014dc77817137b5ec7f3abe0aa0bb08e6e04da3bdf6cc307e937b6b9e475eb8252095d770abe77160da62e8700a591ab9d4491e2fd81ccffa4554fc3f3068e49f661ea199b39934cf070ca2f550a8713ec1a9e139ae494f6cd13d5767f84f6bf0ebd9b082a54cc6a38b2a73c594a98ebb3142ad34d21ee991d9fe1f1025d94ded7ee2b4314db664ae6e59191d075d03b3847e18f08210f27b745b863666ee96272039389bd352ff67863cf504a4c914fb4fe0f8a37ef3832f675b07880b74c23a7148606654378fbad5bbddd7ab9a086083e7f8b4e7c1a3b439bab69df5643e87c4c80892ed9f71a6d43b40dccf3c3059dd6b4f5fd5009460e34414ca8f3c742ab1f373fcb87e549f5f6484eb8eca0bda81622416d4ba92314fdbe97e7a0951be46227b68ac38d6aa4130f447a457e083259ae560c2cd3b70d3dc4d78bbec4e240e4a157be474d778551c87e8b6e59c19dfd1e4aa6b8987acc7fd211b8db0a87cfeca6bc1d7aa5ad0dcb5d88cc516d531507bf40c5f3e510cb0e869e27f22c3ac6b37f02f1df00b777ad91699d89f0a8275124eeb094d0ef33d390d4835e58bbab50b0cd3dec18639ffbbc09d1c593d40b11d1e86bd1bdf554c2d1efd8be17bd6f6896a4036a3739942882472095e36b0ebe34f6bb9c467f640dcaf91ae1c16a5d4d6cf3ae504464c8c737975042162f5a9ae3fdb3b317996261f6b8b7e445a2cc6dd7e030579057710b8db85b2c7295da755a364819fdd3298992460e95b86c62512ad6b34941b0a28f11d22f10d85c5387a6e2b598fc2a62fb88c82181904fa61d9c610cd6a59529df2e61e13844a7ff874020389d372d40737cd776e97c7b016199f391a160b003688d0e59e013a6b015339a3229e898a6cc091a88db3ece3dce6c879883de9ccf9bc9baf9c6670cb7f3837e89b8a0cd99018c9c90dffb263b330816d6b6cfe022ad43e7f104e619b556d4eefd16a481e826d3b48b9c16b4142c1ec7a2918cfc8b5a20ad06d012f15bd20bf3bd1d6d3cfe47c699747f2d9a584541149b1cc2860f3d86297c273737dc5d8a182f16d181a8cf62b0c8dadee2494bea851d5c50d8d4ed5f832a27e834d326b64cc92f38900ab917da4234e232ea6f39175130ead5c068ab8d704f59e20ca01c91b47fe6e7f930ef28da89b6112d2c386c4c1720ffc736e63d7a72ca3dfac2a6472267dda13d76fb1e298cafcb3b735a41cebc12a56fe126706277d2cbdc2e272c1992404b5bbfe5459a8257743e193a118afa4f4bb6932a4448a85b91d6c5c6fae03efa217f62abec77d9f307c92b8da54c8cbe4a88e948762826dd2ae491f6e47124bd39c9dd2ae4ec472bfde9dc54125904abfb62c15b9897f2a05e9e7406ef18fda430ea5a8c96bd470ab49ba4370251685c0b16c7ceaaa4454acb1ce169ce7b05f056ebd2c4befee04d3d5fd3919d1a39383e467c0dab73b9be91f25697761eedf7e626ee81fff374df5eef863d7e0180e073f42be234ed3f52f16fe99cf436468d71d763b8932e14ddae6c2586939f35a3bb51ee820a9a0517ca7d4e0254551e55af9514d785062719ed31e41ece31baa65044f1ef092bcbb176c3f61b078ba0ce7e9c8a466c12c52377fee0cb1e0128896573f903f9df6bcfd6f5f0ec9e76dfcd57cbc8c5b00222810fdd6e4bb9414ab5abab64c7c42872eb0bdc449cecdb2e47d119673967bc42f3e1ff174f95e3ce72c71ab70d64b76341a68b1915089126429ce5c0ea568b6ff37e86a2bd2e5fc9a3a33a898145133689a424607abb18a2dcee200fa0ce29f7c05ff1d1a9f94aae124619ebe58d07a6f28cf9f2fcb466de5e48c109949c13258fc5dc8abd1de1006eb5a981fea0a82d00b81e8fcc720d94c1293408fe98cf6f51fbb65c0dde6e13dca122ab4f42db738e8b513ea7eaaac88ee4d834a90e647292d48c1d0922a5932827d31dddaabccf134dd7aa3f0b55bc03b1e773b89daf11f9999ab31916e14d95d9ccc599eebbc95224053f7e19568330e21190778085897e481ad335cd37f809aa7c5416ef92ca53b7afcb35e7d07f9bcd44de1ab7141f6ed685a1ae55c825ae6803618ffb7e13c68c21c36e671c8e5c76825d9d5e1edc2bdc896f8ddb8323fee929cf533ccbd4ac930a4ca17aead267b8ebff3cd9c36af5be387f6c66d23e7a77da09085ea558d3bae8f14a3a8b609ad8c265118a5f6eb568bc63745b5241fb6ac50f27f97cfe85409a8141f3ca4d04a791f7b06b043859509e1459d36e418bb34d0cacbb87166c4118f9296ffe42b0944f5ba139030bc75b2f381c7aa8763e15861e5d8a86d6394536b9dd7a2121383b084df06b0e6ea8261eb4a78cb93f7993aaca8cdc11157c8c9f929ef8e6f8aff7e379ded2a1cee90ca6d836bdae309efc925ab4715c8368da5c639ab1d96f9590f0ab0ec8b95ab4a71ae5cfff39ed7cca7f0ae98140417addb81fa58edef2a20ac183c61b38e940d1eec43be4c1ada5c0cdebe0cc8eead77f996a719268dace9dfdcfbe51bb2012af2745a4cca436787e3db741307849ce4359a0c64292ab063a5f861cb20b771a4a595a450c1824e74a589f0b424e110206ae68f716fe7cac0991543f538d68663e5410c2da8b9e8f323a5a2fedec5e7ed988aff8a80938fa8b58a7f5b56fba937f54ce649bf86bdd11071e2aa30cfc1715d824a2eca3ae68a799d18b9365171a3a8bd1d9d71dc9fcd4a814a712e2b33e93bb6baad9085ee28f5e2101ce9455233f59e6dbb29181823a963b0d7b0f44db1c4e3cba0834db5dea5179dcdae8413ecf50f554fd5e2e55cc8ec709739c2d51671d265ac5d3b597f921ab676ec2a107a8286e4805a813c6d5df34bf7c05eab7e52bec403c933523a85a1c7be934e862b4d13f1ccff0b91e3cd3cb38352bed4bfc06d9e6ee1a668a121d4f0dde8ac04e02bc4dd4e1caae9767398a4bc8d3e858fce9a3069f75bb9c68e8d1afa733c8442eaf9c8662b7ee1014d8ff8dc8a8f17ce59f4f3abc16741857ef36acff8dee95e5a80713edf8dec686257776cfb61d333b356522740d3bfb99965a422b3441fe9eb493e1c91d949064ce623d6c5549d1e9c484ac91f0dedea0de6843f3c225dddcfac545c70a556a1a1fa1fcb46c90b73cd3b9c06c0670363870176df054fe070ae01519a40a965d9d0a976b117bca1b4034190b911e32670896668a8a9222a6d39ea2c479752ddb0f4955c21e21fda8b6a0ee61f9a3b8895682576eb948d0a19e3c77c4b108a1a218f8dc204d6ebb1e08d60c2d4404afb6ba063c33be710f26f5daf7b254606931d2a39e11fb41529b0b59bcbe8126acb6732ba2699474362312f88b1d140571cac9e41f54660d0f2a84dbd97b0f3ee8b5d27a87f6a7fac78ec675e660700d84c7a155f9a66d7ac91ef9611c54379a26ec8a668c22a482d3b4103eca4e48b507d87a7f518083780dc9c24b3a22b285fc406ccf01999ab2dfb582c59bf066ecf4b9513a120f2ce6fcbfabe56a7ff5985b9aef334ef9548f8508172ac0bcd9613b13aa9ec6e67e16ca3a93e1d4ac397f4fd12d4cdca5e78bbc5ade3fe714f982804675d32cc3ecade1a1f2498f7a63f0ac74e2ac54a270af382d8d03e643f9e0718d107a2099fa1b2abda356197b441b4fda8923e1ef48a17fcb9a403eeb83dfd8aeec3c42cd0d6d8d06c299b72fd9c9553c4188eff2e05ec99fcd1d8c93cc73c18d256b8c34d7a53e67d9955f17492bc8471313e1ce2f9fb595004916e3b99c2440fdbd8328f928889348b531f1f9eac78f3f32eeb5836b6534a4f1015485880cc4743304872e6c0505b7ef3574c3ed4aa19793114b755aaf5cb2162c106494d62f0cfc0a3aca063fe838b2e7b095656aa45e481727d30369f7695f4428ec5d16e1f5af7072d569fefbf3a45fd2c1b22db864f5e8e5047343aab754d56929a53e8306c3749dc05f7a28cefe31fa90a8880a66129336a5adeda179bf335c503e474d5c1fbd2a905057fb7a8e99b9949db00ba47e9670fc6d0c0c7c0288313bfff8c4f6c49cc29071a42b468d2505b1ce96d97247abb99e4902fe8bd96dd7c6b01d79cc8ad058663460d5d8de7af3ac4ed2ad31b34299f3661a5a2b321536d5abcb3664ae845d7d6db92766eda67abacb4a8faf79fd019623209f6afa4fa288faab454b50d601d9c60bf3da11630241c5d6beba308bfb9d5df4ffb467694dc959dd8b22a295c1481286d6450b5397f2e4a0b92e6f63f8262d6a0f122b99b6d83ac1b9f64a33eb684dd41960f5af1684353ac26dd0c08c800e965776d8ad40b1fe0eaf5d2afeaac14f4df11db02092b9f99b02c84f93cd42f7db454c5fc52d8ee4b37185708b1d5f3b0a789c181938e1c3b0386da2c735b2a9f29fe511e3ee28be801e20f3a7e043138f7cfba2b56e92af65d75bbec456182257c0fd6aa2a50fc79cf81eb64e4370018a8647a1c7315f3011233fa3bb13b11d58ba78c14e7c1f23248b5e449c6a7fc3399a72b62af150dcc084653f8c7540def543e52e53d304790cb0f3e987d33f93fcd59824179482d3471531d97765bde22287aa8714f998f435a3c7f4b42e73e6a3db5db17729e7e958cf9f716203b5da0c85460cbcb86a330224a61b21cc2170ba1c9d82345d22356032d3c570e147ba1f7ec6fe818796ce756da85d68557cbb948db43a44e68be0d92393d984b0df476f48dd77d1761384a2244e0130e46c647c70f7c922118cb98fe54a3a07132feddfe8c6c10090a1c16368616b990c484e793ec1768d668374a54d495e061acc4ef8c9315edf3fd7d3686b21e72e740d30e09d4aa752b73321ed3a9a997ac90686a467083e8121cbf273835a2e3f0503248706d6b83f3e7db78cca6be23e4203eb99c03052dfe537b38c3e2df88d2f95e1334aa6dc8c6ccd14e79fab7a6b2e05b11c21e58ba56abecdf26dde126787abf0db5f367ed4056417f73ee9c34875c669dcc1a3e99c68b700ea145fe573bc311f51148db71e00e85ccb182ee1261c13a0aa7f594f8c3cd2c8658def877cb8e2733c452d97006cb406606f6787f9fe576a72d078d760c6738bbbd83f0c88c261384edd36dc1ad963918f3407271da167c36f5ecc219eccee8890d68c2efd90d1db0af454608f897f5db316a8f754b4441e1ca7d70598d4761e300b6d61817c8895396e7b46633c75a6d9b692a957cfc5b9ed8fcd00c353a21db1d7c5967aea626f57653a3980e596df772fa33dbcbae61269e763606127d4eb28b759d09360b0fc16204a789adb18061640e9025e606ccf3aa6754217cb2489bc03790d2b5f096344b1f0554a166ac2511052b0da2a2e7a619ac36889370402236f609ba116ccdd9ba55b110509f24603921f7a532d77d18b5fa8fb37ffaabca091c320b6d8d1195e5038a47f9d342c243647d52d35016d9b0d485396f16013cf645c164c38ce98f479399b2875461779149b2bd13482684f3b55063c4c21c26eb7df579db5b0fb32afcee615f2f6928cbf2e25c92e0cdae45c0b37a1159575bdfcd962a9205b7d3ef335c0c6ff4a29b2ae7335a76e30331c98f86efc1e8ac8967e04e373177ef744edf7f50116f7e7d8eedad21e4bc27b62df3b85d24f791b556925cebf1adbce461f8e3d8361bd2cf42057603f16b914510c3ab042d88fd0621e054f17074b79fbc0b356ed88a97dadf0dbafa0152c94a9f6d0a9ab4b16d82594a1fa32aaad6b9fa8c36dbb7954baff1d9b47cb876aa3e0adcfcb0492b471c434bc0100017d3388f055f19e8bb1236b10dced3c2a6eb26bf8e454e01db86e2271f86571b887acec9999c356cc9e99b1a9ee251d3370d90dcbc06224666aa8326327571ce2a91b6c6c1edbddb3647a6821480264dfd7e9736a372cc0a7fb72700d4ecbacfd6299e959258259bf8b645140a8c4d750b40b38f99785a2ecbb54183d1bce5b3c6bb92fc41b2ad3c1b91c0d50e99b54d829ca55ea26af3dbb8e27730269e7a259a2895d111f9966c2a562468321499ac3f9ffc8cadce70633635d91f962984096f17d44d2d3ad3c28ae47beea25b02daeee2dfe5f012fbf3442e3e313406e862c7a8b9ad8f12672dd6229ad02488e4498848e8bdaa5c009a7663da6de2c5177324ab0c07c757e42ea5e6e878fd3f4570651ee68ec537ab3fad145adaba4dcc9d1335d8b26ad827dacbe140cc10ec32952994dc303ab4659d7c7827d912fb0270424fbf7e65432b8874214edfdfc85bd3bbdaa30580d238999aa7e45a3ea0b0002add8c8f6da0c596a7c83ea659ef718eaa6515a734a951671d72c02386b4b9d9c6810de708980e00583616dea791181c86ce129e8e4900fe1670a6b5750f3d71d7d6ed4318c26a08d9916228a477266fd1d916aa80d2431f38688f710da730bfef63f261b6b23b3a0ea5b177fff13bbbfcf1b982210793ad84c035d0b2caaac18fcc5c87b2af33cc41d8657b23657508cf9fa30666d8e615a8d7313bc027ab2e3595196eb454fee2ff8c3f3fc83fdc54c8393b7e42403688a791b1bf9861d3a712322465399e63f62d2c4371c492ba26961e04d7a042e4524bca9e49864dbcbb01bd96244b27cdbdecf060a3080451214baf336b1fcb6228cd827c5a3357dbd6ea5cb1f0d78a462690becaf8d4db3fe8db21f8c81bba255f28171b1e04310bd7177df81e43315c3a943add85dc9950c278efba84182f5367525fedafc4ca5cbea5034c5044bc9e6e6ced0dc63cb9ff95d4cc9f060fbc2059ca38d7e781fe2eba8ccaa46237dce07bb7038096f26dcd1a75979dc7750ccd61b2121ca4c8f14859b65616350810848bcdbc84bd55f24abbd18e87441c0cc05ad01fc6aff50e8c8735104209a3567ece0533eb1256559702df330814ae75181183e82e3c7259065605481bc1da71dd290dd4cbdd1ea5f24db58d01de597dd85372fa5695a7a03f4d7a56843a0358572aa6a49d3046d41c15cd2c95f1d5ec77cb7acbfe2254e6c5c99b9b61de97a549181e927d8d456923ae63b650cc10859b70b542633c16119008767415cc995f708056f8c8935903e109edcecd037d855d9d9b40a4e0421064d92fc7fb12351827e39ddf5646f103e244f156c1f7adbafbf29e22e8fe12f93ebe8949ef6a4632ee2e0a5b51f9de250a2acb5e41a15758a627b28e8b88f49bc36b1344c0ca354f9e5b68d1f704f00c5c07845c5aa115532a637e66e12a27cd3773b5489ca666d68e1bef0893071f356417c361b8c00fbc9c0d5e784d8cd8cbbe545dca09b55dc21e11c4763c08317e7837482f97d7b4232767f405a325980e1ccf853052e119eb783b1c549ec237734aa85cb8012a0771dccc15baada1728f7c4efb6cff2205438922aad0c5647d4e1e85fdbe9c6539f2a38c4deaf8bbd0a922a03df0c138c60b1386fa217aa52346c558595f86bfa5a08590178ffb68ad6d2c290856bf3fcc5c654de5b854dbae2103327ada965235407bec985cc77c85f550ed5e1fb13e8cad3d578562ddd2bbd7b7c2ccfd41841bafd24af471866789987858ed2eadd4989d6184fc9a1e70cb6e4394897f1bba71b28c84a28fe8ded4af7a7f0682529e55bd4bbb2f7ac10299e98011437f740020789062ba39c07e2f79f9c222fc0bafa843313f5475d8d1ecf822e4a13eac93cd307a2b18eb2d44d1e164871d8853944de0375944d31f1ab291cfbb22f5f7e37a1a36b43b817db3a341e544bfb6fc772a157061109f7f0f750ff3a95b79ef7be849808f34b146f7be50978584c90d5605ec8c22c04217f1560c1c11ecb513b5ad94a4faa04a3c1c9ff8a60fd562b17a38145aa8850b7541f4b0cbcf2931ad6fad2db6dc7e2ccc10b70b54622606521d3ee942e9fefe659c5fefd81b1376841615acf194803d947acc038c35f5d6aad803fdbfc9296bb7ec9e3e7e7241cc7bd94e0239dff2e9a930e60ac8d3ae7ff17cbcc0153d3fe11f023b618921bb06431d18ee44c72a9df44bb644816d60bc5eab2990f9cc6a3a555f7f128498e6d17c17f8870e0fab7345cb78d5a142015898dbcbb7d6ae54cb4acf02f67d45bf7231a168259a1cf36ced1bfb0afae5080ffdd421d929673f47b0be030362178b36bba81bcac0852cc4d6848ea17062ef3c028baa310ee2d616c43857c61ae9bbe7dedd4796cbaf4abca77182d10e0a18c899edd8d7a7baddbf211d4b0c9bae1de6c2328651f62396c6774e367f7d08db50cab105cb45d5aeeda6f28fa92fc6eae4a32ce8a43cc0c646cd2d164eb97a0da63ebb7ca2e9cdab327f418082c0dc0344eab45e68daf96b816988cf489a9641bf8e0ea47761c342fb7bda8395ad9e9075f472012cd9cb7793d6cf121cd556d3c914057a30c220c5881ea056bd4bfbc34bed61c0f991d40b19319e5d87bedf498863cb2b5a6d162459cc9da1ea483d82f467249097218f993a253ed120b8a10a4f2de4684b76c25b6a9eaeec06dd088abd46b8f74e9c889404d9a946b68ead5b3b109035e423832376c74b168ed771268852d2a07f730a62b78d67ba022c9b8a969fc577b11712a17f1794135f5e41bb1b08306f2ce8b4fb39f5415761bfe8c6692244348d5ee16794558975c22ced9ed110ff3db73402964abfa1bc9ada8adda0add23ece32d98109f92b0b91e14d2ab1f7b94dd904dd1adc5dd159f8639cf917c910d08a1fd0ac534672fe4a6a83c808bf98482e2e383ea41567e692bc066daf915df705c2ff1f5331db76fab2709def3e3cd82c42b58091dae02c5c30832b760e00e99df5a1ca72a20bbf421d183751c5eff47ad18d576746a83834570611b47f87fb6e69b73654ed6746a5094ba60922f356feedabfe4d2361bc6647aa9f45f1275ef5b2fe01bcba909ba0bbfca1dd02f078f2223a9a7e64aa0b0b436a26381e8b630d9745965b3304e4d4baa30e2c85141bcad24c51f435df1036ec8c6cc5a510d54248a9c8d66a32c020676a3048be719cbf1c93e1a45388eec228ddf068321259049abaf942298927ee1fd5f1741ca401ad0d48a339f8cd52837a2cbd489c30b615a09c82cf426fa91c8c6b05a73a61347b0e68a0589518a6259d9cea517c4920339bafb2727e87fd0c27bd7dec3b644d2ce9217ab63a00e1805b2cc26cf593603317a21f2d7f017dc087054e1e720706a1379a50e65ac4b38ba4dd2df19ebe208d31ed9dd86ec3f55aa8d1274f226e4fc18c577f4c6221631e528ffd7f18ac2481ae6b16926c7f7675dbdfd8f8cadc6d458ceda45b1325c796a3bb2d1d00568f1afabaa9b0effc96f6419928452e5f419d346702f9889f1ae35df29a1b48fa29d3874e9037125cf63c0c1c9dcd553cc44f58b65ce8577249a1de1453594606c9a52cf6df98446f8f8da5fe0c277d13f410b5ba671337a6b9929e4089ed7bed9a26b4353a1189115e561eab4e3ec894a052be04139128ecf88f47e4090ad2384c1b42b08e94276835c1ca81748df82b28205c0de1352da8ed9f4ca064077ef801dcfa0587487899a0c31b66a4e599c354a750dec41ad2d10763fdaae3f4ecab28046654f6c593644d6171370136b757f8c91179a61cb4d60b60a9f8024d56a1024b546f430f4f894af9f1a20708544dfbc4a039a3afd723f16ea1bf32cf1b2de9ffab03a5138029bee6c6399c0c844cabc97ee4a04d141332aea0e20b928185cc96cd024305318b2ff5072dcdfdb3d5ea4b5f2180dc6f1936a305145c83ed9477fbb582e5b9bb3ee89ea940554eebf8027c651299ca3d0309c10fecd3c8444df2656927a6c27fba074b651c08cccf0338766e6738f54824c0841bae9df9ba3c314b355a933fccbfa9ef32875c95c0a4acf8df751630f822578896d28a59980cadc938fae86ea3d50e8520ff6328c49620f3111059310f5172e57f85dce62d6800c66931cc193f09398c7a814061b378b07f9b16bf58dece1afc8e7b9546080c4420da2e1289cce4da7e9dd695fd3de237b24142ab81eb2af79f670f3c2daea536298e8ed4aa4437b05306f8cb7a14822f64db8d81f974fdb7d963d5bb78ca04af6b928cc71d1b4b7ed55ab05e8b0a59da3bf2fadaddf59f1bf4ff7729cb4734d9d3c9e03926534ce5f8577721b4442701b8ed3ad3ec1f9ed5aa77ed2db983c7fdc63d226759a2a5bd9f0079ba00d3119c41c95893a8e2a9c00e97a9ce253d92f5146733e5169cdfdf75af2e8e8cd2d0c45b4fca28982f53ce5c5d1d36004116b96d3b3f2fbe46c007b2a42c1c8732a9774266f447b550456fb1dd6e71bd63827e30a100e5d9732628f802cb2e47c39848701fb4570034518fe575ce7f1d21f7d296f1b2a6d0da8692117897abdbdf75b361ff08b21a1f58e69a2afade6fc975a451c7392812c4d21d4c722fbc15dc581178e78bfe933308cd3c326f02caf9aaa299028a1ed7bea015320c2b4d47e474e830f1fae13a146a321f04c8a784b9a53b2659cfe4ab44bbd6dd2b07fad74d675f9d7f53fd6e9c9858c39a5b82cef7eeedf814348e732ce130308ca5fd18d8d7fa96f42d0694d59fee0c8b3f4c2bdf0f9ed6b81002793941314946cb9957724508dde409a041301473ce9df37946c78041259bfed24a079d76dba38972cfd2f5fe6dbd5bdce2d228d6134446294da62780550f064642b78798c4d95ceb7ceeba798998b9d86682b51ae2729f18960ffa90478fa9ff7517d94cb08d542bd9086c99c970c435d9d8a9f4d8521010350d247d1247a12ae00cd81f0d037f841bdb34b36d4ba5692c385579d223d1dfb3fd803742731f3f35ff29334a3c005b5607a5450ddf476ec4f742a220b134c1dda1c99d8099b247915c3df8f5d5bf4e4096cb4d88d102b12eca93aba0f5d1f1eccce079122d929dc60482f545cf4302f4c78f0bb64b70229cd4f5175006bed5f56c8b85e8377d1f7b56b12c68d58157518ad57088e09b984c00a45d81848f34678e998c47b06a5db15b7b8c619be0b8695f4e9e19e21e65c5cc1c690222665f5177f09a87d22975357184d506b80483f0ca0679168e83b437178fff95ea71311655a1aedf52b6455edff20053972024fab1c3f96b98f8d439db8e53100f37dad8c939cb4231e25b5c791b5e761545ea177580e818f2c687fa7d7fceb2b6d8ebdfccdd05c88e98a96635709f8d9b13a21397eb6ff51239804db435f2e7adba8ac663488f9aea3f3a96d94a580574cfd8a75c000f047d162c2f7179272bb3860dc934e53f9cce1592ebba3f0cc76c17c05faad1b48544df710bd0f80ea1a8098ac7b65fd0377b93b197f89dbb380ae7f9612de3ee66a161aeb491b04b763b576824834854ecda339dc99eb025ddbeb2c54a91673317caf60be11ba3d9b61386385e1fd43da502b5b02b0caa60bbd021006f15a18ace0054c2e3bcc22f0ffb6bd6a372c5045ab28b1fbffabd1a7326bcd02aaebf6cc49b1321d7a8e69fcca7cf3420e847aa24fea6e42126ba603bc71ed0ed98c2221f6176fd7679daa2fc96e827819af60fa84e886fda6f9fc56e67e41da2de09355732fd0460ccc5a06de18ee3a0f71685aee6a52491e611c5e5a9c82cc9fa886210a9e1d41e2ce2f86f6a8a2604a73b8edd8a52023d6be14ae3d6c1ef645731bfe1028642ecd168d4a6a4a6b425f59fcb675fac8de467c7deab01a58755f3004c31a45745135992bfd84c5bf67bb6ea11f15f4f7b79bc0c1e6f144985525c09cf2aa60bf28fed0e2bc3c9e90360d03d2671834e68ef81b743ea3300702208cea68e40edf91118a6cdc3ae1ce6c1709c636331b7fc283779cd51081a26d2928015a4ae254e4d15b4f3eb7e6535b267adfed5d0079fa3df2d92359e80206da34c14dc1063af2bbff7f6fc18a97e003f3382108eefd2362888203fa7288cb093ed8ee68717f0fe7d8b54b8b28fb92d232ea9dee387d8ff224c949f6508d4c62da2175ee69daa0ce7e8e8b927171f558d9f2631570e9ca042884d4a731d980cc725edd44376f5f9ec69550ec3d38b3d7456c0f010e9be8dddbf7b5aeff8064b1775cd6dcfadc98f321af2a9408fe0422c90b1571cdf72d16e909c3e4546f74443223f00414ca3ae22dff17f57ca7088055ed3835c38208a0717565316bdc0c0a4c3797fe55017959dd9ecd95cca7294dbd5a0f9ae6a116e82f93d75156d8667c01567f71f1d98c2e141b93eca2482e2d019720788ba112b3c5c348e7d7ef6f07e01c4b0f916fc01ae14da80e8dc9f7eca53d2972b7b003fdb945fcec46524b5d3db105b159acd1627b167688a040b4ef8098e319f2231102b2a471cecd8f20bbd1ebdd8474a53c951e2a2fd7c536a1d4086fb5bc3e4533d4e330a1765622a77343c20c6a50f24bf0ae926b149010d64f59d1f7ad84abb75a5d238a12d2adf98f6f52b790fb89b0d39ad5c88d2cf873a6a62c53242e994a67ef5e14edfb0873fa1b7bb754ae05380beb94a610604fe9b7df228a56207058128258c8915eb978c6998d412ec3f99722c4e0e3e61d468b6f8f20092d9902aa0c6b95204ec0b3955636f8931c7275ba1ab367413764900f10749faa310e0a055ddbac21ac49d1f39381fe886ecba34add4a4f10725713402d95681502cad9b4ea40e835fb95977dd83d1bb97618c3d40d9797e80ad521199095f83e19ae6c9d1f72330f779adf6caecf1d6db09e52a6922967626322daf873f105241183ab804146f6e893b31aa885527710a88dcc5f3600fd61f1af8aa80a83ff6114726749da0ef945cbc7bdfbca7f8375abb6d69ea63cf0c5dd45b86747eaa2365061ceb0f4c02403004fbdaf5374cb039e531dec7c7b1238d76764a88d276cbacd2438c2a53938cd3fbec15ccc7ac978f42b064d1383acf125d792ddcecfd59d4c88db048a295502956fe5aa07462350f181180cc2c9402b62b8dbb5c3f747474f95e53129133ead46f6c0709eaa44ed2620bf81dc0ebb5a947ff3a4a5286f289a35a8872e3e43a88ced8be84fdc31431108a753a00605498b9f8b1ce7bc303dc6a57c723b0e9fcd32f6b0b784b637764398f0b8935ab5e0b8ec3504325002632bc72ba3e92d6558a293f79e9930d7aec29a20282a6efc747ee8b4be9c23d3d128e27a5b442208f92d223e8b31ba743c5622896d02a6bebb48f0dd457065375c653f712e8887eeff3aa3c825009451bffbc111a47624a2c2132ef94c6b102e1f92a2f463c82fbb305e0e069a925d787e9d77159e53e410327ab232b4b542c2252c3085981540e52408d0a341a8a178bbd154685df77ef85e8d889b5d819cda975837f6eeb6acf58522c5f7fbd1eec91a94e43bbc72deedeb96b7c1d607d3426a1bb56761012235ae53576c8f1b3070611e3d878b51c5a0bfc13e9e77ccd4c30b12c4b9e20a68ac30e42163a6b66b7709ecbf89284e1477d83d197cb245e7dd706e5ac64e710c20a6b6976b71a4b56bec49102f857d4c4ec60dd94dd2e31e4ac3aa9cdfdcbd4a5e7ac3b2935b0258c7c2e5da406e96f7d71e268c99cd8676fe2fcb4b2a035c10fb5505f66769c6c0d2a910856f4e91182890d8ea9769bff907311186a67987993286c1f470b596a27fe7f1c6346132a8b5f16e49c04e35968f13f67dcd597e912e769a51eae811d5ba056218cfd94bb86148cc863018f92d87cfb199cc690d2537e4290a2f07df96178039520e09dbc69c3274e69d29396f2ab5499d2bf5083c5d7644cc8d28d3cd652125dd063b3c58dc52eb437e4171707cd4cd4b2289a54386024ae54c48745027cdb60ac893ad17a53c8a7c8be3c1b6312c9def205b8219f8d72259f38644746e670a9f67a42b52b40c4fc880c5865aebc2a4d97198ed80fb9ad03d42f2a04ca50a9ce4af807265913499b9e5728cd23633ea7bd1c3e62a0f545d2250e1426c38220501b773c5de40302e1de8edd76ccf25c265553d7123cad2c1be1222575c9f017fe7c2600780de4cbeed670c686969b9438d901e0448e31a5636f7e36e15fd7bffb075dcf5ecce93f39bc3eeec59cdaedf8172bc0f50aaa6fe541b4e1c8e25b91eed56076fda50ea15a6ddafb08688a86c7e42723cbf2d6f374689345389f1ac0ebd8339bdebf9cc1da0e4c617000d26dcf0aea1f3b0c95c1de8006ff8030c12966b10dd6f4949bbef4a9382cec9a4250286a1aa1968826abc997bd53eb0eee94af7286f1da2b6a4854d67022bb4221cf2547e380edb7673cc9295be2281f0b2c7a3e5c88d26967ec0df4ca031b103a2ba6ff32ebf5166e01d70d582af9693b524e98a235a1780fff2c5d8485f7a1115e7c9e86d311105e5a38220b0cad04e959502f1cfa4d70accd546b7f01ef17a70bdb0229d8f81811108b881c3e2f8caf9a07dbd29dea67f58812e3ee289425d4e79f260ca08f01e122f0795dbca1d2cca12b29d6c2926ec16a2a809b3ffde725678798b39210229f7e7017654c56b2fd7c21d41bf06325b04e95219e760da1c93ac8ab6a0dad6cd015ef4a88dd100396e9f530bd439859a6bb5376c9de551922cadec27b95ef4d2675b7ca56dd94c7db1e5cdda3ef4c5043a2f150ee6399bf23db75b4b4fdc38dfed5bbd290ba653e29dd6799b07aa43b8f7149b73511de8c0048f24dabe4894ad4dd043747c2081b7b12374e3bbec004ee5391448bf62c8a395c94bce5a2dbef2de508e92144c7a1aeccafdbde187010d6673991e5e6c66553420c482909af9616e9003b314da6ba82d109184fb70d5f74abe345637cf22a55322bc58a46bc6e2d4e5cf4c7a2d66dd0b2262963ec4f4e12c7c98ea271f8f2ef4a8de8afbb7f4639e969738d2942e91a55ec143609bc8e2c1e93a7727545f84561f7e75cfdd7d00cb2e24963b4ac0b5455568b55a81cc8cf3644a10b3d1f664b8f6c5f11e82f1f3f1301d75257ae77de54b001ca9c50bfe0e198cefeeab68cce793c4d78ca5fcc8e58d1a5bcc48d5b58e8f279b0aa2fb99ac461632096c8fd737787305b60b4b0b00b7c9529d177315a36c3de5bebbe7a04a9ae74bb373a3e098d78a48854c4dea2209827c76220a19bec8a81b6091f0645dad1f0c469dc9609b93d4c5e7d2b07904a8d2292a1d0e3cbdac970097e1e8c43da40a129098c02595e27a63d9090f4b4c8eb4103e844379cbb6774fa5553fa02d2a6795b8d5411d8809190f77177e736e2736b6ad4803aa533e4d0edfc931523b0786f74fa197631ed6665748da1309b8c37465b2a4a8fc009798f3a8caebd5eabb84d6da02ef7258e1363822c44c81a8edc41ef74dd02164609f78fdab97ca5a761aeac6f88ccf20738d2735277e9f8202171463cd7c07b4485446bd87e93cfc8dddb29099decc6ce71e1fa458fe97e99b2f53bafa82016967ea94d4eb346e05a61620a264cc9eefada16ccd44a307b8617e9dd48384d71910062df6f2702a610bb86d3daf5a351a956f98d7b7745d380fd53bcfe3c463434d3e48a03a3946417201d56e055b55499541403f2305f4a662b23c704fc5a774441fb623d7d7c34742cd05d41a39b234ad9836022ab31940d3807759bfdd7bc438c75d9bf664fca03ebb8aac7cf02bd605183c2ae1975065353711df6673524a50597705c232487b2a0975acc223788bcda61bd5b6fd0e1e7929e3b59329e052580bafe64edb5b5e85fa5bdcc0d3d10569a84729b524f2fb7d8d6bc5ce1ecee4d159e83782731bcfd841b9a5965742526af509b3220c73a49de3237e0f247184f26b42f023b9a7ec9369d495d4ae47e14035fa6147b998fca5f96cd219a19054b328e4e3964c941b0c89430efa4a9dc2bcb15401e0c4aa469617092f884af9e7ed60c68037c114fff66e685966a3813942ea8884cb04d16ea720f0f0c6a19dc30603183f661e4101163d009d9e3ed164be99a363d8c38293067d3fdd4bb2fc366a71a1114c0c9494ac23caba238ad3da00752c56bfbb75025173bf1dd842bf5b7f9b1b359be5b4670384acfa65f858ac35f97848b5100d63b8aff7f4ee6c20f6f26e76f34927367ef160cb447800100d174dd4c8a80faf36b33efd2deec246db100e19c26d6821df571c37e536d46ad6da41ae0dcebb624777c41ae273137c12db21603a3596987fdf0b9ebce9b2089364fa0079a58a086cd475ad8183b93d756680d72a7ab9a75e56fd2a26cbdbe1ab95f1ac3648f1423ba63daf222c24823d1a529b4815fcf37beccdf27461250676c489593e94a6fcce211341691d27f19ef0554d1e3786f87aad507ee0a201e79fea0f5eb96822355b582a9c9336b432f3485dbe3db5ce1e44e2a7ebfdff399a34f02acee1eb08e8cfa462c6caa18c35129ad842863e96d179313656d8d6a012bdabfd3e690c07457d243b5b3a29cf5bbe5a29bc212b9c806a33b35dd0b57211f555b266edd91f426e10029503d0f15c8ead1ec93a0ba0099ffd1344727af6e7759ed44d635856c7c08bc570123f3c6bdec5d576762dff831986babe70921b3b01e22556dc398588df019d8b389cf1c71580b0d5aa9307aadcd2e540d84a1cf560c9453b959c7065bf021259e6ad259a829b041fe75d07d06f7f0c01799afcbe7cc3f037fe1980a403f3aeec8a7bfa7a94fcc79b85edefebd3cf992c800bab90ba1a725b43a771b966ea5e2d1657a6a24807680f0a45c8ce61cd8f5214903c750a66e3957a6a8d62e0ddcbd29fe3ac3c2e2d327f4550bd298f6db5eb96af9759e4a1927dccf9fe8f62a8097ca813062222b26536316a1d35db275b63cd37224c722a7b60114fba86a41e4e25dad2a559672521bf7acf3290fb6c260aac46dfad5093dc0dd0e2f411d217bc34f9f474096aaa782741bfff1487c5ea0f17067e795d725eb65da88a74cd773ecd7f8bb1ee0b647c18f63190ff14edbab64a58658c4686c33c9cf7e9977848428e134073a74cc8cb0fe8ae29001fb88c28eb77f7c997de77d7be5c84310bdf547f410ce4365b7c5dad8c710c23b1be6cab72eea8bca2ed30eaf9bbd782121adeb3494171aead9f9145dbdb18bbd955e2b48641f9f51bd7df5899ef7ffb281f2e9e6c907f0b7649e471f8f0af8159e87184d77600ef3cf217dfbecdd1937d7b7409a82dc912922ebb2e7421548fab69da12fd0ee9849b2656203d1e9f2ce22e633f792c55fb294067a922aedb9d906c6718dcb7e0cf028736aa2d0ababdb3a5c75f4be26e835264aed86dd832a9638fb880731bb4bd6634eaca4989d652042b0b91cf24b07298d6db2d696a37ba90349948ef79e2bc595cb347c9e052fdba6c9ce7a8013f891fc8c88ff41fee85b5e594eb70c04436d2a20d2b8275431413b346660acdef6d8494f4ee54544c466ea096b4fccde54589b91cb9dfb5f498a2f799c8416de78416020db7891e89ae765103ebb755f06f768d391ab585d9207a997fef8dddd39043af63d5c4aa1c24a6cd742a01bb7057a844030d38a6f125c01d930f0849a36230b7feb700774615b3bbfaf08e32d87ce510aa4cc73970fbc19e5995b5a56bba2b699e6c15e345bd102061fd5fbc079ef11d978c25482126884e9203426c205ca250749c3813e842ef7754077b11b3ef2335abc2edb696c86738364e12fb1b110a851f117f4fc0eea2a41875cb3ab3a2cf9dcf062b752577aa46f06d980ca2307e16eb3c6392ef73a0b9566abd33130629fce3b7f325fe05ef05cd2bab2583d6a828de165f11ad85beacd23da2af8b351937594d1e23b01aed61013dc069dd437c8384ba0ee28882d2b06676a59ba48f06b23aa8df575cb4c55f628c8f328a12356b492af702b437f2cbfd291217e825d5160eb55454e168f2ec1b7f2397b12bbf480ed1536ddb1d5cabaed9b9a0edc2acbdb9fc3eb7bd287bf4a1668d87a825ede3da42ea0ecdc44366509a095c035424bc3defcb4f3091c46a9a604757cadd07423ad8f38e33e95825e7fe183d9e0d8398b717017956f1eb47eaa55eded8a0ebd207cbd6bd19e8fb2a0e2f81da6124798816a848a30654eb4da94df3f59ca4b2f37839081e2d8769486406c02d5f798584971b273ffa22cd3fa4becb888eb9b3c1e9c02583df5340ba8d4f8a1bb3160281395c15efdda8b8125cb0c6976579de5b4729255a9409dc0bd581814c013cc551b0236e921265778ba6e1b1807aac42aeaeaa98e35714b6f0be7f3132ea25f1ff248c7ec17c37bc5f981d931ce44f0906cb50e54160cfb65e4d9bfb53570bbe1cbdde23eefe4c4ed25931875ecd2704806024281e92ac3abf508e2819a96713ec9176b6389d0ab58ef5d273c38d700ff186f3cc6ea828816cf825ece7f0268448cdf467346260a6117800d076b9a6641ec32613d6be40dd8cd5c250860cd5ad4ffcdd80da8b4a04976f96df8811503da168084f8a2a46b36d619ded3ef6c2213d14e6992bbb99ef0650f0e38c69b78011d6023f90e8d0189fcd7e67d332f007ac07768f279241c329914b51ae59f19e03c953e1b1fe213b243ef0e01ac9f1aacb6dcc68d95472a7d62521f5428a7fcb54bc492fe990ba1aec55c2e69ab7a92758ed1c9a7dfc85428bfa99ffe032caacdbe1d34ad6acc6f4cf96f71289b538bfc5f87ba72b97eae49af8433c7695acb2adb74899d60beffdaa26f12296485f515ef2bb4da9307d0b08714d746400357e7635680639cc16a886823f7630b177d476f4565862e8745c064ca639523ce7a0606385431374c33ae676986a05ce4c793bb605857c9be7bcfa02314cf04d6a24623e4b5c9861b7b77bc0fc883f589cad740c16e3451ebcd8f5bae33f7022fc47066e3e017183be130e4f4f3ff384ee16fa3dd0c19c9cc655edcc2cce97a4f564b45a219d1c5c0fb0ba6aad1afa5c7c14c37d26aeb9b6e89ae6b304b384fd410b010977b505d72fd7a451413e9561d869ed0b2bb194bb7f980aeba1851390d97b0e264f8932aa7ed8e6be9eab389cc2bbaaabf458a21996c9b7fb8c7864a2325ed5d77c1e0a1ca7191fc02b2ca3e11c2727334f64aca0befd9bb6c2e0c958c035991e31413f4eae077b624a040a21eed812721276aeec3464adebcd7502c3d2e6f7fdf60b794215bb619a8829ea5d3fb1db29469639a51ac75bb6443b72b801fb67aacc091c3abfe9e557fc9e448d0c741798bd7586969d67ba0d820e4294da6bdd1c9da00a09464e6d1a4d425921556d4a8512783fa4b4f5adf36318a1da37f40eba426ee0026dd93463cdbfa4e93e5938c8bed248e62882c1c3948f35c22d5af1ec42b9ca424f830f7dd804c20c0705c986f19a4b47aa30d2b1022435293ebcd4f4ffcc1ce18d08952c5413f2f0de6474e1f1908a602729ece0d41b79134c0444faa585574799715bc3d5889d163e88acada6aa5e2babe72235322862ad92e694a61c17ca03b9450569999f485c737e99eaa3aac81018f9a4696053af9a10459323b260780aa7cf863a16c42e2f4a977b83e84a5cd5e310f047e20c539042babd893ad815723c1128d28b5aae799943d280613816efaa2f537683e52d0d6327dad1cb4525c510b81d4c217fe2379cab8ba216c4547658f75cdd344322259e49bcff2b60f2bd2eef2aa37305bf58f3fc2a7044d1e002364c5142ab36e736bd49a07a8f38ade0c297acea252f6f1ddc95d3e96b57c1260169dc280aae63f5ccebc79149f5db1d29d194eecb464c0753de8dbf1894c854fe5e911af7b500b20213b551926ee53e01881541305e0c68bc57f57cdf61c3242d9be071346c77043ea8afa6489a95628e24d499a5a86d4f0fe8fc9abed033b83eae5d2f457debed5e3dc0bcac0e5b52c08aec8639c0d980cb2a355429b57ae6393a76faa0d8c4c6e0dc56b8bdbc454c19b3b52587e63aa9c673ce82e70b2f3b77877b2e50a79eef9163fbcd2adfe7cdab56de95fec63913a5a42ea25fe2b7adbac82c20131ba6c509d6d9d180f49f9421347307b9c8cc2a31a09a3681fd8955ef99b35fa25adae45bd443b8e4f561a4e13c9311d2fba9c82213dc8db661110c7e29a53e0e0b89ae474cf18cfb68757d00b86188dcc8d9c9b7160b3b1fbdf91f6f9aed41d1874062e63db11bb1e872b36d085e8eabf1ccb5ae1395d22e4afb4c4b23b12e86c6a36162c8f2cfaf51c3ddeae87549b43143e95f5bb7a0c7a3044c244fa75f7a8e7c05c1631be050d56dce8d7cbbabfe62360c8e40e158ad094fc27b4383ee29752725ecf07b828ccb46bfce260ca26aac4609d615c6da76a55bc1a80e90d62a2d6574db971405abdaf7bb1b44a1d268f9663db26393bb84826ad984c97371c844cd6d1e173a1ec67f0522cbe1aab55e6e408b8b66a89c751ca554f2a9dcf2f07a01762ee1a475529c2e2b0dc6477ccb0a00c133394ff7be892ea30bf8be49dd8d797ad067033eb7da121034d746dc44b67cdf5351ce5d6404a035466e60bbf842fbf4e8a760bab1e43a0c504c85f00d403e9a83b218b16d7e3f25b9be85cef378b4601a9d5ddcb0e996db500c7a41e1d547662fae63e4e6ef1fa0a3c3d5c01df83aa3392d367d0d9417bcc68556344ffed294e045f97c0910636189cb7f577bc90de5054bae12922ea17b841bee6fab1dbcc904887937a2bcd7581fc6f87a676aabf272da1fc946db365b28ff3d5dab602140d3dce8e068994ddccc4457b240a2fc300cd039df98555e9fc884a937c0fe774d72f6e39a17310c89a1acbe6692eaa84e1bb57ee98a5e9539201f2e39cbd0cbe8ddb3eca54e7b99f1ebf821b91aa01e3a1db680978c67db4289a78a3d21a3c48b55991b0331267f0a102d5bd2cee55754c05e6db811a73310dea3020a5a1e18828953984343ded8d5f9a90817b4d4efd00750b31d0f152b5e66a49656101948939e3af8780765be0fe5f035b68ecb97dd2045d01849703e257037d5c799c73a08fe00f0ca54c7217a853218c1cf214d8cae7c2c6c2ae4433eb953426e08483f7edfb662441bc93450556a02b6a388c120313d7cbe24ed426174786932ca58b1f55b09ccff1a8de276641a42322cc90b63b4795b64b7daba438f93b0260354f1422ca5a5ccfe729fff5a96915291764e4742aeedea8b4e97390e2c349c3ddc564c93b80271d900a779897b382ab1feebfaf1d568d482b7ae389c5f0589ab79931e4881dc7efdfeb04f74533ac2bc027d2c0bd60f4e94a589872a3e7afa647bfc4913909aeb80f226183c02e5b0d14e5e619a1f447e9970aed047e46d044e1cac3ea9a89fdd9cbda78d1baf2782b5ce61c35925f19c62be0efc7ed12661409d3bba8704633beba494b9ed54546999625f427afb26df98a29d6d3b1159b607f51eac2392edc30df13fba544b179851bdbf076420662440e1139ae1e78a4a677ddd24ae44654dcc686da917404be0984f2ec88c17bf60c10726a6df64ca1d85b91d1c5b0d4347a6ef2abce9ce4a63b59a7e77008daf693b8c708273b355938be99d92c647863d817f36cb21b2f69d6351e0d66bbcf87e39bb629d40ef482f3ce4fd859441305f5ca0573a1e45468e92ebd4b21943ce1ad09a8f49d263916b8e49071a6b3452bcf5d1f28a3fd538ce74bbedd479ef2a6264a357fd335690fd73b21ce77ef9989616181b32371a16739b903c0b61ce293e6178e4ba07f906696dbacaa2a40cf90a20e1b55e6ad9cb72ab3cd997ef26ca3980a6bb21c48ab01ec8618b4ddfea17f3feef1b76795375c2b24d693ad0195afada18694b90641f41fbc5a52795f68c9c28d1ff29f623d10a0d5d0d6ff4dc6e0d8f6cdf46646c7d3a6fdaee3bd1650df3cf018b416b6105b72ec9fe092bd88a0ad30c49caa0d05d0de563db5404cd227f7d50c81e0f2fc3919a625451918b938e5003835e1b8b785b413d803f21fda9d7fc7d7b3ce1876d7758f3f954d5f6a2178634bfaea8e9adf1220aefb9f31901f9a38ec14039c6785e7b65e8bf9de663cee9dee8fbd60a308b1e58c6f2f43316d92ca1c0459350d412c965c4a4bab66ab237374a9ce8723cc340362ae1f7840a8ed6cb1840fbbe00376162aeb305cf7304a2a4a61e9b4b49e647ecda9cd31acd029be713023eb1694af6cabc8669857cc55d54599d32689deb7c2957a27367a1c32e9de28409571dcff2639d0697049d47e0bccb70092e7735c85ccdcd80002b518efcc4fded07ec7dc3241ce5c0dc1f7ab13aa3d1625b147d0a9fc44d674948f1f08a178ceae4af73ebd72540c8feade6f989e3ade0cf16d371b70695ed78ef566e4c01dc3b00dc3518e60e4a0d2c977f1bf9b75dbb8e65651472cac00adf71c04529f4ce478994337c5966d48c17844aecad83d2f671d7b6bf7f3a9ef44e13af4c1f7f4f818bd228bd7457dc35c578f30472f4bdf446e6f1b2c72baf2b9780644c5d7205e546c53ba0bb48817e3acb6c4da94d243e2a0f2e4cb76ae9163c0a31a9fa87ff7f5cb25593f2ded89066a94a415b0c5b0ece85ec5ba09e9fd57e6a18ad15f0234d7982d3c2e635bc5f97aa20f7d8aae26e09d90157ac36bcc84ef4bf2581d31321ed7510d2fc8edef1e8b773de26c3c730d2467d847bfe076546b97c3b6e82543d991efa38c11ea4ceefb666431bf2b7b82a7b1e8f34938272901455e6ff2b9e20d887bb9d69e9c8c220abf42dca90e7656c1e6b4b6912b89cfe0464e67d90b4519b4584494f54555c5afe69c80986e02283b8d8e94deb5c1d5c9416248e0bd615d611b7082b050b6d2e33f800b3052a84d6388ef236cc4dc3c29bc666455625a8504b2ff2d77c287936d1e1cf5ec96af274c0566263e111f3aad577e03409d8075be669abe6b5d43f3ecc542ed1ddc6a82ba8b8ec7e1f6338d8cfcb974dcc50284d1b9ebf94f03bad81b83591413fc5bb7ec455ffde53c85b5bdaa47da646e1c07500f3636604f98959ee4ab493093b9a19eb5643a8bdafa3fb50a9ebd12313c670177c1aa833d62b042dc7d4fa9ab15b8a9bfe682266bc26bccc44dacac4d0787c5801a9d067483876e4849f39db9d389f890cbc747c12c866c88e4b59fec2d1c4297726e55ff90bd9070bde7463736baf651efe8e4e13821fd30d585e7e60006ed7b0bd76ca1ae19d99a9ffba272e094de5cbd5170dfda05fe02f42c4483aefe7df8bf83bcd7093b75285607dd3100e012ebe42411bb1a6c30a897cc90ac2fe47f10623240655f73bebdc9f200ffbb6f185a1b59a1568787bb1e35605410ff4ea7b8b9c607602d24d295caff763a41b249bb79d5ddb09970161b91adf153660b9349cc4244cfcd79c0a7998ccac8866a06a39a4c53d7c64a9d49e74e4d1cd09818c4ec6c63c57cba52556c5f6a1888d52a683e33f2f57665da09886b981b9a361d0499f115c1b6abdcba9d15e69d27b61a04f0e3e079f8e25f0774e4bd75ef16a13556295dbbf0a60bb960044d7f666f8308bf901b49a0433b47461a32e5bce2a45856f8070d935ecc4fa0f8a9a9347a116e2ea8ed7a4b702fcb0e539dabb4f3e6f358d330f67e232caa60c2c2c2a5903b576cf3e3fd95aac04752495802a8121a0b6822a4192240340a08368323ef579b4b4d35f227738015fc46d8da19f23feae67fff8be950a1b6801f65fd5d1c90bf7edeaf3ad23f5f2a67cc6521f5ad142d116def7b821c17d4a3da161c0c5ea24baadcdbdd7961914d46a3802219622d0a746cecf0a5a5fb0f7c29827f24780379702584f67db56c322979f4f368a78d72b27365c9938e201b3abf7334d17e9f645dcf42600fa31a54330c8ace62f7e9ed8227e0663a69cc52036f111d288ed629df1e40cb202b9ac35de5f965cc6a881a2879e1df36f494c606f78657b1a82d39d05d03a4cffccf4d56b51ac49eec3e0f906a48324f8befb7518a4da12c8f9c30dfcb07a0425f57a40c4efea39ce641793f2305ca6321e176f2289a955e54dd8f8ba10215a95f548a58c96f56475e76add7528ffbbf08a4e6a8b58477918be479201aab7eb1474a66a7f771b06f46c31c0ddb16bf8c90d972a50a7363cc0eadde726fd0e931cbe688a551ec2f959ac1832022af33f1825ef2f94d19a3b857520e4708a56fb5900eed287c70bd22f6157efe2b850dd404e5a74b2c4585f752d0ef4d4ba0a6c9763f422e98fd850862ea82f64b84937f3755f792ff2a6eb3f9f583c1ce3718c986a45d9b75cc94f5a4ceb29e718d7c2a50411ef988c32e75b0039bee4e13cdaf03a1782d7f01599d850d0a4586484ab411eacfe1f8e9d9d2a54d1ac30581d6b6e1c32358dea7b67448b6faeec78ce5e692bf6d5817ea83d946ab373b1a16e3761381148190f86f8daab00eba0ce27299b75091daa2237758f10a4650c6b2ce0308c36065a6d5bd30fc890499f86728b7df2414097d3917450661eed2df6f39cb878f584622f875d1d77485307673e4beb5a3266f98e64622ded143dfaa5349ea1a888f33dfb7fa8508e65c701581e8654c15ce0076b5f72ef6f123d984641db9db32e5e4c95554a7669c969634eb9722f905b8b3b2c0b23b3eee34dadd40d9a8c61acf64ca2f104e817c6e761fb71de30bde278008860c79a9371bf9ef57ee4a3676c165e2cb319cc3ca32359242a63ebf833b11b7aeb7b4597991c77ebc8a234208ef36fce091a0fa7d093c05e24e6f7688a3224d6df1e5b03eb842ae91695a7d91578cbb0cea2b54fac00a7edd4d01ba0bc328d5394064cdca04b096b750f36be42864a2f4216b5b5b4a05fa865b78bac58ed5d5b1adcad3aa42084b40bc92acd4e193e8085c3ab75d9d50365dee5dafd3d4cc0eec3f804c63b6d0e40f8d573c142ade70805b52c22e3cfc946a5f1e6e9f97944c9b14a823430e38357b9354357d8cc8b2f3fd12a66d2293a4b0387813f564e126a766b37edf22f913a880abb25bb907b0ebea0a1d524b00afd5ee420588939c54ba76eabc05decf47f7285178a2e98b62e20a10e49f9b01a981c2e62750d611c301ddefc0ab9dd54477c2fa61f16acbd894610d632844c7a63c7813c7a4424fd8feee341f3f7528269249a6b1ec93fb9cdbfc96de102df5f465fa3713682dfbb4ec3b33a41ab0932b7e49374de68f23427ee47513604c52878212c2f81037cb13d5393f5917377c34526f1074b9be667512b03592bc69ee8dac526d3eca2411891f3976804fad87275b9e4b60391ab209b1bf39d491b55941e9b976af7edbc7beaf380fc863136c080f696041deb7380ab73f3ddc5bb524c9227fe2ddbb0b7eae6594ffa70e74cab0ef4ddfc2b9e3ab202744385d2c541bdd01be5cc6ecc91aed45f1e332b5628ece9190cead4853aca7ab79a995030739e5a0a7195978251ca422b1edea12be8946aada7b2f7c09f193fc34fd4a04974781b98fc09873099477e1ec5ade74c3536fed512a420ebb7110d0010aa5e714f3da1508937ce7de312224a4c6cecc3a87bf0eb640fe5d8156c0561bc8e3ec8f89d1cc4c69290ed2dbf7785896e8c58371cb8424c1349d7b925d8f3cccbbeb436cdae8a74367d75e9333ac201c686a770d183e02010d85197ec973ea7e17eb089b913c96691fc632d0ee15d6aaee186479c16a17e130b2faa3eb782eb7b03e67e095f5eeecab7c3cb47cd32ac303d771b19e0f10c97673f86f932905b187f71e0c09dc85938cd3f771d6a0319ab1dbb82ca9765081574e0d8315b875290db37d12b41ae61882d0d13f2c858a7fdcea86751b2c0b3da1c175ce86c40327c940a7472f183716cda776708b155ffc476c6fffd5e7cb3f0560b60522a45e93f42989bd3c0b20b9a69e07ae1ceeb20b9de50ea704b5d738ba731c0cf41940e7fee75560d387f065397098a513efe7e7564d5fed15576fa3af1a5761eb5f05f718c980d75f49876a7fff3807c8ab0f3ebfa57de656ceda4f36e7e847de4633ba4d53418442c602bcd92d426108e2d656030039b113fd09b5fa6e9832d9f9e4eec198e4da60bab759918360c060172f085aa083c3fce27627a9e9aba9ea633a94e39ffb17f98ea48e9fa261bea7a55174a1a8be081ae3ec986f4840ae0460fafe2d5f7d82112ea030b94f5526c8fd6acb1295746a93ef19dcfb63d4cce13691528338cf3efd1fe8ca9e16449f4f8f76bb3fbc444c3dba75e9d09d17ee35f4bfbeba241d0a65670642a93b4b311fdc15bb87f3e88e6c95a93c78bff9f01ee8709677c92299d4e0103118c383849ea5274ef5b18eb245a06f0ed3ca9bc8618a41a56eb8ebf998056836f74e6d5bdbbc6ce025fae25b589815a5988edafe070d5b8fb706b6fdfeb9ba555fecddab393f56a80d3c590a4d778ce975e921654805f61cec29591ef8f5351ae2d40df83242985cc3937d09b8f38771a02d5fc6550a3b92c36ec014d38390125c9044c7ec32f86773d5f58c6905826e51c69f7de0f0aa4190c155975218cacaa87309e9c974e9e8a09c0a87f3034bfac5fdf408722bc90bca168b5f0ecdb3f3209fc1b2b25b2ae60a8a8300bf8b6761601a82c6189bacb9ec7eff83b0cdaf71bd95206d25190d795ea51e9a0616c35d1261bcfb26ae8ea3d0f81386cf8f16faf741a23bc51b3c0c45aae7a80587fe622b262991d1ca605fa1128ea4dec9d00aedee441bb511645aa44dd639f6f11625891809485ccebef66b815b31e65cdf2d4e688bad018bd0c772ae32d4d3f3d467b8ebab8a129ff92d1c36da2740e949a885a1c1fc819532520cea140b70d5814e52f984f181cddb878f54b6d4c1db7efa49c95477203e9d1e5ec2e7e5f6c9163a9192ac053a577e12b678e6ea2b8973acf5ffa0b8c7a0e6cbeab85ce682356be37761e6155138031559035b8b977921d12ad415a486f6563881c60e17ea179c2ff93ab7b7876592345a63389b8f697b239c9178a163c637d6b0a0643d1a6d3c34cdc3ff8c6f1f30251cf5589ff13b7d40531b69965de234d9e26ced477cfffafdf2e8f9e33750950da7bc6006b58cc468ce8f6d264d500dec619d8589e0cabedc80b1b8af08ba702dd0bcaa7729286682aad23fe46e3eba28043f6152eb076b9920d979b8871b98d4de4e482393dcefeec02e62292b636b3a82aadd797993f3ac199620814c92c3bf837d0697d22ca52147834e57a426051d80b46bc60f89a7e7c05615c50d74c02ecf48dc98a7faf2e2e6d4cc35304fbd0abdaa2c182ffb11390b869f87385dab819074abfb411dab529e6dd79d160937bb58029e12040ef8fd8c252235426b536ffb204aeeaf0af52bcdd6f67fea2d2bd16a2d28b4c50c6131c790d927d1f5a87fc8cb1afd5a29e1c0bab3a686e28dbf387b9ca6ba441519a98ba65f6836d4a3e42d142899ecbe2f26ba47e3494d6b61fcaf784902efdd54c887db4d16a8faf6293bbd17a411fb3ce9640542ed1429937ccfd2df2711a600b3acbafdc7cc5bd0ba245d56dc5c3985f3d76219212678b332e3142a037994b6b1e6ed2d0f77402a6f26ac4c6c4a5280fdfeee096014d396835634e2c9b5bbbd7916ffe72b924a0fb2988072df4ae2be997ef27a1b82112e388c62e70455709676801a85896f4df7c94b1400f67a899373b880bd1dc225abf62a577184253f661aa25df5ce7bd557a9cea2a12b49bdfe44c168a8247cf86861cf3829d8dcd4540d6a6bf283abc004f98c60d322200ba1874d96faaffe1d59620f86921374a316babd1a96a3ef75d8d6ec13fa8d6e8425665d9d3bca73871bcc2a61f4ad28b688538a33524a6276975bd08a2b29df6b129c4d061218deade3560f8c2faca7ec00872b13272f1df14439d396631332c3824aadfe5e9dd9e0842a41f85f20831734d15bd1c550fb814325267a8955b370f1b060a75efdb22915d2cbe0af19dd1357dc5df2fd363256ef39801f873e2bfabd8c478ffbdcb8fead326d413f3ade99a084b4565aeea7a6f7666ac62af005e546af2f7b761b612d0881bc3cb4b55f0d3de4413cf9eb70320f7a8925b183d3ee850a71872e52ea7041262c628afff178c769004941a1226980f323ef21d21fb32f6b1c0551cd9c4385dc22c60b273871af63ca1f9678c960a39a4bd6346f9257fbec1d1d8a869da90f9875794f52ba2be8ae8446b8ce3ed958a282f9a5310ee6227867eafc24d6084a6e9e12ba6cb07a09bc4f4e752a9ef0113898ab6e2e9b5e8bc902cc75e0b3e04f68c477cb04ada77df12b21898f943c40149b220a06008ea569670fd50f1503a6246e589902d7c617335b97df3eb2c9cb558604b95131caf2b6bac9d1af38db6364a4da88a8d72e2e67cdbfd86f453e90f089f3ae6389a24fc5ed73e45f7e1accf44c36e8ea81b428db8e350605707bdefe11b36be2349b49da2f4732e343c9124549aea022a086479d3da64511b9bb93f1c3273531fc585a7720213dc68fc221cce734b9ea2764f1d00a75f11bb64b5e9dfea533afdffd86ca6a2adcee003f023c9e27e0df6990085edc59fdbe6d09d5fb89c21fc75dc82585c871d29aa2d1f8b2d1582267e0127d882948597795f3cc3ee1b95811df579fb43c4c250c8b3d18a513ea23b6e164fe536f4a1d21ddf9f465837863b7a853fab5f7eadbf5e580375674a91dd47d4a4f49c98a08d299ede90aca17ee4c1d934a89e6b5adbbbff4b581250788316298f5e2693ff2dd5654366fb5cce8d64b87eb3f9948ffb7fd187e7d686fcf5214a91b730103689b981d925db719370c34b23628d337b877eecdf53b3174394bb2240decfb1d512adf70493e117d96acced7180e130e0a491c4ee3a8ca1ba8f4f00ea0a170e91afbc003e73948a548809e7d9f208b61d1d0ff9d9e83c4c6f439a92061943c199b5bc8215c96865fc727d8e39d6b8e55cc6a7ebb2b7df26811fc64665f1135ea52263f827e48638e726e59e4231e6cfffe1622182f71bb1e5496bac9799792602c13d7a91e3e97dced3efb29918b3667e8344f1937e3795af2c5d81fa47572b474bc145857663e81946a35052466021ab8afc69358c4da80a140ffac6f678a07a74ba332d9dad9995d1c18c4cd6b289240481fcdfad31a5891c9260d908e6dbe3883362be13896981fd39a7e4a4ec69e8dbca42fa7196b4efe403093dc1357b31c92ba0721ba96af45586345297c72cca9fa9fb97cb6492ee69d8112f89659cae8fc71c2f1fe1d7c139c0ce15a6eebfda9af5f753248eaff14022bc68406539c6658e54989b36e9eb34250664ca4bd46b4805d83450dc5b72ff70f90150772bafedc094ee3086d54a2735f9dba397c9638fe78206565dc68858ded3248d825f51fd68e1df0619be1790e4396785d224820b5e21e2312e85a05af3c37a01531528a57a8ba6727b8cc58a2268986e5e81dde6d7b4a0a4f4b71f60e91d51bb03c232de39e1154b3afc8ebacb449685ae367e67a949e050102086f449a73c7f444dabc65b9bf1d518b22ddec1b818fb84668f8b542c492fbd3545a6401663c350c2ba308ace42bcc9d0cc5f5f77cc193a9403b510cb1ee7966367a8b9ede396f391986e9ad1575c0155a5fb5545dfab8348ae17af053a06008484a3e3c884258351e8fa953d96c1b3d5272eca521530d9a911027d4e529ff34adabe10872d421600bf974ab8da5da2a6d99276aee3f22cbac1cc94d1a74b19712a2341c8678cb610efa33f3fa127a765a0189b4d6b204bc8b5e8cdaeae0d98c2404b26a1fdbbab6ff54e4afafa2cc0dcaec4da1eae1005857ac36187dd70836a2b3e9a3a88b298f5c168c599ac868b96f0466df77ae2b17150548f10026e0eaf14923efb839e5170b2e5c1ce06772dcf5d14e9f48a1349b11770a875e59b502fbe652eed22e5da3fb82955fe4699017c8077e895f679d5dbea6c6394b3523827bcd717e374a58d1f7b0b6751d0b26c7ad8af475b45ccb9c84d04b568529be83a059db463244890897c82df4364fb824acfe12ced6b45213c89d4d7692a9c0233387f74ca6840b8daac4f42218b13ab662f1d5eb1853babc90fa92e8b97200b195ced87e290ec4e5ff942906ddde53e446ab66a8373662d5daf38249d0da875db301c3f3582f57abc51973e0309d2ced4eac8645031aa6fd106c8774bc8b8ad45ac1362c76620550eeff031b466b6611bc9c2401e3fafa8b233b4db79dd84c40981261b567cc1886b73a4dca080bd0fed6964ea242b90588011aa90c214e2baaad191d9442e4ae84daa90d1b39bcf1d0218b82f641c5c66061f5c5fd40c6958a83eded293c59be45de572a67ee7f6a360ba5516cede0a7fedb83e0d0768000a56237371571a9a7ae5e3135da29a0cbf7975a1ac270ac8c0aba82af731dd77bb1e339b702433d1a444d0d50a5ba9177258af66da09c83f63c3e75e34f1cc50d7a704d9b3ab3d80c459ee97e0cab82e040949c9661752ef433bb6f6d1591fcf5544c6c66204008a03f12c2e5ad622cd9a8a7763a35bc39fdd67a880732d63b6cb93b2df25a9883063f9e7cdc50979a923e7676ef49ba37dbe41d64e971f20a94d4dabfa8ae4c42dd2b49720e11acf9945c9f4c00ff45234a982e2c51ae40395e301eabbb7ae62d7587a82038f73c28961e9bdfd59cf6cea0b155b6aee2e3346aeafa04b011d33d967f7eebaad227a022ec37ccf4a21b02ff2cd45ac0e83f747c05bc6e292e4019a430d217fbc7128e99aa2403c8a9ccdc039aa2bcd572269af0bc4b4d57bef4827d61d1c0cb91317fda538277587ec4b6564c7fb01cefa54ba323d68389cbc05092cebe1130bebaa7470871d1a8d74ad429da6a40baf8f15f087d506b35b03083456d5f29b01ef434fd18bf58461fdabe3288455b1bf7aa6e6e5baffe97cec5dcfe74a387afecc4a09fdf4b7a0aa03099a154e63ce8dfeab08b5a55b9a96a867a5b50bda16314559a7687ad43314e9906929d4f44fb4b6c43c2f9c91ba18af176053ba546deab4e351ad08c3d92a5b7e9827ec8034a4d81bed31dbf277e291fc8310583f4f64e2a7a0765c2b21dded07329699120dbd24d6dddbcd472f9f5dd044ec5962dbd65368564fccb0fb403623b51c8f9d1383124f3761fabf84153cfaa7c7923f850400dcc74919ee6d04e3042f44b79dfb0c58bfe9bec72c4fa95317b6524e67d0863a94bfba403ce16026f29043953944e1f32a59742767adfdceacf458265c87fd6efea7ce11d88bfabb22da86a2952701387e2bd6f00ed2d2e5baea41c8ca6062ba7d1d28b984f5ac41596b58b82d605cb2d8578208f4c3275edcc07c9185e0cb898129eeabb8eee76c1b07cf9e98f06f48d89335958f6eb1ce312ad42e0980cd388a49a58bb6508fb8e021bf515cc74d10d2f298bfa3d392dd85143317f3dfe38cd5ed3915e349e8a392c997c3421202117c9f839c20c578366b5b9e423db7f1d25545d8cf82f84592852ff15b8192fee49a83c1d1260a27b16d950d725ce06165503ee130c758038c332f8193a5c102ef76d1472921600835f3155d33b39231e9a33079777e07d0913cd502ae8dba01004dac8cd2e441a3f2633dba395c07d04b733ec7ed4df36b0051cfd329afc8ca991d37c3dfb96bf77b18aacb96b89c3ab7c3bd2fd1af7ff2c9d01935af4d12ebaa63b871b2f48c1df1ee8ccb1848abbaf2a816c973d8e37d249b5b0f347dcfee1ceed21a43aafe586addedd7c6fc97f124a084416b4ee285ac7e0859de00da10a8c62fa8357200030e75ec021c8974378ec6ec00d3430ece9eea9bf6b99bc014c64b8016bc24dedeff02356f6d606eea81534995cf56217e5f083491f5dbd49e83ceea5f12844f45bd07f999b45658dbc5fed03376abf705639f88e9cf034ea3ea6b4e537e7bd674891607674bfc6d937ff92b89f42a9d670680615cfb3f3ac34d2ade30a65bc7fc9d388ea254682cdff9943da44ca3763d48594cccd9e889ca686dc300a1a8ab1e3fa32e734cb1398bede9594ef9103e491ea3e5082178c831b09b9a5d9cf5a93e7aa535ba5154456733b5272e149a8f6ed1957892eeec2576b910e008b6181a0cd5a6e160e6e6818d0949cf576616f31c371de08817fae89da380d84c8734d16e6a15499e24e88edcb1141d8ff7945350a4fb83d9c4c0d160a0fad4ef4a9ddd8e6986aab31d4e71abcf1ed8c100fdb427e186d30b7ce3ff6f59a12fe4daee62e10888041ba7cf38fcd3af7925f1ce60a65307d389355b5139e00dd532369598e493d101c96c0cdf14b5010530a8ed0db0f010f9c1fceaa6a45197d7d646c57d7a5925b7641cde3847f2ef450ad83473a1694a4ff95ba03a169d47543d392a77c15862edd5d9b27fcdd9019758a33d95d3fe608c2397378ce6ccd01e5fb5beb173cd80fec9402437f9058a629615348f2127f58d5096c3b271e3902e39dccbede556cec5c61e8c6745552bf2c77002a3e928a29c185ee7467f84b3448b04294199e282639622e34066ed35fc413bd8bd954d7f223dc7a255f08f739e844ebd9bff5b3fd3e6e2a5c830374fba34e69a55bdf9debfe0af03da5020680735cf9165f10df5a8af1636b4f31e9bfa4f3371c4798978da809bb5e61cb09c717d2c6579b1eacb49de598fa5e6c2325fb240aeaea6f727af1c8731777a721bf6bc91b6310ce0dc68eba22c2ea229410b5b76612264321173c9523dd8bb572a395f033bdf4d406239890ac9d1a28770351c98b3e0e01d5663ba521bb0e50d28e4b1019a9fa92287b19e8ad888a6200ccbd92d87d91d5189412d967360698413273d4bc53a66c08c8bc7e96a4865b6891b26aa1655ade1b256e34ea10337ef58929a82e2ebba7fa286471dd98b0634dd526eec1a026b0879a4e639c33d2e8870257b9ba377c816516d910f31c82c96f67885953c8a8551b2eb4695b3b7a11af6b713ead35622760235aac04b1ad3bc40042ad678149c1032f3b2838fd7380270c0bae5caaa32f86a8b439e7006b0babc5d6de32484f6463ae226ab2c331f9701f263334d5b6a8447c4c14d10cf449ddfd974fbd7e7ec0f8f73ca97645f2be8427d092dc100ffb64f351f71e5bc0379fa8438554edba6db3a37c6f96d8d88fc3762157b954724ef05e47a926474d6dd7c8a7eef82bc177da246286de65e4fb627e21a728d0b2172f78bc11d01c9a822a890750971d8b56b5f9e5ef2f1083b064f649037fa0771cae4a166d8d78862c0450159df73535706319a57848bb66b130b0d8ded5999a14c828c57887473950f8af2fee686624c0153097bdef4e928569e4e8ff2a39481737ed8570f342390dcbebc817fe3a55c790747a4a32bde6a770e002351a5676f73ac0c329f343996362796e90bc819e7e4199105004363de3fe38cec64de707b83b2bf1651e8570bedeeb0c043fa40c1873d0bf31e27cc85e54a7d825a6baf58ead23045f1e8bda4f8e23607f0a0e63d1c818f272197d394f02acbe3259bce52081f1dca519cf14e4805bacf922e8300c3c49fbe0f963ecfd329b8a68cd762645ef0ccc7190074de339f02b7c2958db384caf4f426afeee54ac5c02dbfd55fe78a8e9a83244907e57bd61ba53df4acd0ee0db635afa3998569fd3103169fcea3b0f06716325919b89331357de53590669919365137f77ca1206802f51db14c11627a87ccc42070f7cc0d5bcb2b21a0c824535579e8b02cd8be30827ea4c9a0d17672589eb590e6b0045c8f46d3823102ebc08050f2d3586e23998ded35ceeb51c22358cb6c9276829baaf9906d5c4174b96d82c92784f4176d774c35208d99620ecc3865cd341a961081f9ce08345f2424ceaa45536de6724a9943bca9ac08a04b43a82e2df1b2334b9efe85eed9471e9e5b9f2fc151527d98fab35499f12cd13fe204852c4532189aabd0e58736088c2e4dfa6e2e0dd36cde1a14cede059e967369d86b71bc7a1e94010ab5b5724f9e22961dba3f319f0a15521667614baaba66f8f8255d9af79d1c0a1da278ccc7d8df6af7b3152d9ffe236b920d1d4ff238f437b3d943c37b3b86c2d01f1f48a51b8a68133ea00fc34505ec5ddbae3fb94f69bee3c56a15b088593c8f04dd57310c079c8af2b2790f6de57d0c9bb7a06deca7bd38dafcfc4521f282b4264a746be0bb2eb69007822fb28c40a2972b40635b59c13a1f2641e112207770b12a26c81a5222cec3cae0cf35106f2bf6b52436a52a1b91b90d67f6a46f1a1d364a407db6e416a3a846be7b1a88d42d7c709ed1b2119ccac125dcf98473f82293a1a792653fc1e56ffb68785bcd55821dd7e88cbb733a075686e9386f438a7eccb78ef3129894e9261e3d2bf3dab44f4c5f3aae922192f209a5b6e6bc5350d55d1301c920c76da3f40daec5195575de5275cbdcddb79a74fc9182f370f0fc0b79a640ac0dac7be94e9a4814688859ff04e425e7b24742a1194c6be155b297931975171fd92f17ce3c579f53479a6d0dcf8d52d37b16d68138858ebd22dd726ce2669345661a1c4dc5cd25ce3353fa80e45ec5a1b8bc1bc59bb65c90505148eb6b765b903bc6c95aefd047459f6e33066f2a3b306707ef1103df8eb8589c48f6bbfc010546c569bae00bd4490f78960142eb8e0112f26765140997d857bd2e6eb5b3c3792f7f99d31f38d3982970e7bd871c0b587ac506da727eddb578cdb8ab450fb27e7beeaaaa115e5f2794662f05afe38dbeaacaa521de973f532b7a18b6de5bd9366a44aef22c424497d821c98095035953896fd3d3b08a9286f44722bc49e284550599662a453e816ece7c6cddd1d84efd2477932bc8b80499be98a8ffacc0cf78aed18f97de472aee3be8c895b9e42cd8b88ab03556db061c6bd83ba5a7ce535e33c442012d5bd2a93fa4b93fb41ac63982bf5dcccd4c523a5c90a92a9457bfeabfd0ab1781e91708a91511afab629cb9a464909ebba72ef14e197542d401e26fefc293326c2f74d9df8f432838ae1c23e61b1f94a92d4c7b6d986d51ac2bcc5c64e8b72393f953d2ab46b43cdde62009d8d1f35319b0598cc8dbe85783660c5e07db4ad3047f38d3f166717a7dcbc625860e663b497b52e7e6727aa6da34f188040574bc5f2f5a6b4c59191a8d35d040340cd928c8bef922b9b4c03853907b65b6323fbc4e027311a240b8b3524cbaa431bc37377e2b0c38a736af288d36bcc517b5cbdb6ba58875b7712f0693224adf2a9a817ecb32443df4a3c8ce438ff5ee9c66db84e25faa718fd87837453419814d2e5fbe3d114fcf23b6b2c4077c9ad828beef4d70c783c2bf3ceef9ce9a92fbbdf8b032973d92b5dffd8fdbee76f459f7bfa3bfe1ad3175af7feadb6a358d4ba2e513608e4878a6e7f9e075b2e1ecea1892dce884dbf66a86d115ea1c3d1a861dc21733597fd58818c8289355f166c74066078ebe1be0828b42c89d416bb85d627f0a2907628ef84b600c1554bca128355cd3a284c8779a3c365a11d0ebfe6a2d7fcb2dfbb31a8325012140abcb35a9b6ebf4f620ceedf307435af8ae01f3a02eb371a5537aa7938bbcfef134bae77469c1f39bc5150826ab4d1d997528be15bf14f11e8fd6295bf5cb0dd208fcd6dd71678adba72a4d8d5840509c60b1eb6c3ede0e1d106372c416086a4fcf533521bc8bdd806fbdc440f4cd433d68f9a5a1c6b6fbc3a999d3032ea67bc8f059ec6e377d497695dcc98c7e30bc640e69361f99267c3a98051a5dbc412bbd7d6d198810723379fec21ea864cb282c043f5fbbed9d2555a2f6be39d349378bbc0513371019e17b3adaa18616a9a14ecd8baaf164c902f685dbc60f56e78e4685fff430ab79d81957368ca56c0e8ddca9b8df2ac155fd6f5f76205c915c2fda7091b7a0ff2fd3dfcd1db76f62e2018e3bd3e34b237af3dac9c53a12cdcee6844f301b563af7e1e7a4f3fef97c232323c11f728b1a76ce07483ca5d881e3707e51230a2a2b3af67ce0da0b9bf88a53175f43d0c9f16ba0c007177fa2b2816e26e4cb91fc24d273626e7cd0f4e6777d334e47a22d01baf7e96853417bc3f93227f8bb88ed1e226709cfd7487bf79a8168b47e8f2a5d78d4a1d1e3e0e1b04e2edf72d51e3aafc6f4d4c42db700dd204951f1a6eba590c682a5c4112c4b205e1c107e5e6471bd6203a58b6d87fbfa18db8a892109e19cdc98c35e4f9bcc70e44f1dcee571f33ed489a3a33764d3816a23373dfb9bed3f06e2877e67c908b4c0a725990d1eba787b4f47290bdc9143c9343e2d3a59d8103fe0b3580c70f2355175ba372b251e723500a26dbffb8aefbe8c8ce384eadeeeeb9a61cef9e0891efb07f58b5f020d5666297172b56d9dd4eafb6eb79403cbb3b785a312dc38be81d930aa84d9be529c2cadbfe0785857c67ff248dab5a516e96306a4f4f5655088e2a5b1efc22360369f412fa72cbd1057d9ed1537042617b04f022046d6a98380863e0e7dccf09bd4b00c395751ecb1422bcb4987d0c427d1066b4376917c47bd3fa9f0b89ef8dd9564e249eecce0e5063d08ab2f3389bf20db93d4f05f68159f79b5e3364d0e04baca619708f77160cb3a4c7ef153a367efdc80b85f0890c30f90888cde91a174438ca9d1c4c98016e3e36fc560c39c1add16292d711d99ea5f3213acc0eb3dcc596740d90c1b12c2d90accef1e7859a2b7a652f44a4f17fd3a8089f5a82013f3922cd5616a782937416c3fb8e3629b04a52e335946ed2fb6e89fcd41977524d2f00d25a2ffaa349fd68a5e51830d5fb9e320fe5b506327d84dbebf835739420ee6c3089b81f3a0d8ccf4eb06c932611f044653e5445dd0e281a8763010b360aa82e2688a62b200d09f9d4759286edba79a48536138da1d2d0e322dfb6b52b31dc6d344d74e63535635c45030eed75b89426a949208a8156218a9453a5430a71d60eb7ac5215215e5e1d30859c2d19687fec4d2758cfad0fd4ee1b01e2989e006a9113e1a7f0fee66545cc28a35718a387fe691effd1d91470cbdcf9e5835eddc8f02c7e0606242a9a4d175b1a0e4ba3fc2952479fc33c8e1561b7fb50d560bf1fc93ce680cafd6f98d97590c5c997f2e886d92b2d85377c8c2a6584a74f45ff4faa4956f66816f1b3972f3bf36648d9e6640ed94598ddab43e3975499e82300ca4bf94d0fa51b4c6800c553d40a56097a427e33098db1bcce27eb83a30b744496cef613effb53d3db6b61d4207969aa7d1252575346c3205134d6ed7c7a74500303b0e7d42379e11806e18747914db91b23c0850046b7219074c7cc2932c6614768fac45e919a9d29b351e686868ccae2e86c2f1b55cb673991f10d5ab0e971f5bcffe5528d42886f89b1bedf29696423766778e23c64ebb60c33601d06dcbc37068b4c3e187df63c591f7bf35dbe4291164bb931a9f16185e9a74402604b015324f1b459e88a1eed4a4602d2e21c00d6226acaeb57980e5f395d6f3de053cee40c299a5784e88f415e069468cccf9f426a2bca3db5a498fbb3e63f3b11df82b9fc05a211d539d7b8532ad721d2c1d998c6e1402e7ff75a742a0565f97999540d1d5ba59f3f49e95f128eb79faf1a0c2aeeda81e065bd1c2045b67328dadc185edad0ba7d78462889e545bc6162af4e5dc9e8290d050e4788c3b34b62f8a44d3bfaa211c61e579d731d98838fe7951ce9a560340be94bf0c3d5dcd3dc09ac238d52b0a631c7dcbbd73ce250f546cc8170c1b1d362e11392dcbf8084cc3cccf032cf64fb0209515230b87182106a5c31b5c42a0fc6a4f7501d83c6049548718d46df936c41cc040e0acc789303b0812267de515e6c76ddb630ee3218901aa65743ab344868f35aa3e557365c6bed29f2cb5333b9806a3ce96c05138bf9752ba91532bca670330354829d919c449a86f0f6d7742e832301f1c5bcda7e5a30013357f27755a3271544a7681ed57f4b81ee7e2c195904ae1d4ee4299b7e2f0de1da739d88089012224c00cd3d1b7f787b3b71455f4d583698766bb85fafc9de8d972b7dd8bcdc26716e60f4cc76b8ff86d35454e205ff3739ece38813b5db03c583bc971f5c218abdf0bc1700b8e2d472cb432a1ae6929e9f176b18e70f8fc1772c409afb71a92405cf6d527ee81bf69f16b747c622fe034cfc153b02bacd49b9d09b668c8c5986e523b2ae3bb98cc61d1b7aa82c59736f2ee6a7ce3adb2babb0c00da5fc5ca26c8ad970d6da6019397bbf9be9c7a6db578427bad6a01d96f56c72f807a4b123c3521e2daab987b06354a5157e13949d49839f0623fc5ab7ea9db9924820c938cad8c9f8381c5700be7878517ffa0d954ec2914aa49fdffde2d34a03bf80dc7a438ea0f77feb5b1b197ed5419755cd885d507b9acce5260647b6d695eaa90f3090027746f21032da59b2e6454676e62b1db4c35b47b09f181822e25569f672e52f55f8810691e01248de51de7331fae850af52fcd388b2f98c23516c4e88ed31589f49456ad85642e9a8fb6c6555e1ea7b218ccf70ad48ef8577bea25447636b829de2813f83355d32721200e2f869103de536f1a459f77f2ec6fcb1b1653835d40b127e889ae66671aaf71b256cb6cca82c1f3ecceb9c9f4fcdd39fd3a86a2cafa2f46152fd2543716134877993812fb70d9897ba1d7f9c6f6d6a0c2663bcede39a31fece0a002c5d3c2bce289bb7baf643d145d4a5cee955c79e6b25e9ceb576c23a06b2454d242ec8c630fdf1254fdf6dd5927d8c9d1a85839fc52729ab232e749e0bae13080f976bc6d242ab88bcce37758617a56c4bcd1cc03f2db61af7979fe391ad06890391fd1544065657b107609375545f26168346213da7d64e78b5c84fd9b5cf1af9f59d698d62dab727903c6b87291eef755e28a0f8f35397b7058531d569f8d1c584b30c982f583259f223bd0f4a54eb6c5abbeb8e953c0ec951189a787f894937daab4f0460bbf071edb990062990408168f70cba0260f80e86ad61a2c86ee9c54b9028fa908a229bc729434612f487cf02af562addf4881419f7718efd334c02153ef7ee6dbfad527e0b7c933ca012fac2733508970af106efd80c1c1dd013839865abbe37ac7d1c3dc6d88e386073b8877e61afc679fd556198881740bb4db1fdb8a22c27779d34fe2ae61c7d374693c0a55c187569d70ff2363bb98627482fbc0b60da33d8e7499727146d32dfe8026bfc1a697204715b5f39f7c1ac267d1e03109eecbb19233c0c9d749fec0fc9514cf40df05295f479d6d75da90eda4e5db5a683e37693ceb16b6fa41cf0e8fa46d87cbcbd0f4f9808938d8cd16e9eb6823b522f7e556884ec157117923f1123ec5fe4df41906fb867e23a8b1d8b2bfdfeafefcefe073621a9e61530b2ecaa99e194120dee7c76bd73315a47cfccab92046ee1da82de8a95ad78ba7baf0a42af6382225a9f09c94e54137af403ebc68ff91687d1ac6aae6a2614fbe4e2ffa0c7ab6f6e9d4e44bbc3ba50c30fdd15b42c168615c365a1808e3b3716b042db666a8866ae42401e8dd72054af7cfb30dce14a9f69fdce07e75c04d0786d83849d85ce40a02ce7c35c9fc6b2b87b8f705d91e8cd08cacbcc88d2961e9f78d7bc0c25e73d89f6ec91c603dabc5130d86e8118a098d5c684b15bad61fbec70b407496d11fe8cc7d6d41c17cd7a8a1f11702a5f6bf622462d87bcd8eb0e5a39d0144b395220c21637044b1fc8a8a27c92e20a1ad2e1038c549a9870eb6b64c77e8fd7532a8511f2382841d40f29657e501b1f27101d47a903b3aea7ad2283fe5b3f4d8c839ef360604d7532026959c76598aa034809f5437b4549d8ffb5c238c1dc000b2e15cbe95ad4a21ded1317c9e737932dfdc8ce48f9fe52b47dba849aee39491ab2351ab340c03640a440ab63dfa558ee927bab4b40595ed793b6914d818185dbdc6458b112d42812f05d779a8b623a1892074cd30a5f09f220e990a5c2d79922fbc4148bf4afd23bb18f655bbddf9c3f3ea6bd23cba03f197552711813a1cc6c4bc2c090d57597b2eec088860b69915c245cc8e6f4d04943eceea56d2c46a733971d01bebcef4cdbb899feae364338f9b9d0f7a6d6809fee031fff21753750fce49a70a2912cee5c85ad19ec1d0fc4bc28e74fc3e6bc1cb19368e92ca7caf39dfa976189a3768dfa3fbeebe611b5f2482b32f60b20a173dff9a33d51f62e672f9e139729dad53ccfd3a484c4fcd9a191c5d91346f48d414f649f7715faf87bf0e8314fc5625ce31e73b67473a1669e8ab2dd325e9a7bea81342c26df22fdde9c1c7efa522fc0ab57f6a1a6b2924f308297e1f4bb1caae37f97d0d458d93b83e046b97d51966ffa620e102295c1fbe1e928bd6f2144c5f76017365b8d63e2b9c2a3d3087603030c6238f432a454a81525d0559d897da63e18b02ec8d51e0268fb5d5cf91ca5e2aec96b0fb8b0666aeaa29b311c5311f0a57333e5e6450f38eb0aac426f54135aa54e4406ae05641d41037e7287d9032a21b75bab84b34f74eac513c4574d229e41d0155ef2012f8687ce4668096bfaeb54ae46e72bdaf1cbf3e40bdff969860fefd7d741201b637c51c9fcd70ab6172e5a0fb251de7c7e9d5be00579cfbd0d237404855410fc9f7d04cb1f57d7aa87d0afe1477c87ecfbc501c96da225b623af63149635c968ea4be28686a24525cfe24d04c96a54fb72f03ee47847b7990a1b129f2fd29c0cce5a6b43308a60b6d51b3076b322c26d265e973699530be2fca0334233e0d91c6ad3bddb8bad411c20c3f1e680f0c737d74743f29cf96c6c18fbca2e5b6adb0b5449912d36be12ed78e75d3850baec5244fcc5f19c9fa5badd1b19ada139a0830732105f0555bf947d90f3c00ab4c343c97a0b734b0be86ec62d11b2e08ca7495e0c2bf2d6b1520c3e45161e6a27ef5e093debbbdfb28deeef2a95ec79bec4bb6e2de77a27f2097e263025d49d7009c1fe78892a75654029a7f9a1cf60d983cb070e31f062b3548fd795984ec16943cb234df764427f41f8a7c7ccddf156ca3db8243dc12eeeb534776e0254d2189f05c5f926971d39229b94633ba303d6976397461420b56899e329ea604892db38edb58c8be6c963557f9da026d66977718952d3040d6257f569e9d88c56224c804a69081a75b8c0633c6d707b225bcdaf3d425361ca4733c66e80a3a8cdb22030fd68e5c32379506bb158ae6033e08a210bbbcdd5da6cbfd0186de886fa15ce5eaf4ff2642c380616cf97195a605fe593f5471dc82b13c97431e037c12fe8f98988138e67ff20415b0c68227b00632365446a5512234f1fb4690a2b2c2532305ad7ce10cf4472f3530a72e053401afb449e8519ccedd43eaa399497e23d0974c42da586c2e4b15f687e0e69fec9b4f9a1b5a2f1b2412bab909cbc5eddde127146488fa233b7a5bab7ba5c242ef7df6eb575205fb41c69316d65cae39efc5900755d4583313e100f7bd65be95b3e7900632595026eed1de5d9983dcca72b56464522b8074824e522b34c2adef946f1b7f21f7bf0127829dbd111f09741fbf44bbb6f69bd4578e80611ece59060bdde0737d67c7c14883acc20edbd95cb5c91f3124f390e4b1c0c24b75d45d6a882e3026c3489eef1f64c4e49880226213046cb0b68778a20cd30c7b504bc5fa0e1d7be5ee1c39cf1e708eb900c4b1fcf3b423797b704f2bbd1b1af7479b316001aee035278b48e68d8b0c6be21024261665b1791131f4ed0cefcd115a0ea3504222afd76d14a9f67fa91df8a0fc3eb31975bea9d42a2712f290413d4813155c7a4b879930f79d0b63c1251757a3aba09813d7021af4b8cf10102b89bbe3051d324cdec75a375af72413705567e7b09e7963ef6f44ae02de88e1d5e8d6e2a491fa6a153f4fa54c188e96ecfcf81d08515b414f255f3375f90bbbf8bf2eeb08e1e49a74b7928dcb32617fbca7fc539fcccc50eb211c3fdb352a0809d8f731687474e443775fa7942cd0c19b226f1d3328465b2cf3adfe52b10d58e0fffbdf84ea4dab9c653831ac70fa40c62f56bafd13b03f0cd2f4c87f7ff87513604d1827add814c56a9648244a379480a712792d8ae655add69cb8a365eb59524f40d2b5cbf9fb7c288815a0f140a87ea44ff883acdb6c7ac09add354f2d6768006f8304a671fd1b2b6314f9332eecefa8543882e5e4ee34118f477a2fa6bde32ad9df9e9af9658935b8cfe428f246a91b3f46bf83bd9597954a64048fe6e91f1355904194001471e65b9a3e21cc8572b8758b2d51aa8548c2eb7d916d8aa53155460da8cef0b407e3e3205736aead523dc3b1b3862a180a97353795d31705690a27995b6acba85bdcd5d13fcf37b7c5de2f70826d90da6ac8066f9accefe9a478e2b8bafd73ec290a1d0a43c8c6dcec59be3f61ea11dcf34b599f7ac6e896b565230b02f19e0443af5eede4f127216bc77e35d16bf30d88bf1b5cd85c6443dad7e5b8afb64cd2668532880acf9530aa45d153fa7582aec079d719726ae0c2df6af71f68a95a17f274db9697f5c481ed6dc7b78b6b07da647011049667c214fadfec900137c400b314e1d0178c7397a63348fe485908456622d184d80a08be001e9a6b9e4dfcdd101ed124aa1da74a6063e318f32c35757397e3cb76f179a47416fcd317abc705d9c6dce773995c36acae03cd733ea7d3eb61a31cfd9316dfa6b9b917d36ec1fc8ef983a237098a10102536b54ff6dbd379b81b48e39fcbb3e7e3a5b92d391a0ce29d5293090da6fc3bcd155125b31e5e928a0243f61473ba22651607711a4320f088110016a58b99034e849430c09ea00dbaf602fe0619bcd25b381f9ee8c0155d9af3a0d2bbaebf7caf38b1b95fdb4948f37cfbabeec9bd5b1b3a416b804f40bbad318a225939e38e6fc97e4a764f660bb8f7c2d098dad3854342a0f779d890aae55aa835bc1e7db971276fa55a06afad0ccfe52b57be1af5056945dcefce3e944b3cb0c3d4f74317be124812898d1b52755613565fdddc291e55570db5667a1a3b39e1b4d68ea90274522c9f7884c5732f0810b025791f81ea60dcc3ba6a102cbf4909e538a5db55e41563ffa8b163c8d8843b83295e2dcff7967a51a27949af8fbabbe2a2d3c17653cdd51da2e41b6fefbc1dbf93cbda0f0de2dc2a6f9b3e34308b8dc18f18752f5e92a3baa3d3f2f5a7b52529607ce8ecbe2c8bdea5c556215137cdac6981d3cac62e2fb98a04a9c755f53ac3a34a0ed30dc4a9a156ef7ed4c14f75254712abc9b4c3f729e247e8f9c166d941c5a89bbab2752459567d70c516dd9c2bf68f680ac89a374a19e37010715aff891335190061d6fd62fdf50a0a189293a159e06b9e28b418c3268012fe5ba550b8ea16eac1ee2e49419e20fd238af944e83de0c32d9074edf709ef4a7d0dd31db4542fa0dbff8211e3396afac424c01b7df3789072151df9cb9816d328b3d6f6b52a240fc29e123bac712bca733395c5149ccb37e116a8d232a7df79e470f6e996b6d6685e9d021738550691fc23e2021573595cfcbc69ba033ca7a6c02d44458d994b47bdc023a3e768c05cbc1f528ed6e69253624e3b229626a7182fc15635337c44a86c45e373861651b322d054cbbffef101e07437063c0bb915473f727a80dd7d559e83eeb3e08ca5e183a5218fadb2bcf9dc85d73d60bd16979a28ad33c04164bdcd2baf7beea8b6994b87d81526c37aa0cd22c7bc961253ef9da286e294dac6dc9e51c34fca821b4fd4a76463e038baab4e979cc3e55f9e5a95a2681d93176ce6ffb8fe7abaf70f4d535cf6de9dca906bbb977bf8abd1a82b1fcd5dcb5db636157851fcdb11117a2120cba67287c196da8bca9bc9c4c5587a1986b0dfb0ed74eb67249bad84a57e37c816ddba2ac767d6755a1bc01d53779bac1de5855639d452eb365c34449970f1ef28fafeb328890bb7cf60d5342fe2204d3be7353381535fb0dc34f3cebe7dd1c28355ef00ef453c7f01fe55479240de2844da94fd1749c1630c2f1f0a9e688f08a5a433f7b5ed0aee24f16250600fe49eb57a8acd71702f607042eab1786ae4fe2477e187f8591ef13b97b217bc56b2900f8ee9f5c4e0696662349182bcce234952fa51bb4ca763a5ac467c614bd752f6a12bb09051610ce1fb60a41d7f4d0d19b43341aeb9d0308cfdcd0d9b4560635b7f58d4362ff3a946b7195eb354ca4ed808778af17c40a49d4bf78de0ecde35abb016208c84bab85da0ae9ac9cc32b77563a35505c59b07b1eaeaacdc21cc0291d093966bf210f997ac09e72402d06f313ac41e20c6b958948324d22ef02a5af6da6ffad185b9e026b9fc1406fb7ce195cfa0a77cfe67fa91cc396d5466f1a618bc5ecff97aa6eaacf13cc3d8876988dab0921eb8dfa9c02222818db1fa9e108e53d193ed2aebca95c975019f1f74ff4d2872670a3076959d9b38954f4450f302c4e98982cea3010dc6c99c7365a52f7b441b4ce5b90066fb2fad28ba04f321422776222cdbf8d9d6679269b2537d4960cd1f4235239f880a3b88014a34657fbef9f5ffa5da1937f39eed7dc76feba27109d1599de03d307a288cf24dcd280c0193b4ad4b4f4d2edeb1e146f5d0359ed25edac911b00d1e3af67170799d4e3cf5172bb9b05f750ef65a2b84cfc8e0281829d33e1481c9321e54f8dab2ad539ac6d208394b759b712c983204760f83e7fea477b566f6f66350a7f9ca29a55a71e19816feaf1dbd3b1d6b08b7096d85d4d4debc19f4fbbf2db27c12a4b3c87ce15829d9bc729183938dc29547946a2ae3f7e4dae6aeee13a8d145a9f193f7a26d76e33d65d0eebefe72bed3b483493398496fa87b0ed1735f20f7ee1ad5d13d1d25ea52cf2bdf1a12f90fc4fd7b43a17a79961fbc242a9aa1739c196055f4efcc1568ec92d191ea245c3b072816c241659293b025fba75279d032b8662866635012d0a6c0beabcaf52231d9f7bfebc9e92ee226ac44bc66d1395dd90f1616b676900b638d355fec2638336031e22e2c73c27e93681a0d1524f5fb366279d4abeb179867b3096950a0d72d9979638380809af3c8ac751d191b6e9854c6cd7d0d8e57df755708d89f0b9e9bbd1ceb7101b3b0718eb17622145ef655f1b377ca90b7f595bf5d3712378e368cd4925a94ac2801a3ce8860e2e7406c2ba0bfac2e01d3fce51d48e49ba992d75a1175eeca28b3aceeb1d217d0ce4567da68f771c803b220124f7411b241ad7811d0fb12165d04ad775e66ba2feb32a4470578bee34b42750c02d67cc9899269e9ffba1256a2f831ac00f4355e9199e5fe6e7d7a26b4a8609b1440c29cd4ab166bf4f52cc89a1d033a604ec3271cdda599e5e13fe8c218aae88449e343d2133f1b28eb04e112c5c744ebfc3f350ee36ae3710ce240c731a912519689d6ea4dd244ed0a3d852f270baea657573b68af3d1f2f71292e36913517e5366ddbe985d5607116890fa8ec418a1886c7d8a00e618999313bdf2fd2204b60b6bf6a0af05dd4a55777c9c7c40500ea864b84eff1ffd3e6277c5b446a12e98c3cda6ebe440d922ca0204cbc5599beff120726b453e0ca56e4a2150545262128b3b2750052df71a07543567b5c4e1230f8797058d7e82228cc8b2e04c41bb92222ee17e557d788c4cc9cb268c1c2e64c9634539a3d10a64f68375184a6cb762c9ba0d982b7aba44b851d82b1545fcb952987ec0d96b614cb08f509d6ad268bd9310fd39fcf524170ed3967b915bd18866a9df06c620fb66af9219a2d642dec9d4dbe0893d7c990f9b9300faca8d886fd49511e5cb2c3f2a0e078e1ea09a070335652971cf79f8a9202399dfc8d16f5a2c58c7d2a30e99869badfebaec9fd48849a69c78f2fc2768047bd4c7ef9562894eda45213164cae57c5579617d98a02bede112868a20fd26cdbab62f6243ec8bf63a67c28a499de6b21fa36318de2144844070f163bc880f6898348b829cde92f3c4b0de469bcd0cf1e9db00f7ab40cd140bbd9366b2a542a1feaa0fc68e5feb6e08f6c00114bd44796d2c75ab6003ab6cfea2eabbd7046e1f3835b5e36c22230dd511a61c0ec2b54743d1c5f5125e0fbb6151968a52c4e5bc91ab23ef6e87792f4594bbe3fdf75b69ea6a30febc56e37d12e6b62c4415f86d466c2af3172151b5d34c40a5a4e3f9c3f2b233793390168eec2b9e40a9325d3532f403be330e243fed1dd1b95b96e263c4578ef3e71c8b7d24fd910be7d27d39de0c406ca7fab51d5a9eb4a9481dc625085498292e3d5b677ae48e677b402b3ec1d3dd462cc69bed857efa713a14144a815ce98190f953c79884bae8b0a8909b1b86431c0e758abee7163ce2f34ce47b69aa4c0db973f7225b88c4fe11d02a2c0d8519985ea3f47c4dba956f267b5f6ecf9608043ee4d2b2e402e9af76e27924f6dcacdcd382f12d0b66a51a5afa5962489640c5c691535477d7bdc8a3e88d9e70ad60b67c5e9f4cc8e9cc9b3348c6f2de2a2c36ab435c4412960110696f7b7e17f02955d7a0bf9c3795dad3b71ad3db067913d60e78434dbaf35b3969c3c4df54ef8497c30234b8ea19a763a275216742fd39db3984662b068b1ad332ac9d7a51536ef82bba91f06b1e8083f7b4b8166f5a64af578c0ed71a1383978c269a023f4fd5c76250b13e3b3678c1c8c037996e660288540245d76b8cab8d41641d1773bfc50254f247bf4c36dc906c222e6c5b3b217086dde34c05710fdbbc56832523f5fa78addc381b762130b02c1c831e2d05becd521116b3e6999e55180be637a5fb00f3c16aee50a5f8dc877f0abdccdcb7a74bfc920de8b24e46ae683f2f9bc95d9263a1daf145a47852777b74fb6423fa94b4409ffd2886714d7d9ab736772ed955284b4d9e1b58c3549485a68f8f477e7d5aef23a87061002710b994bca5b8ea5d8e67c4c33269d5df01a406a3ce456bc854e1c1d37d312a65e82cbfb86521851089108b93f2f666cb65d8d2c5279ba7653748479425ab60a8c3a8e390405865680f1b4372510869b754da87c62e940a76a8202cc063561c221a829f6232206e63d7596846b9a4f751e7a86c4628e0203b34cf4ff694e6c9ae0436ab338bdace575859db4403e77a0cc51084ce0769f042d955ab5505d3013b640ed0c7fd51f776e7098c6be9d156960a565528539bba82d883b1770defcbe6d26a0de1518bab81f4eb10469fbcf2bf92e8325fb74e5a85dd10e594073dd040f3247c2337bb8919f421f68b7668cb44613ad1cd8f36424fdc1af4745d7bd68b839ff7927d124642619f20ee859c96ff61906ef643fe6bd534a90405ec28144ca6a8eba6c595c566647b44991bb0f590ad63b99750add34a1cb7ad4b328f37a9efa8a0611b21cbeb08882b0426d825a3b305c603b280930912561edc368f2d8f20cd93d5e42203eef5c14ac6e66201e41db0e96a4a44b688555af935e3dddc4fde18c9d4cafc4d9b553c5002632f5b47e34b1c711c895db712b2c20daea8891698a69d85df5005e602999dc536dfd9032ea4839e182f9205ec8e333d8960927590f507bc11554b283a0fc8107b337261d775c7f70778262f04a006c6cb0d93764365fd428f2d102d30a97d5e0b1cd7a7cf432c075c9b8d02953e568e165ef01009fb58d81e5360a37d3e1c4a3c3dcaa657e22b90d46c01c67c52ad37ba0be98cde4c1a8971531db9f136892393478acc2f8cf57a824fb68ebb1229e39727890a60da98959a6ddfcbac5c4365432c7e8617fbdf3758fbb26863b2db1f054626eb527af728e1ff78149c3f31c9c7e3adda50e148bea2a8b3fe673400dd8b9ce7761e609a5296e3d5a45d52c4d2401c98a2a25747666c8f0f6a3d538d69f58d785da7d7a50114cb53896ee8e2a0dfb8aae7e6cc40654d92097939754d96c7694672ed36bb1d994cc90309784e5bce032a20150e77d26e147a2f5351d152853dcdd9ba72720f57b3fa581a3a585509d66045a0dd2d23523ee0bc7bd6e12a22146b28055a31a4808cfc35bf9ead209ee410da4cd58a53e542995c889d4863c39b4e801bfb2558830d1a6a2c98d7b5b308700f5778d8a90c1932092fbc9cd29b32657be63fc2fab717e1ee28d2b3c6a50a5e400f758bd82cd2a70ff48601d9540f5dd98c3bc9452679001f511fee70c04100e6f3ff9048df3a40b6f36511d14969ff4caf123996c8b02526468ee68e8d61853899a7738e9e0ce6fc9bd24c84f2f78e941041618b0321e835573c4f04c2e207ed5dbc0da2b43c185dd30627c29c30193ab45e3dea608c653790ecd97674e06f0bc00dde1dec2259e4a0239004e367a5b8d8bfdf2f4288d2068de81e0f146bb9f2dd25ce9c214e284984687993cddf96267e4f64d973113fb4dbcc6825e252777d4f383432e13c34bbb67eaaa8ddb1bb1028bba1c73998e9df3d5ccb1fb9218f52a78772da4cd7ddd14208efaef64eaadca979185bdf163dee010640e7660d6db2302c41f9bcfcd0c4933c10fc9e0ea5c779da4c9ed1f8b4a64c0e82b88eefd11a5f308defe431669c77ddb254612e4053f83e67b677a7f7b98fcf7cf53309121ce4ba2e0f50f654b7c9f7c4987d553478086ddf8611ccfca4fb4e7bee276acd0aea1a8b64606f8072a76122627526c4d8f6d1ee2adb4e1d902ab7b6fe042eefed13fffabb8ea570f6606b555d93665ffc50cbe5d58a707fd8d215f9016333857f770e807f131967d74c6a0de9d5a411b804e7e8b6f00ea5facf7071c94fe56b05cdf239b43b4c02b2a0ef09c5bddb65e4b575c1c7a9536d01177697001e6f7a759693ffcb2d2079fbdc3842dd6fe80c6ec4d83f6831a1c7a134e888a73c979d7c714819468f9ccbe58d7417f8b7083d3f211aa3c8ca7878ab9e4a7521945f551e4dbc2ee0a1e3b17afbe2e8666c770f8f97088389d8f9836d2abadf22c177be44f18db650cf3df3261bfd2a411172d6564bb3f73691bafd1293b37d4facb183575a634ad3c098c42b6a7916bb6955a0945c103a0231050468924b485048b0e124e14d0b86cdfbf4ae450685ac4eeabc9806b1eedd196a26940acb59d4a77b949fb249990f6243ea86433c2945b681d4348f7e47870ed33b8056ed8909b18aab4db0bded3e00627abd11606408348315b9ec600a0ab4c92eaaa28a1e521c9d6c97a6c7f493e5bb4965651aaf82f911aa4ffe823c87a743bd3d3ce2849f23e5bd16f86913e619588b486e7f0ac9070af718aadb1417f20f6ecc4e2667255bd7361bbfe1794ae1b3afc4fcd1801b823192b373dfe608fd1e25551445453a37bbd95a53871ca324707fe8166618d5ce28a7c02abf8da4fcf69a45b35a00ec951f28b5f64fa914fa50e0f0cb350f1bcf5956d7448ac7dabc6c012e1e0e79347b5109b6e007c741eaad381f42c8ec528da1a8e41987dcc1179e816fb767daf9e644ec40585cd281d4cd9ded984eb4d9665be79d638e8d101b02167e1da2c62614e5230fd4c247cf603644fe11a54a2d7537ad0ac447f80ce90ededf5b82d7ec6356a5b87cf6ae626c0a87b4d2dd821936ca8c5233dd45560c26fea5575ba3f14fccf057c0698b050909ad680a74131091911de11a8c84149257c0574a44ce67d29582a25e51479a9194471d9c8dc501272314566ca7e7c4f503391caa2c2b2d5f3d2039eec616290c802e44f5df624f0b224385f5e4c8faa579606bcdbfc73a897a12a3954b215c07a797114d241cf3b6a27ffcc19c5ce12a9c69ccb5c18cc1c6b168ba11c4770c23e80022a074888fe95a9b830565e9f989fc8619a09f7afb2f71d61a0a1a571325d71de4cde3c314bd361ad070cf82c7986a7632056839479c0be5f1c1f58bface716f9309ff1332f51eebed1231322c37beb0273354b6d6e2448049788e873bc145a60f013b331715ae8455825355db3c8461d332045623e5baefddb4496856a2a0755abc8446d9a6d573bc35f1cf75c59ef6cfcb1e178e7740a8ac98c0ac0f90ffe0076717747395b567ec114fa40e7de26ef7429aa9912d0ac35a336f6a7375cfa83c9c6918d327e7678e7743c54cf9b0b8476559948ae5d9e744cf1bbbf5a86759460841e18614b13047d4d0adefb28e5b4f3e4cbbab635c9923172b240c330d3fee48c9d11d75a88f3336797bacf3d7433d1ba7a7c19b776b8565e7f102d54fd101725682c74add6141b518bc9083abec5948eb4090469cb8d3a1b2db381d068d7f38b355c4e9486a7327082b986058c70978085f3d53560eb948ebc04da14273b58a60dcf7fb11a653b3f8e75a6495383c057c304328250d16dd16fc569fc9941ef27c9ab7ab47e75760a756beb3c759d5806e6888103e783bd09d3c6f66f06c4ea3ceb95f62ae7491f31b73d88d82e9154cc3722a312dd1ab6fdad376875f354781cbb8e86256da404f55cb6d07d7af63046996173f12a02f69267fe789aafa39fc1edefa9c360bc0b2eac4c27568d3138af9dbfbbcd7d84a87e38740c5b22c4a6d427aba7212cd0be3c35cd034198d69421a27e20cac28bd9efef9492e76d09ad1d32e9c8a654a77f971745605f21b640ea0d7ce4ad9629395eedffe394e21725f2c1eddcde76a50afb66cb2d84883d1ce63821ff4b38ef7fdf94c1798129c2b7d59f13659ab2ca331ceb48ec35444ccfe524ba3894f049be4ecba4f231c4755fd0e6d5ebf59a05d013057d71af1090c31ab829bab3c3676702dced6b82c7d918876eaa3f6d834759b1d9ebbc5d9f0a5de3de5a17367a2422cb4f37d604c88897981ee4ff50a654a6c4436fedb1dbcfa8c566ba902377075c05447b97beb1372cc58da276a48cae94bfb1b2db38ee8c32504d308ba77bcab9cc518d61db6909045dc7ce8ea2ac0d4ada95b7a24aeed90aa2a3f07911db1b6dcbd9bc07828af62c3ea39aa4b092555cf44587e2588542f7c5e507881a4176f155ea2afdeec139e3fabc76dfb88c10585f685eecc168056e6c6707d20cec1581fcfc935de1c04e485a10ef2f6156139a99f02b68fa06b07512df369e309d59e0af41ced232d99857a71e149240b45090db6d85e85932840c4138c21d6685f035497a3a4e667bffbf3e7754cb74e42fe01a35c15abf07bfc5fb411864020b8f60ff84c6248e67c62950976f96ca71153d556895a3368fc777c3e992eaad63e3d318eb5adea98c391445330f4979f5521ebd036531d2a570290b8bf3b0a1ebe76553ec14bf0de70dbbbff08d72adfd342d4a21f1fc66b25d34e40a5e06caece99f14af3129e8c2103b841131e28b2ba079842319778f49b67b764a96991b28c3be1fabd89510f412d8b58ce9ca4addabf25dc69e18ff892d28d672e45031f38179b8b1c5d390457c2ce496678e0df0108e3b25a4022caa2be2cfc55d778b27e0d10ce9d467a59c6031133d9da4c55a2cfd363c80501c75a67c8c80e14ace38c1c0870422daeaf398caaac538ff4cd95db35fd3eeb5ca6e49e72f8df40c2b8e9993c48bdcee6930f1539f2fb41091414c682107c65e6411a43f20e94cec571211f74873cfe46b0f04d8a8705500b8a7464db65a30a422e5926c4812b92399b1a3bf383f14e4f1dcb33b0a906a857bbb0fe076947685aeff6e64de83a175f5e49abcc4d13ca1db4107613126e8284c086c9a7246d7280784cb9d02ceb2efe943f0e18b338ff96f7e54ec497da1d437f218e07b0fe588ff59e4043ac7d4ddc77f8c9c7f5030f0d58e376ce40eadca14352841d0795ad1124cbeab4faa2662935eec17a83f71b645bf8a4f111717cece79a7f3c7d2691f50096ac3234661596977804e684dcda00b549df1607a37a1829d8ddd4451c333079c4c480c2aa6003594fb950c67301b8615d7feda521826e50275b4f0e3786553f8e74a0a74fdda73d9b86a718d3e7367c8f43c2c7b9f0da6f8248c741fb918eb0dc1376d667ead031af048c2824d5619cb198317c08775f18f2830017500924a0d24dabc695156d7722a67c174a1da0cc815bd8ba1721b531e5a48b40634bae0ad7ccc08ad8873e1c603203b9b3b5065718c736d446f399686fbfdcae89ad5b09fe4ca0d8e1da3b29c201999f0da32e64111c8c6fe6d6b6463d2db91b122ceefbd4ab0ebeef172db17ae8538c23c6f7ac50df37de10933e692172c6e3f9cdc622a6b3d1d44185e24c1824d0b5ec66f82f4951eb6fafd0a1a5bc980d49283df04966287f6d4d38dd5d394f027a7cb63ad09b92442fa480cc9bb85624a76231495367fc5eabb6a0c06d5814603929667907b3fd7cb57919cc65826075842a4290e5d830434ccebea5d7c5a6186c49005883f0716b7dd984e81cce207f215484bedc24fb79d352a006c39fcbf846b21c6667c1c2760da30b17881ca97f75b063c7abf51ba2fc2324cec8e4253ddb23aff89df98cea3fbfd66ce9a28b3180f9c827328f77f53fc6ce1bc31ac35cfdc1ad07d59202c78a9cb79b83d0bcc77948b06d0423a9abe042bdfdd349a09911bcadd3f743db57bfebca9468aa47f9612491ed23f03d40303f9e98f7ac47b637b6dd335c390f2f96add255d51fbbb46d56786d053b72439cf43b1215262a87d35623ee2ab7775cf321af075ed06aa337b1dac5c6b4b27148857e7562f3a9d4633c44870fbbe19583add2067c396dca15c1335226df333ac6d8650ae1ae0f6f56a6d77bf6150a8434827e65413aa9c482d4a51ff990093150bfef71cd30f285b59ca3fb19c9477cbe06de6a831467c6395d0965e46cbcad04c99d115dd9041254eeb239226683dc96bd08ed5cd515e49af3741b1b6809f9fbfd9fa4e544014b091abde2e34ca57eae4d12e9d25de21f532f392d31ee5bacd75872a1fea7d5b44146dac6024983025c6d390221446005d5878e8da89f9c326a5f490a335971ce3ef86ec4b882a48e868eed5132793b3cbb5423fc09062d1cd599fc48825465217420c1b8c873f81f6f1fc572547b88e31d80ca46d37f59434620fc61f1a7ddf0ce2be68d2721720f612c2f1f19e170754e73073646dc8ba62ed7b329f777d550edfbbf5456ceadbe821c66f03adfa4e24ef80e40eeda97635fb79f51bc51d78f82a87efede7cf3a1daf07db36022922ce27f3283ca192ea238eb96518a6b2ec19c7afef428c403b172f47851f203dbc48658db3b08fa0c46fef24f088cc97e6ef721b1890d9e5c5eaae426e5896be82b4c293dd21ca8bf3d204061fb1afeffd31102c0f62d892c4bda2cf6943166e5977c25b5db88dbaa172fbeb20e645b696c3c97d43908c79a889e85aef269e519d49ba2b24e7a6fefecbccec829717c50a77aae16672efc85be3f222c3cc43ec929b3df9a2acdcc035e93a5d6661b8309054d8947e611e0505ed41e30e97181b4b170a5d2b4fcef6a710521377184afc1247f14ec67d11efeab9374091df2071158074459e018b0a57dda5e0d8942adcfdc5b7d0f48b9d44aa6032a63f9e925cacacbe7ca3c09975b32364864953c53eb6c67e912b1b3a69bf712249c0a5931fbfa1de4eaf3e13656328bcee027cf65685d9306a1b6c78e99fa9a9dc702d811836513e744a220fb1d07ec8e799900c40e9b360270803dce2185a54be1cfdeafd9c464e136bb19fa0b6e43252ddcc227d3170f600ad24348ecdcc8322fe5a52b18c3c176ecf6adca8ebde53f78cca94f5d58842c30dd827161ab4b6eed1c61b733c26250930b95fee6729bfbbb76ec939b702b637d93a631f9f3a10af791efdc6e2d3396c58137a14772ccc4f1cdedff63d99ee182f47046fc0a6ef104e0e547e4cce74ae946285eb14790a77916c46a10e83dfedda598a97dd3d4ee1e1349e71a2dc33ec2f89f480fc92176f2a9da6553c2a282d0be25f13892ded5b6c5af000a5145f8f7826940b3395a3f58d6e3f046ab66980ff0a4a7b21303326fc6994db85908c996a860f4f491bc48d470311e52ef5b5898d6a64a8333175877ef33449785fbaba903b382abe684a2e54f5d02505bbcb174588011211e51a89fb0b26df58271585dd4ace9df9496040df518d8b28e82ee1823c921331f9d00771e1382ada64044451ff6ce9d81293f74c727f192aeee7c0c5c40821be454d8ef2283bcaadda33e5919fabb32bc039c197b6171606b26038e7dc7b755b82a6eee8a3b88d9cb6b09a1d32138e353af2cd8493f2942c9851aaa6596534f3b2ae50ff682346e7ad0cf6ad004a4915be28522763221e7dff07fa58405ee8b279280c42a52fddee74395f49a3f53e85cf78c10540c61e937dc0cbd22d6a0e325ebf35e2522c70dcff9c3dc57d8dc10e721f46923e169ef860a4c9d18cfe198d7a2bb47d56f6c6a464a39450c72ff7c75b2023b92cf7cd23651fed6fbed0534900cd8897bd09fd1ec0ae5cea38a042fb76b66ccd2190d873e65e937c405c8f76b59aa67ad9090e05324df69d9bdf687032045d638ebddfaef6b414b05f65347b206df24e86cfc58944a6cc751ddfeab55c56138807548c7426fce453ff4d96e45dd58a68c899589958d54fdd7cc489f13facc24405134bc12cfc7fc322e50110ff994a35ab5426e6c9ccb1101d4fbf9507a0d4206287a91d47344b997f0890ffba1df85f78430ba57afcf53ae925e5bdf892d32f716271b9f7b55078d5bd481d1f4e781e570b1e77a85ad795256edc8c564e438c19fff209a8749c614ad463ed5125177bf2e2df245d63fc6bec7f7e0533a261972e4b7c5adb3d8ba0207aee1f9db5db99fd233626983ae329e1cf4e9cfaf6cc08dacdc15916fda3da5c2909f7d464187dbc2a844bdd73abc5a29495f1032d6e26aa23fc052ddeee71d411bb50be7dfe648f4cdfc8206dc17f03e1cf65816a11d9493aa1263f2fe7b529f36ec86653745f823f153030cd3432fd7319495519ed00536a223362e8678001ce83e3f37873c62abcebec02120d7e366b17d2e038d4a0af5c0a0b92c9a60ad1faaa250ae489a6a1780d5bbfe0b9e3523a4b120d0a88068807981d7092726d08095dcfffb60b32d07c666ab561700c24cd6f667b7d9db6686fcf0d17c930785225b880264026041b99e6038e5f6857d393c45a348c72fbbcec8348784b64afd095c4301b880aacfd0fb2b8e460c189bd7f74bccf06d95306f515037f31b1a3f3852c2561e3cd1c6dd2959ece72659897328fbfee0a5de19c2f8adae5b176baefa69e5ca8fb2f7c88cd20d349dd5b581895dd9e7efbd498fbd7da33d00ebdb2e3933ddda02eff7bd7aa91d23f905c4e08c9219cc71527655f99c52f20dc7a7df1147350a00323429e53335cb70c7f606f7dfc638bf428409b1e397309b72ed57a3d55283ba0785161f5f1a2e1e53f2b9ffd3fa79032d407927dc198c4eb47fc325f0048d9696c8711be5ffabd236a0719a365b1785a45215e854ca8a704ae07a0561f93486a89bcf95594ea23eef8a75ecbc176ce8c547f8b745d72ec8565569a36d9d8a4670f44348c02ee343a1475127727383fd8c1181e110778922e76e85fb89d5f94f3ca02f9cbeac700c5834e26a8c455771b3f55ca92c16e1be83147bfcc0b3b02a2c6e5331fbbd0c30e05aba11802e98ec1017d0874650e797f5d9494346cb97db411ece848ebbd8c96cbcf2eb034dba6ac1f8f033d754b52920650d9403da034d983154159260681ad2c6c088ac41bb7cad944561fd7336288912a3fc7c5765f99c5f41673db03925d253f0e76be9c86b37369d4397d0c4d9668b7a2eebcc074f38d717880107a8c1a3aea66c479a14fd9ebc28e5569e7212af69f3d6f5f4235ef692014596bb903d4f4cdb80162f3ea14ec6b67f16fffeaa932e9f5d10fab80cc3a8c40784d6d3c5640162ef6e442c0d62ddd0373366e843366234ccf057fe7293ba5e9f512d21984595a981e272f82b5e0fb705913ce79e46a12de04f9723a76687baa455a7c1e424e1bf90fdff6645c0d52832e0de7841bccf8d454189c06af0f136c84b047b12221d976659950a5da85244ac6e514bc0bcb4ca07bd1c4b66641ff93c83d3521ea5e1506892a9fa8414e253ba3fa27187e198392761bae82463dcef6e8157d763041d262ad9b95717afdaaa9d9a8ebe7bbe0a07510ce9da4444a77f91cc716d1d30eb554c203c0ed2c936a5ce3e3d18bde62c9a77127fea466158267a798e7ff0e1f5940fbd1577399f474ab437a6188cb9d1b0058a8590b91855c0a78927a21dde48787aa005fd5f50acae8849e328d000e55ca5955163bae03a394590fa5102f58976393f33521a3296e583e052d92e864d2bb09ffa9ef7606cba891cabc74fe43a6d9cbc21ce804ca536ca845c6250cd1fbc6fb4a04e0fbca2e65628452981290863abfd06fd6f5bc51b2c2d923100008e6f8191a3c861005fcfddc6452efa9d21092a75e6047ccc612ee82266399927ac43aec7278871cc14e3addabd46099e8f031b1720aec2c0a1054d13afbc4493114282ea6ac6ede0f833636a8bbe6ae0390815174944aeeca3b4a8519ab9409b39e7d7db5f2bb68efd0041efcf19cfed7ecaeb2285dd7fb9415cad59ab0af433de06af5f59dbbf779702f6ae2654298e3ece7f7bb6d38b52f6ed7b9a76020aa4ebc7cc193ca36f599a0ffd5720cdc25d9454465779b901bfac163b8548af98560811b3e786c36ecfb3cf63c3afed004e5229787c8fefbe3ce8cabedb57a0c13edceba5630632ee6447fcdcbc8a085e54d120d7c99e56173e36d0fb4114ac3fd694a3ba0638b9146d5e07cfd36b4167ad4539d34545f139ded89deed440f567450ec4546d366f718dbdaf721fb61c148c48020ab9144e19a1c66d71ddb287173b6dcb96917e4bdeb0190923865582e7cb2f0e8a46726b710359a4ddec46cd72bb6eaf6ca76b72e166eca2b3d96da19eeeca46a404eaded524e57b1c397246395dbba1d3f1f2f8f04c11c16aa3de51520799fca8425c4b413b143bf543d6d681d4fb59a590404c449d36d54d299a9c107b06c58531fb0d19a6f233d781cc57b47154e36e2ff88d3bfcd33d960ef2be09aedb0521167ba932eedee1041a1df2a4aad83fb32100d80a5ec7aebade849a2d6cbe889452149a5383ebe4e99346c8e171f0f5d1bc6f5168b2a582bf9f884a5032198f76fe347f060c8dde617bdd2444a8242f10d73acf21ac5e29ea786c62239bcddf9b3ee940e121d4614104d9d9e8d335dc2ac1df02121d108e40ac5bfa6272e5d9c02dbea03fc946815954809bc147af787f9e5657166cdf8cdc491698bd82f1ac65e80e22476a8321eea80ec8520c2cbee95c5cc8e5f7bfb8407f8c639d2012d34ac1661b55ef15da0c6c165319f13ee68329c28d5fdf375bb8a7865b3f196e68173156f9008b1563da9f0e399518f5cc96814a5ec490c260b2f5b256c7105ef02a54a266f6f036eb992fd8ccaebe40017749a8a673843879e12cd400e79970898e756d48e358a1a78e899a1f6c5e5dc49b4340a160ad28e0de3a1fe62c92f65ec00a79745c217cf2857ba2e89e26f33031f589ec5f3cb14947c8426c328e53d21732790da5649633319baef0e592935040f223a8f955705ada3400b09dd560cc2198ce26385532868530350b286dab9a77f306414fab8977c246dca100f49b7627ab25b9d08806863573944cb80d6ee8c3b1ad4a9daf8b7d6b3c74c20c5cc0e5634a741a503edc74e2177fab74f9ed1034bce1b92658b290b6bd16cd8ce967450b363aaf2f9dff63b4054e65ba12390b6093a268d81b6f4c68bfb13326decbe47b322551302da48eab1443e798c4f8956f793211c49617e41375287ece31b80557944831c5317653b2f9fb319e29bce421d54ed5543841e4ec9b6dcbf14a4ac30f4c13990eb23baa68de7eecfb81968e9f893d88c8aa8ddf36f4c34d41ad67c4b2b2b20df68151c931ae42082381f07b361590ec1d5bde16ffe77cf92913082d865b8d9ee3c1905289a478689ecb0e40f8225090a10c6ad7ee424069c59b9caaafbea83dd075565bae9fb69f3c06363b48f41ef6add51949d37904dc892a696ac0ef860d314827abe01f350a6e0d710542978b8d608ce4a8845ba67133af4389fb9c3365891e675e9382736b301bf3d3a2050a7646f6c77f3e1d39c6768f43d58d30c34bad5f882c46ae38879e05ae1d3cf8d29d2cd0e3a11d045877254bbec6f0b634c7e24357448ff72d00ca78d991a994dce6cff6ccd8f18335311c7ab993b42509794bb9eacddf18de27d6a69bbcee65d2c1b4e10c025abd3c81149e7447cfa1f838b96d1bd2189ec611c8253d89db0096bd13241bf11fe2a29b724e22b0f175bdc442bb573ab1a866cbfa58da093a8083475de8b4b83f60b1b8111b86111ce5cefbc061ea2fc90f24cc135b5975245223139230338eb6347f0b039de1a95a322b98b4f3cc2eb69e581aaf11cda72e3f4150a7dc4b052c588ffe3534251f8d268f08f785a4f83daf62a4a51349a28dbcffcd1df4876de134b61dc4c67498f4877e1c703dd337260c918c9a1df189cd8a3a066ed18eeb6db8465b83fe7700aa89bd75b841eda2034df20137ff8f7e5a07b297576bb7cc0e9e48f14401a3bd4ddbc51c7f4264bd58b33201b60fc63bf3b9271065738d075f5fcbb61f844b6e32bee57191d184d3be1c1808bfc1077bde8182d820d831c1761e30ee51e8fe644112d7fc1c7ef3511def1b1cdeb4f8ca8d5884ec2655e075438614b76130e68a46af30158c1f6a9975484639672992474e3f6a057bec604ddec47e441870952c0a66316c5e842b4d4a8b367049144e1769e037da559c70ef89f2f9ca8b959628c60bea85b34ec543a3d0ac888dfe08a46aaf07960ae0855ec1120ce672fc89fd32161b04a3d9178678ca399c661de6c5a2c96ebe5bd68369f0be6589d5f905c7ffb723ee35325f70ed41a4941f6c6e708ccf6ebeb9a9a8e0c353ad9338e6c721015873e9f76ba6871fc5885a659462c018bc1864c6c7c5920220706627575358915520d7020feea4e6dd8acfa41203db1bfef8826e64ea8d938046c80d68286a0eea1a815404da8cf6c8d70c552283c51e50e726e9e5948cf8945cb6e663e3b5764c475bbf08cbd0647e4e2abe8fbcc3581d1b894a05ebf75350006ec3cdc8c8ceddefbd959e30201bea5bac8433be0be5236419e5465a99cfb7528bf8cf64f76c78df7cc21f5476b9709ef055758e6d66984866d3808d7c839b1ab869c1ba11489eb8fd44d95885e119c3d899453d304d40dc3f6964d92a5e1a5b0026066ead2903ff4f4d3db75eac24556757cdfc7d3ff1b50e29f4326d1642fb813d46bd89c71e62d50a79aac61f1040484b7bf7ae8d8d91334c79f64541e72efcbc7f2d4fe553bc668261784ca3a09a38370b66112967ae568bad9c5d6b0b04407a48ee8b4934710fd7e35f91c17dd5732841437bf5980070846cd14871e57351a339891f86df99caa5d267b9e1148c9e8eca76773a09506b0248c6a43d7e8eaf7003f4d569a744e3b6cd5f06bc7444473397b13953936a35ca3a80d16f4fb3eed30ca86767f84ef60a7a1ef7bc36c536b624181ccf972c682918e5e52da1bdc33235438e95afbeb4009aa7f57e4a2624045df1cf9f6e3e9ae46fdf10eb43116494acf5466bce37d1db2f3de443fc82e8169d6e043c6ff52d727538a3df88d132ed2272ec1fb363181d9c422eb416a41bb06ea985e92f0516b5b733e2cc65d9e5f9723cce41b5a625931c6275ba15ce5188bd2b686f5af749bd53077a718b24855fccae882f965772b2a0ba55a9f242cadccb8c15f4c57120d9804bdcd1251f28f5af76215c7231f4fc24c2c5fc73890a9f7ada6ff7784ef040288f06298e183169b9563647ab502d121403a8bb93963c6ee6ca66d44e72f249f69e0507d93569634693428b1756c7465402cc93828f68b8231d36df9d29fc05e0929bd747fc8694e7dac9f5ac8b081c48de75afaf73cd9a6a9eb9ff7e39ecc0573a3ee3a7bec1b1b061d580e68ad8edbaa471cb799437f1735cfb8cd397a1e4a460bd30ef476ddfa5cb36ac0e4ecee45fdd108f940c287c4139e1aa9f9a99a932e80336ff39984a52cfb696ea0cbe018fd9b0d72a66095e602840a585b1221751805d2199bb7a240a9800114229828256c49057502c7632b568885eab56734facd8d39e467b2b8c5ddbf58a3eb07a0636a681c40d9114dc71aa3501e387154a8b83dce84ec6e2ee597d352ab29f3e6185fdf2a4d0462e6b1f98111b42fab7f8a0e283b4f5216535fb8b2154266f4620695beb6ca74db94db8ea9754a2c2ce5c3bc14edb05ca8668cbe7c85a3bb5e5280388a6a9ec9f7cb39fe1b7c55b4167101f7ef436bd8d0a0db3447459b0a29b020069d79367a8d40a61e7a9a8116bdb87dbe63b8c01ff571da8e63aec93935b4d1e534276ee02dd84b71c01df78d3c50e7d4e57b95d46eb3d1aab53610f856ab136fc43b1a67c51b72269008751ef9bae83a149c06d59636d2d703afc89ab5c476712aa1bf2a9a9f5c2431e20682db44bcb15a700412e7c16fcf54b8706b642652538850bd972955392685b71a2a3ee371c3358c907f02de5e42dbab3d113f67dbda42711f03e38d0bbd8ae9f8d6df2949bccb65b376df981a5504648177845faaa4c971d8dcb3aa97c11c51c1ccf1f7a4659099e215d5e9245d28c9c67e2f2ce38cc953ba54e1c2ea37de228f4342515055bea716393a7acaff45522e6e8091db3a6fe13c78d25ca8c7e9bad0541e4e120842bd07ba73b665ac536bc243ad7b03ba3f2c08c083cf8a71e6fe4f5c210a3ebdacc73816fb6059c94927fc89e89f0546a01b0cd04d63cee89a4823b013c9cb951a75034f1ea064febf9d252b8cdd34bb91a8a494026c296e2f82306c319a49e7fe864f27a881795c516be61dc5d60e4cc93d9b92dbd1323bc66c9b415936b8c017d404536f253b26ae9a7495e750a3f3c138622d5a38acc77426f9c636e95825cc27ec879a1251a05e9c6923822ab3d9b8c7e68e4c8c8015b6d83852c3fa157c0cbe8e50ad32f8d3bcf565625016b45b4995dce5e0299572e15bf2b8edf11de094482db1cf23b0caaf8c7eac7a709a569c20243bae2a5616c25bcd40935b7e7675ad15858e2b24fbcbadc452c4bb49d10b2288b9c9cdd8d7fa684418e1d5016e90514881a01fdea9c80802cda5b7f328550b909be769925b7d04d452856797ac2dffb4a06f470be480094a6cc8da8ad939d35c7cb719d522ae46f21c4a53bb1a6887731a6d4dc59c6b97d7389f85319457bb5c0cc9b35acdc17673f0fe24c9b3d4af30a3713659793d200cf877cde78cbf6ac7e3de174bb21b35dd653c59c8a21d57c5f7085f559ef7a6d08d7fd0f16eded1504b2d0b2615281a1d412887770168ef6390873adee8108301999ab376b7d160953b831933ba41ea2c7d1ee94bfd882b463c0a473b4c74cdc63ebd17996e7538d4fea95a9bb73ce27c7fa21ef3bbcf256252b71e782395ddd033e23b1abaf203afdcec70906835580d54171eb1fa1c8b32d244712bce711664803dc96ff0ce9a1f13c5522ba2876b056f4eeff86916bd066570fcf57fc49911efbfe79522b5efc81081a999eca5815ae068c5aa9f4888d92d6d7b6064a110f0c8a2ee0458f76b1ae5a123940fe18064068f6448cf0a3a29a0fd36ca7d50388bbf0062e5ee0572cc8743b4a620d91d32a8020f7076c4cd5e607b52efa28683295ea54d65c3b4f20685297100d7e60976e501cb087ffa932c1eb73d9ab48092f162dc92da547c9d15636b97ccca4f7c76e63f5914fe285117ac150c53c52d1041943b243167c66dab7dc11d593ef7c29f6e7c7f710532835d9a29396ae9e4e6f1d1c6bced5cad5ffd1e91ac1377580e38c13e38c42fcaf995ffc36f050de322853ae4d1e261be25b3a61fdfe9007465488a75a9b53ec68edaa9935c3c2a32499db51e5c68b7cefbcf69adcbe90fb6eb406a47e26f66db86f0fd636d37e21c78b42c77cf0c59b42fd990c9bcdeb94da176f2e5f9e6d851ea6965e5b8e13234c38d0dd49fce03e98c49c3709572262489345d63064a2d52665214fa0e5ef9f2a8578a39a7f7b632bf2897df344acde64b9fe94f6491b599dd10c3b20a0e28e4262fe5b41c1273fb64b67b2843b9b55ecfac935e4cae6000e4ff3fbd01519b209a5883938f8775363794ab64b75af33af46aaf05c924473d149d59a0a9a8ec20fdb8a1453920fffc044f88436742336e6b2f212d643bb4b73faf494a462bf6a1669629e4312e71e3ade4b40beb3c4cd179ab42968bf8df91b271914fa5bb17c9936862b1dc0d1e48de575d69a548eb7872a44c94bc54f10678bea3567ebd4186a69538b262e560112aef6c9cc66c730e09d7509c8ed4237b3b0735761620bce8365c45b307860c696df0f1dd8369eee5055f1828c82b608c5ccd375e4469efcf382bd81ab6f120772c549c2f25810b664add80f6f35c0c4fa4bf0cbc3dae7d978229178f2ef0e484e8441f1465f09244fbaa886a060341987bee7c43095bb68c8c4f229270bff1c483bd0b3e5a6e2d25d84fd5a75c382af99e1bf9dd1be01dc07daf940be63724ce5d2ef20ed91ffe8cf84a70c6c921dc0dc87e8f7b9d4ef924a0ee5edc1de54fd9a7d1904156efb3319e0143dcbc1a56a7ed59aef486c4b80298a7d0d8eb81b572f386fead6bd16757200970639a1c0e9d0368e0a13f911698ae0f11ab660acff756063f03a4cf58c4968684786aca6e343927c9be14ab9285b74e6d5ab866519bfe40576ec0f9aef94d2a2ad33204bc16958eb513307ee8116dc50ccbfc1c57417754f827d0e6b3957765a9541f205f93a119c23f9272fb97759ad93d5940c98910ac5edad85e73f0525c97802c749356579a239a09551e3175324c72e12f49a848251ffbbbb3a4136989735d0cc7de6657b8644782ccff8a90ec15e316f0cb342ec2e1c4f0769c0af951367656c7b4914f8de3d79d94b138179f4b021a73ad696c6aeb1074f66438f3fabf41878a5bf654c4c7ff8ed02caeb06c66d08fddf270e4d99456e0d694ffeca70e633848a93c2c8933a4875e702fa0ac2f1b7a2a3d1b8d8ef0a06b412d11a985a84d506d5fac8cfc54f13b089364aae727aeb36b0590bc1c0bb021ff299ca97bacdf2c6496b03c8cbfa3883ecb935ecf466d836a7b7437e4af1f3ed79653f997345f7ac3577ba22f651267c1bb8dfcd4a6e4a9e5c3a6cf6695ab83eb7338aac6fca42865575f9282bf98c5ae81cb0f21f3cd36905d674cf1db14017933929a9474450aebcdf2a64db9ad04252c2008733f28c14ac7440d0b6395112a2b80f21397edf99fb29fc06f8fbffb77cc4e18dbda099f88123b18fbded6463604bb214031947fb435a938291c001bfccddb9a2dbedfa7cae703951df394eab2ac301e5e1ffcb27ae1cca7f4e4ec4b661f3f063518a88ab328bd6a728f9599ede8027bfe524b72b65920e819dd14b8ed00046a0c6d65abce793774391a28ee72e28e22aa588f81cf32adb874fb85ba8d4e6439c8a670d9846471692e736200439c38954a7e364d635f008f37f7a725c8d0a10cc8647ba1cff51a9c30a961ed55c13d3223e54897b6ef97444587301509c646feddd75d76630e404fe506c5e686deb0c68d4d5ff4d74c1b079203b44501b6f4a0ec1b0b2ce276f3f6697854725da3cbbd8105f5b692b262163512ba20d1025e502173200767cc5e242d9458c58abe0f2a29ffe52cb187dc9ae8a23682a0b454a2d1b3c4d9229c2926769640cee0f995a6798ba3a8566bec5dc6241fbb5706143a38c6013d8b7569a9176e9eab0090f79686a14725c03252710a452b444190c5e5847ed39bca0204d623cc325c2b528a2e8f3d899bd7717b07c7af0b9ebf0782c91ce9d6e70291fce48cf2c8c5ffb394bdbb494f1e9b35c9c2fedb83497672351eb1448d75cfcaec88273b82aef85c4524b3ef35e5370aa032d9bc44d2c1b3e846ea727e67137f5754ba3bfefeee3bd2651c8fba0c50ddfeb1d3b19a6f6aff25d30584230519537287aa7ffe9942dee2467e31c4a56ab747183e1f808958656818500f386de82cb697c25e038420e5370cc12e102ce64396114d3953e9ea0fb78b0769d6c4696e24b5438059298f2721e3fcd54791e97b916458b346139f3acb9fb6170df97da0bdce6ceb408f5aec17160364ce185fa4f935c6534e9540b2a4211019d8721acd76c1d06b8a86f9bfe5dc657aa0114ab3116ed32a9c9122d2a04f2f272ae12ec254a0c6fe9ecbab03ead8dac34edef6bb4ab188fd500b1ab2e71cd73cc488f5057c190e73c56f31345527c920410eed069199c5f6a5df148de809608828e8924ec2964362f7ee9296af8549b1c1f103cd602888445368344f63bc53d45b6d4dd2635900fd25ae42591af10ee5d8a501268b5ed8af6fc8f60120ac2808caa2a5987947639cc0aaa4722cbe9b05d41771628b60162ab8c9f52b49e74b7497e4b47a3fcaae65de25e25da469d33aa336d902f0a05d7e15ca2bd03e464212dbec96fbc689125f2bc43e77fd28a909aec325eb18314050a9e9472fa9bfadb9055d6d935dad281b17e059fe10fcdc4722e68fb39f0661f8d1a5c739b5d4a5894c0164a5f37421a1b891b696f76879f62d1498fb044d8fadc0de818fe569ef1d889177684e70cbb3478521855624eecebe323264539ea187b1be9e8cbff41beb067531a5aa0a1059e7afb991d01dfb7afaccc617a6046e2b4055c95e3b97627e8bd4fdcb5ad5a00a4a67fe12789ff6a9ace4eaba5cc937ccd85a2c4270c2c3900883d6a22d7866c52baf2dc1e2e782d9cfb99585a5d540844a88e77c54bbdc91cff38fb6de39d6d991c1443cceaba9cc95a0c63f6ad8673791054c78544c49f8a811396e4a052da1b7f88d2a9a8903f2c47e20218bef3f1216a25c58505d191e8d7c94b2cb5faf516a56d72fa5a30633cdfa9b57924081c29f5f82ddbf4b4e033beb5d094956f0b347e64301657e3c79ea130628aa195837c98fdf2ef518d4995a1ac457e5d1ffb597f0927d7c732d81b031f63dc454ffeb3fd45b6f501419ffe9435fe4703bfd9bed00a790e63a6a61716d7876dbf58c83d02dbda62a1730d60aee764d9941a014851104ba0302ac5e33978ec90aac524b5b0a45e3d8653590cab0df4d1748eed6e3520bc641465c5258804f57585bab7252fd252a5830d64599037983ac89b57f3c9bc0d50e73ae020904df87d0a30bc1fca3e840406f20b23ffa938cc1713869bce02f5a869818e1448fdcb4b43f094a6bb5feec6e4a72722be101ac028b470aeb84f84d04d1b387f9a3191184d12e09557612a0ad3cfb6c4e16d1a3482f00c66bcc0a7374275e6ac43d36feedccf88ab083b58fabd618bec0a08520cde1e2e21811e54efe81bc7e4083eeb6010aba120bef1139e9f1d43c6541490f1af09409a18b71a87fd8fc4eed7de52ff0fc3a1923e32e359df66b29a33aafe9f6879b8d5528595bc0d9e60e158e58e93d67192d49fc1653d489517f976fe826690ce81844e096b31066d55fdb989cc6f927b0c7cb0a5a9e80948e09126e4cd963c746f523092b435376434adb090c84b49895056ed42b3008df987f66692351cac023021abab971da9cba0ad8bb56827cc6da53c8ab16db64c08389298253774db708d031a421bf9b40c978eaec255ba462704d1959c9e967a18f5fe7b88b08fd6189fd3dfa45eee0bc03595e09080b97eda186feee3dfc2c65d63b943a29e0d4dede9497ac474f52c6fab898493b45dce897aedac7d07b031cc573c1bdbd519c9e0f6e30a8868f98235630f1da7de23a2071c6286a3b264a2432fe410629ec87017a1fcf3313467f585f9e59e3bfd3c075c199d2eb1d46fa7210d2d683a4e6d2523809a9d2a1515fe2631d4be5c7ceaaa4ec5c45213f06ae5da07eacaa8b0de8dc5f54df2e986281c196cd4fa499934b5124d4c389f8ed518c6483eb33bf8fe52690737e3bebb13145f4438037b4387651eb59c338c34f8949a361b7ad9868d9238260cfcb4bc9b06585c82ee0722d0bf4cc9111028a5f96ed583fccf79d58a5a2147f01a16bb5b38c0d4b1a3d67ca4fc08a026127b234d2c7b0f7ae7534754ba1c68a71908c6b913c63905b6ad0a55dc95b4a369f611143bff6532dc7acc5be86917b9e79cf3c929bae5d32ca4fbb9425295ca83780338b2c86440c6b859bb0ac21ec567b41aca1d02c82302cc5549f1ec954b8b461494293d77ae7d47260ca98de18428f6916fa7b275077d75a553556f4093c114732ef5c98336692b12d39d2e55973ec5a33b9f6f62126d46471297757222d04243c23d1c19206a246a373e44efa8d6c357f6c9b43bb99b76a91a580437de244d10ed735cf5068fbecebffe7b90428063a4750fcaabb7427c94b1373370ab36c08c8b8ee4a3a88cbd8d5cc83a460405cac491c7134babfa4651173b58ad96209e3d526a3005eac71250474e5a87c9f71069b24e62d99759f29e4325f1c80cc2e12bf2d53211cde76bf4213b329ae3e57188920a663ad7e5f30ff25f9320b7aa7554bd8df2a9bbd2e3e34c738128b245704c4849588f2ba3f3993338e1922e65f8651fc6a079e94fb79415abde173efbd9328d09a555a8733b861dc7a89a19a13012928c93117c111a377208b275cf0efe4a442424d8db3afcf09d5c40598fb2894846df5cd295a18082d935d599b3b7b610498d87fa769657dcdec7fb12378c39c3e371b632b2b935f668aa9792dd297f91d6b1ae7af66b3fc4140cd552e331e6864425c3c90f666b0008ccff6b72dbb1b587a1be519c993c7ee40460bdabb6a29da63150727b73c97c5276ae73a867c56683a8513b1a8fedae595f473014a6a12460f932f72c0cefd1324bb02367cda5a16859f7c2d57b44b370ed571bff12a73505a1cc641450918a197c500b0c49df7557006681f16cae7db64b371e70de94f32c0869e5b386479a081294eb4bc710b9758c752552750f97770e8064edbc18f43e4febda9af3ddb024dd965d9d684cde72b6c309a7d90f2c9352a376554f1a1d3745d66cfa559bfb3e14afe48e522d7a3667a57debd54188442708dcf02f654a068c8cd595174748416f10e9ca8fc91fdcb76c0a6415b003c80a852c825c008b5556898a5817f92511c2a9291bf2c936f67243ccb294c6a451e6c9675644649202072fe06a974cfddf5fbac8aed97bd96c1c61d89f62ce91a3771468b348aa7f798f6bc2a048611945040b3146b8ebb9fb69a1d6ef00d9c820fd3e79102c79c5d076ab4bd3bb218dc9124c775e023ccb83a53d8e99e1eaea1de63cc49ef3fb914888fb1d74f47d6a1385a0ab9ba1116d84aad278b6152d9c602321c625127672fc97b2174a627983734691f571a775d4f2736336676285e2ac471199aec4625e9183a67dd11f68501b31e32591a68f7b9cd23f415c261822eb6ff8ec6c231eff2afa007dc8f77e0897e1cb340f8ff7aac465cba39d8d5a30f9e4c71e57ce769cefe79738f2a245816fa27e4be7805e5eeda3c3a3419ee79593fca3de9fc60c8c83f29d1b67e26fe24bab77d7b56f00f8d1c2d77344ff2fd1a65512aae50f5c435f69756f7893738192ad6463a46a054aa0a1088ed05094cabf306288f0cf320b8b01e984e61f1c054fd2443ee25cb58b31335895076f52c01b4c5c9d9a7237462aa35688f5c28eaf071830188b4645e1e260718589400a0ee11f8d35af2e0cb5a393c4d76c86bab2016ba1743177877bd0dea2c8fd81a9e7029cc4b837ffebc4edd56a2d9dc00493496974549f5d5061f3839d85009d0cf1252b5fa6eb8e3de0d0267132d35d1adbf0230d9d27066f1cf35f27eeebef53e2efaa5ce0faeaa80cacd495820fd7ce5c540abb7a647f7c0d441a34e710a814dc76fbd558e457b10d2a061796dd794cc77298d0e6c96af75573e1537b022c042eedae6c5dce3d6749966097676af0f014c5056f0cb80b59bc98369f6d8b5d5c860adf71b697488f4068fe786898ddb44f82774f3fbb176bb3678e49d5941b339743553c52f4fe7abee0e6e575490efd5c138621725a625e532298fe4ac7471aefe50c686529cf345273785e18aa64e4c6fe66d8f32d8055a84185802b5e865af66bf45642f510d68af11394e0ba6ff4366e2c9e11f31a9bac6d79be4f39bdda82328a0692721d251e53c7c1e8b182bdab6314b7e4ff75302e0ecabe952c38ad741749128f1e410dfa9400db2cc4293e8107a6fca9e7a69a905c8fe340dcb481a035e99f62d3d748ed74e9eb4e963e8d22c3fcbebe34e4d36ea193d7fd1f47ce14885d5ee896140dbc7b24f723b77bd15c46442e8998d3c0b8ff3688111c738ed7cd58374aff81a0082077c8bb54a4cab0de38117d8ecdb1dd009d32e48b4147253b4a14184a0eb20302175e6b239a08ab12d8c8c130d8184c3395d39535df834eb70b63b19732f2725f90aaac3781928fda5f2c1f24f48ccbb0ec9d64c75fd8cbe6a2ea73d9bb7d09b0a2e54bc18c5eea7d67b7f7990e353ac995de2422b8c59b77bbebb54fb63168a023e8f0a1ab92e75c50d384f681720bdf4d53ef1cfa6b2082f498928e4f28d993879219eaafc3487cbc28e753c56f661a5db33c5feb78e7df0943207583abce19da07848181344b8114c06ad645d2ce28d965c364df3bd83fdab21e7d26ee7c432dc1656d55272cbe86ef6a25e358a0d7cfaf3ddc4ae39b060d96d73170713788b23d7cffece4f4deff32b7d6298d59e4017253bc66dbd16a8f056dcd6a0a9cf7429df0b9cc36dd3adacb669caf0d410f09d8164134ded1d37580318759f05eeaeb89f92bac04b93333a02eb5abaa6a77921c6a67dbd5d85e27d7a0ab00bb6da16920ac7f1f09d4079f1900bf6b8f7f4f8a677b09689768d4ac9f5a41186b11bf0cc164729dc2ef36488f135431ef7138bc0b289efc53482511bda576ebda86f8896e7b19adb3a82e3ff6a8e8db7556acc01e06c0370b94e03dc055deb4ef527a071dc7420ccc2a01a2443e038b184c8abd3ac2df9c4bde2a05d03ba4dfc376a79768ce686b09e4383ca891c5e2cc76044ebd5dc2cd3623bf9b3613f64181058347bd6ca31024d0c6d74858cb8a8c273eeeeb2d165079e4b7666d8170aed27b0196494e3575b615c9202dd6303c2961fe1f6dbb7ee5fc3244f5ffbfd39f6c6c699db6d3994bd3358d5e34267b9efa9c2851661f7d438c1a28f01dffc8f3c05c7607f43f01a5077b2a30164723ae475babc8534f5c87dd497a893ec8dde4fdf7c8fe3e952a21cdfd8f853f9d7dd96bbfb67095e1f0c851ece1617c4bc1fd2e21110c4dac9a936c81bedcce037d5294c2963458c22004aa01453db73fc048e4535c728958be5232646c8321b61452a8034cd443734677bb4ccacc06b1de6935eb70ced4f595ebfc507fc8267b184cf7662f9731a17d8263e45c7d7847a93e3aed6b7cec1f29766da18d285728f0e40b8a820da3c863c841c500b6ec6b7c19f0d40b2ab6f694a985ea2bf0c9ad17e189855546f88507b715ec746db38ad7660e224fdbca924a97648cc67d3956d42d871087248f60756a4d7fd0505fea343c15d9b38fd3d7ee42ab70015bb0d3e4957dd782a0532985ca2067d80261f2b4c01a79e36ae636ed5dc4bd73be4c9adafbc403163bafc2e4595439bb5a70542c55603b2db42f94da47684ef1d143cbcecfba4ea2b3927526314e4a2077fdfaf84af798ea73bd9097dac1f86863cdba45c983b8c1945b24bb581087f874cd52c5e5fe2e41e4f1bb5f592c497294a92c5935c52b909e948206362cb86a1fdbe6bd487fc2d8125949199f16012d5407180a45c3a24af77330f67cedfa8d4aeaed7b2d430043bf0036f2d90957d67bdfea7fb7bf8f8eec70e75755939bba5c6f83cc3407193f303c4f1981fe711f0f4f5a8ab7892920e794a41a42c28911ad29a580a84dc8cb0c456d2500bd02c87d6daeef2b81f7eaeb579ac4043793bda0163be1882ea7debd42da0fdd941dff1a85d4ebfa4e2fff4f224a1ce07ba6ed611c3f5c29df8ded5679568f737a848b1a066062c7f68a68c523affa859d046d0e6ced529d0e6bd602b3b44f5112c3212c954d5760a46fdaf94cb5829e99981be97cde92ab2adac1df2937b6be6e480f4d4cc0a038efaa9b17f0665aa404c5daeee793f923c9d523b01d3bedab808af945e0cdaf320aaf1b447d9512e8e2e7ac19d675466d633ba7aa909c645b876ffe0cf46c58f7bfc210de9cfb8cf08ebababb57aa0012100ff14c8461d7447911fd52b7f6e4e53b7b0a20e568a253802fcf0b107c20b6dbb1246edf92f487e89fccb1f9e262664a2b73a2cfc4f62321deb562d5c01adb79238d3f86eb0c49352a2342ca0f8d558c1db7a30a3ed0c26b1a7bd576b56394b7e6b7c9ba605bf5921f020a56851bfed8d83a6c3e61d8587940c638b26ef1c0e23744ca52cb0eaee971db245084eb2d98c1e093c5dcdf03f8b95ba64c9cd8a1f8f14c5aee5c446d07d5d2457736fb70dc3b7b71874f4c8274ef3d2856fb5ec1c3fb6b9b40295732892031440c8b187fa0976bb214ff33e371ab8bb6eb7f1f5a51991d53454d0fab581d34f08f05820f5ead0151ed6bcf666510e8c900f89f13f3258b7230c1cf260a035d7ddfdd6f2f66c60335c1314fb0082a8964b4b9290f6ddf772489be59cce2fea52316c213deb9edc6065bb35246a6e35143710d45c7e4aa66ea019ed463d76d72dc3eee0e56c6a0c8e022a21a574e58a9ce56f9a030c1015232e5cc392baf8d175d2fca1b38b3e4b847f18ebe9090bb7c4c4e411f23b478e711c88dd06c79fd28f37a6ff630de5d2e34af6c0afce3bac26b029b0cf57f6838c45ce9df2993d47c579895578e929f779637bb2a2de879550100f8671b6c8fe619e786cc6c8e1ea933e964627d90a53fc58af950c2e26a6e4cae58740dd492f97b16530642413ad0f1dc8dc17f7cea3b14fdd37b655dc9e5de67828aef57f51523f9e6972b6faac1b0ae07996be11c643b15e09e9596b9a8bd38c7adb4dcafc2669844ee783768988823685c39e7a87c546469c6f8fdc1a6d2a9374715ecbe863e460e3062b46830b6cba4dcafbaeddd4d7ef0cd28b25f2b07761e0abb491d070028f4d215588d379f8b41d54674cc428fc77ff3337297f5d01ab233dcd20b11c251bbf1974aed8f8fc338377c7a2f6e11df1a2e6a4855cc6cfafc3973333e38173988ad068ee39242af9dbd4e0423db39190424488b28826009a164305b9fab249aff9341c8046be99fa14ff3b01e31b5ee39695faf9089d5c2298bbbcf32572c375b4bcf1e7f2441f06897cb5f855d897fa985c65a4c73118be19f2807c5dbde930f172e302b88503874ea7b6f39ae83e6e4a863c54642d867e61f6733a1cd96014052da983075b75f98e9ba80f68ed17df33ff3d3ec496af8b2a327175c87aed1ebfeea2f9732e0d05627bcf0b1c12d8302a1375648566c5bc52212e47f094ff7324cb40f0e59d028cf2d8980726f40ad5530e557b3ab40f4351004fb5c9ecb54f18a346ca5b6105feb93762f2f19af97a3c0522cc9334844df98d92d2fdb5b73fb217ad50fae1427486f3b93cfb9afb3907dfa2e305a644082ae95fdbf5353197a13c1e620ec970e2ebcc740a972e4bd12846e11f881333eed879592341ac662a4b55bd528cd3851eba18246d271331b9e26049a2c4ea639cf02e068a9b68a0c91741cb77d3ac60b04b59936b56d2bf0f2e3cb6c7910e4abe04a53c2448ef30e2ec832add6e84b11bdf9032e9b8439ec46ace570d2ffbbc1adfd2de2b306a121f4d4fe728ecc6fd086883f1663ca26a6016be726c3c328fa01af65a8b80378defe07e192e209a748fc79df9ba4ee547d33609a432e7036612014b749aefba10afcc3e989b7a0b85b005d7ee9be25cecd41233844f795c608d7af567ec4497c8c0bf1a8c148a81069ac7849059ab62af80743d450a74a926216ff535de92a6ccaf264002bd4cbb5a06de538f7c451510d80ba87ca5ae8ba03726a68bcd4f3dc3db8467943c7ade25f4b29096be81de6d9a4c8b80611e02be016223cd06d55df835423942f3edf60da4f6250d520cce8e717f4200d1b624d52a339714da2240c0f1d36f81b7ce5b1b89e8868b9cef834bcb9df173dc03068eefae7e03ee86490569da844a8d22d58c0c1dbc84b2d124133a31e7413959d16c1c8e0e36d161a0059c68207b683bd650cb6fb4ca508d731b54a8b4cf4dbc7b97bc30dc77ab1e1c06adcbf491d2dc5dffba693ba3681d444f378dfa10974ec5ae38c5fde10e8760073dba4193d34f84734c622f12240558ef1dfc32c627cf51349f436c0a2a95c8d1ec597801a13c4ad0a838062e5d678aa4bed8392db91c6a18cf40caf8f444d5faa48c134d8d85de952520229e67355e52f5b29b62feebaeeca9687e53c8eccecf1e1cbe3dfc40f76b8683ab55263bb551a0a27055ea27bd0d39a70111b8ae5d28f02c4f43b749e0cb0f756eb24c2328ed3057a69be0a1e3922293830d065f149d18c1fab630411461d0cd7e2ab9bb75bc7cc76c268d5263f4c052393ac36c7a50caf284cb0e9b32765b3cb4de508133040407d7badf974b60ae91486243acd178d8d3e28e769b87f3571f32440aae62b2f771c6cf7bb311d83911c8692f548aaca749ec3a9fe911cfca3421be1ae13e6263a93ce4270694b0730587bc8255ad8a44645252e0eff707e6945a7c9417f0215f04008501f222b234f2775c80029d90db0498bf56aa5171dab28e83ac04f6a99f1148f3f75c0a6d1b10a6a25fa0ffeac887c4c4fb582a323c86e7743831024ef4937514d0600328d73fe92c26cfee50f3a53ceba71694f2aeb21b2648b70e3d4f6a17be87ea9b2b85761616cbe70547cee551b8bc671e58c6f7b93cbaf154d7a43fadc11dea2a66ae217bd4a74b9cdb5aff39bb9da764f0d0ec5abe7e4f7f03f36f69691cd9f69040d576e3a8e18394e95b3c487ad241997a8ef3cd569c0ea2cbaee2c18e96105c55941a2e1360f76ea7b048c291cd06bb29bbd56e1407a46c52b97f0b9458898c69dc7d1fff954aca3d73695708e2653e8bfbb8370c58c8f4cff52ff4bca2eabed7630c45a072855b4b8127392d5cc3782f347eb9d1a1afe4839696ae3805346a3710f374f079c4e845dd0d6e23b72ac4e780eb37656a9ba5e95c0389b388927da7c94645ac9e1292c4dbaf36b44167a5475dc55071ed1ac97452e79ba9bbf9d799bb4fc1273888a6723fbe5d8ce2d53048de534347a3b18eb93cbeb59176f21aef127bb42e09a8a4112d7e2d7375813d4e60287d8b254a74fc299282dc0345032f0d35b1acbe6993f331e6d3bbd8208e03828c362f46c999f5df4945f850dcde59e4a0636cd1d97d933acac4c38b04fde65368c41e87182bfc5d6a3b54776334d4e4d92dd6752a958861aec7c63afc41c2714b8fdb16d02f3499625ab5ef06425cab55934fbae2235e5dbeb1dc1d7f43e1c8dd70ab58f2c6692270651a11f96d5f1b5de2a474dd6d51c2a36d43200c0036896735fb9a1125878404c632935539afdb3869c90e8646aa9e7b55b3130b9062e940aa4a4d48d8e063ecceb8cbfdd91c4b87dfea166c3d99d8f6e639d3dba8651fca12496c2b3444474f3f1e731c87f4b2af01c7d3eb846800a6e81717f45af8837306f7d050cefb90328267a7269eed9b32297b4b51459682a282905af3616f46fc65de50fbae58ebf1466c9223d193f31e793a0bb628562a9b2d26e53226d6c6e893a40e5e355df5401e3c05182da9d4eadb805e7ae2085f6fd945393da554378e55ce9baaf7cbfa1d0cf3b3bd532763f269f72da5abcc70febf05a5fe9bd8b264d686123df93efcede925448341a9a541fce432d11e68c047be9a41811fa8570e08dd4479422179904140f7cf6d5551752cda4f36083cd02f7b458074726019cd2de6b0887c5f38c3bc34e71dd42b6c7f7f555889cfebb533c726e8aad2d29aa3a115191317b06b0ef4ae3f42c8750a5529316841a9b7e84085af4c5b000bdfaad2215fae92b1d32aa8df02c1808ecd853c07767bf3e51a925694d92492b6049c49c98e344db6461891e6e683e0c9ad9482cbca411d697aa6295f959a06d0af94f553719f5cf81f7e84743399ef6612980af4c895e64d1c8d2c896ac535a570a6ef2e777f138d1d2ba5767ab362e8c9ac6cd51ecbc576636c9296a39d8c265cd677856e34c109f4ecdf30a37bbbea81174688fd79cb89580b245c6960220a810ae9fac305c0e5b60737de33d760cb3a405e0cf725f3639b47bd96e2dfc6d64eb4bb0368147938ebda0487fdf4adcd6550d0a06426331ee91aa1760d21f39379a16c67751b7b9f30f87e22ed2c5a91d615d9e629f5b423d8d86d70445c596d7be718763886b04a5892ece5095dcbca504c07bb1dad2a0782ddc106c3e362aa1b60a1324dad21c98012d27ec856b22f0e31bdcd1003f32112d4545c33c24dc4c2b5e9d7e2ecaeab555283b8ff85b654f551562ea7f0abbee4ac8b4908b8a0ae96434ab3b92a95b99e8cc4128346d10af023542a312d6ae325293e40602a5607357947258ecd515b42d90376763961c28d7b013c8ee0c6416c62c8f4e8b433e9550b4c4abdfab3787532b4611da2893b0e0943a59406b13240288718cce1cb72d5f1e5e1c829ed3434834357f3e0aa12046429eba39b73836b834865221d91b6e86e185bb7a79c1f6d006c9d02d160ef877c715c8db022152fab8e5660db9084d7618e0b5f83e65b72cc7415e780c26ff22d3431c599551a1d64d40ccd6d40cbdca1a34137bb51967f98e0e1c2905c6406c5ebe558ee58c921a6d5af6a20833f080020efd7a5d45b30b933b1726ecfda8af5bd6e83c737b70f746ddf9239d9d33a1521116ced217c2d5ddf0032a0a14d2fbfdf52b58dfb8fc44af445a16d3cf506937aa910789ac4d0c43ed17ffcb2d03df27ec226b5949aff12808dd531e9a60d8b0134d4b4fde5380d35d9f2a961e0be1f53b3ba8acc241038da51e2802f945ba698f66bd7cc567c07e2874bc9772d0523dfc648955ba628b0f314c6bf4077968951d56fc9331224e2085c4ae91f5762ebbe5deffbcceb7ab2e64b0431020b52536f020775169f6d3c2873c37ed0dbf52292f509c6577c1e54bef30922abe1300eea1450abad8581430165b3a604584a8afa07ac8c115c76c4e2273d5c61b05e35f973dae455a8ee6a49dff6adff119c668c91c7fffde3cf0814991c7f1be25f2e7604fffac84a8d3b2ce94fbceb96e56586dbcf7067c8cb1fc6aa7d1a487fc8943837b32fc51aabf557dc7ad1ddd12de88c5bb4b5ac6c85ab7bfa9bbb04249f175fb1fa279a5c73ba3261f17135e5e9f7aba1f20fe7d61d63bf9f73121eb8aac973681eba4832860b9e97e518ac66eed1066dd982b3e4e2fcb4afaeb189bcd1631882c1c92194e0926b1a783f06179bd0d780d11b545a5d5a86aba132e016aa519c1e0d4ccc2a406a8d60e3e48fe6630d92079d41f20b2e9fd77a52b2281500334609d1963eb1bc12dcd6c9560fb8caa85cbaf915d42d92b4d3a28b90c51c55a2eb93b826e39811321fc94d6abf32c5d4e50862a140195b77f3290be1ea5f8b9703e8e54e245be8584790803e63e148b8ec831037d038f8f298cf9042c740ab0318e291ddd47fb7577463d06cb0863ad46c58f8c8161b362710f21b10ee048a50436050da103682e0d71ab267b65965a1a6a3c8a7b41d7102177579ecf268f43a9f35323e64ae6f0d2fb68e9884b8a4f2d868059370916801d321766ceef556357679f5332dd7d6ab7b08b56f1ea2e675a8ef43d98d2f1cdaf9dab241b0f26307f92da70c5b38a28b7bbcfee64a60b00839c5c22eadcc6566941926e4560429d68ab41a58e99628904d4b069766983f1b79fcdde2199ad9b7e382d3ec943b43153ccd22c4f50a0105bef55a4b9634f796db625fa9b3691d4d9892e7fd52637fce95fe109873840f1e151167894565954aa67b8705a5ef5d4d15bd52b5920578304435dcfa34594bbcb3d9eb76f15137f5501f91d8a11cfdf3e4e20d65b7ef6a9d174b80cdc8ff6e2e88be622b41b671c3a734019ea42c25048f6ed72c2fec74840264384e8b86cdcd78c0b401620de48ac8ce5acd3b1f218be661605b6e238c07dce7d6d5dd33d06864aa6a8e889dbd83dcb69da89310638761e107bf4ec8dec837be43ee3372c721426a567061316c5a54d47a0fca88b1e27bfd04c4b73a3be3f9181fb049e2cf272c8a305710dfc473a751e7a59b6a496fa45c828dd0af823a5dc5bd013dfb1e0dd855eeadc94eefdbf43aedf3dd6905371cc544bdbba8e08fe1b1cbf85c284b7910b686be226ecd2dc5a8b0e7515b04c5dd7c99b57a61144b47eeda17a421e872d87f495705b047be2db3f407f5194b8f04b9242e01f4a06ffe7a3cf5606c12d4fb86dde40394c3f6f9ceee9357008d735c7963f562cfecd82ab798cbb072a1b87fcfa2167e87d1304478c7c9532e83cd4ae0e97ba60b1f1bfc51d7aa891df28531adf96daf25e8355bd9ccef1084a5eb87a463a7fa8f4fc0ff9f8a85b5d6f72b9c8910686fec6789fe0275dca773e698d25ce1ed72998221b63f22f0ed4ad33aa92e294438e4c72b6efafb4717885c2db94d313a318740c130b54982d223409f81aa75d28942e1f5f2ab62f5bf4d698cf2c6201dea4be022020052ea2ae18751b75c24b8d9df27ac47a63a0acb6d0420e1935fa9f7bf497bffc1fa69e31e6c3ce263d4aaf2422c127232a52b19670aaaec8e834e6580f356772385c8b9e665cefc86e12e369e416af6340ea8819e3011c94467c119c694c104a37d322530e7d34c5d3c8186450ab3d06522182281419ab9c277cf4042aa8d380e93a49dda62f9dcc2770a3461fada3ca7a03395e23dd305ef6f05bcd4b4629e05da887504ff58e0c3b691fc425292685f754da701f728d498f9ab4559df9bbbc13d61f8724c06e5e3d4f83ae211c61ba71eae96bf76101d7b2f5a11db671df5fe04ecdb1379ee884adaa36789501b6e411867e54dc3ad7e770a6c11f06acdc5da4ecfae1379b7288e4cb13739d09951ff391871469f354b377b34e5dfb20ccf911167a994e376bda4c934c4de2e00262dbbfbde583d7731c9f9330e1f08884016b759c5d2d7c4afea6e9c9ec50e7c6663a11a6bc742da0677f26400fcab654aaa81e4cabeb0ae375085449429df7cf0de16354c4ceec803a305e5ab21e0cfba63163d3f9982addf03ff78d26bdd206943571819fbea1b923ddd5f13eeee4d3bb1f4a0f5b418de9b4d0cc5c20cea3a8be7cefbc79eaf0caa73c034629ab2744501b65efab0ad95416215ede2cd92bcf713f0bfadbcded3564015606d72ec83d361d501324d5c44ccf324b17a412e28306b9e934bf656b09ce07d4da77377c568a2414321a8fd03fb1ede378bc3485ea7d9d7d133b324e18a05091d14fcb4e64e07133eddede5e20d6040ab489acf8417fe025e995fd0188e0f204782cd5b4974c37ec06a97be7518f7dd30460edc75efe94797e83a39a2f4512889df0f828d1da8d486ff5df6c780668acaca429351c4a9f5f4ec761263ede6be2429628954c05050971397785d45e005f1a4bb9d124a9163af027e8881abe91264af73219dccfcf4d929aae699579bdfdb34a9377390829064f3925075c69b64f06744bc1a4abf4279eb09f12874a64e9cadfd69cfd6eedd7bd4063d6c7ac11c5650bab1a69658e73cf054fd0dd818ad52920c796acce623b74112b2f901db618288a63340ebb2453b89d5ed7c7de1ea3bc0079cfec05e84003476c5c314bb4b7c3a8922197b06e27ae1ca6cf50cf92ef87ee2040a2fc59dd64d584fc629c16511ad1203731f6f931425df17e7841f1e8a958770ca5a38a72e9ba9202196de91fac251d83a2126c3c53c1392f70d1ecdaa828ace261b440cb4ca2aa1a4ccc1f4edbfe2981288ba66cac0a47cb2667fe077d2cd75c08c80eceda94924a76460e68a8443a40aee4a517e790caa21db20e5b00c0e1a08d757f85ca235c8c26b5510e3b8c816953a0fbc547ea9db1a155a4cc936930ed9fad23249540fd9153f2ee9fc72860f1ad9cd6186e06e63b790d3ab297a0b8456358c228903d5f81bca8657ee9c67552ded934a521a9230f9c87d29f81072a13854f7d7ce5c45849f0bab6f8488078c8492e42145fe5bdc67b9afe4d9c78559c8487654c949110b363f8f46346f9b525b5e5dc4d15f3cd57724240b2bb463b562c150dd083b22a06190148b9f6f8952e028261017c82248746923b983ca377ac7f1f6f7c61705f2ac3a58de9279b3eee735ad05a99771b0e9401cc36042fdcc24de4bb4c97e5b9da49d4f160ab5d70d597bbf6f2ebe8a7727b4dfe3b43017eab2191e09b9f8f89291d7d094c340f853ab442e69c69cad1672a09a9020b0cb5fac08cd055f1cdde01d8445eaeca5e0781dbced9c14648f0fa5ce21769b11d58f1398a78954112222882ac062e3433b534ab8dfc9e6c4be8f2fb3106c11ce859cdec8f956b10c7d3832bcc26e470941b177294deb0ac774c8306017b444bd6190413ca73597e7dce06453a7ea9eefcb9c72261968d14e1d9e0d81b844d0806515e38163abce28e308050047cdfb8d44ebad1df010081f240e248cde34d46a8b407413491fea80439d960a84c2fb0c0456d370bdee63d8b0a07a9fdd17517018545efa46cb73b07bb3549cad1cac15dbdb8ed91aee827ff15c2f61cf450f7b47e56b521f9b18fe58c37ec0e13095a2ee359608118ee74021303a0f9898711b0ef7d9031647248d5719253e7d5ad334b2b6e69967dfb81e35f04cbb13a0256943d856be761e75469874d232f8ae834ce836edd5cf9d480b1d25e98751a93da05c864c6f5282002a1ed0c5df2e16f3d410ae6fb9b458756419018943314ec1e21608af9368947d095c560b53761bc85864d534d2f8e8ca5b5d0af05b650e97aedbd93e2065656f8ee5425f13c7eb8468101160dc14ae60e8df880aed6a9eacf5134e1424a28f02b587a04b4fdfab4625c69bc6321bd302dccdc861b3630640075a700d1c5e94d3ca9b79ef5dd8ca9e1db2dd8d539ea9cead0a4a2988a1ff4c2131d11141f308723891c621157b0470595a69288e8da05e6b471d8812c5c54429ff9632e74ac63f101838760a42fa258e6824804e643d27af1aa4d023220d36a420387c79eed99b15212ea0110c8498562289556adab12ab9495d27de9002389ca5df72dee5306d37dd20f6d59dcdcf2b90f02a6a5275a11824365f4f6d5e38d39558f4f06aa521d8aebbfbbb45f53266666545d546073b71358c95a76464f468c09ee14f7bdf83509f396ed3af7f8859ae2a1f95d21291f39376dba78fe9e84b6a5a0d06b30aa694c89415896f53a3541e60a56d4dc721ede6ecf0bcf5ab7770b36e35a885880404bc39dd1f19e832d31751c16d7ee4930ab862e5268e5c4598bd3732cb058bbe994d1f0941dea59f7b50b811ca8121d56790af368fb89af0852841020e5cb06795bd33dd28ca784a081e706624497ad0797fb6a550e5d274215f61aebf7561e5ff913b6872401a07867c3fc98686a5b4d79fc27256d114628b65e4fca483ac10729ce9ba6b79e8bf8288510b52f2a563fa9b6be8326e30dc5eaa4f3b7d120706a517256f862e0182f389c91ded6e9d1bc18b8413d0a8c53f6578182d4dd1d884027b99b63176305406908136df0a457b79be3642aece51af367c71f595b1cac2cd3295352d77cd69ef0aac5dce634a2544d811910ffa7e9701dbbb25a9b9e1a665600262226ae7aa6d2a7e5e4ad4dd911732b5332a52bf82bc0a8bdc1e53d89aa9a954181deae25dacca4c815cb0ce981fb1b9d0eea8c33977153059779ca986ad17aa7d6542f316df764b9c702091f758c043b2f193f7df9331b809002e520e9f73017be7f05ef349f6386dd53b4333d5891911fdc41579a3e18387e6a3882e2d6a73fd7432a84d0d5a5f813a35bc3d10a0aef2d465dac068d860d7b72f71c6a4f83122fdad725054ff3756d836bfd54bbf0084ba6e3103cac3c84160082b6ac0799d292e155a1d558a3b53416286f86115301766eaa83f617337b7e72a9a899666c7f0df3db4faa4860341fa9f67ca6603eb363396eb6624f4895a5714fbe66e973c6c7fce261157d78e799fa6dbb7ec90d8de8e08da93a1815774d81033a5fbbf76180823778673bd33310ffe12d18b173b1d36c0381bd45b494160d16155b24b0a8ab7228eeb08c99a89d45abfe1d7a5138b295aacf521dcbbe7ba7167591704f1ccacc8d1166bca8270f70005289a6ec80e4e781f027e8778e784488d2b85d628b6f2997a8db5a3fd59bc8c0f4cd9ea7bfcc905a918c9527ab6077ccbf446c1e6110535f0f25350b89a40f3070d96e53687c8181fe64ac5e5a3a8830787b3612f9059dd5d5652d0fdf14b7d5471dd935fa87e9ee33eadb4af08a4118d74e79e45893a20c62ad3d2f254bd2d08f66aca580d693aef4e84d9358e17c20908e0239764fa799e81e060d7f86b29ec45191b2d21392c808d14dfc4e3f2c7e0252b0460f6c370bcd99ced043dfe240b9bab99a62bff1049b1f8e3d1b0f926141dc98ee19620677ed226a65752df2601b359aeac94c36fe62b22d5300edb0533c79cb76c209a885195be920e34e9e64fc2bdc138d5cd2d5834e73cdb999cae631e951f48a07d5132a4a69132940f5f0f1ebbc0ab4ea6c6944c0506ef1fa3b98f4dfac47f69a7aa3b238a3c8bd8fe831f1f01e37c7990aafaead6d8bd4fb6f35fae2b167318e8d48087767efd761006c46f134ab5aaae6fa2f273eca57cc425fbac8684abcceb85e83d20f166467ca257914fbfd498ae43b2543a6e1c4fec3ba75de5bc4a608caaff02942f039701bb3e6f97779bbd0bcca3651d4a02f3c8dacd3f3e9944e060c8eb008a879ae67dd37ccba96a0e91292fbf7008448da57884a290ccfdde9bc082c4dc37c7880f934e20891cff0b1ea25024cf653c145050284d22ad18f9c75c7a484c38666f4401729baba2bc834b2c48caf78d9bc2d5627c94453ebb6429e827990c5073ee58900b556c81eb130f81357754e1349f5c2e594c54aab6ccbcc27620e2e6a1e3870a1825b9d33c4abe6af5f76ad48283f69eff7125aaca747c67e20eef84e36688a761bda5d72df11a08b3c21c5692c4809ceba9027d0ca90dbb6f9ba63a5181b90682a474ead3b7ee0064bc3d57e46fc27c087ef463b6a1bbb89facca55c6e5edfa7ae6b1e35713637dfdd2399ea1c062328567e405957863f644042f3bb9aac920a1774fa3198370b209375c7d02db88074d15e5429e1a25b99e871fa38fa5d9b7927b26eea6bad8e1b081e44e5d505a94cf80c71169dbd1c302e20c7e04e80b48063637d29183b5049a4b1854f5a3594867545f23933fa401e9b047a904ec78b5f4ed183a6114a80b4b009688fd011df469008bd0be9c532ab255189ae5d504b91ec5a4f5282b86e6dc603e8a93d25438f657f97e7c86cc6b4acf98905c2420f99d03e3faea00ba8d64d0729c93d9880e05e3d9830f62c6b0d3b3fb1b6e4e0d34ca9a3e00d87733bf506be24f426aa71933a17cd03b0866d9a203abd4a1109e302c4385bb1b3c6f43a0dabd1c07547109388beb6d40d8ab37e79e46197ac462ee84049ce79283a2a4cace234c4679241bb908bfa75c0b915cae93052e3d1a014ff003ef4d6a65c606273298c784b9888de415eff88b38f979d0761a3589da484799fcb6cff928a397acf769dcd4356a030bc026cf378918d592342cc8588815dde76fc0e88e95ee34f56a75bc0af556b8cdced3db04419d7bc2f3efe28933b87c61aac79189d91ea1b8e746007c2d75e5ad502b025fa7bd13c71978434aac28ba90e977975c54497119d54045054b230d6e066870e354e9da3d9a21c64f5c34126a8a6908cb6cc1a2396a1b9e1ec245bfad56fd035a5fac6396a6085ed7526391d0a70b02d09ad54865e37651361761fafa06e036d342a7c167f4d2f96a007a3e0c04b23a5c1b210602af6785620f03e094904523299ed351d3095931a54edfd31e3fb35c2105d2526647bd52b26ed9ac6f61512cabdbadba4a62bbc05e77033409a4cccf25c5e0aab8e3de3c500af33667ea9da585493596f81ec34f9b01777d7ebe6f466f64e962430ae5107dfd35974a8ddd825a1f9e1b016e9b7e0f7bc98ef556278e4bd2abea792c2ba134edb800658742a3f08c06b8bc259ead447076a4d2142772cafd4af8ba3a0663cc204bbfe6338c40e787d2b6b8c991c7cf9aed8f7f9f5b7e3a4da363ce30ba56bbe5b4e5d14f10e98d6baec2cc41f235413cc4ba04cc61f35ff504a8f88d65b6ab5c55fcf3fab8acab8b915a4a0b012855250822987a2de6f28c78be1c6a6e293c3988b1c3d19a9b71c94198a2bdf08adcefc3efbecaa529176e1b8b46521033dbc84081c797931bc556c761c01a6da15a2a13829adf0097f9db8740a6d2bf753d7c23ff831180d552b49a1556d6768938ea4d0d4b9b108f0a5ddef95fbf5f24abdc913b40db0b24e0536add714db15c3ce8158fbd31d96ca9ef5430dcb412f8d37832a299488f939194818fad852d0eb46976351720fbd261e6709c3641c4f9f4cdd9d857c209896beb4d24a3dbc78c1b4a71e7ae10f54accd6cdcb90db08904691dc96128c1a18b74fc69daa389dee754be03a5847a0e894b6b0665a997c407a37380075fb8df1ca9da3d49680a6d33680d96e802fe083efb6e8eaf5e8bdfbf3c1a5c4e9faabb0e88e7ef70afc27a39da3945753864317eb30d2036cbcf45f66a68e91b69413f44e9a9272d32233fc82da13d3bd55e9359f306f174b9c1ef576694fa90486b968a2ff581fbc442ac78d91df73c837281155febd0906a501c7b48723660c6e1b165f35c42f32aa1f2c677c6303f0e2979da776d131de00c60d3378dba5b4146b5fb55ddd05413599196fe6d0bb380bc7fb7e1a46683d0862a80eaec2a01590ef8216a7ff4873857638ceb1cf197fb400d982da9fda4fd153d0933630a06fd63f6765c5572f678eb58e2f6dca367e066412159010581ba23f87094d22211256d7791d7c884f4bc3fe2a17af0b1bbb5ee309ddd2e17e920cc3e3fa0a3563e64c8e927029b3812b772623ebc2e7f995e005d9fb4b5ca7f999f53c5c8bb66817534042cc87af3ba024e835ef6afd78046e6b5a6ead8dd176d980a4a36713abfc4eea2f39af78809e62c6eff33c9a16fcd48c1abbfafbd08215607cad15991a35eea64cdb2bcf2e13e5f493982ffe1057d910dc410ab2830ccfe67d0353a7549de0ccf871c71ca92ece751f2e09d1bd95bebc60e8c731a5da6fbd1982630c0d3ccdb5186581f230b5697c796afc492b7db1b9f105d11beca7b41b16ab1f9a9a26264246b189b5e2728728ce158083e3c5226a1244d508fb7023b490bd7aca36235a8c21a1251746d95663556c903c0aaf525d93d830f7634043e1eb28b1555ba4755b489e95c8490659681a0c59e682aee70b3fa6e0374e994db6649f6749a2ed431c4e20a1be074c5c82b582bdb8dbd01a8cc63a39bdb298e00730675f2709cb4575a57366a28352031bbc68ebc16cda8a69aedab86a8ef1cbd7e6dedd4e230b1f5f9ae81266759b94fe0827e5f87021548dcb339bce96c7e501d90c51ea40ea6d9279a6a645651b965a42410b95bac8f71d3945dfdb6f3b532c401aaa4b0443f2eaf46e7cedfedaa263d7f8c6924f73c9fade4b27626dd938359d4e3f9b66305e8b3f11edaf0b4730bec8b2b87c3f578939413ac24d7bb7e969036442c45a20d6c1b839514173e4f560a0decc1abfa10b58ab821d71e52e381de22e4eed5aae70dbf81c8df192a6663188d0faf5b93f29cf8b11d9b049359b0d25891fd898a0a3e399d33857b853d71b3ffbc6a2ade83aceb0386e3273611f71cbb5ea9207242f94ee359506e8aa46f74dbc5ff0487d81f5781c188171f436b7b2e6054789ce8fee8e49232f57f844f211bad82d54c8e6c9b21f6b1e704c815ef422d94a7fa44081c28d66cc8beeeaa5b7b6c7dcd88972f0f56a917fe7fa22469f2c04123e179290d1decaab476ee3a8fc9f4018022d2b84e1742e601d799c8d6e203e174b51f585b8fa528e2c8332ec889078872d69c9ac51c6ebff9f302bae1c06fccd55c4b1730c9b58f804771398dad06bb96cd23d5f9d187e1460c907b6c0b36ce029c9ce0efd35eff1fa631b833d7cc369f34e07b9e1dd736b305d3d3fb2ac89bd481621afd67011090d60b0134e40a4a6a775af134420b090d27f7529839fc8a466b2e3f16269ec03661944311379198ec912d3c154c5a4f4ee28727b82ab6daf85552796190c7f5a5d8f98b23ef00c5d542e774b22b8f4b474b1477b2ec0ac502216baf2d92dcd5532e2327d128832fe0cf658bfddca22d17767161025b1d60661f93acb03aece3ed54e6ec0771ee1886561b62efd571362dbc861b1f779fde09a6dccaf2d6782ef6bdb4d3539f90762067e0b125a179994c473fd0bc59bc7ca893e616a9df3150b745fb65f01bac77505ea91b8c2398a4b9e0209f1ebbbedf68c4eae296725aefb2621e635e43fc611ba9d7a66deaf4a2f03f7e07849a198ac9d8417d72a3def1780604b73da6e79e2e4d0ff4490a1b768a4ee7441f01171f912a9f586b54d30b9a7d33801704d0b8908f511445df4fb6f66ee2084db5355a43f7a9dafcc438a40aadfb5b9edf83fb3062436c27a8cab1649062601acb64d4458d4758d804bfc092994d7d56a746d12dbd001f4e87cb8af5745ae2ad3aa67ed689409a5c82914d802bb7cfd828ecb614c6a4c883521ce29773ee0265f8ea70104222309a648c4ef7c6d60aca1943029a47cbccac2fbad301ea1580b633daa4663f7260804d5300692f23bc7e7a3aebbd8ac27b2e1d21e1caa6ee9cf2d48a16d653efd649eb677b17216b535bd783f575d1eb491c8497de1b89ad304ccc3133b31fbaec003b64a7ba28f45b6a4e26f48e904c29f7f86802a7b35572237e577702d27659c08fcee5d5d9cc5574904dfe320d52c4500b42d2fc82fb631faa01665ec398594598f49de514d0739d452a63ab477c4209fe6894ee278552bc3958de3a2407d7077ba1567e8ae2b0a7b1b53d6ef3c4689eada328cb42d2a4392f6bfe43bd6d1388745dd8e9524565b78b24de4f819496744761c286cef681387a9c478e1ee9a44c5d12ed681eece9391466e9c03dd8c618cc95c0f71491775b72cf335981567f6aaa07cee286d66ab6b43b9251aa5da6b5dab75483df8a064bc9cd3416d476171f3a94d23678d483400c9a085afad730a2ce742d5200068cda5c6ad7db3400e223746bb3b3696be4c568a2643aa49c2a8fdfa842f2693f1ddb786126047d4e4000501ca36969bcd54253d03c291e33a344641e867c1187c713dbb2ca076beb039b1f1ee84b6943b8c9665a4e3b7a626bd63363496a00d4c584d9205109703e59eb5fb39f5df01bc2b219efa322514fb2740940862f30b7c0cd681623881a9f4814c93915df8e2fdae6fb72ec22f0f1fc7fec1fcfaedddcb3ccc81273dd165059a9b9c43c8320e80225aceb4b7e297a139eb728dc7046ca3fd4d2471d4be076f99ff9fa865b5793fc9029a626d9a95bc03a65e67d0aad214b509896e6b130780fb5884bc1d0dfc26374aa531ae28c91cf5c6293514ff9f76306204f2ca0cd7dcb3d0883d0d1b0faeb8c81bf0c9f3c7f75a1c33fb9c97fc57c65821aa1630afc2a2116122db015ef738982a90ee6a6677882117d05a95320247bae6657fbab73b0e9d7b6c3b95e90619d5e261167640810a2455d4a7b3a1b4f9da1952baee1f9a28cc4f812169b579e8eeac1b65b892899e7b66c98df746f15628f9f684d686c23dcdb4cc76300521e11d1b72046b5a6bed1ad04b12ad833636e420e77e34e81a31d1bfcce4218b65c211b52ce2ad853d8cd5c50f05e19a81992516d0138551421b36f890442b6916a709be918e90f84588a38f540478f3c78a6d230328c0ff12dc7e58f3fef083e44bf09f9eb44f3f5d6046ff8751e80179392bd8e8051159c9c6103aeaec350893ca57ff28a0dbab40f5a9016a2b72a55f5377fb2398b17e5e43b9ad91f644cac90c7b404743a1cb47d51582008d18681de03d00e074919da158b7c18f95c3d51179e9b131be7d6d03cf836c028a430f19e7adebd95c65b7e5e6bba3f0f3de08f8245c6c3f73efde1c91563e4f86370619b5ffb5b7d6f294ea59ca0a7eda6d50ba0d02f237c9e5e2c41fb9952c2b1af72257f1c89b2855ae9a27755de63ffed7c6c942e9d105e4a2fde52196564c8131287030c13ceff16a3ccf558d00f30a02c2229f5f0e4d3783aaa992a8022330ac3c848201e62184f240ab46f4304124a95adf2555043a41450cc3a2c79930c1230c616c8ab20f92610f51231766999c0adfb4bd481003125423f6b791cb2f8da4ae68c1158851aa77db8259327c1f0775a58b6ed5b1d4763ade355a44d3aab5a4893b5f8f7362ed7fe7b2bf015d94423ce21cf770205f3d02d95ad28007df82dea3e92100a4cca2322a2317e1b4d48be14e8bdad423157b197f3d4df385fb8745a18f02563bbf97618a8f7e2f55289d5f9a225104dfd6d980dc5ec536c7a7d91e09c6d2a84b97ab02e7feee07ad5bf644c3499dd3b22ed7bca33ce15a24b6903fc4018c1ed8f8deb14a2c34140cfa01fadf813ab9d236e2f97c0cab41202038fb781592d2b640a25050cb038f6a71dda9f8252beef7e083b607b8a3fc822a261410dea068b8aecf1109599d7260c89559818763f3f5bb1c5c28634b7b5d335d0baab6a335635d36a8e13775deb583c5b0324bbf161c1a7ae7883d2835dcbbe469d577d534dd3308bdd728cb047590174b520203b5f8acd3cebbac181aee93c49f3915f825361154c667b5c3f8f5a5968aa8ae5825a591cad783fc047ddd1a87ccc3074b581692dc41f76129b72a88576ed8fe4681399d290a050cdacd6cf3e6d33a71f74276a172a509855bd6e3cd5d2bf773d09630374d86f2f7c8962981962d177b50b951285cecbc87326f29b0ddb30b30f0cf98840aab79cd9abe61f1913305f8673a8d208b10c38926461ede91fc4a01656f5488fc02e6182cc87443a2a4103a3baf04061f606078b51b9aaaa9343d79768d64e41d41d933219d33a8e6edc33c70689411792faf11ba89a577b9f71fbeb9807c6300c18d655d9c8b3be1cee539a9d2b4dcd4a76e826b28c3ffdef9fe2cc5dcd52e57415de0506aa1fd37696230a9f3bde772a4732e9e3d5fc15ec551892d8fa532f36176d152168992ca1335c8100c4e86fe11b8d30373aadfccff40615eb1ea130c1846ad4b9293e03f5043d00731562043d25bb3c1dfbb6d7434612042725f1ebad31261fe983a0f895755d70f2183ad2ce30ddc50029d07662e7350e639ca6341cc5391b35b4fa8f4f0640529f0c7832e9797e2b73e334f09aa0dd9912b429eb5fbd62bf72c56dcfa637262f472f5d59e98b7102d2821be02cab4cad7efec7b27633f1542f927c9979b856a853ee6eaced88b28604d6e7056668463cfe6f62f2fdd9308b85474f1f83db973afae7a066c691f9cad4449948ce6342fed753f943fe084475fd880133a764f644ca19ab5a892b52041539bbc61e1edb715169a7fb9ed0668c84c2fe1f32aba26410fc195d307fb07f6db62cd3e523de0dbfa5238e9af257382c4dc38776f6f57304a510b949d9b137dcfbb9bda3965f942ddb1dbb3ce0f7a66e1f8f00715980a032e79386bd972e388c2b24e153827ba38fc37d2ab9abb4f1de2db598859439ef2c674a05d96bc5b514e0d1968b1544dbc5c2ede2343b59bd38a32872be0fea605e322f8c8785f953cd5903e500ca12e0aa370c4c62aecf4ca7c75a58b30cf216c01f08f21f59ef9db11b16fe50a80df30903abdd44371eee0fc68a4c1b781d63304924bd91ce7c6c82a8cfd8b395f6123bc47e5849bd75af0ab8369bf859caf99059f7a0d37def923c77725230493c88dfcd4a7cd8e7c6cd5be19472c3976f936e655aae8051f0d3584eacf4012b3f7c2f0d9f9a609146bdaa46b98e559c195ad812354f06d0a10d7369347b6603d43f85237e3d57f59b93a399510187a029646e7712dba2d3490065b542794af43287358bd4c952d1e511f5f409286e43d3891e78623679f12f034d6cdbf853f44bf5a8a0bdfcd9fc25b859d25825c0d469938c59019b641c2d3e90e82dbf31e3e14adec6c19bf1d9fe7f36cca1acd4a3dcb53675f9d591e297456b316651c961a6075e075523e96acc18f69f55c7450542cb655496a37f656a7386db388cd163d9df9866983389cb2975df0e415614963c970114dd141a8b5f492fe2c92ff5935804cba3cd9e7b6d5412753dbeeada769e285d8daa55afa6206fd03996d99217367127f401f4f745548786e6674a6485c40ea56d29ba914a6478d380ba13035b573bbaa6f0c05b463277aae85b8c0d7962389194b11d5ee461437d059c56b17875d72260a5f24fda68a5076a3ce49802e4846d2a635e6f45e11932c68206aba3732d427f9641f5abc2720d50b8e30b60bf3dade2c5b534caaefa767fbeb8be663a10ff9c29b02a283a9a288cafc8b7d35faf4ef5243276c3a166b1b115c8dc68553de188b632c92a2c46fa48d2356565098cd4d80f8f2de97e421bc8fd454ba114fb5a801c1ef2ebfbcaa819be5c660bad2fc6155e6be3b3924fd3557940ffbcadcfff4523607657e63287380467dd33945692093e3856a8a0c52dd59dbab709d28c9ba1d7d14bdc39c40066cc396627c5af33c3fdc0a20ae54e571963b39eca722e4045f1830c6a5000c374e85137888b97275c8d65ee9d554bbd7f6b9bc610e68ec35bd2dc5549788a980f9c55365351ef706a0a478da71a21af5e5f2cf440d58514c87784a8f5bfd23491aad2236341de7ce8d4c172c73336de7a25a95c460dd832fbacd5fa5f201c02333d6ac154f5ce26186eccccf1c4e59861f771d08eecedea033f6a6ae47691d06b4be0c1e521d53b8b9696a3fd4c25916f886e110fdde55cdb4c7d372e936eb5a383c295c93b896cf4a38e2683988c6615df4c058bf823263d371f6621efd41317300759e1e6b68f39f5d013c78e0b23f7d5abd300f5056506b0fda84a8c613bccfd1b1baec00ba565f3cff4bb3772adff230d78ad3bda3c1e60cc407e93cd894731f8cfb644e27da07f6d5663d9494e833b7f20f64f7695156c8a47c6c22e1bf0cc6a183083bf37f7bd211df0fe6d3b4e071ea7474a459268f3c3d7d3879dd2547ded32ae1e155a691d62de76c860a9387d805ae787a5636191eb003f7f8b6008c1b892d19d71d93fac9d20175dc34afa1e2f4d1803cf9ed9d00a8d1fbca3c1773974d245200c934203d909f5927356c5a164957666cfbbb64c3ac4d41f4171ebec60cb081a87211ee7e8a1fb5ec5b815307ef7cc7792e761d94e487fb9f35173686370b18752995beb9fa37459f383ac7c0dcde1d9f6287197ec65706e2ff117752e214b1cfc6bf606655ce9385167d24997d83b387fba17f661da6757b9393c21c16961d0fc0d64c9ee5d2a8e6bce03338023256c1d10f02fae4b35ba316dcfc6a16b6e6393e9480209bd18214bfcf941978817617f3164b51f99058e9696bc8a64261ba741644d9143b375282ac6e6bf60fee9bee6ae71cd06a9229daf68cacd2b8ca4ea74895bb4dfa0a83045b81c258e5f086a497b2bf10967bd42adda6f826281beda1482d0a08c8c95736882843a6a85905954fe3958dbf60df0a6ed633a1c83e2cf9146e97d33c3d15613571acc203ae7d58ec74764648b3f0985c37986df2db6333b5d870b3a978243691d04302c413358ee61b41ad34b8b74b41851e1a65644e8be0f0f992c3f194377f5b1b02ce469e3702762282f0954921186f6dd26cafad8211aac5ad405f5a47b532c642e2997d43ad97ca5c7b8fd9e7f2ab10ba131fa8094c3b3f0956df75cce405494ac574d42d0d32e462531d9140d4b081d2c53d3f6906cee2817311f80a820cf093795c0d616ebd0b7eab4466fbe010b9c8cda9f86c9f9eb9dc0c275b09469113558ca803d80762c948bcf9ecba018550fd9c678d64afaf37da0635e7873b997dc9a482e7d8bd1dd112d187a9419201bb10cf37ac13095e9a302c8f9903ed3a4767e29fb795fb9b9cdbc2f8ecde23f04edf669bf8f7d3ede3a3e65a118206bca5e7cbf1338332e76a377c95523fcc5583e704a4d2331331532d588f9dfadd288e63468a3d65eb0c4fbccab13649be06f2b08fb78753a14bc8c9bee60c4cd2677c4574328930338be40dab84c9a1a78f4a84d010a8a2d6133926e18e05705001253db01ffad3f198effe64b233c46ec73038ca9d9e728baa9d06d514af37752d799f556b1045c936b0bc07c9e4dd429b0cb90915ffeea25615e6c3c01e4cb7cdb95fc4ec0cfb1f0d4a3363ad6b238c98d531f6b5d5ae49f7a72f2d2e6bf53279994a4e5946e92d3d5ee82877426d089964a4e8f4bf66f53e728a61313b965db399bfb3240ad3f6ff8b82c1af7d8d75e950dbdb1bfbab07016b140c908be69dab462268e84d236ae5bf03e9b7b5ed13da41846a637bbc5de8a42eae0f7aaad4a5ad36f2c2329b29ae34a3ad0cfdf9aea2bb44081c70d5444fbf25daca8385b5824d3d4b40ed792c5f3034595a3c2c1127a2e8f619f275e310b6ae7d556e4e09595a41f012fa3243d0f0037cb4f3766014bad321dfdfff7c3a56cd6e3d91e83ba0c4c5b6822462b2e7dfca0a3ce01d4e50d499de4bc3581a807a56b90575d60cc90e48ed445535433d5f6ae5170dc7fe6280ad0f236197b74111517f7123c57c985c9fbccbb80132dfe2808249d9e3a3c03e86f3b13306ff570e8b543703d805155bb01365d987ceec432444262da8b3ca05a9f3da96154b2745a9270ff5f1fd96f7562ca0258a33c69c96e74268f93728eacbd969b4f0e642eb38186c6788077995812fd45b5f87ecb705c0fbb45b0ac4bfbbded32017e784a35b604561c9f70f0896ab9733f72ae51f2298ef381a80043c73b4241bb442d1ad767592da8e59f38c53c309e6bdda601ee9c606f061d471053381746bb887156300ba6f70561fea80a1d500512531763b0029de85fc717f93558cdb91fc81e0a3c47f9cc6fb2ef3ffc027822056a7f0f5cb9c21fb97c4bee6f969bda2156dc246831489d31d6d355826996ee87997be6657aec7a3365e69e62d14c74f9321a8bf72cc15921ca11565fb3764d60aaed299b1b2b13fa98860c7c2a8c799163c357327cd68439393646b74d433329f260eefbf8356765f99bd4298400e4bed309c43d525fb395d34614b1f7762f9a949da65fef76bfa0078bf3b1a6586a499f28c011ab85349587cc5f668ca4e78d054028ddab5e8107b1c01f5a795ee3b45eb97d6376dafde18694f51b00e3e720b6eae67ed2e605be33a04c6f4740fc7ce5e2697d97019b5d8d4a0f0cb1fb8399a2af2059eeb585c70ff7de78bc9d07fced76cb924bab63cd64dbd5febb38197cd8a5cb9787ece7036c04a06809a8e93729cfa09093fd41aa9eb580e05daaec3a49b5287b4fb151e5a013a740d8f5dd3e2611c3f7e38f927c0f9b0390325ef22c7f30eb8463cf7c037069e77b815ac4815b77496d46d25e82874103c89aa4fb807cf9309d2d61a72cae996120b7ae50a05ca2485b191dfffc5b9a99099cc74b050b26500eb4abe4aeb9da7c83559cc98c16d3a640120e44fef4ff1e6557705bc2e21f7aed2ad886cf3ea2f79669f643881f184163884f2939ba1cbbe4b1b140f372c6f94bcbc1203bcf86bb4bf2b27edf916efd74bf7011113f6f24e3083d4e60bf8b0c8ebbae745144545f98284c3b4376364e681adeb72d8322ed89426425b525a2da7c8e363bbf664b83db3c5aa6d7c693216a97f764c1bb0f06028f9f2e1e8ae93dfe29e33b462821f5b1141330655a7318f57ee53f8d0a6af1125439dc2cc1be0e2b4a7492370d1f83d2c3472ddee12eb8dc00be623435ae6f47acfccaca0a5e801107b1e803d1dea54f117f9206bf00c654c0f8f75bfdf432a5fd74408fba3284c43ef22b838d8ab5d07d9c99ad63369c0ff04a5f3301e7241cb85bef6648a5f7efc1d375553975ca31beb4e226a3aba1ae44c71d3ebb9236524ba160eff49ebbbc64f7c1e8ae3309d76faff275ea150e04981bcddba042b3ab244edac88d591033f070b297d2e9d8a6de0ca770e8f1c261cb4a81b7153c92972ce9963280bb2178f12e7e6a1296b4b7ca4c262df6ee240f68eb43a607a784cd5d66b219d3f276df77f02382f529bb3978014c7cb1f1ec7bdeb496b87faa4228a9796e81edbc513d1adaa5f14bb21187f84850e40e1c57d28f11a776cffff564a73dce16c8f4b64d7a37f588b1094a412f05193597068105a9299b4f0ae063e610253ce0526d85876abf9f62a02bc4aa42ec382a3f7077ca4f8c1c7f8b1c2daae6e1c84b7afd8b469f8df7d21b4e391d6e9e36fd5f7e29fac5bb60ec9a4e8e82e48d21d1a62d5c0c50df76a4733d4f26197a878a3a5c4a78f37b0280493e4ff474f00b46605d4e6707c4b6963369b5641322435a4b985728c2120d36d72479f69f57e304f970a3229ad9c2c6b3044e7e151ca0eaf1718e3f46400df12f0b9390de0de9febe9cfc47eee377571bcc093a1c3623b2e99ea827b9b83edf1938e573310239ac871aa48dc9a89b4a53f3bfe1ab36bf19b56dc84c4712e8328732087a7b751777e1d70f7f71390396f1134d29217cc584e48ea6d45284ca9db042e189670f6961ec4baa74fffe0d27b4c204629ab3fff2e6d42654b1d607cfebfec266b03f19e97862e379a3086ab91706b21ef79ba76a2e549655e54d6860161ca7c4e76ff63229531620d4ca87a13dcffaf8c01c45f0e72fab64780e3bbd71a6a20e7e25a62d03ab8328c1b7b086085f8e7b75451caf177fd4e424f3c1d7f670dd5ea9129ab41ae6f51da87494205062b7d26ce2566dc96091ffbfeeb82639bb18957e510f1190f4aeac678795df827e238a9c92da233b1bec1d86c9049d6a19b949a098d4174ff1c27c6a45c4bb649bab11c0a44814e22185c8800a65086c03791d3273c8858621581dee5be9bcf9c16c2ee99594832d2892463973278760d1aaf1a074a14277e040511f0ea7ad0714b31eb9edf94d2dc83103839ce64c4472859ce6e4c1889dd0e4c1879affc4a5a61ba83bd5ac324b72b8acaf9e2f44a1d872d599203993041b39576f01af043cab56d767525a9acbdb8384c72fa265229621b37f53bed73f97f65982fc1d0a701e3768a83661b42978719deebad53655282b1100d39adc73995fbe57aa0b5f18b502ff883f60c643f475df59a0b8241a6eba1dafc50491efa701a25b0bc97e327127bf946a2a8a2304ed932e0e132ab6b6ac10c08179333f34e5d66a2cfd4f466069c1c0ae66c8cc222776c663726bcc1c090c1172dd15e359790070a40cfeefbe05850b744ab204c7303e7a74a1d705b57c81799e243dad9ac4d1637bfbfc6b4607964543581d8cff76e3a9f36b6d93a64449159ccf44bf3e8908dcee7f35de93eb2d3d98176c47b2c9b9d16ff6b625e8332972dac5e7558925097168bd06bf7db5e58cd8538f8f9ebbd8c4743265c67982bfafa574f40a35043ee0ee0f28946e57def4e0127f7eb5225f8724a342443d9cd892c8003fd7af322390663351a54dc1362523722926e3e7dcc48a895ee18e0915fdbfbb67eabc592cc247434ac29fb328057da87e01a663b8734ee6134460d0a90d2cfcf75ece37cb2e080c198cfbdeaef8345cf81ddd67be4dc636794a7203f2c5cdfc5632aa8503f787dc86195bda0c3db3d5b533251ec69d3200b6e6b44244059fd1fe9f16de8b1ed09f126ae7e70c6e7c5016994b30f5e3f2b8549899b906defe3c877703f945f077603d0f3043b409b864c16a4f89a78b6027c835f32c9b967d8374cb605269aa279ac045598d57b79dbff51eb4cb59b180a1bfeb4ba055727c3ee4a3438a53a2d93e0e6cd1e48e3e31f430b9182bfb75f3ce16e6d628e2fd1c406b27bb8646ff737071f5d58edfbda6a6198fcd02284d5c6a0f5ce5f072223141e8dd84d3f3e89113a7f16cde3e85adaf7e72a0b4ad078ce398bbf00a465c9e93ad9cb469e06a5e08815cbdbf6cfd052ca7801bb9ff1f68e8618dcdd3555e0f37b7dbf64e65df4da29e9c96630aa237ac0950a29c5b20a9cb20a31e4a1d7fe71ae31aa9e52d6c5f2d55651b1f283c11b4e5dade98647b9f969c26057202bb49661d2c77fe33e5f82ae73970142f7f51def9b80c0923db33d0b72409c60e6c69b643023e2d2289ed707f735ed4cc5a792e87c04812de3bfa4207b0652018bfb9a3534703a1228d0cdc8da294193b5ca83fed6b50c866b58ddb17a43680b17e4156ae26bc1a6822c0613b11895605f895bc379d279f39624dbcc311db2369faa723040902908cba3226326a2c3e008d71bf203884b2d69b50d43503b165c2d912ccc812d9d5eba684c851b5839df42c886b2bc769ea6daf47dd407afc2694a6e66dfc1a5f389f7a287599311dba4f84284eaf6cc9fc36be478cda5d7d6418fac0180e4d5606cd117534ab75c6cfc43779be798318cbd8dd188cdf955bdf4bdf4bfda67011778e780398aec0a45685025d94af5a8ccee775d7c4d192735f1e4d90a860d6c3ad638d206883dcc969fb7ecff1ab8c4e457e08bd1bee4749de72370d55e9611120738dd792b0b17e0553b2c9393c641c6889deb045ddaa876b8ed2c25de3206cafd773f87435f2c3d0ef8ce9d0e04d3bd68d8d996c110628d97dc0e205a51556d95d04eea26d16629a84d92ad9244cf31b59261a6c46785dd03277de4d1950c5a2b103ac800d06eb7699aa1d30f8dc029af0847d014ec5aacbaebb576c464361be04cef24ca91d779f55bc079d59dd8041b0ab6510a2c4222fc34537c012eec3e4c8e29ce34d01a8bf847ba873995b79b6e0704ebff779617dc3e1cae9c255346c3e37cc05b5ed8c40b7cd7857b2f6d1d7295b2b7787d88644321852d85e12fdc175b6a1bacb6a5efd3f4e4c68bb4db9365b2050a68b1d5141745245cd799d7aaa378e47184832d3063f2f0fd2f504016d00ed8b98499cd3f0386d7519770119c685792e10ab32919e671d1b7268cb2dba8d6f36a538bc1ee0c2a54739dbcc5d8288e0580585d560a304e025ce423f40b003930c3cdf311cd6681468663a00a9fd0008048a85f62f802ef7c22b565daba49cf6fb84f2fb14a187ed378aaa361bbd4921857dae8cff72e39dd7c16fbb267f35dbafbbba30623f51dea583ff6a9d963c3444d76e93e67c72670cdf6fc64d35529b9cedea406651cdabb8191356b29200b1606caaf14479689c64a783d934bacfd901471447dac9517670f1ca236bc88476257ce263fc32f274e378b6aa4a6f3489b8c093713a1f437d030da5189ff4f2cb92dcd3ef87b553d420e93aed1bb07706ad38ace30faeb1a8b0faa1f27fb88df5b9777bbf103d363b57eddc7dc3885d773b702b00a04f9e3ddccb81747f983cf32494f979312e15fc9938113ea1519805e837e3e9c5d242c1c40fe596d199eb3bcbe24b6230639bf429f484826c8001de2e4d901dada261d2c56de52a9b7e78902fe2b5c020b65824ac7d9aad87b6bc1d52ae3fd69aa8419c088f99db36550d6c57566330e47aff80d677a5cfeadc859888e1ec381f23364525c03e2f1b3f40a174830a7d0980850fc65ef488260c3c3bdf52193429c5a1abb62cc87001fcc00040fa04cad8dea08b767633f732e5a1bf4f4a1043679dcb0167cc45d6482dd4df01337423b45bdf274d917e54c5266f8120dcfbf0f76c7a0ec05721a8fd75c9df5db0c1c21bde549a9425a12a68a8f3fa21fe8736d95bf183aaee711e45e2c63e1b542139a1278c1893305d94dd702a97d16863d55b0be19ad043e104947b67960ef5ae2c5376930317df0acce10b08c7682f05b56f5528523220a7aecd1d09070f92189c486851061fcc0694dde067146eadc05b5a69727f03f7965d503f9352d0b53fa530bd8be8a9b33ad462697b9afa9f1951e107b48d088afcdec3f5ec99d44abb0d53666eb205d4a9fb60886793fc5fa178652c87e3b6ac34930a3ea78ffcccf37e5603d0c7ebeb1dd51257bdaae0c6fb5f8d0e6e35eea7d1a8c7108ceab786f6b1c756b22fa012ba148c3eb61b53773228131ad179cf7fddf5b424e782b996e9abaebe7ef260def8b71f527e31645ff20dc7eb18fb87245354ae1c06bcb20803f45b77c01337656964b62ce1bd0afc1ce478830e395784f61b8e391c8c3e2954b1d8c0778070370302558ff32cce8329fffc4a134b7fd4f484f55261cdb32f90b67e673ddb4560140d222dafe3174e45398d6cf72374a9ac94a5c414af707f37d0670d873e84989d5179f8e826e857a0380e3a1b5307b48f8ffb6c8b50c12fd3b5e07238e239ea0489669d0f665b98c8d73525e545d03401b9610f6e72d64c0f82693c50d7b0e3f7c344a7da798987652bc5af91ac63b8b3c39989b2365059593a9da29c389fd0fd89b3a6959c92540902ca6507a32937be518581e5cf859a1500c70d21aa1813d276b6c74a6ed6b97add8dc4c283c592b367c8c5fdaa595b38b3b5f513d848960d4f96c8731bf70df82aab68214b38e2af6bc6c9e34aa9c00f645e8f7eedc677fce7dfb42595436a8cae3218d3f56e698a102a13c062d3d407b92ccbc3bdc29dd7dcdaf0181ba29bdcc9cda91a3622dd60968bad3efa30af8701b365f0d7e9665695452a4bddfb9437e4570ec5c5f9448da1743445537f05eeb872c48155b42cdcea7aafd119226f37ce2f4344f246e6e7c219ef33ad64f37bd794e7a295df5db8a5b438dcdc12b7d3fa4c72921ab26ac5af67a7502e7af25ede24cf645c6ea90742e7db416f3e869c174d68b1edb19345aec5d2a4fce12bd93416ae352337a97ff01c6e8c3dac046fb8415904af056470d16460442289d707758eb4ab8de977604509559eaf634c386fdb935351e989b7c52d8a4e140c6456d0172fcf6b59901fa695c2bfab7ec17dee12e6fd6e25c87a6cd1ea73f876eea0a7bad04424dcb9102403909ca4036fbe67709cfc2d35235c36344369bbd0df9b3a09bf539fe812fca3de8850a07ececbfed0dca679184deabc374186cc7aeddd82bb12707f571d8a0d07ca848827f86a2627f45f39b947aa780379b04440fea1c414418562070bbd6c7a39981d3070185ff41afe5b70b26abc61ebfe0c78bf577b50132c7de63894d00319a9ee07f5e4e41a773868d64d6c279d0b3a71173027706257efd7c60614fa0ec32e705895b03236f50a0174947513f789ec1ea7862f272875e875fdd6f35f10d9cc5fb67ecfbe3b78296b5a8f129b1a3c7034885b02cda8173c154ea189013ad07c0fcb778d5125820feb91aedeb8b4d43f01a2c69ef125a52884141f4e415487732c9dfda3c7347b4d1aa9c49ef337ebf8055d2d9d6927bb31af21bdcda0a4bd6de207fdf3e5ba5d449ec649eb5d92cb20d5b537548085fd807c6f10fb42d054aa5812f878d7f068e67d7adeee2204cab31bd3e8b4b07d148f27bb9b44e5ab39264776119a275c4aeb8159713cbbea03e22dd4ea4aff2a5cb0139578cb444dc4f7a09cae6cd5a9df167ca47169a2cde2a434edffcc86588811d14bab12c7752105753d40b03c2545ad2aedc2230b616687f4ffb7518c0cf4c06741d4ad343b10f4d5ba692f29421a0122db75eb266067587cd3b15301da3f9aac323545516b9b68e96078ce49cca8441daecae0ed1d1681f3a4cbb658b66cd1283f5e123b14979fc0b768ef510b3c90034637fcaa6f177ecd454b489fb2d3c9221475258d27b7bc8175ec52715e7b3ab0568ff309b92d73c557db5f730662016bd377720445bdaf29082c147517a4bf3eacb78804ce31e617dc6913774b87713921af2be73af6173aea6a03ff6901376a37ec6fdea7fa384727ce957db0b0c0f31b4126b0c30a5bb220c994c4902afe1275c64e82e720542f14320af6402ea1d4b8aadef47d3fab7e7450f53a84a1c7797e9f4ca137634979e38341826111f5f61e4d139b6a84bada1ebb62df178a7df332ff88399f0d3225dbdee5fc2a2316166dd24f4c9c3e5f251f97cff17dad736b3c9318f831e1df0190a5a91bc4a430dd2880e638fd53a2e54e2c4b62bd3dd1186cd1315b736eb0ef6b99e2f457058a3299fde596efb239a7cc6494da992d76cc9fef1ed03fb775df89835527c91537b4f9b2f384499da55bbee6089bd8437242af1d7cb2f4ac6ddfc19b2e3de78a7696ebb047e5ec4a74f08bcf4131c323383a968c83a9aab1b6677a3a0173a958b624930b2d0c192c1691e2ed7c5b3ddd7f7de20853877078893e0c7154a1839de0f49d892870aa28c308beb6c4c729f52d2cda0feb429d71cb5c618807169aee1e276edbdcb0c9277c573528c9a631266873d517a0f348a8073ebe50dc46e23545e71ca611bd596728924cf2ae9468874fbaad31b5fdd1eb0ffe1be5a8b95f7cc216ca1618ef4f6f903a1c75837a3ca468cb58d48c44a5580c02932551e5d8227d147f1abac9fcc2547864e29e3282e827d0824d9d173e3b1d0d148bc0aede6693548b20056cfaa96b2ea5f620fabfdb1d735bec5e3516b388b805a2eceb259129d1f8bd1b08260ef86ed8c618dfc525ad4d017b89bcc7779869fe5942c94c3acb30c73ada1397bec799976a6d56255f676258f8fac36e137bddd08ab3b770da985d698b81d7bfae56a19034c9655502ca08173e92b32498cc6d23628bdf3969d5e007242eefe88a19b53f712d84a00e0446ee7e43b252a62e68abbc375bfa195c69574c68f4287090c50b3eb97cf71be08bb2fd92aef33f40ce94983edfac2a76c40100f2065905b5d41011823100a4a19a9970a8dbdce93fcf6366677ea94869faab56c6c16d586ef02805bf0e500df8638394d9c0768ce9da1646e507af492d6f7171ba0ac7d48a062a7802e7dc3ea30fdf4039dfe43b81a52c4c3e2fa4851f0c2b78d80e149d6acf7f3127cc42cfb87c934556c9d82e65a40dae8a9e63bf63c332023650b19e65a7d21c85b320af15ba950bb589ac4643ce3abcd8eea9aec8c7e47a706849e14aaa4e4dbe016174ba45c158d6482bc5e62cc2a3d45fc86b90c31be054c01d7b23200e3b0aaed7df63094463593cccf04e14ad28525d56de905f0861382661d516a7ba9279b2ff2074f63e4eab1109f23ee6fd1eaa79cb94c2011da6f5744d5151c868ecc8a07e644d2b3c3f05e28484d0df67227f11674461294efceed453685a8e860e3da7e31a552a7928e78186ce775e41d955ffe100be993eb5b5239d53088023c8d48adf80ebc67b81f8b3262eb6a840f21fc82d2e0f50f84dc017fd2fe0ea4668165ba70d42605e9d258e82b040cee9c0f9fa4397a59c8a7bad9de79f9b12c1ee72bbd152dc255d46e6ea52f25cea751995ea3d3e20ebf014f4241bcaf32a1347e663fec674b8e0cd2c83f269d3e755864c479e537614a0838c5d77ec0fb39030d95c804df5c9b48786b64dfc2e5d77002761a5524029c7ec2f4e765afc200f180430a635c2b907dc5b29c07f06833ab0f6e90dda29a4727e661e86e3676fc50c7f00c2b56912ed140dec18a365996889405b2265f16505c0adebffcc33e1459737a4073f8e68ea14b6b2c08449c74912950a02712f349bdb5bf96997020402b6c02d66c3c156a88a26b711c6350584708b3dcc4ae5a674deba2f29095808736a22f723b6e0b9c50460b275618ea0a6c9f242378405b4ec54f643941cbce31ff3cfa0b9848da825cecf27daae5d5e604ce3fda4f05284742de9459c30c0048813dcc82b2d35825cad3652bdc185fd477eada94a8865a26ffd6af80a148bd963ad8a1f2c741ed9f1600058f158a3fc7f21fb8216ed17005ec1725dc1a4256d6e89f56e27c54716fe40b3f64e40003e59e605f42f9fee4f590740713935462e823b59ed8fb337b92e27e12a9dc28ef0a4314401e7efa38cd10c2b9c874b3849c340ff87f7e2ec658fb5ba2ec8fd22e964a31c9dae0288cdceb5d05eaf7eb9d8d9dc4f845a3614575bea771b291aaf95daef014e588fe2eb8712b1cdac4af3af3f9ac994b89db1af09587b621a24dec41ae2867fe9812c4fb253a4df8823e784807e29c429b1c7f16cf50201106098b7122128fefda9631c6071596bd667e21c98f951c6c5a90f558b6f8f4159ebf2551b646b345443eea581c0f3845e1ef48ccf57538102170108dc430cc59c829907cfb329cf15dd0c2f525f6997f2914047ba82ea837b53343ee5a6f2f6a81df3a2e853aa750e421a658898f6fc373c842e10fd29615375459e2e4d69fb2a8c1f19d75c3e93543e937b3b5d5d5b2a3b4fb7e43b6714c3587b2a7286418ceb082a7704786e6e53c719ae65d516e9695998ff5b2ada68433cc99540eea88a6e966b775e3decd0554bfa86777af559135a1db68560637dfcd796eba9cdbc6870763e8742ba0d76cf151c73e7c554536614997aa8ac7bc984fd86ff4d4a287b1614a15776e89f96f834cfd0cbe21980436b476aa875ce500</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《算法竞赛进阶指南》第五章 读书笔记</title>
      <link href="/2022/11/17/%E3%80%8A%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97%E3%80%8B%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/11/17/%E3%80%8A%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97%E3%80%8B%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul><li><p><del>可爱的数据结构!</del></p></li><li><p>竞赛复健,自用向整理</p></li><li>为简约文本,代码均省略开头部分</li><li>书中所有例题均在acwing上可以找到</li></ul><h3 id="0x40-数据结构进阶"><a href="#0x40-数据结构进阶" class="headerlink" title="0x40 数据结构进阶"></a>0x40 数据结构进阶</h3><h4 id="0x41-并查集"><a href="#0x41-并查集" class="headerlink" title="0x41 并查集"></a>0x41 并查集</h4><ul><li><p>定义: 一种用于动态维护若干个不重叠集合的数据结构</p></li><li><p>支持的操作</p><p>1.Get: 查询一个元素属于哪个集合</p><p>2.Merge: 将两个集合合并为一个集合</p><p>我们使用一个树状结构来存储每个集合,树上的每个节点都是一个元素,树根即为代表元素。</p></li><li><p>优化方法</p><p>1.路径压缩: 一个个往上找树根显然效率太慢。因此我们在每次执行Get操作时,把访问过的节点全部指向树根,这种优化方法就称为路径压缩。每次Get的均摊复杂度为$O(logn)$</p><p>2.按秩合并: 又称启发式合并。即在每次合并时都选择将小的集合合并到大的集合上。单独采用按秩合并的均摊复杂度也为$O(logn)$,但同时采用路径压缩和按秩合并优化的并查集,每次Get操作的均摊复杂度可以进一步降低到$O(α(n))$,其中$α(n)$为反阿克曼函数,其在$n&lt;2^{10^{19729}}$的时候都满足$α(n)&lt;5$,增长率非常慢,可以当作常数看。</p><p>一般来说,在算法竞赛中只需要采用路径压缩即可,代码见下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fa[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) fa[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Get</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x==fa[x]) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">return</span> fa[x] = <span class="built_in">Get</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(<span class="type">int</span> x1,<span class="type">int</span> x2)</span></span>&#123;</span><br><span class="line">fa[<span class="built_in">Get</span>(x1)] = <span class="built_in">Get</span>(x2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>例题: 程序自动分析</p><p>先把相等的数合并到一个集合中,再判断不相等的数是否合法,用一个并查集来实现即可。这里数比较大,需要先离散化一下(从此题也可以发现,并查集擅长维护具有传递性的关系)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fa[MAXN&lt;&lt;<span class="number">1</span>],n,T,b[MAXN&lt;&lt;<span class="number">1</span>],cnt,c[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">condition</span>&#123;</span><br><span class="line"><span class="type">int</span> x,y,e;</span><br><span class="line">&#125;a[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++) fa[i] = i;</span><br><span class="line"><span class="built_in">sort</span>(b+<span class="number">1</span>,b+cnt+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(b[i]!=b[i<span class="number">-1</span>]) c[++top] = b[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=top;i++)&#123;</span><br><span class="line">b[i] = c[i];</span><br><span class="line">&#125;</span><br><span class="line">cnt = top;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> l = <span class="number">1</span>,r = cnt;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line"><span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(b[mid]==x) <span class="keyword">return</span> mid;</span><br><span class="line"><span class="keyword">if</span>(b[mid]&gt;x) r = mid<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Get</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x==fa[x]) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">return</span> fa[x] = <span class="built_in">Get</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(<span class="type">int</span> x1,<span class="type">int</span> x2)</span></span>&#123;</span><br><span class="line">fa[<span class="built_in">Get</span>(x1)] = <span class="built_in">Get</span>(x2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">T = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line"><span class="type">bool</span> check = <span class="number">1</span>;</span><br><span class="line">n = <span class="built_in">read</span>();</span><br><span class="line">cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">a[i].x = <span class="built_in">read</span>(),a[i].y = <span class="built_in">read</span>(),a[i].e = <span class="built_in">read</span>();</span><br><span class="line">b[++cnt] = a[i].x,b[++cnt] = a[i].y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Init</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i].e==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">Merge</span>(<span class="built_in">Query</span>(a[i].x),<span class="built_in">Query</span>(a[i].y));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i].e!=<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">Get</span>(<span class="built_in">Query</span>(a[i].x))==<span class="built_in">Get</span>(<span class="built_in">Query</span>(a[i].y)))&#123;</span><br><span class="line">check = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(check) <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>“带边权”与”扩展域”并查集</p><p>例题: 银河英雄传说</p><p>并查集所构成的集合是树形的,因此,我们可以给每条边加上边权。定义每条连向自己父亲的边代表二者之间的距离(包括父节点),在每次路径压缩时更新边权,并维护每个集合的大小,每次合并时增加一条大小为父集合大小的新边即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n,fa[MAXN],d[MAXN],T,size[MAXN];</span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Get</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(fa[x]==x) <span class="keyword">return</span> x;</span><br><span class="line"><span class="type">int</span> root = <span class="built_in">Get</span>(fa[x]);</span><br><span class="line">d[x]+=d[fa[x]];</span><br><span class="line"><span class="keyword">return</span> fa[x] = root; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Merge</span><span class="params">(<span class="type">int</span> x1,<span class="type">int</span> x2)</span></span>&#123;</span><br><span class="line">x1 = <span class="built_in">Get</span>(x1),x2 = <span class="built_in">Get</span>(x2);</span><br><span class="line">fa[x1] = x2;</span><br><span class="line">d[x1] += size[x2];</span><br><span class="line">size[x2] += size[x1];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=MAXN;i++) fa[i] = i,size[i] = <span class="number">1</span>;</span><br><span class="line">T = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line">cin&gt;&gt;c;</span><br><span class="line"><span class="type">int</span> x = <span class="built_in">read</span>(),y = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">if</span>(c==<span class="string">&#x27;M&#x27;</span>)&#123;</span><br><span class="line"><span class="built_in">Merge</span>(x,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">Get</span>(x)!=<span class="built_in">Get</span>(y)) cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x==y||d[x]-d[y]==<span class="number">0</span>) cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="built_in">abs</span>(d[x]-d[y])<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>  例题: P5937 [CEOI1999] Parity Game</p><p>  区间问题不太好做,考虑转化: 可以发现若区间$[l,r]$的有奇数个$1$,则前$l-1$个数和前$r$个数中的$1$的个数必定相同,反之,则必定不同,且该关系具有传递性。考虑把每个变量$x$拆成两个节点$x_1$和$x_2$,分别代表$x$为奇数的集合和$x$为偶数的集合,每次判断对应条件是否成立,并合并对应集合</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n,m,cnt,tot,fa[MAXN],a[MAXN],c[MAXN];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ask</span>&#123;</span><br><span class="line"><span class="type">int</span> l,r,id;</span><br><span class="line">&#125;q[MAXN];</span><br><span class="line">string s;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Get</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x==fa[x]) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">return</span> fa[x] = <span class="built_in">Get</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">fa[<span class="built_in">Get</span>(x)] = <span class="built_in">Get</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">discrete</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">sort</span>(a+<span class="number">1</span>,a+tot+<span class="number">1</span>);</span><br><span class="line">n = <span class="built_in">unique</span>(a+<span class="number">1</span>,a+tot+<span class="number">1</span>)-a<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">lower_bound</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>,x)-a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n = <span class="built_in">read</span>(),m = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">q[i].l = <span class="built_in">read</span>(),q[i].r = <span class="built_in">read</span>();</span><br><span class="line">a[++tot] = q[i].l<span class="number">-1</span>,a[++tot] = q[i].r;</span><br><span class="line">cin&gt;&gt;s;</span><br><span class="line"><span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">&#x27;o&#x27;</span>) q[i].id = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> q[i].id = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">discrete</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++) fa[i] = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="built_in">Query</span>(q[i].l<span class="number">-1</span>),y = <span class="built_in">Query</span>(q[i].r);</span><br><span class="line"><span class="keyword">if</span>(q[i].id==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">Get</span>(x)==<span class="built_in">Get</span>(y)||<span class="built_in">Get</span>(x+n)==<span class="built_in">Get</span>(y+n))&#123;</span><br><span class="line">cout&lt;&lt;i<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Merge</span>(x,y+n),<span class="built_in">Merge</span>(x+n,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">Get</span>(x+n)==<span class="built_in">Get</span>(y)||<span class="built_in">Get</span>(x)==<span class="built_in">Get</span>(y+n))&#123;</span><br><span class="line">cout&lt;&lt;i<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Merge</span>(x,y),<span class="built_in">Merge</span>(x+n,y+n);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  例题: 食物链</p><p>  食物链是环形的,因此考虑把每个点扩展为”同类”,”天敌”,”食物”三个集合,每次加入新条件后进行集合合并即可</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n,k,x,y,cnt,d;</span><br><span class="line"><span class="type">int</span> fa[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Get</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(fa[x]==x) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">return</span> fa[x] = <span class="built_in">Get</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">fa[<span class="built_in">Get</span>(x)] = <span class="built_in">Get</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n = <span class="built_in">read</span>(),k = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>*n;i++) fa[i] = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">d = <span class="built_in">read</span>(),x = <span class="built_in">read</span>(),y = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">if</span>(x&gt;n||y&gt;n) cnt++;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(d==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">Get</span>(x+n)==<span class="built_in">Get</span>(y)||<span class="built_in">Get</span>(x+<span class="number">2</span>*n)==<span class="built_in">Get</span>(y)) cnt++;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">Merge</span>(x,y),<span class="built_in">Merge</span>(x+n,y+n),<span class="built_in">Merge</span>(x+<span class="number">2</span>*n,y+<span class="number">2</span>*n); </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">Get</span>(x)==<span class="built_in">Get</span>(y)||<span class="built_in">Get</span>(x+<span class="number">2</span>*n)==<span class="built_in">Get</span>(y)||x==y) cnt++;</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">Merge</span>(x+n,y),<span class="built_in">Merge</span>(y+<span class="number">2</span>*n,x),<span class="built_in">Merge</span>(x+<span class="number">2</span>*n,y+n);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="0x42-树状数组"><a href="#0x42-树状数组" class="headerlink" title="0x42 树状数组"></a>0x42 树状数组</h4><ul><li><p>定义: 一种用于维护序列前缀和的数据结构</p></li><li><p>原理: 把一个整数$x$拆分为若干个$2$的整数次幂,即$x = 2^{i<em>1}+2^{i_2}+\cdots+2^{i_m}$,假设$i$递减,进一步将其划分为若干个小区间,即为: $[1,2^{i_1}],[2^{i_1}+1,2^{i_1}+2^{i_2}],\cdots [\sum\limits</em>{k=1}^{m-1}2^{i<em>{k}}+1,\sum\limits</em>{k=1}^m2^{i_{k}}]$,可以发现,以$R$为结尾的区间,其区间长度就等于lowbit(R),即最小的$2$的次幂。</p><p>设$c_i$保存序列中区间$[i-lowbit(i)+1,i]$中所有数的合,如果把数组$c$看作一个树形结构,就会像下图这样,其中,每个节点$c[i]$的父节点即为$c[i+lowbit(i)]$:</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/vbrr8g2v.png" alt=""></p><center>早期写的sb博客《树状数组的两个小推论》里做的图</center><p>基于上面这种思想建立的数据结构,就称为树状数组(Binary Indexed Trees)。</p></li><li><p>支持的操作:</p><p>1.查询前缀和: 像上述思想那样,若要查询区间$[1,x]$,的前缀和,只需将$x$分解为若干个2的整数次幂,然后累计$c$数组的和即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(x)&#123;</span><br><span class="line">sum+=c[x];</span><br><span class="line">x-=<span class="built_in">Lowbit</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>2.单点增加: 给序列中的$a[x]$加上$y$,同时正确维护前缀和。根据上述的树形性质,只有节点$c[x]$与其父节点包含$a[x]$,因此只需要从节点$c[x]$开始,一路向上修改即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(x&lt;=n)&#123;</span><br><span class="line">c[x]+=y;</span><br><span class="line">x+=<span class="built_in">Lowbit</span>(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.O(n)建树: 用处不大的方法。正序扫描序列,用子节点去更新父节点的值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">x = <span class="built_in">read</span>();</span><br><span class="line">c[i]+=x;</span><br><span class="line">fa = i+(i&amp;-i);</span><br><span class="line"><span class="keyword">if</span>(fa&lt;=n) c[fa]+=c[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>计算逆序对个数:</p><p>定义一个权值数组,然后倒序统计即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">f1[i][<span class="number">0</span>] = <span class="built_in">Query</span>(a[i]<span class="number">-1</span>);</span><br><span class="line">f1[i][<span class="number">1</span>] = <span class="built_in">Query</span>(maxa) - <span class="built_in">Query</span>(a[i]);</span><br><span class="line"><span class="built_in">Add</span>(a[i],<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>例题: 楼兰图腾</p><p>每个点的横纵坐标都不相同,因此只需要计算出每个节点左右大于/小于该节点$y$坐标的点的数量即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[MAXN],n,c[MAXN],maxa;</span><br><span class="line"><span class="type">int</span> f1[MAXN][<span class="number">2</span>],f2[MAXN][<span class="number">2</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ansv,ansn;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x&amp;-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(x)&#123;</span><br><span class="line">sum+=c[x];</span><br><span class="line">x-=<span class="built_in">Lowbit</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(x&lt;=n)&#123;</span><br><span class="line">c[x]+=y;</span><br><span class="line">x+=<span class="built_in">Lowbit</span>(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i] = <span class="built_in">read</span>(),maxa = <span class="built_in">max</span>(maxa,a[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">f1[i][<span class="number">0</span>] = <span class="built_in">Query</span>(a[i]<span class="number">-1</span>);</span><br><span class="line">f1[i][<span class="number">1</span>] = <span class="built_in">Query</span>(maxa) - <span class="built_in">Query</span>(a[i]);</span><br><span class="line"><span class="built_in">Add</span>(a[i],<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="built_in">sizeof</span>(c));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">f2[i][<span class="number">0</span>] = <span class="built_in">Query</span>(a[i]<span class="number">-1</span>);</span><br><span class="line">f2[i][<span class="number">1</span>] = <span class="built_in">Query</span>(maxa) - <span class="built_in">Query</span>(a[i]);</span><br><span class="line"><span class="built_in">Add</span>(a[i],<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">ansn+=(<span class="type">long</span> <span class="type">long</span>)f1[i][<span class="number">0</span>]*f2[i][<span class="number">0</span>];</span><br><span class="line">ansv+=(<span class="type">long</span> <span class="type">long</span>)f1[i][<span class="number">1</span>]*f2[i][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ansv&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;ansn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>例题: 一个简单的整数问题</p><p>区间修改+单点求和。利用差分的思想,使用树状数组维护该序列的差分数组,对于区间$[l,r]$的修改,改动节点$c<em>l$和$c</em>{r+1}$即可,对于单点求和,计算其前缀和即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n,m,a[MAXN],c[MAXN],x,y,z,C;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x&amp;-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(x)&#123;</span><br><span class="line">sum+=c[x];</span><br><span class="line">x-=<span class="built_in">Lowbit</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(x&lt;=n)&#123;</span><br><span class="line">c[x]+=y;</span><br><span class="line">x+=<span class="built_in">Lowbit</span>(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n = <span class="built_in">read</span>(),m = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">a[i] = <span class="built_in">read</span>();</span><br><span class="line"><span class="built_in">Add</span>(i,a[i]-a[i<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">cin&gt;&gt;C;</span><br><span class="line"><span class="keyword">if</span>(C==<span class="number">2</span>)&#123;</span><br><span class="line">x = <span class="built_in">read</span>();</span><br><span class="line">cout&lt;&lt;<span class="built_in">Query</span>(x)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">x = <span class="built_in">read</span>(),y = <span class="built_in">read</span>(),z = <span class="built_in">read</span>();</span><br><span class="line"><span class="built_in">Add</span>(x,z),<span class="built_in">Add</span>(y+<span class="number">1</span>,-z);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>例题: 一个简单的整数问题2:</p><p>区间修改+区间求和。我们设$b$表示原数组的差分数组,那么查询前$x$个数的和的表达式就为:</p><script type="math/tex; mode=display">\begin{split}\sum\limits_{i=1}^x\sum\limits_{j=1}^ib_j & = \sum\limits_{i=1}^x(x-i+1)b_i  \\& = x×\sum\limits_{i=1}^xb_i - \sum\limits_{i=1}^x(i-1)b_i\end{split}</script><p>因此,我们只需要在树状数组中维护数组$b_i$的前缀和和$(i-1)b_i$的前缀和即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n,m,ind,X,x,y,z,fa;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> sum,sum2,S,S2,c[MAXN],b[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(x&lt;=n)&#123;</span><br><span class="line">b[x]+=y;</span><br><span class="line">c[x]+=y*ind;</span><br><span class="line">x+=x&amp;-x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">sum = <span class="number">0</span>,sum2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(x)&#123;</span><br><span class="line">sum+=b[x];</span><br><span class="line">sum2+=c[x];</span><br><span class="line">x-=x&amp;-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> X*sum-sum2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n = <span class="built_in">read</span>(),m = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">x = <span class="built_in">read</span>();</span><br><span class="line">b[i]+=(x-y);</span><br><span class="line">c[i]+=(<span class="type">long</span> <span class="type">long</span>)(i<span class="number">-1</span>)*(x-y);</span><br><span class="line">fa = i+(i&amp;-i);</span><br><span class="line"><span class="keyword">if</span>(fa&lt;=n) b[fa]+=b[i],c[fa]+=c[i];</span><br><span class="line">y = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">z = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">if</span>(z==<span class="number">2</span>)&#123;</span><br><span class="line">x = <span class="built_in">read</span>(),y = <span class="built_in">read</span>();</span><br><span class="line">X = x<span class="number">-1</span>;</span><br><span class="line">S = <span class="built_in">Query</span>(X);</span><br><span class="line">X = y;</span><br><span class="line">S2 = <span class="built_in">Query</span>(X);</span><br><span class="line"><span class="built_in">write</span>(S2-S),<span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">x = <span class="built_in">read</span>(),y = <span class="built_in">read</span>(),z = <span class="built_in">read</span>();</span><br><span class="line">ind = x<span class="number">-1</span>;</span><br><span class="line"><span class="built_in">Add</span>(x,z);</span><br><span class="line">ind = y;</span><br><span class="line"><span class="built_in">Add</span>(y+<span class="number">1</span>,-z);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>例题: 谜一样的牛</p><p>设$a<em>i$表示小于第$i$个数的数量,可以肯定的是,第$n$个数的大小是确定的。对于第$n-1$个数的大小,若$a</em>{n-1}≥a<em>{n}$,则说明第$n$个数一定比他小,第$i$个数的大小就是$a</em>{n-1}+2$,反之就是$a_{n-1}+1$。以此类推,第$a_i$个数就是目前”没用过的”的数里第$a_i+1$大的数。我们可以用树状数组维护前$i$个数中没用过的数的数量,每次二分查找其值即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n,a[MAXN],b[MAXN],c[MAXN],vis[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Lowbit</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x&amp;-x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(x&lt;=n)&#123;</span><br><span class="line">c[x]+=y;</span><br><span class="line">x+=<span class="built_in">Lowbit</span>(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(x)&#123;</span><br><span class="line">res+=c[x];</span><br><span class="line">x-=<span class="built_in">Lowbit</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">Add</span>(i,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) a[i] = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line"><span class="type">int</span> now = a[i]+<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> l = <span class="number">1</span>,r = n;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line"><span class="type">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">Query</span>(mid)&gt;=now) r = mid; </span><br><span class="line"><span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Add</span>(l,<span class="number">-1</span>);</span><br><span class="line">b[i] = l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cout&lt;&lt;b[i]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="0x43-线段树"><a href="#0x43-线段树" class="headerlink" title="0x43 线段树"></a>0x43 线段树</h4><ul><li><p>定义: 一种用于动态维护区间信息的数据结构,结构见下图:</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/r0ivwet5.png" alt=""></p><p><del>虽然我知道放这图没啥意义但是上面的树状数组放图了那线段树也放个吧</del></p></li><li><p>模板: 区间修改+区间求和</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[MAXN],n,m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;</span><br><span class="line">tree[node].val = tree[lson].val+tree[rson].val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">tree[node].l = l,tree[node].r = r;</span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">tree[node].val = a[l];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>; </span><br><span class="line"><span class="built_in">build</span>(lson,l,mid);</span><br><span class="line"><span class="built_in">build</span>(rson,mid+<span class="number">1</span>,r);</span><br><span class="line"><span class="built_in">pushup</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!tree[node].tag) <span class="keyword">return</span>;</span><br><span class="line">tree[lson].val+=tree[node].tag*(tree[lson].r - tree[lson].l+<span class="number">1</span>);</span><br><span class="line">tree[rson].val+=tree[node].tag*(tree[rson].r - tree[rson].l+<span class="number">1</span>);</span><br><span class="line">tree[lson].tag+=tree[node].tag;</span><br><span class="line">tree[rson].tag+=tree[node].tag;</span><br><span class="line">tree[node].tag = <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tree[node].l&gt;=l&amp;&amp;tree[node].r&lt;=r)&#123;</span><br><span class="line">tree[node].val+=(tree[node].r-tree[node].l+<span class="number">1</span>)*val;</span><br><span class="line">tree[node].tag+=val;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pushdown</span>(node);</span><br><span class="line"><span class="type">int</span> mid = (tree[node].l+tree[node].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(mid&lt;r) <span class="built_in">modify</span>(rson,l,r,val);</span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid) <span class="built_in">modify</span>(lson,l,r,val);</span><br><span class="line"><span class="built_in">pushup</span>(node); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tree[node].l&gt;=l&amp;&amp;tree[node].r&lt;=r)&#123;</span><br><span class="line"><span class="keyword">return</span> tree[node].val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>,mid = (tree[node].l+tree[node].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">pushdown</span>(node);</span><br><span class="line"><span class="keyword">if</span>(r&gt;mid) res+=<span class="built_in">query</span>(rson,l,r);</span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid) res+=<span class="built_in">query</span>(lson,l,r);</span><br><span class="line"><span class="built_in">pushup</span>(node);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n = <span class="built_in">read</span>(),m = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i] = <span class="built_in">read</span>();</span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="type">int</span> l,r,mode,v;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">mode = <span class="built_in">read</span>(),l = <span class="built_in">read</span>(),r = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">if</span>(mode==<span class="number">1</span>)&#123;</span><br><span class="line">v = <span class="built_in">read</span>();</span><br><span class="line"><span class="built_in">modify</span>(<span class="number">1</span>,l,r,v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">query</span>(<span class="number">1</span>,l,r));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>例题: Can you answer on these queries III</p><p>经典题。维护三个信息: 从区间左端开始的最大字段和,从区间右端开始的最大字段和,区间最大字段和。合并的方式也很显然,不具体展开了</p><p>这里有一个小trick,将查询函数的返回值定为区间结构体,这样一来就不用写好几个函数进行计算了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[MAXN],n,m,x,y,z;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st</span>&#123;</span><br><span class="line"><span class="type">int</span> l,r;</span><br><span class="line"><span class="type">int</span> Lmax,Rmax,max,sum;</span><br><span class="line">&#125;tree[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;</span><br><span class="line">tree[node].sum = tree[rson].sum+tree[lson].sum;</span><br><span class="line">tree[node].Lmax = <span class="built_in">max</span>(tree[lson].Lmax,tree[lson].sum+tree[rson].Lmax);</span><br><span class="line">tree[node].Rmax = <span class="built_in">max</span>(tree[rson].Rmax,tree[rson].sum+tree[lson].Rmax);</span><br><span class="line">tree[node].max = <span class="built_in">max</span>(<span class="built_in">max</span>(tree[lson].max,tree[rson].max),tree[lson].Rmax+tree[rson].Lmax);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">tree[node].l = l,tree[node].r = r;</span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">tree[node].sum = a[l];</span><br><span class="line">tree[node].max = a[l];</span><br><span class="line">tree[node].Lmax = a[l];</span><br><span class="line">tree[node].Rmax = a[l];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">build</span>(lson,l,mid),<span class="built_in">build</span>(rson,mid+<span class="number">1</span>,r);</span><br><span class="line"><span class="built_in">pushup</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tree[node].l==tree[node].r&amp;&amp;tree[node].r==x)&#123;</span><br><span class="line">tree[node].sum = y;</span><br><span class="line">tree[node].max = y;</span><br><span class="line">tree[node].Lmax = y;</span><br><span class="line">tree[node].Rmax = y;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid = tree[node].l+tree[node].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=mid) <span class="built_in">modify</span>(lson,x,y);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">modify</span>(rson,x,y);</span><br><span class="line"><span class="built_in">pushup</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">st <span class="title">query</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=tree[node].l&amp;&amp;y&gt;=tree[node].r)&#123;</span><br><span class="line"><span class="keyword">return</span> tree[node];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid = tree[node].l+tree[node].r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(y&lt;=mid) <span class="keyword">return</span> <span class="built_in">query</span>(lson,x,y);</span><br><span class="line"><span class="keyword">if</span>(x&gt;mid) <span class="keyword">return</span> <span class="built_in">query</span>(rson,x,y);</span><br><span class="line">st L = <span class="built_in">query</span>(lson,x,y),R = <span class="built_in">query</span>(rson,x,y),res;</span><br><span class="line">res.Lmax = <span class="built_in">max</span>(L.Lmax,L.sum+R.Lmax);</span><br><span class="line">res.Rmax = <span class="built_in">max</span>(R.Rmax,R.sum+L.Rmax);</span><br><span class="line">res.sum = L.sum+R.sum;</span><br><span class="line">res.max = <span class="built_in">max</span>(<span class="built_in">max</span>(L.max,R.max),L.Rmax+R.Lmax);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i] = <span class="built_in">read</span>();</span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">m = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">x = <span class="built_in">read</span>(),y = <span class="built_in">read</span>(),z = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(y&gt;z) <span class="built_in">swap</span>(y,z);</span><br><span class="line">cout&lt;&lt;<span class="built_in">query</span>(<span class="number">1</span>,y,z).max&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">modify</span>(<span class="number">1</span>,y,z);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="0x44-分块"><a href="#0x44-分块" class="headerlink" title="0x44 分块"></a>0x44 分块</h4><h4 id="0x45-点分治"><a href="#0x45-点分治" class="headerlink" title="0x45 点分治"></a>0x45 点分治</h4><h4 id="0x46-二叉查找树与平衡树初步"><a href="#0x46-二叉查找树与平衡树初步" class="headerlink" title="0x46 二叉查找树与平衡树初步"></a>0x46 二叉查找树与平衡树初步</h4><h4 id="0x47-离线分治算法"><a href="#0x47-离线分治算法" class="headerlink" title="0x47 离线分治算法"></a>0x47 离线分治算法</h4><h4 id="0x48-可持久化数据结构"><a href="#0x48-可持久化数据结构" class="headerlink" title="0x48 可持久化数据结构"></a>0x48 可持久化数据结构</h4><h4 id="总结与练习"><a href="#总结与练习" class="headerlink" title="总结与练习"></a>总结与练习</h4>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sb代码合集</title>
      <link href="/2022/11/16/sb%E4%BB%A3%E7%A0%81%E5%90%88%E9%9B%86/"/>
      <url>/2022/11/16/sb%E4%BB%A3%E7%A0%81%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="d755494aa87eb7d21c52baef3c946f14a9605a06a4fbc06c80b59c420fa0a361">4630436162ade97ba2718b7d0c4b3b63de8a883833b29a6c8a637d8d3a271cdc7fd9434fb817496d2e111da19674eaf830d4679b14c243dee11b4b99aeed4cd1ca55e0ea2e1984b642160ceddddcac14cdf1e29ff6f61ef29ab2db25dbfa1779b1b85663f37f2612172433df49838eae3129e5ea886c9a343bbb89cd9ad03adb99fcdebc40c2c774dbbad4c1be85a6c0bedc97b9f3800900f2f0599b8f1daf0969bd140a5c29efc257c0be70943b824b608d3544b15c1c232db33ae9f267051592de6957568b41b008d88116bd9ccb0bacaef7d977350f2db44a446550d12fc562b0321bca0db19dc15618fdabc600864d6e0ab96ed0f91ddad401e3976bbf1b999da0521c59de4305b1a27fbc71be22b67b3539bef22a222d567a255a57d235d4109d14da1379427ba5895e0729433b953fe9f056b1191dbcb81a683837b975ee0247ff8f22257ab9ab22275e54a315dcd493870ede2862cbd4fb4d7d5979d906efaffffa8a3bbc68dfddce7de2897ff42ac7d442901eb37b64c27e33267734e76eb4583b810cb78664cd20e197199dbd4b5ed90970316d40f9785e0622bafa425667091633179112d8066b0f7554f901fa3f15558fcb457a5b4e53849deabe6dc143b010438ae71b604029163f132cb86fd4be0c4aa0c7764ff57adecbdc18cdf0f2795c99f24e5918957e9eaeeb061e46c97d77e89962dac521a78d16f834ac5bed1fe2a6c8636cfb2ed33b1ec103b9d5b32e0efa7853b4b8768c220c72e77c20202c549bd066796fed0c7a4c791760f16842d2f48107722549d34d9ae27c03406b6b555b8fa4ab5403c1a3aeeb42b29f5a5f0eeceeec3339a8581bdc52400086f93eb7f64364ab58b0c869b049652b74490d1f7ca4cfadb4d527f46ba9f8307177fe1c27ead56a06913c9ecdb8c22804cf4f59f405d038e310ec7537c6f409593be4eacb3090d94d7891517382b2146dd8e7c08096743385d29dcc5e83924700348ad746c89575680a7ef54578be12adf6ae98548af2440d1a429fde5d7945f1882af5166de1f9db277e60ad1afddce32a900653791ac4039fb67d834de9eb3c7791eb6300d0da9be2ad4193c9210fe0e4e52774268ace716a0302f0c0260d4fdf93ae33ee23ca24c7b442e82c9b918d952bdeb2872b34ebef68d6d7458c4bda1fac3cf886aceb96edec4207d4c6374c45fb0a37639f6f00cf357488d56d5e6e92593dbcf0434b2a68cea2b5840167e52234ccaab392142fb5419f1a66d9b3bfa3c5fbb26f7def4b98b3179e3856035d301b028b16b0a7cf53e0b376561513c0ad5ed801dfd41ce5c448cd8ce8dd856de1a53ef3119791f0bfa3779f317e5b4d69ca5027bd6f0a1afd20b45b0f5126c23859358fcb3b1ec11e55ed79b56adc46b6e831b84244176d64898227550abf2fcf3f9fcf2c09a1971734b7999cb562d3d8045ee0541566d17451671dfb17d5894d573444507ac13a88953200bfb477dea0275178af13fe4e40556d35ea5d2466b88f683ad2107b2c0ea3721301d645dc138d7967d39c157d71497a6563ed93d70dd7c211bc1f3bf3d04f85b4a458c7b2186543554a683fafd6ebc8616d026f696f1c77e44babca4299f19126e3ac8440d8e47be34ef763d424b61a5dbea3b81c3775a1d7d503ecf974b9cc8627e991b60e7960df04d2ff3ea188c0b6a6839b56bea5109770cec761669fc55b2fd7ee9717f43db38bdc1bca5054c8185b8328fc4d5e1c249fb1fcf0586a8bf8b6f1679e4d9cc8e5f929c5d1e9017dfb6998da19516d619a2ee7fd8b8caf722af9fd1c98d823d68d96c201e6da40104d74123f6e9436516bd452502ba664756cb2e54a967764e0c9de7228dee52402af1e35d171ac2fcabdb6869b9814c5f0044fa217fb91fe40235d7b800bf2700016dcc992bc84c6e349ef6149301cb2c655a978fe1078e990aaaac9302ba98f7c51fb4012c0cb78aa902308d7f8fd9a9713b571b8a2dbce215e6e8482c1152f31352c7420d9fe96738e2cf5bbe21228f58eba9d315de23f75c7d720b1adda1aa387e6907cc43d251835c3ad75e8c700ea32bae4579ca19c12fa979ba31eb70605fe5911aed23102c373551c76386e4ac67c79fa974903e28bceb126e2234306d4a3b5bc76159365e75a7e118ed6ca2038baa4f1ecce1cd1e60293eb45d5a798c9f2cf6754112753118b36e4ea8cf448b8d8d1f903d4e0b346170f0672aefadb3059e051b668b640f1ba48bca0e9782b117f3e5643a48345375a3011b2329bbceeeb436b21ac4d9845a53186060490bbe6bc0b628f60ccb417e4d5267192ed6de5dbbaf225226477943e46be46b433f4cb80932ce6432e916cabe72da2b44e2de97316591d5493c1ad4399efed857fb36ac0b9a6a4951bef3ad7f4cff7dbd9779daae785598bf731107192d7919aa6be673d605d3bd374824fbced7f471999992d4945db25a34f2d643c9017f52fd66bc7e6153622a789f9de6173b9c4f38d834393f602dc1ac1f7dac79686f6140bd67bebead89ef7378b50799f70c14a8645f8cac28f361562706a1805f64ce28a00d9a89b2ba38c17b3f608884fdcbf61b5d029966ee203a08ce1a0ab5323e0535dabf0b2ecb5f790db389d3e636fb5a43c1cef732b93492a9939297e1b58636ac8317a6572bb007cdf15ab9cb811e5a8262bb7ac4043856faa1c9cd098f204668e8ad4c365d71622fc7a20235a24fb3173f2a6f196f3564e0ed7afc545883cd527c24a04b6df24dc37f0705afc81499615db01237e1da4e6afc47c2d176a8e7a27f1ffdf66c5ca5f9f6d66d00444f0eb95e7cec7c604261bc3cb0bf6ad1d3fa00ff8db771fcfeff204266863e70efe7a8e325aac3fc78642eb5c6f2ca83e01a4313816b3996ae3e5c868a0880dc8d3131bc5b8baed83b7a82dd31b6073df2aa07180b6ee10a29b9e32978e5cf58bf50e1945489b8290d38336bc443fa65b732f590e334cd138eb24d174d83bbe1ff6b227bdc7258b5007ad770b8dd0a3acaa86d8b181125850b8d94674645ee27349c94b89c34073bf67cd74fa6fa5cb73f3cc5195b8f3aaf0436bc9bc2701292c6112791662a1c8a818393eebd5aa03550266cce1ad154c1c825380fc0220251a2dec0bada4ca943ea3c4596510c930d3b27f2604bcf822cf34e3744aa2b0d037bdff98a41ebfadef90379781a61a58a0d389107969d45d482e50327d93f4136e75629202d337bdcf06a2ce47c7afebf68a57e51717b7059ee8fe2a4f0dc0de3e71c1eab3d1e0bcd304acf8bfe05ab88ce84e16340cbda03ddd73e233818350f6a0a3c9381923b2c9d0dacdd5c748491bfc925ff93916bb0928255466175c07170f1242c31ff9b2acc2a8e75f5fb282075737a192796b492ca875ab5a9e12f621950e50c6ba744d77e9166fb14b5ba45c0ded1627e9ccd16357eea65e94ab00aa68bfd1e171857ae8a33f601a08179d3623651978d7670cb0554451d306ef409e9984d9570bddc3cdacfab17879cc3e3dce96689a636d524238207815a498ab2d82164ec54dc4074677c55f3882bd2091aaccd412f94fe700de0ef39a1c778a67fdf74b15ad241d1e45389a608fa35dc61e082cb74f72137a62c8350a9cdff853b16ba7eadeb87bda23738fda9459572442d4aa9c27bf2cf6dfe2eb42ebad0227b20a777ec6eb1bfa795c713ee6618e05f2dba23028efff692e8630de1fcc2b22f89f3dbd6992e9bae4621f57c038864c603374e5d62e8423b56ee610679f4ca03b926e562c5821b8219b4f79a599849cac4dca16c50476743957193f2bc895ad0b8025ae2da9c80a6140dcb6b5240d1e45ca8790e699f6033bd04fdaa7702fa6941b5186c7c1a7629c3f8f39e9db2dc281a9aaa59a4c17dfd031d3da343d20cc5c14ad61b104348322c7abef9f1c77734105944a71125903803186beea532d077f2d3c252b60cec75f4af13e45e60813d62603e1310bafc7590d1b16faf4bd3655a744434fdf1c643cccb0e2b92d62f2c24d5c9baee3dfc371b59e48aaeaf3bee8e350498c6a2eec57492e19de5845adaf952fc932a28db3e8cae7b8dfdbe63a453ed54b3db9fc033b6d7300518550e732f957f443b1b084aeddc0c693d681930caa154c2f5b52040b209afafbf7caaa7d2eadec2a9baad26caf0f1d923b12d88d742f4270ee436e211866866f798adccc6e9dc63ec911293cebf2870f3213277498766013344ad12bee7c9d582880581ea0d83c749c9b0734bc02c01afe4cb7f79e7f10a1406283c6861be18211bb6864e31fabe4d99e1bb79bccdb8dab8ce311c325e9e28ce2c3c120b400414ab73ea48a8758028aa0fad189459784a9dac93f633f80234c25e1f6092dc8740b7081f81c3f365342ef1b92f5f96159e46b9821ac9369fd02ca0f9d83afcffd04f3a32158707086dad45fd5a01e25334e397aef2726e96a139fb7f6db0fa3833042063912d7a6b3ae2ec7b8684f5fa58d16de6620c2b717a96dd8d5704aaf619037f41abfb11cd2f1d1dbf794f8bbce12a50b14f3368c7a8b9bdc39a39c9ba7a2be54c95a918df4c78f20a171094ff2577a3721072e22d93b663b7b7d575a4ca7a9cd405b3654c2aec20f29b10b10713edcab2aa3d2539af0363e62002e3b17e34d83481245ad96204957adbf9fa8c726401270e5163aa76bf96133501472c3dc01008e0f952f020b9b643893cba8be7f2648eefe4979a6d60b73c07b74e259933951bee6ffca57b86999671ee1822862f024431a8586b5601de5374317665d0dd6f8919cf834915b58e2f1124c4e5bd7049cf8d565d35269359009cff0e07f9c01f2ae97a2da3207962784749a03ab5bff2511da38c56fc87ca858724a298a3ddfaa1c4b24fb1c86a245b50449021554b67dbe92b2016cdef72594cff75444da9dd9bcdd574a4068d04749216314f8aacceec6422e9c0ca644f6173b84fd16415e4d6ef0fe9d57454de265b8d32e9f3debc1239d4f95d3015018140b30fd9a7d62c2bbaef81cf3dab1e81551bf6332992cc601d101c5c24b576e12b9e495e5d5f4e9f73b541a1e89bc7a6ca912d5c9c6ef8c16b0512949b984182598d8e0035d5e5fb29d6edc7528339688433a53f61b666f99be101d2b43ac864af2923b5bdd5b3bd15c43d7a96ddd3c82560d1ee3ecb1d3a782216b83f05cf58a95f381706a1712edd9fbb5daf3dac4e33ae8b549c28d13f5fd56829600b1c620d4a43893eb5bbc54b841d42fc71fa2bea86f935c614887a39502dd1f69a7444863bb4b310cffe43e420860a0e36acf39882639ab73494964d1d45af1964fe58fcda0041bda441720964f71a731b4867a8b0c1ee51466ba43a2f089c38ceeaa573e52fa167f1a9aaab9783c006fca246badabc319a7ea736f8c2cc4f4fc272baa4c1ab5413332bd222d22b3ae19406d515e09f62e1f5d492b6dc77f823a9e19654d69fe7cd0604e9b1f2e2e9965ce668a1c3eb8a382280f92b284a91cf3a5b9fc77e3cc25f9ed8b9af095a03707062ce3f9e8a575f7ff4cfb3f4ff2c2c6fd60d54376883ca5e2bdd9a104722eadc54a91e8b03d7f755f138136169d0606e3b5048f894a3860bb63d85b2ccf471369d8c90c512742473fa6e01fef03667a6d031c520e649abbbe90a4298799644815a2cc0edb334cde59252df1b3bcdbbe5cb0329bff284cc150fb7467391dc1448c26fd0bc7ccab5aa951325e6451a2a2821dfb8cfec0fbc07619a639d5e22ad6e5a553d238fe635df189f442528546544d87eea39973249b2456f288240d7495e06252859ef842bcc89e1638e835ab8a3de6ad0efe3a314861021b1ab7f351322d37332b212407aee9a27c36f1550595839d17269b5be3021519701f099e0cd91b038915ce9c10e4fbe5e4694b99a0b70ae21e4a7ad80a8744f1c92098a462b00713706f2cd2e84846aee58b2f09dc3ba6e9d7b0c5faba5444cc64275c9057f6e6c6d8f7ae58be51a3ab99a9db5c62fe56f89b8d1024a788ad4ff81ee1fe60f46aac3118de3fffea39e79e9f642d63f86cd3cc08d28bd2bfa1c1147dc14da24e2e4a302c3e5fe59354cda4bf0ea4b2d876ee4744aeae53cdd30c004a0986235a0735d9dd0c281b368c7b7052f8745d8ab18bb1cad72e02faeb8c70065827419c6f5514fb7eef8e11fe445fab5ac12b517a28a348e86d3c7e9338b4f0d6aa0c2d434e037681cbe2aaa69d49a4673eb1616a4184bf5a29d12d7a62804d0d0332a4292d3291d179847b2a7b7ed9e55c77984423999e61f261f71b8f735c5158b79785016792a1484e12ce83e1ce74d8b7fd1d9a56a2683d70511cf6d5758c6538cf27fa41b82998a75acbf828bfad5e9b759d5fb1d72484a2ddbfeffc0ff0f0ea06a967d7cf6f8dc82b7572a9fad4b5fe733f9faa17f1a309b4f853489028043d06dd0d5bc533955e78940579c0b650eae2023a75af561b451a6ae11037524f678ed27a165153824d462a43fab9cd613d5e0a213f52c845c8ea80c906603b633135c5c2f29f7478025f371ee155bdbf7d3ca26f6494b76053358ff71926155639c7c48b80037a2516b469a63e9e78bb88cebc81a67d6a9df54b693787ff5c77a533c0aa1f5a7577c45b0f7d98ca75cb6d85d7a79a00a730b43c0ba71dd49c9cbefb048f251df5f735143580957e655f4730e92440e60a3abea2f2d98fdec2df5583178daf4562de0fc38c4183268355679aa9ced0b49426e6158aef3a7b8cba148a8bea55ca9ece0f55c12ba0e29735cb62b080c402a01c158c0ed6e7a3be9c70b00a3b148bf7ec02c81bbe676f6220471137c167a1d4f85ed16e777b9442271bf9c65b1aeee181f3f1c5b10410d3c9d088a08e40c594279fa9f47218dde66744488c0a2ff08bf34012cff1a3a33b574aa1438ede7b69d8f026572ba4ec46bc2add8ea8c0903ff3876bc42a752385a8a0f5b86b43865dc781a3fd893130ae5cca20a0391f97098d0c12badd2b46e61d6501a4be802ebd4db36e3d8a4051150624d42f5af19b69bd36a406bd06ce8528108556665ce875c1f25c5ac23f93db8d1ba04f4b36467ebf3732e69a032d490e90569be69aecabc0e15f14bbe91cff5fc829bdb0103f9254671ab92f9029b938fa876ebe2a6d8b1935dfd5b5e03bceff2b76bfdc2944402a1c2a180dd5791a089a2fce22f4587c717493ea37c4a2100c7b91f22e7d0ba5c4e4390c826bdfee86faa2e39497bf9cac23c9b5cc97e7d9bc51cefa30527665ce2c9b8fe667dbc45f26e56ccea7019a4f6bc3d0a99f15aa5584ffa194d8512403278249ad21d80a7f87f9df38929cbdcef6dadab1f2a79fca5c73e6bf31113a1d307a3fb6e1025180f076c885f818f5ed02c2002210363957b9b82b570cba4cbc58e0a18226c6dd80c4d22ce1214bb3eb92957ba50606b5b4a23ddc65a999eedba03c4f9afb083123df4dd424262ea2beebca7bea768f53875bcc4ccd49fa5a1724a9fed2edb3be87a5d91a60ae1f304f458c5bfc4b82c78499853e5460d6525064aa3c9f211f79264d0ed71d86eb675a4f1f566dc3e39c1185c31589364084804557130b56e3990987e2642bee09bac9d2c9fd08e6cabee2f43cec13989aee8bf62c721c5b0748d2d42a30059ebde5b91f383302889fbc8c086da071a5ed1eab88bc111782988d8252fe2361eda2c1ae60c2826eee70926ec4daff5383f06d7c4956ab4b5c9cac423c08b8e8a72cc0bd2ef3fda3fe6727aaa8ced9acb9bae20a5416ea46946cf58ed45ecb16c858c473aad06d962693587aa9edfad866eb7668a3a752563ff85563fbf41b496113682c4c3f9af29377e8bb908e7722b5b2fc6c6e0c33e49729a547f62237b2d6b150abe630685755ead0526cf456392ba3a566e611a45e98e8707c5e13b610b953422a86ab40295e4d4b6520f17094c20a46c410237208e8e76f609caddc886b90af45aa855826b8e599283da14421c9c374c997a3e3b1ad0839b55e735de8caf72df69d6e7757e9840528304a4f323314be45e71d2d9303e26b53528942328ff983d243accc5f9d3ce09c7de904b2b36bfde2cf027d7b8f28b1784e1a64085d88f5b63cabc2a2549996e90003d458e773389209af6f71573c3771a66e3f3a3705bf8b92d894d051073560d0492aa551a1cd8946c43fb44b228cc67b2135551191b50a939acca7fb907b70ff2764882321c51244bda9dd13b25b5f7399d05396d950895b6c43d0c0941b8ff5eb7f717c49360907bd1b3adea12ddf595ef62b0303ff9d69af0222e7a5f7c19b18400488844549a10b88fc829b4d57476071f5670e205a59786873d4c3f83976dd4dc21c0a37f4d0954a98b8a340cf769fa755ad82e9bae8ea3db2ac2eb3e811809d1f64f308c964a31cb3349c3d37e7448ea0511d1bab8bf6ae084c300133794af0da3d1d020c2b5c13e5c796ca27a8698e8897ad7e09313eab38f3c3d02895b93009eabf3766ccd3e285de6ac54cf8ef2a0d69122b62c092c07b72fcedbb76c67e541b82f616dd3a8aa58c274bea5df51ef6bc8be0d676b16d77d6b65921199523fd1fef0470798ad2134270c432aaaad309a97afd9750e83524cece41ec64942b4d9cebc2856e5847da05d33f07344624aaddd282deef91aadbc33c3f2ad240fa2955d14053598bb435dd9976802aaffdec5e6e98d897311ca83df9164175d1016f49fd2e4ddc2c96ff206196a13a97a87920c65972ddaf9555f8134ea5cc2478602146166c31a732594b5260a1b8769aea78f7e27b92a4557b45fb390e2277c1eb01057f37e0c46045c1e1302ca71cc4626493598cf9f55618f82364237c8dd5ac57b31000c7ae18854b85017f4c56ca6a48f0486692017e08b0aa9aeee8cf6a8d6f1dcb59afc9743751582d988036feeb10139fc091640856c850cd2cbc3b297ff7a6fabaa8ac14cb84d2c3cbfcd980b39bbfc9d0e1abbc3b2f63ed37794a7e27bf7954392776364f10916031c44132232e23870fa57cc9bd683df7b7cf3bb2a3e1d32e4bc9b72c1e05f6f249dc781f</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《算法竞赛进阶指南》第二章 读书笔记</title>
      <link href="/2022/10/26/%E3%80%8A%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97%E3%80%8B%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/10/26/%E3%80%8A%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97%E3%80%8B%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul><li><p><del>是可爱的数据结构!</del></p></li><li><p>竞赛复健,自用向整理</p></li><li>为简约文本,代码均省略开头部分</li><li>书中所有例题均在acwing上可以找到</li></ul><h3 id="0x10-基本数据结构"><a href="#0x10-基本数据结构" class="headerlink" title="0x10 基本数据结构"></a>0x10 基本数据结构</h3><h4 id="0x11-栈"><a href="#0x11-栈" class="headerlink" title="0x11 栈"></a>0x11 栈</h4><ul><li><p>例题: Push,Pop,GetMin</p><ul><li><p>开一个大根堆和一个栈,模拟操作,当栈被弹出的值与大根堆堆顶值相同时,弹出大根堆堆顶即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> s[<span class="number">110</span>];</span><br><span class="line">    <span class="type">int</span> Top = <span class="number">0</span>;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt; &gt; q;</span><br><span class="line">    <span class="built_in">MinStack</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        s[++Top] = x;</span><br><span class="line">        q.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q.<span class="built_in">top</span>()==s[Top]) q.<span class="built_in">pop</span>();</span><br><span class="line">        Top--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s[Top];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>例题: 编辑器</p><ul><li><p>开两个栈来模拟左右移动的操作,并记录以$i$为结尾的最大值和前缀和,每次有新值插入光标后时,更新最大值和前缀和即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[MAXN],MAX[MAXN],n,top,k,b[MAXN],top2,sum[MAXN];</span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">a[++top] = k;</span><br><span class="line">sum[top] = sum[top<span class="number">-1</span>]+a[top];</span><br><span class="line">MAX[top] = <span class="built_in">max</span>(MAX[top<span class="number">-1</span>],sum[top]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!top) <span class="keyword">return</span>; </span><br><span class="line">MAX[top] = <span class="number">-11451419</span>;</span><br><span class="line">top--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">move_L</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(top==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">b[++top2] = a[top--];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">move_R</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(top2==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">a[++top] = b[top2--];</span><br><span class="line">sum[top] = sum[top<span class="number">-1</span>]+a[top];</span><br><span class="line">MAX[top] = <span class="built_in">max</span>(MAX[top<span class="number">-1</span>],sum[top]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query_max</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> MAX[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>例题: 火车进栈</p><ul><li><p>搜索一下即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[MAXN],n,top,b[MAXN],T,cnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> now)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(now==n+<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(cnt==<span class="number">20</span>) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">cnt++;</span><br><span class="line"><span class="built_in">print</span>();</span><br><span class="line"><span class="keyword">return</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(top)&#123;</span><br><span class="line">b[++T] = a[top--];</span><br><span class="line"><span class="built_in">dfs</span>(now);</span><br><span class="line">a[++top] = b[T--];</span><br><span class="line">&#125;</span><br><span class="line">a[++top] = now;</span><br><span class="line"><span class="built_in">dfs</span>(now+<span class="number">1</span>);</span><br><span class="line">top--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>例题: 火车进出栈问题</p><ul><li><p>方法1: 设$f<em>i$表示有$i$个数进栈时的方案数,我们假设第一个数在出栈时排在第$i$个数,有递推式$\sum\limits</em>{i = 1}^{n-1}(f<em>{i-1}×f</em>{n-i})$,会T</p></li><li><p>方法2: dp。设$f<em>{i,j}$表示有$i$个数未入栈,有$j$个数在栈中的方案数,有递推式$f</em>{i,j} = f<em>{i-1,j+1}+f</em>{i,j-1}$,复杂度$O(n^2)$,会T</p></li><li><p>方法3: 卡特兰数。经典问题了,用通项公式求一下卡特兰数就行,要写高精度</p><p><del>你说得对,但是python可以不用写高精度</del></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">A = math.factorial(<span class="number">2</span> * n)</span><br><span class="line">B = math.factorial(n)</span><br><span class="line"><span class="built_in">print</span>(A // B // B // (n + <span class="number">1</span>))</span><br></pre></td></tr></table></figure></li></ul></li><li><p>表达式计算</p><ul><li><p>中缀表达式: 最常见的表达式,形如$A$  $op$  $B$,其中$op$是操作符</p></li><li><p>后缀表达式: 又称逆波兰式,形如$1$  $2$  $op$,计算流程就是遇到数字把数字压入栈中,遇到计算符把栈头两个元素弹出进行计算,后再将新值压入栈中</p></li><li><p>前缀表达式: 又称波兰式,形如 $op$  $1$  $2$,计算流程同理后缀表达式,只是从后往前扫描</p></li><li><p>中缀表达式转后缀表达式:</p><ul><li><p>1.建立一个用于存储运算符的栈,扫描中缀表达式中的每个值:</p><p>(1).遇到数字,输出该数。</p><p>(2).遇到左括号,把左括号入栈</p><p>(3).遇到右括号,不断取出栈顶并输出,直到栈顶为左括号,然后把左括号出栈</p><p>(4).如果遇到运算符,只要把栈顶符号的优先级不低于新符号,就不断取出栈顶并输出,最后把新符号进栈。优先级为乘除$&gt;$加减$&gt;$左括号</p></li><li><p>2.最后依次取出栈中剩余值并输出,最终输出序列就是一个与原中缀表达式等价的后缀表达式</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Calc_RevPolish</span><span class="params">()</span></span>&#123;<span class="comment">//后缀表达式计算</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">c = s[i];</span><br><span class="line"><span class="keyword">if</span>(c&gt;<span class="string">&#x27;0&#x27;</span>&amp;&amp;c&lt;<span class="string">&#x27;9&#x27;</span>) a[++top] = c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(c==<span class="string">&#x27;-&#x27;</span>) x = a[top--],y = a[top--],a[++top] = y-x;</span><br><span class="line"><span class="keyword">if</span>(c==<span class="string">&#x27;+&#x27;</span>) x = a[top--],y = a[top--],a[++top] = y+x;</span><br><span class="line"><span class="keyword">if</span>(c==<span class="string">&#x27;*&#x27;</span>) x = a[top--],y = a[top--],a[++top] = y*x;</span><br><span class="line"><span class="keyword">if</span>(c==<span class="string">&#x27;/&#x27;</span>) x = a[top--],y = a[top--],a[++top] = y/x;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;a[top--];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>例题: 表达式计算4</p><ul><li><p>把中缀表达式转化为后缀表达式后计算即可。注意,这里会出现负数的情况,需要把负数$-a$转化为$(0-a)$后再进行计算</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[MAXN],ans[MAXN];</span><br><span class="line"><span class="type">int</span> a[MAXN];</span><br><span class="line"><span class="type">int</span> top,maxc[<span class="number">610</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f_pow</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(b)&#123;</span><br><span class="line"><span class="keyword">if</span>(b&amp;<span class="number">1</span>) res = res*a;</span><br><span class="line">b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">a*=a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">infix_to_RevPolish</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="type">char</span> a[MAXN],t = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(s[i]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;s[i]&lt;=<span class="string">&#x27;9&#x27;</span>) ans[++top] = s[i];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(s[i<span class="number">-1</span>]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;s[i<span class="number">-1</span>]&lt;=<span class="string">&#x27;9&#x27;</span>) ans[++top] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(s[i]==<span class="string">&#x27;(&#x27;</span>) a[++t] = s[i];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line"><span class="keyword">while</span>(a[t]!=<span class="string">&#x27;(&#x27;</span>) ans[++top] = a[t--];</span><br><span class="line">t--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(maxc[a[t]]&gt;=maxc[s[i]]&amp;&amp;t)</span><br><span class="line">ans[++top] = a[t--];</span><br><span class="line">a[++t] = s[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(s[n]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;s[n]&lt;=<span class="string">&#x27;9&#x27;</span>) ans[++top] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line"><span class="keyword">while</span>(t) ans[++top] = a[t--];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">calc_RevPolish</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> Top = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>,x,y;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=top;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(ans[i]==<span class="string">&#x27;(&#x27;</span>||ans[i]==<span class="string">&#x27;)&#x27;</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(ans[i]&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ans[i]&lt;=<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">res = res*<span class="number">10</span>+ans[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ans[i]==<span class="string">&#x27;#&#x27;</span>) a[++Top] = res,res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(ans[i]==<span class="string">&#x27;+&#x27;</span>) x = a[Top--],y = a[Top--],a[++Top] = y+x;</span><br><span class="line"><span class="keyword">if</span>(ans[i]==<span class="string">&#x27;-&#x27;</span>) x = a[Top--],y = a[Top--],a[++Top] = y-x;</span><br><span class="line"><span class="keyword">if</span>(ans[i]==<span class="string">&#x27;*&#x27;</span>) x = a[Top--],y = a[Top--],a[++Top] = y*x;</span><br><span class="line"><span class="keyword">if</span>(ans[i]==<span class="string">&#x27;/&#x27;</span>) x = a[Top--],y = a[Top--],a[++Top] = y/x;</span><br><span class="line"><span class="keyword">if</span>(ans[i]==<span class="string">&#x27;^&#x27;</span>) x = a[Top--],y = a[Top--],a[++Top] = <span class="built_in">f_pow</span>(y,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a[Top]==<span class="number">0</span>) cout&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;a[Top];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">maxc[<span class="built_in">int</span>(<span class="string">&#x27;+&#x27;</span>)] = maxc[<span class="built_in">int</span>(<span class="string">&#x27;-&#x27;</span>)] = <span class="number">1</span>;</span><br><span class="line">maxc[<span class="built_in">int</span>(<span class="string">&#x27;*&#x27;</span>)] = maxc[<span class="built_in">int</span>(<span class="string">&#x27;/&#x27;</span>)] = <span class="number">2</span>;</span><br><span class="line">maxc[<span class="built_in">int</span>(<span class="string">&#x27;^&#x27;</span>)] = <span class="number">3</span>;</span><br><span class="line">cin&gt;&gt;(s+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">infix_to_RevPolish</span>(<span class="built_in">strlen</span>(s+<span class="number">1</span>));</span><br><span class="line"><span class="built_in">calc_RevPolish</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>单调栈</p><p>一种用于及时排除无用选择,保持决策集合高度有效性和秩序性的数据结构</p><p>例题: 直方图中最大的矩形</p><ul><li><p>显然,如果下一个矩形比上一个小,那么该矩形利用之前的矩形一起构成一块较大的面积时,这块面积的高度就不可能超过该矩形自己的高度。因此,我们可以建立一个栈,维护若干个单调递增的矩形,并在维护的同时求出其贡献值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">memset</span>(w,<span class="number">0</span>,<span class="built_in">sizeof</span>(w));</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">if</span>(!n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i] = <span class="built_in">read</span>();</span><br><span class="line">top = <span class="number">0</span>;</span><br><span class="line">s[++top] = a[<span class="number">1</span>],w[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">a[n+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n+<span class="number">1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]&gt;=s[top]) s[++top] = a[i],w[top] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="type">int</span> W = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(s[top]&gt;a[i]&amp;&amp;top)&#123;</span><br><span class="line">W+=w[top];</span><br><span class="line">ans = <span class="built_in">max</span>(ans,W*s[top]);</span><br><span class="line">top--;</span><br><span class="line">&#125;</span><br><span class="line">s[++top] = a[i],w[top] = W+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="0x12-队列"><a href="#0x12-队列" class="headerlink" title="0x12 队列"></a>0x12 队列</h4><ul><li><p>例题: 小组队列</p><ul><li><p>开个队列数组后模拟操作即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> T,n,a,cnt[<span class="number">1000010</span>],End,id[MAXN],k,ans;</span><br><span class="line">string s;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">memset</span>(id,<span class="number">0</span>,<span class="built_in">sizeof</span>(id));</span><br><span class="line">End = <span class="number">0</span>;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q[MAXN];</span><br><span class="line">k++;</span><br><span class="line">cin&gt;&gt;T;</span><br><span class="line"><span class="keyword">if</span>(T==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=T;i++)&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">cin&gt;&gt;a;</span><br><span class="line">cnt[a] = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Scenario #&quot;</span>&lt;&lt;k&lt;&lt;endl;</span><br><span class="line"><span class="keyword">while</span>(cin&gt;&gt;s)&#123;</span><br><span class="line"><span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">&#x27;E&#x27;</span>)&#123;</span><br><span class="line">cin&gt;&gt;a;</span><br><span class="line"><span class="keyword">if</span>(q[id[cnt[a]]].<span class="built_in">size</span>()) q[id[cnt[a]]].<span class="built_in">push</span>(a);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">q[++End].<span class="built_in">push</span>(a);</span><br><span class="line">id[cnt[a]] = End;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(s[<span class="number">0</span>]==<span class="string">&#x27;D&#x27;</span>)&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(!q[i].<span class="built_in">size</span>()) i++;</span><br><span class="line">cout&lt;&lt;q[i].<span class="built_in">front</span>()&lt;&lt;endl;</span><br><span class="line">q[i].<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>例题: 蚯蚓</p><ul><li><p>也算是经典老题了。之前写的题解:<a href="https://xcxc82.github.io/2020/10/05/p2827/">P2827 蚯蚓</a> (yysy现在再回头看自己之前写的一些题解发现写的是真的烂。。。)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; q1,q2,q3;</span><br><span class="line"><span class="type">int</span> MAX,l,r,val;</span><br><span class="line"><span class="type">int</span> n,m,q,u,v,t,a[MAXN];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n = <span class="built_in">raed</span>(),m = <span class="built_in">read</span>(),q = <span class="built_in">read</span>(),u = <span class="built_in">raed</span>(),v = <span class="built_in">read</span>(),t = <span class="built_in">raed</span>();</span><br><span class="line"><span class="type">double</span> p = (<span class="type">double</span>)u/v;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i] = <span class="built_in">read</span>(),a[i] = -a[i];</span><br><span class="line"><span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) q1.<span class="built_in">push</span>(-a[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="type">int</span> MAX = <span class="number">-1e9</span>;</span><br><span class="line"><span class="keyword">if</span>(!q1.<span class="built_in">empty</span>()) MAX = <span class="built_in">max</span>(MAX,q1.<span class="built_in">front</span>());</span><br><span class="line"><span class="keyword">if</span>(!q2.<span class="built_in">empty</span>()) MAX = <span class="built_in">max</span>(MAX,q2.<span class="built_in">front</span>());</span><br><span class="line"><span class="keyword">if</span>(!q3.<span class="built_in">empty</span>()) MAX = <span class="built_in">max</span>(MAX,q3.<span class="built_in">front</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!q1.<span class="built_in">empty</span>()&amp;&amp;MAX==q1.<span class="built_in">front</span>()) q1.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(!q2.<span class="built_in">empty</span>()&amp;&amp;MAX==q2.<span class="built_in">front</span>()) q2.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(!q3.<span class="built_in">empty</span>()&amp;&amp;MAX==q3.<span class="built_in">front</span>()) q3.<span class="built_in">pop</span>();</span><br><span class="line">MAX+=q*(i<span class="number">-1</span>);</span><br><span class="line"><span class="type">int</span> L = (<span class="type">double</span>)(p*MAX),R =  MAX - L;</span><br><span class="line">q2.<span class="built_in">push</span>(L-q*i),q3.<span class="built_in">push</span>(R-q*i);</span><br><span class="line"><span class="keyword">if</span>(i%t==<span class="number">0</span>) cout&lt;&lt;MAX&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="type">int</span> MAX = <span class="number">-1e9</span>;</span><br><span class="line"><span class="keyword">if</span>(!q1.<span class="built_in">empty</span>()) MAX = <span class="built_in">max</span>(MAX,q1.<span class="built_in">front</span>());</span><br><span class="line"><span class="keyword">if</span>(!q2.<span class="built_in">empty</span>()) MAX = <span class="built_in">max</span>(MAX,q2.<span class="built_in">front</span>());</span><br><span class="line"><span class="keyword">if</span>(!q3.<span class="built_in">empty</span>()) MAX = <span class="built_in">max</span>(MAX,q3.<span class="built_in">front</span>());</span><br><span class="line"><span class="keyword">if</span>(!q1.<span class="built_in">empty</span>()&amp;&amp;MAX==q1.<span class="built_in">front</span>()) q1.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(!q2.<span class="built_in">empty</span>()&amp;&amp;MAX==q2.<span class="built_in">front</span>()) q2.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(!q3.<span class="built_in">empty</span>()&amp;&amp;MAX==q3.<span class="built_in">front</span>()) q3.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span>(MAX==<span class="number">-1e9</span>) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">if</span>(i%t==<span class="number">0</span>) cout&lt;&lt;MAX+q*m&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>例题: 双端队列</p><ul><li><p>考虑将原序列$a$进行排序,划分为若干个”队列区间”来处理。对于每个”队列区间”,其包含的数字下标在原序列中一定是成”山谷”状(先递减后递增) 的,因此,若没有相同的数字,只需要统计”山谷”的数量即可。</p></li><li><p>再来看有相同的数时的情况。排序后,对于区间$[l,r]$内相同的数字,其顺序可以任意替换,考虑将相同的数划分为若干个区间来处理。贪心的考虑,对于每个区间,若其能连上前一个”队列区间”,就将其合并进去,否则,新建一个”队列区间”</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Nums</span>&#123;</span><br><span class="line"><span class="type">int</span> id,v;</span><br><span class="line">&#125;a[MAXN];</span><br><span class="line"><span class="type">int</span> l[MAXN],r[MAXN],tot,ans = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> MIN[MAXN],MAX[MAXN];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(Nums a,Nums b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.v&lt;b.v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(MIN,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(MIN));</span><br><span class="line">n = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i].v = <span class="built_in">raed</span>(),a[i].id = i;</span><br><span class="line"><span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>,cmp);</span><br><span class="line">l[++tot] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i].v!=a[i<span class="number">-1</span>].v) r[tot] = i<span class="number">-1</span>,l[++tot] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=l[i];j&lt;=r[i];j++)&#123;</span><br><span class="line">MIN[i] = <span class="built_in">min</span>(MIN[i],a[j].id);</span><br><span class="line">MAX[i] = <span class="built_in">max</span>(MAX[i],a[j].id);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> rev = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> now = MIN[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=tot;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!rev&amp;&amp;MAX[i]&lt;now) now = MIN[i];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(!rev&amp;&amp;MAX[i]&gt;now) rev = <span class="number">1</span>,now = MAX[i];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(rev&amp;&amp;MIN[i]&gt;now) now = MAX[i];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">ans++;</span><br><span class="line">now = MIN[i];</span><br><span class="line">rev = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>单调队列</p><center>$如果一位选手比你小,还比你强,那你就打不过他了$</center></li></ul><p>  思想同理单调栈,及时排除决策集合(队列)中一定不是最优解的值</p><p>  例题: 最大子段和</p><ul><li><p>设前前缀和为$sum_i$,有转移$f_i = sum_i - min{ sum_j }(i-j+1≤m)$</p><p>对于两个选择$sum_j$和$sum_k$$(j&lt;k)$,若$sum_k&lt;sum_j$,显然选$k$比选$j$更优,且$k$位更容易满足长度不超过$m$的条件,因此,$j$位永远不会成为最优选项,可以提前排除掉。我们只需维护一个满足$sum$单调递增的队列,即可在$O(n)$的复杂度内解决该问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">read</span>(),m = <span class="built_in">raed</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i] = <span class="built_in">raed</span>(),sum[i] = sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">q[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=r&amp;&amp;q[l]&lt;i-m) l++;</span><br><span class="line">ans = <span class="built_in">max</span>(ans,sum[i] - sum[q[l]]);</span><br><span class="line"><span class="keyword">while</span>(l&lt;=r&amp;&amp;sum[q[r]]&gt;sum[i]) r--;</span><br><span class="line">q[++r] = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="0x13-链表与邻接表"><a href="#0x13-链表与邻接表" class="headerlink" title="0x13 链表与邻接表"></a>0x13 链表与邻接表</h4><ul><li><p>链表模板:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> head,tail,tot; </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line"><span class="type">int</span> value,next,prev;</span><br><span class="line">&#125;a[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">tot = <span class="number">2</span>;</span><br><span class="line">head = <span class="number">1</span>,tail = <span class="number">2</span>;</span><br><span class="line">a[<span class="number">1</span>].next = <span class="number">2</span>;</span><br><span class="line">a[<span class="number">2</span>].prev = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> value,<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> now = ++tot;</span><br><span class="line">a[now] = value;</span><br><span class="line">a[a[x].next].prev = now;</span><br><span class="line">a[now].next = a[x].next;</span><br><span class="line">a[x].next = now;</span><br><span class="line">a[now].prev = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">a[a[x].next].prev = a[x].prev;</span><br><span class="line">a[a[x].prev].next = a[x].next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">tot = head = tail = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>例题: 邻值查找</p><ul><li><p>此题是让我们查询每个数的前驱和后继,我们只需要将原序列排序后组成一个链表,并对于原序列倒序处理,每次查询该数的前驱和后继,并在链表中删除该数即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n,c[MAXN];</span><br><span class="line"><span class="type">int</span> head,tail,tot;</span><br><span class="line"><span class="type">int</span> ans[MAXN],Index[MAXN];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line"><span class="type">int</span> prev,next,val,id;</span><br><span class="line">&#125;a[MAXN];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Value</span>&#123;</span><br><span class="line"><span class="type">int</span> ind,v;</span><br><span class="line">&#125;b[MAXN];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Cmp</span><span class="params">(Value a,Value b)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a.v==b.v) <span class="keyword">return</span> a.ind&gt;b.ind;</span><br><span class="line"><span class="keyword">return</span> a.v&lt;b.v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">tot = <span class="number">2</span>;</span><br><span class="line">head = <span class="number">1</span>,tail = <span class="number">2</span>;</span><br><span class="line">a[<span class="number">1</span>].next = tail;</span><br><span class="line">a[<span class="number">2</span>].prev = head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">a[++tot].val = v;</span><br><span class="line">a[tot].id = tot<span class="number">-2</span>;</span><br><span class="line">a[a[p].next].prev = tot;</span><br><span class="line">a[tot].next = a[p].next;</span><br><span class="line">a[tot].prev = p;</span><br><span class="line">a[p].next = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line">a[a[p].next].prev = a[p].prev;</span><br><span class="line">a[a[p].prev].next = a[p].next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Pre</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a[p].prev!=<span class="number">1</span>) <span class="keyword">return</span> a[a[p].prev].val;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1e9</span>+<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Nxt</span><span class="params">(<span class="type">int</span> p)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(a[p].next!=<span class="number">2</span>) <span class="keyword">return</span> a[a[p].next].val;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1e9</span>+<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">Init</span>();</span><br><span class="line">n = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) b[i].v = <span class="built_in">read</span>(),b[i].ind = i;</span><br><span class="line"><span class="built_in">sort</span>(b+<span class="number">1</span>,b+n+<span class="number">1</span>,Cmp);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) c[b[i].ind] = i;</span><br><span class="line"><span class="built_in">Insert</span>(<span class="number">1</span>,b[<span class="number">1</span>].v);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) <span class="built_in">Insert</span>(i+<span class="number">1</span>,b[i].v);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">2</span>;i--)&#123;</span><br><span class="line"><span class="type">int</span> now = c[i]+<span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> P_id = a[a[now].prev].id,N_id = a[a[now].next].id;</span><br><span class="line"><span class="type">int</span> pre = <span class="built_in">Pre</span>(now),nxt = <span class="built_in">Nxt</span>(now);</span><br><span class="line"><span class="keyword">if</span>(pre==<span class="number">1e9</span>+<span class="number">10</span>) ans[i] = <span class="built_in">abs</span>(a[now].val - nxt),Index[i] = b[N_id].ind;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(nxt==<span class="number">1e9</span>+<span class="number">10</span>) ans[i] = <span class="built_in">abs</span>(a[now].val - pre),Index[i] = b[P_id].ind;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">abs</span>(a[now].val-nxt)&lt;<span class="built_in">abs</span>(a[now].val-pre))&#123;</span><br><span class="line">ans[i] = <span class="built_in">abs</span>(a[now].val - nxt),Index[i] = b[N_id].ind;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">ans[i] = <span class="built_in">abs</span>(a[now].val - pre),Index[i] = b[P_id].ind;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Delete</span>(now);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,ans[i],Index[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>邻接表&amp;&amp;链式前向星:</p><ul><li><p>本质上是”带有索引数组的多个数据链表”。是树与图的一般存储方式,其结构见下图：</p><p><img src="https://pic.jitudisk.com/public/2022/11/07/f3d2c65968c40.png" alt=""></p></li><li><p>上图中,$head_u$就是每个节点的”索引数组”,每次连接新边时,将其插入到对应链表头部。</p></li><li><p>邻接表的实现通常采用<code>vector</code>,不太好写,因此一般会使用链式前向星(数组模拟邻接表)来实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> tot = <span class="number">1</span>,head[MAXN];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line"><span class="type">int</span> next,v,w;</span><br><span class="line">&#125;edge[MAXM&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,v,w)</span></span>&#123; <span class="comment">//加边</span></span><br><span class="line">edge[tot].v = v;</span><br><span class="line">edge[tot].w = w;</span><br><span class="line">edge[tot].next = head[u];</span><br><span class="line">head[u] = tot++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="0x14-Hash"><a href="#0x14-Hash" class="headerlink" title="0x14 Hash"></a>0x14 Hash</h4><ul><li><p>$Hash$表</p><ul><li>类似离散化的思想,使用$Hash$函数将若干复杂数值映射到一个容易维护的值域内,对于映射为相同值的冲突情况,建立一个邻接表,将映射为同一值的元素归为一类,每次插入新元素时,检测该元素是否存在,若不存在,则在表头插入该元素,期望复杂度$O(1)$。</li></ul></li><li><p>例题: 雪花雪花雪花</p><ul><li><p>对于两个不相同的雪花, 有$\sum\limits<em>{i = 1}^6a</em>{x,i}+\prod\limits<em>{i = 1}^6a</em>{x,i} = \sum\limits<em>{i = 1}^6a</em>{y,i}+\prod\limits<em>{i = 1}^6a</em>{y,i}$,用归纳法易证。</p><p>因此,我们可以定义一个哈希函数$H<em>x = (\sum\limits</em>{i = 1}^6a<em>{x,i}+\prod\limits</em>{i = 1}^6a_{x,i}) \bmod p$,其中,$p$取最接近$n$的质数时复杂度最优,每次插入新雪花时,判断是否有与其相同的雪花即可。对于随机数据,期望复杂度$O(\frac{n^2}{p})$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[MAXN][<span class="number">10</span>],n,head[MAXN],tot = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line"><span class="type">int</span> cnt,next,id;</span><br><span class="line">&#125;h[MAXN];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Equal</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> p1,p2;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">6</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">6</span>;j++)&#123;</span><br><span class="line"><span class="type">bool</span> ep = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=<span class="number">5</span>;k++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[x][(i+k<span class="number">-1</span>)%<span class="number">6</span>+<span class="number">1</span>]!=a[y][(j+k<span class="number">-1</span>)%<span class="number">6</span>+<span class="number">1</span>]) ep = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ep) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">ep = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=<span class="number">5</span>;k++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[x][(i+k<span class="number">-1</span>)%<span class="number">6</span>+<span class="number">1</span>]!=a[y][(j-k+<span class="number">6</span><span class="number">-1</span>)%<span class="number">6</span>+<span class="number">1</span>]) ep = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ep) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> id)</span></span>&#123;</span><br><span class="line">h[tot].cnt++;</span><br><span class="line">h[tot].id = id;</span><br><span class="line">h[tot].next = head[u];</span><br><span class="line">head[u] = tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Hash</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> PAI = <span class="number">1</span>,SUM = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">6</span>;i++)&#123;</span><br><span class="line">SUM = (SUM+a[x][i])%P;</span><br><span class="line">PAI = (<span class="type">long</span> <span class="type">long</span>)PAI*a[x][i]%P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> u = (SUM+PAI)%P;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = head[u];i;i = h[i].next)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">Equal</span>(h[i].id,x))&#123;</span><br><span class="line">h[i].cnt++,b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Add</span>(u,x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>字符串哈希</p><ul><li><p>取一固定值$P$,把字符串看作$P$进制数,并对于每种字符$c$,分配一个的对应的值$v_c(P&gt;v_c&gt;0)$。举例来说,若字符串$S$的映射值为$X$,则$S+c$的映射值就为$(X×P+v_c) \bmod M$</p><p>一般来说,取$P = 131$或$P = 13331$时起哈希冲突的概率最小。通常我们取$M = 2^{64}$,即直接使用<code>unsigned long long</code>类型对哈希值进行存储。这样可以避免低效的取模运算</p><p>若已知字符串S的哈希值为$H<em>S$,字符串$S+T$的哈希值为$H</em>{S+T}$,那么字符串$T$的哈希值就为$H_{S+T} - H_S×P^{length(T)}$,等价于在$P$进制下将$S$左移对齐$S+T$,两者相减即为$H_T$</p></li></ul></li><li><p>例题: 兔子与兔子</p><ul><li><p>模板题。用上述思想求解即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line"><span class="type">int</span> n,l1,r1,l2,r2;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> f[MAXN],p[MAXN],x,y;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;s;</span><br><span class="line">s = <span class="string">&#x27; &#x27;</span>+s;</span><br><span class="line">p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=s.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">f[i] = f[i<span class="number">-1</span>]*P+s[i]-<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>;</span><br><span class="line">p[i] = p[i<span class="number">-1</span>]*P;</span><br><span class="line">&#125;</span><br><span class="line">n = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">l1 = <span class="built_in">read</span>(),r1 = <span class="built_in">read</span>(),l2 = <span class="built_in">read</span>(),r2 = <span class="built_in">read</span>();</span><br><span class="line">x = f[r1] - f[l1<span class="number">-1</span>]*p[r1-l1+<span class="number">1</span>],y = f[r2] - f[l2<span class="number">-1</span>]*p[r2-l2+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span>(x==y)&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>例题: 回文子串的最大长度</p><ul><li><p>算法一: 对于每个字符$s_i$,使用二分+哈希求出其最大回文长度即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[MAXN];</span><br><span class="line"><span class="type">int</span> n,ans;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> a,b;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> pre[MAXN],last[MAXN],p[MAXN];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> mid,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">a = last[n-x+<span class="number">1</span>+mid] - last[n-x]*p[mid+<span class="number">1</span>];</span><br><span class="line">b = pre[y+mid] - pre[y<span class="number">-1</span>]*p[mid+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span>(a==b) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cal</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> l = <span class="number">0</span>,r = <span class="built_in">min</span>(x<span class="number">-1</span>,n-y);</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line"><span class="type">int</span> mid = (l+r+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">check</span>(mid,x,y)) l = mid;</span><br><span class="line"><span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">ans = <span class="built_in">max</span>(ans,r*<span class="number">2</span>+(y-x+<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> k = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(cin&gt;&gt;(s+<span class="number">1</span>))&#123;</span><br><span class="line"><span class="built_in">memset</span>(last,<span class="number">0</span>,<span class="built_in">sizeof</span>(last));</span><br><span class="line"><span class="built_in">memset</span>(pre,<span class="number">0</span>,<span class="built_in">sizeof</span>(pre));</span><br><span class="line"><span class="built_in">memset</span>(p,<span class="number">0</span>,<span class="built_in">sizeof</span>(p));</span><br><span class="line">p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">ans = <span class="number">1</span>;</span><br><span class="line">n = <span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(s[<span class="number">1</span>]==<span class="string">&#x27;E&#x27;</span>&amp;&amp;s[<span class="number">2</span>]==<span class="string">&#x27;N&#x27;</span>&amp;&amp;s[<span class="number">3</span>]==<span class="string">&#x27;D&#x27;</span>&amp;&amp;n==<span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">last[i] = last[i<span class="number">-1</span>]*P+(s[n-i+<span class="number">1</span>]-<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>);</span><br><span class="line">pre[i] = pre[i<span class="number">-1</span>]*P+(s[i]-<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>);</span><br><span class="line">p[i] = p[i<span class="number">-1</span>]*P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(s[i]!=s[i<span class="number">-1</span>]) <span class="built_in">cal</span>(i,i);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">cal</span>(i,i),<span class="built_in">cal</span>(i<span class="number">-1</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Case %d: %d\n&quot;</span>,k,ans);</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li>算法二: 见笔记 <a href="https://xcxc82.github.io/2020/10/23/manacher%E7%AE%97%E6%B3%95/">manacher算法</a> (以后用空了真的想把这些学习笔记重构下,写的实在是太乱了。。)</li></ul><ul><li><p>例题: 后缀数组(SA)</p><ul><li><p>这里直接用快速排序进行字典排序会被卡成$n^2logn$,因此考虑使用二分+哈希,找到第一个字符不同的位置。复杂度$O(nlog^2n)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n,SA[MAXN],height[MAXN];</span><br><span class="line"><span class="type">char</span> s[MAXN];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> a,b;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> f[MAXN],p[MAXN];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Check</span><span class="params">(<span class="type">int</span> mid,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">a = f[x+mid<span class="number">-1</span>]-f[x<span class="number">-1</span>]*p[mid];</span><br><span class="line">b = f[y+mid<span class="number">-1</span>]-f[y<span class="number">-1</span>]*p[mid];</span><br><span class="line"><span class="keyword">if</span>(a==b) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Cmp</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> l = <span class="number">0</span>,r = <span class="built_in">min</span>(n-a+<span class="number">1</span>,n-b+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line"><span class="type">int</span> mid = (l+r+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>; </span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">Check</span>(mid,a,b)) l = mid;</span><br><span class="line"><span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s[a+l]&lt;s[b+l];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Get_Height</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> l = <span class="number">0</span>,r = <span class="built_in">min</span>(n-a+<span class="number">1</span>,n-b+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line"><span class="type">int</span> mid = (l+r+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>; </span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">Check</span>(mid,a,b)) l = mid;</span><br><span class="line"><span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;(s+<span class="number">1</span>);</span><br><span class="line">n = <span class="built_in">strlen</span>(s+<span class="number">1</span>);</span><br><span class="line">p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">SA[i] = i;</span><br><span class="line">f[i] = f[i<span class="number">-1</span>]*P+(s[i]-<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>);<span class="comment">//前i个字符的哈希值 </span></span><br><span class="line">p[i] = p[i<span class="number">-1</span>]*P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(SA+<span class="number">1</span>,SA+<span class="number">1</span>+n,Cmp);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,SA[i]<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">height[i] = <span class="built_in">Get_Height</span>(SA[i],SA[i<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,height[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="0x15-字符串"><a href="#0x15-字符串" class="headerlink" title="0x15 字符串"></a>0x15 字符串</h4><ul><li>暂时略过。之后再补</li></ul><h4 id="0x16-Tire"><a href="#0x16-Tire" class="headerlink" title="0x16 Tire"></a>0x16 Tire</h4><h4 id="0x17-二叉堆"><a href="#0x17-二叉堆" class="headerlink" title="0x17 二叉堆"></a>0x17 二叉堆</h4><ul><li><p>例题: 超市</p><ul><li><p>带后悔的贪心。我们将每个商品按过期时间从大到小排序, 并开一个小根堆, 扫描每个商品:</p><p>若当前商品的过期日期大于当前商品个数(堆的大小),直接将该商品放入堆中</p><p>若当前商品的过期日期等于当前商品个数且当前商品的价值大于堆中最小的商品价值,则将该商品放入堆中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt; &gt; q;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Item</span>&#123;</span><br><span class="line"><span class="type">int</span> p,d;</span><br><span class="line">&#125;a[MAXN];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Cmp</span><span class="params">(Item a,Item b)</span></span>&#123; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>,Cmp);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i].d&gt;q.<span class="built_in">size</span>()) q.<span class="built_in">push</span>(a[i].p);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a[i].d==q.<span class="built_in">size</span>()&amp;&amp;a[i].p&gt;q.<span class="built_in">top</span>())&#123;</span><br><span class="line">q.<span class="built_in">pop</span>(),q.<span class="built_in">push</span>(a[i].p);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">ans+=q.<span class="built_in">top</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>例题: 合并序列</p><ul><li><p>先来考虑只有两个序列时的简单情况, 先将两个序列$a$,$b$排序, 最小的值显然是$a<em>1+b_1$,次小值则为$min{a_1+b_2,a_2+b_1}$,假设$a_1+b_2$为次小值,那么第三小值即为$min{a_1+b_3,a_2+b_2,a_2+b_1}$,也就是说,当$a_i+b_j$成为第$k$小值后,$a</em>{i+1},b<em>j$和$a_i,b</em>{j+1}$便会加入第$k+1$小值的”备选队列”</p><p>对此,我们只需要开一个堆,储存一个三元组$(i,j,a<em>i+b_j)$,每次取出最小的$a_i+b_j$,再将$(i+1,j,a</em>{i+1}+b<em>j)$和$(i,j+1,a_i+b</em>{j+1})$插入堆中即可</p><p>对于$n$个序列的情况,我们只需要每次进行两两合并即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n,m,T;</span><br><span class="line"><span class="type">int</span> a[MAXN],vis[MAXN][MAXN],ans[MAXN];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line"><span class="type">int</span> i,j,val;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> Node &amp;a,<span class="type">const</span> Node &amp;b)&#123;</span><br><span class="line"><span class="keyword">return</span> a.val&lt;b.val;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;Node&gt; q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> res[MAXN];</span><br><span class="line">res[<span class="number">1</span>] = ans[<span class="number">1</span>]+a[<span class="number">1</span>]; </span><br><span class="line">Node b,c;</span><br><span class="line">b.i = <span class="number">1</span>,b.j = <span class="number">2</span>,b.val = -(ans[b.i]+a[b.j]),q.<span class="built_in">push</span>(b);</span><br><span class="line">b.i = <span class="number">2</span>,b.j = <span class="number">1</span>,b.val = -(ans[b.i]+a[b.j]),q.<span class="built_in">push</span>(b);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=m;i++)&#123;</span><br><span class="line">res[i] = -q.<span class="built_in">top</span>().val;</span><br><span class="line">b = q.<span class="built_in">top</span>(),q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span>(!vis[b.i+<span class="number">1</span>][b.j])&#123;</span><br><span class="line">c.i = b.i+<span class="number">1</span>,c.j = b.j,c.val = -(ans[b.i+<span class="number">1</span>]+a[b.j]),q.<span class="built_in">push</span>(c);</span><br><span class="line">vis[b.i+<span class="number">1</span>][b.j] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!vis[b.i][b.j+<span class="number">1</span>])&#123;</span><br><span class="line">c.i = b.i,c.j = b.j+<span class="number">1</span>,c.val = -(ans[b.i]+a[b.j+<span class="number">1</span>]),q.<span class="built_in">push</span>(c);</span><br><span class="line">vis[b.i][b.j+<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(q.<span class="built_in">size</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">ans[i] = res[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">T = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line">n = <span class="built_in">read</span>(),m = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) ans[i] = <span class="built_in">read</span>();</span><br><span class="line"><span class="built_in">sort</span>(ans+<span class="number">1</span>,ans+<span class="number">1</span>+m);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++) a[j] = <span class="built_in">read</span>();</span><br><span class="line"><span class="built_in">sort</span>(a+<span class="number">1</span>,a+m+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">merge</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,ans[i]);</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>例题: 数据备份</p><ul><li><p>解法1:</p><p>考虑动态规划。设$f_{i,j,0/1}$表示前$i$个数中,选了$j$个数,第$i$个数选了/没选时的最优解。转移比较显然,就不写了,再用滚动数组优化一下可以取得<del>75~95pts的高分</del>(看题解区的大佬说好像还可以用wqs二分优化? 不过没学过就是了= =)</p></li><li><p>解法2</p><p>很巧妙的找性质+带后悔贪心。首先考虑$k=1$时的情况,显然最小值即为所求解;</p><p>接着看$k=2$时的情况,当第$i$个数被选择时,第$i-1$和第$i+1$个数都无法被选择,因此如果不选择第$i$个数,则第$i+1$和第$i-1$和数要么都选上,要么都不选,否则直接选第$i$个数一定更优。也就是说,在最优解中,最小值左右两侧的值只能同时被选择。</p><p>因此,我们可以使用一个小根堆和链表来进行决策选择,每次选择都将小根堆中的最小值并入答案,同时在链表中删除该最小值对应的节点$p$和其左右两边的两个点,并在原位置插入一个新的”反悔”节点 , 使其权值等于$v<em>{p.next}+v</em>{p.prev} - v_p$,也就是说,如果后面某次操作中,选择了该节点,则说明对于全局来说,选择左右两个节点更优,相当于对之前的选择进行了一次”后悔” (好吧我承认自己也将不太清这种题型= =,得开个专题好好研究一下)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> head,tot,tail,val,ans;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line"><span class="type">int</span> val,id;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> Node &amp;a,<span class="type">const</span> Node &amp;b)&#123;</span><br><span class="line"><span class="keyword">return</span> a.val&gt;b.val;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;Node&gt; q;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Link_List</span>&#123;</span><br><span class="line"><span class="type">int</span> prev,next,val;</span><br><span class="line">&#125;p[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">head = <span class="number">1</span>,tail = <span class="number">2</span>;</span><br><span class="line">p[head].val = p[tail].val = INF;</span><br><span class="line">tot = <span class="number">2</span>;</span><br><span class="line">p[head].next = tail,p[tail].prev = head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">p[++tot].val = val;</span><br><span class="line">p[p[x].next].prev = tot;</span><br><span class="line">p[tot].next = p[x].next;</span><br><span class="line">p[tot].prev = x;</span><br><span class="line">p[x].next = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">1</span>||x==<span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">p[p[x].next].prev = p[x].prev;</span><br><span class="line">p[p[x].prev].next = p[x].next; </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,k,a[MAXN],b[MAXN],vis[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">init</span>();</span><br><span class="line">n = <span class="built_in">read</span>(),k = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i] = <span class="built_in">read</span>();</span><br><span class="line"><span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++) b[i] = a[i] - a[i<span class="number">-1</span>];</span><br><span class="line"><span class="built_in">insert</span>(<span class="number">1</span>,b[<span class="number">2</span>]),q.<span class="built_in">push</span>(Node&#123;b[<span class="number">2</span>],<span class="number">3</span>&#125;);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++) <span class="built_in">insert</span>(i,b[i]),q.<span class="built_in">push</span>(Node&#123;b[i],i+<span class="number">1</span>&#125;);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(q.<span class="built_in">size</span>()&amp;&amp;vis[q.<span class="built_in">top</span>().id]) q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="type">int</span> now = q.<span class="built_in">top</span>().id;</span><br><span class="line">ans+=q.<span class="built_in">top</span>().val;</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">val = p[p[now].next].val+p[p[now].prev].val-p[now].val;</span><br><span class="line">vis[p[now].next] = <span class="number">1</span>,vis[p[now].prev] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">del</span>(p[now].next),<span class="built_in">del</span>(p[now].prev);</span><br><span class="line">p[now].val = val;</span><br><span class="line">q.<span class="built_in">push</span>(Node&#123;val,now&#125;);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>哈夫曼(Huffman)树</p><ul><li><p>引入:</p><p>考虑这样一个问题,假设一颗$k$叉树有$n$个带权叶子节点,其中第$i$个叶子节点的值为$w<em>i$,到根节点的距离为$l_i$,现要求求出一种二叉树的构造方式,使得$\sum\limits</em>{i=1}^nw_il_i$最小化</p></li><li><p>解法($k=2$):</p><p>$\sum\limits_{i=1}^nw_il_i$最小的树被称为$k$叉$huffman$树(哈夫曼树)。一种比较直接的思路是$w$较大的节点放在较下面时最优,用反证法易证。当$k=2$时,其构造方式如下:</p><p>1.开一个小根堆,把所有的权值全部插入堆中</p><p>2.取出其中最小的两个值$w_1$和$w_2$</p><p>3.建立一个….并将其再次插入堆中</p><p>4.重复第步骤1~3,直到只剩最后一个值在堆中</p></li><li><p>解法($k&gt;2$)</p><p>一种比较直接的想法是把上述的”取最小的两个数”改成”取最小的$k$个数”,不过,仔细思考会发现,若最后一次取数时,堆的大小$&lt;k$,不足以取出$k$个,那么根节点的子节点数量将会小于$k$,这显然不是最优解,把下面任何一个叶子节点移上来,改为根的子节点都将更优</p><p>因此,我们需要在开始合并前,增加一些权值为$0$的节点,使得$(n-1) \bmod (k-1) = 0$(计算一下易证),这样,子节点不足$k$的情况就会发生在叶子节点处,而非根节点处</p></li></ul></li><li><p>例题: 荷马史诗</p><ul><li><p>首先有一个性质,如果把哈夫曼树看作一颗”trie树”,那么显然每个叶子节点代表的”单词”都是不同的,也就是说$k$叉哈夫曼树的构造方式就是本题的构造方式,因此,我们只需要构造出一颗$k$叉哈夫曼树即可。对于使最长的$s_i$最小的限制,只需要在每次合并时取长度,也就是合并次数最少节点合并即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">ll n,k,val,cnt,res;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">ll val;</span><br><span class="line">ll cnt;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> Node &amp;a,<span class="type">const</span> Node &amp;b)&#123;</span><br><span class="line"><span class="keyword">if</span>(a.val==b.val) <span class="keyword">return</span> a.cnt&gt;b.cnt;   </span><br><span class="line"><span class="keyword">return</span> a.val&gt;b.val;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;Node&gt; q;</span><br><span class="line">ll w[MAXN];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n = <span class="built_in">read</span>(),k = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) w[i] = <span class="built_in">read</span>(),q.<span class="built_in">push</span>(Node&#123;w[i],<span class="number">1</span>&#125;);</span><br><span class="line"><span class="keyword">while</span>((n<span class="number">-1</span>)%(k<span class="number">-1</span>)!=<span class="number">0</span>)&#123;</span><br><span class="line">w[++n] = <span class="number">0</span>;</span><br><span class="line">q.<span class="built_in">push</span>(Node&#123;w[n],<span class="number">0</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(q.<span class="built_in">size</span>()!=<span class="number">1</span>)&#123;</span><br><span class="line">val = <span class="number">0</span>,cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++) val+=q.<span class="built_in">top</span>().val,cnt = <span class="built_in">max</span>(cnt,q.<span class="built_in">top</span>().cnt),q.<span class="built_in">pop</span>();</span><br><span class="line">res = <span class="built_in">max</span>(res,cnt);</span><br><span class="line">q.<span class="built_in">push</span>(Node&#123;val,cnt+<span class="number">1</span>&#125;);</span><br><span class="line">ans+=val;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl&lt;&lt;res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="0x18-总结与练习"><a href="#0x18-总结与练习" class="headerlink" title="0x18 总结与练习"></a>0x18 总结与练习</h4><ul><li><p>括号画家</p><ul><li><p>解法挺多的,这边用的是普通的dp解法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">string s;</span><br><span class="line">pair&lt;<span class="type">char</span>,<span class="type">int</span>&gt; a[MAXN];</span><br><span class="line"><span class="type">int</span> ans,MAX[MAXN],top,last,now; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;s;</span><br><span class="line">s = <span class="string">&#x27; &#x27;</span>+s;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=s.<span class="built_in">length</span>()<span class="number">-1</span>;i++)&#123;</span><br><span class="line"><span class="type">int</span> last = a[top].second;</span><br><span class="line"><span class="keyword">if</span>(s[i]==<span class="string">&#x27;&#123;&#x27;</span>||s[i]==<span class="string">&#x27;(&#x27;</span>||s[i]==<span class="string">&#x27;[&#x27;</span>) a[++top] = <span class="built_in">make_pair</span>(s[i],i);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a[top].first==<span class="string">&#x27;&#123;&#x27;</span>&amp;&amp;s[i]==<span class="string">&#x27;&#125;&#x27;</span>) top--,MAX[i] = MAX[last<span class="number">-1</span>]+<span class="number">2</span>+MAX[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a[top].first==<span class="string">&#x27;(&#x27;</span>&amp;&amp;s[i]==<span class="string">&#x27;)&#x27;</span>) top--,MAX[i] = MAX[last<span class="number">-1</span>]+<span class="number">2</span>+MAX[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a[top].first==<span class="string">&#x27;[&#x27;</span>&amp;&amp;s[i]==<span class="string">&#x27;]&#x27;</span>) top--,MAX[i] = MAX[last<span class="number">-1</span>]+<span class="number">2</span>+MAX[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">top = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">ans = <span class="built_in">max</span>(ans,MAX[i]);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>城市游戏</p><ul><li><p>记得之前自己第一次做这题的时候还是用一个听起来很nb的”悬线法dp”的方法来解的= =。实际上直接单调栈就行了,对每个点求其最高扩展距离,然后对每一行进行枚举即可。(OI wiki上的悬线法的介绍中也有写到”悬线法能解决的问题范围是单调栈的子集”)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="type">int</span> up[MAXN][MAXN],n,m;</span><br><span class="line"><span class="type">int</span> s[MAXN],top,w[MAXN],ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n = <span class="built_in">read</span>(),m = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">cin&gt;&gt;c;</span><br><span class="line"><span class="keyword">if</span>(c==<span class="string">&#x27;F&#x27;</span>) up[i][j] = up[i<span class="number">-1</span>][j]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> up[i][j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">memset</span>(w,<span class="number">0</span>,<span class="built_in">sizeof</span>(w));</span><br><span class="line">top = <span class="number">0</span>;</span><br><span class="line">s[++top] = up[i][<span class="number">1</span>],w[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=m+<span class="number">1</span>;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(up[i][j]&gt;=s[top]) s[++top] = up[i][j],w[top] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="type">int</span> W = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(s[top]&gt;up[i][j])&#123;</span><br><span class="line">W+=w[top];</span><br><span class="line">ans = <span class="built_in">max</span>(ans,W*s[top]);</span><br><span class="line">top--;</span><br><span class="line">&#125;</span><br><span class="line">s[++top] = up[i][j],w[top] = W+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="number">3</span>*ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>双栈排序</p><ul><li>随便写了个看起来就很假的贪心交了上去,取得了<del>30pts的好成绩</del>。正解似乎要用到二分图染色? <del>那等我复习完图论后再来补吧</del></li></ul></li><li><p>滑动窗口</p><ul><li><p>经典单调队列题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n,m,a[MAXN],q[MAXN],l,r;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Get_Max</span><span class="params">()</span></span>&#123;</span><br><span class="line">l = <span class="number">0</span>,r = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=r&amp;&amp;q[l]&lt;=i-m) l++;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=r&amp;&amp;a[q[r]]&lt;a[i]) r--;</span><br><span class="line">q[++r] = i;</span><br><span class="line"><span class="keyword">if</span>(i&gt;=m) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[q[l]]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Get_Min</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=r&amp;&amp;q[l]&lt;=i-m) l++;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=r&amp;&amp;a[q[r]]&gt;a[i]) r--;</span><br><span class="line">q[++r] = i;</span><br><span class="line"><span class="keyword">if</span>(i&gt;=m) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,a[q[l]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n = <span class="built_in">read</span>(),m = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i] = <span class="built_in">read</span>();</span><br><span class="line"><span class="built_in">Get_Min</span>();</span><br><span class="line"><span class="built_in">Get_Max</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>内存分配</p><ul><li><p>毒瘤模拟题。。。坑点挺多的,这边用了官方题解里的vector模拟链表的写法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n,t,m,p,ans,cnt,w;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Process</span>&#123;</span><br><span class="line"><span class="type">int</span> l,r,t,p,len;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> Process x) <span class="type">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> l &lt; x.l;</span><br><span class="line">&#125; </span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Process&gt; memory;</span><br><span class="line">queue&lt;Process&gt; wait_queue;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">work</span><span class="params">(Process x,<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(memory.<span class="built_in">empty</span>()||memory[<span class="number">0</span>].l&gt;=x.len)&#123;</span><br><span class="line">x.l = <span class="number">0</span>;</span><br><span class="line">x.t = t;</span><br><span class="line">x.r= x.l + x.len;</span><br><span class="line">ans = <span class="built_in">max</span>(ans, x.t + x.p);</span><br><span class="line">memory.<span class="built_in">push_back</span>(x);</span><br><span class="line"><span class="built_in">sort</span>(memory.<span class="built_in">begin</span>(),memory.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> len = memory.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">ans = <span class="built_in">max</span>(ans, memory[i].t + memory[i].p);</span><br><span class="line"><span class="keyword">if</span>(memory[i].l - memory[i<span class="number">-1</span>].r&gt;=x.len)&#123;</span><br><span class="line">x.l = memory[i<span class="number">-1</span>].r;</span><br><span class="line">x.r= x.l + x.len;</span><br><span class="line">x.t = t;</span><br><span class="line">memory.<span class="built_in">push_back</span>(x);</span><br><span class="line"><span class="built_in">sort</span>(memory.<span class="built_in">begin</span>(),memory.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(n-memory[len].r&gt;=x.len)&#123;</span><br><span class="line">x.l = memory[len].r;</span><br><span class="line">x.r  = x.l + x.len;</span><br><span class="line">x.t = t;</span><br><span class="line">ans = <span class="built_in">max</span>(ans, x.t + x.p);</span><br><span class="line">memory.<span class="built_in">push_back</span>(x);</span><br><span class="line"><span class="built_in">sort</span>(memory.<span class="built_in">begin</span>(),memory.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">release</span><span class="params">(<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> now = INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;memory.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(memory[i].t+memory[i].p&lt;=t) memory.<span class="built_in">erase</span>(memory.<span class="built_in">begin</span>()+i--);</span><br><span class="line"><span class="keyword">else</span> now = <span class="built_in">min</span>(now,memory[i].p+memory[i].t);</span><br><span class="line">&#125;</span><br><span class="line">Process x;</span><br><span class="line"><span class="keyword">while</span>(wait_queue.<span class="built_in">size</span>())&#123;</span><br><span class="line">x = wait_queue.<span class="built_in">front</span>();</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">work</span>(x,w))&#123;</span><br><span class="line">now = <span class="built_in">min</span>(now,wait_queue.<span class="built_in">front</span>().t + wait_queue.<span class="built_in">front</span>().p);</span><br><span class="line">wait_queue.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">w = now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">(Process x)</span></span>&#123;</span><br><span class="line">cnt++;</span><br><span class="line">wait_queue.<span class="built_in">push</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">w = INF;</span><br><span class="line">n = <span class="built_in">read</span>();</span><br><span class="line">Process x;</span><br><span class="line"><span class="keyword">while</span>(cin&gt;&gt;t&gt;&gt;m&gt;&gt;p)&#123;</span><br><span class="line"><span class="keyword">if</span>(!t&amp;&amp;!m&amp;&amp;!p) <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">while</span>(t&gt;=w) <span class="built_in">release</span>(w); <span class="comment">//注意这里不能一次删完(release(t)),题里说了只要一有空位就把队头插进去,要一次次的删 </span></span><br><span class="line">x.t = t,x.len = m,x.p = p;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">work</span>(x,t))&#123;</span><br><span class="line">w = <span class="built_in">min</span>(w,t+p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">wait</span>(x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(wait_queue.<span class="built_in">size</span>())&#123;</span><br><span class="line"><span class="built_in">release</span>(w);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl&lt;&lt;cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>矩阵</p><ul><li><p>二维哈希。哈希本质上就是加权相加,因此我们可以把矩阵的每一列每一行像二维前缀和那样进行表示即可。另外题也是真的卡常= = 多写了三个循环就过不去了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> eq;</span><br><span class="line"><span class="type">int</span> n,m,a,b,q;</span><br><span class="line"><span class="type">int</span> ans[MAXN];</span><br><span class="line"><span class="type">char</span> s[MAXN],qs[MAXN][MAXN];</span><br><span class="line">ull A[MAXN][MAXN],B[MAXN][MAXN],p1[MAXN],p2[MAXN],x;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">x = A[i][j] - A[i-a][j]*p2[a] - A[i][j-b]*p1[b] + A[i-a][j-b]*p2[a]*p1[b];</span><br><span class="line"><span class="keyword">if</span>(x==B[a][b]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ull <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= a; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, qs[i] + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= b; j++)</span><br><span class="line">B[i][j] = B[i][j<span class="number">-1</span>] * P1 + (qs[i][j]-<span class="string">&#x27;0&#x27;</span>+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= a; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= b; j++)</span><br><span class="line">B[i][j] += B[i<span class="number">-1</span>][j] * P2;</span><br><span class="line"><span class="keyword">return</span> B[a][b];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">p1[<span class="number">0</span>] = <span class="number">1</span>,p2[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;MAXN;i++) p1[i] = p1[i<span class="number">-1</span>]*P1;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;MAXN;i++) p2[i] = p2[i<span class="number">-1</span>]*P2; </span><br><span class="line">n = <span class="built_in">read</span>(),m = <span class="built_in">read</span>(),a = <span class="built_in">read</span>(),b = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">cin&gt;&gt;(s+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">A[i][j] = A[i][j<span class="number">-1</span>]*P1+(s[j]-<span class="string">&#x27;0&#x27;</span>+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">A[i][j] = A[i<span class="number">-1</span>][j]*P2+A[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">q = <span class="built_in">read</span>();</span><br><span class="line">map&lt;ull, vector&lt;<span class="type">int</span>&gt; &gt; qans;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++) qans[<span class="built_in">get</span>()].<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = a; i &lt;= m; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = b; j &lt;= n; j++) &#123;</span><br><span class="line">ull k = A[i][j] - A[i-a][j]*p2[a] - A[i][j-b]*p1[b] + A[i-a][j-b]*p2[a]*p1[b];</span><br><span class="line"><span class="keyword">if</span> (qans.<span class="built_in">find</span>(k) != qans.<span class="built_in">end</span>())</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; qans[k].<span class="built_in">size</span>(); i++)</span><br><span class="line">ans[qans[k][i]] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; i++) cout &lt;&lt; (ans[i] ? <span class="string">&quot;1&quot;</span> : <span class="string">&quot;0&quot;</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>树形地铁系统</p></li><li><p>项链</p></li><li><p>奶牛矩阵</p></li><li><p>匹配统计</p><ul><li><p>hash水题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a[MAXN],b[MAXN];</span><br><span class="line"><span class="type">int</span> n,m,q,x;</span><br><span class="line"><span class="type">int</span> buc[MAXN];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> p[MAXN],f1[MAXN],f2[MAXN];</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title">Hash_A</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> f1[r] - f1[l<span class="number">-1</span>]*p[r-l+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title">Hash_B</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> f2[r] - f2[l<span class="number">-1</span>]*p[r-l+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Check</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> l = <span class="number">0</span>,r = <span class="built_in">min</span>(n-i+<span class="number">1</span>,m);</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line"><span class="type">int</span> mid = (l+r+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">Hash_A</span>(i,i+mid<span class="number">-1</span>)==<span class="built_in">Hash_B</span>(<span class="number">1</span>,mid)) l = mid;</span><br><span class="line"><span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">buc[l]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;</span><br><span class="line">p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line">f1[i] = f1[i<span class="number">-1</span>]*P+(a[i]-<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>);</span><br><span class="line">p[i] = p[i<span class="number">-1</span>]*P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">cin&gt;&gt;b[i];</span><br><span class="line">f2[i] = f2[i<span class="number">-1</span>]*P+(b[i]-<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>);</span><br><span class="line">p[i] = p[i<span class="number">-1</span>]*P;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">Check</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line">x = <span class="built_in">read</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,buc[x]); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>电话列表</p><ul><li><p>trie水题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">string s[MAXN];</span><br><span class="line"><span class="type">bool</span> eq;</span><br><span class="line"><span class="type">int</span> trie[MAXN][<span class="number">12</span>],tot = <span class="number">1</span>,n,T;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line"><span class="type">bool</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line"><span class="type">int</span> x = s[i]-<span class="string">&#x27;0&#x27;</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(!trie[p][x]) b = <span class="number">0</span>,trie[p][x] = ++tot;</span><br><span class="line">p = trie[p][x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(b) eq = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Cmp</span><span class="params">(string a,string b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.<span class="built_in">size</span>()&lt;b.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">T = <span class="built_in">raed</span>();</span><br><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line">tot = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">memset</span>(trie,<span class="number">0</span>,<span class="built_in">sizeof</span>(trie));</span><br><span class="line">eq = <span class="number">1</span>;</span><br><span class="line">n = <span class="built_in">raed</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">cin&gt;&gt;s[i],s[i] = <span class="string">&#x27; &#x27;</span>+s[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(s+<span class="number">1</span>,s+n+<span class="number">1</span>,Cmp);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line"><span class="built_in">Insert</span>(s[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(eq) cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>黑盒子</p><ul><li><p>对顶堆水题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n,m,a[MAXN],u[MAXN],now,p;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; q2;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt; &gt; q1;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">n = <span class="built_in">read</span>(),m = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i] = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) p = <span class="built_in">read</span>(),u[p]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">q1.<span class="built_in">push</span>(a[i]);</span><br><span class="line"><span class="keyword">if</span>(q2.<span class="built_in">size</span>()&amp;&amp;q2.<span class="built_in">top</span>()&gt;q1.<span class="built_in">top</span>())&#123;</span><br><span class="line"><span class="type">int</span> a = q2.<span class="built_in">top</span>(),b = q1.<span class="built_in">top</span>();</span><br><span class="line">q2.<span class="built_in">pop</span>(),q1.<span class="built_in">pop</span>();</span><br><span class="line">q2.<span class="built_in">push</span>(b),q1.<span class="built_in">push</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(u[i])&#123;</span><br><span class="line">now++;</span><br><span class="line"><span class="keyword">while</span>(now&gt;q2.<span class="built_in">size</span>()&amp;&amp;!q1.<span class="built_in">empty</span>())&#123;</span><br><span class="line">q2.<span class="built_in">push</span>(q1.<span class="built_in">top</span>());</span><br><span class="line">q1.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(now&lt;q2.<span class="built_in">size</span>()&amp;&amp;!q2.<span class="built_in">empty</span>())&#123;</span><br><span class="line">q1.<span class="built_in">push</span>(q2.<span class="built_in">top</span>());</span><br><span class="line">q2.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">u[i]--;</span><br><span class="line">cout&lt;&lt;q2.<span class="built_in">top</span>()&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>生日礼物</p><p>巧妙的性质转化问题。</p><p>显然一段全为正数和负数的区间肯定会被连续选择,因此我们可以把原序列划分为若干个正负交替的”区间”:</p><p>反着来考虑问题,假设现在有$k$段正数区间,如果$k≤m$,正数段不足$k$个,直接全部选上即可,反之,我们先将所有的正数段都选上,然后考虑如何减少段数,使得总段数$≤m$</p><p>减少区间数有两种做法: 1.删去一段正数 2.将负数段相邻的两段正数合并</p><p>我们可以模仿”数据备份”里的做法,开一个堆来储存我们的决策,同时插入”反悔”决策</p><p>决策1的反悔决策,即将其与左右两边的负数段合并而非删除自身,决策二的反悔决策,也就是删除其左右两边的正数而非合并两段数,这两个决策都等价于”数据备份”里的”将左右两个节点与自身合并”,因此,直接使用”数据备份”里的维护方法即可(感觉可能表达的不是很清楚? 以后会改 先这样吧qwq)</p><p>ps: 小坑点: 注意可能会出现a=0的情况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n,m,a[MAXN],sum[MAXN],vis[MAXN],cnt = <span class="number">1</span>,tot,val,ans;</span><br><span class="line"><span class="type">int</span> pos;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> head,tail;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line"><span class="type">int</span> val,id;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> Node &amp;a,<span class="type">const</span> Node &amp;b)&#123;</span><br><span class="line"><span class="keyword">return</span> a.val&gt;b.val;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;Node&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Link_List</span>&#123;</span><br><span class="line"><span class="type">int</span> next,val,prev;</span><br><span class="line">&#125;p[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">head = <span class="number">1</span>,tail = <span class="number">2</span>;</span><br><span class="line">tot = <span class="number">2</span>;</span><br><span class="line">p[head].val = p[tail].val = INF;</span><br><span class="line">p[head].next = tail;</span><br><span class="line">p[tail].prev = head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">p[++tot].val = val;</span><br><span class="line">p[p[x].next].prev = tot;</span><br><span class="line">p[tot].next = p[x].next;</span><br><span class="line">p[tot].prev = x;</span><br><span class="line">p[x].next = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Delete</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">1</span>||x==<span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">p[p[x].next].prev = p[x].prev;</span><br><span class="line">p[p[x].prev].next = p[x].next; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">Init</span>();</span><br><span class="line">n = <span class="built_in">read</span>(),m = <span class="built_in">read</span>();</span><br><span class="line">a[<span class="number">1</span>] = <span class="built_in">read</span>(),sum[<span class="number">1</span>] = a[<span class="number">1</span>]; </span><br><span class="line">    <span class="type">int</span> last = a[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        a[i] = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">if</span> (a[i]==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[i]*last&lt;<span class="number">0</span>) sum[++cnt] = a[i];</span><br><span class="line">        <span class="keyword">else</span> sum[cnt]+=a[i];</span><br><span class="line">        last = a[i];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">if</span>(sum[cnt]&lt;<span class="number">0</span>) cnt--;</span><br><span class="line"><span class="keyword">if</span>(sum[<span class="number">1</span>]&lt;<span class="number">0</span>)&#123;</span><br><span class="line">cnt--;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++) sum[i] = sum[i+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(sum[<span class="number">1</span>]&gt;<span class="number">0</span>) ans+=sum[<span class="number">1</span>],<span class="built_in">Insert</span>(<span class="number">1</span>,sum[<span class="number">1</span>]),q.<span class="built_in">push</span>(Node&#123;sum[<span class="number">1</span>],<span class="number">3</span>&#125;),pos = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(sum[i]&gt;<span class="number">0</span>) ans+=sum[i],pos++;</span><br><span class="line"><span class="keyword">else</span> sum[i] = -sum[i];</span><br><span class="line"><span class="built_in">Insert</span>(i+<span class="number">1</span>,sum[i]),q.<span class="built_in">push</span>(Node&#123;sum[i],i+<span class="number">2</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(pos&lt;=m)&#123;</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="type">int</span> del_cnt = pos - m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=del_cnt;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(q.<span class="built_in">size</span>()&amp;&amp;vis[q.<span class="built_in">top</span>().id]) q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="type">int</span> now = q.<span class="built_in">top</span>().id;</span><br><span class="line">ans-=q.<span class="built_in">top</span>().val;</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">vis[p[now].next] = <span class="number">1</span>,vis[p[now].prev] = <span class="number">1</span>;</span><br><span class="line">val = p[p[now].next].val+p[p[now].prev].val-p[now].val;</span><br><span class="line"><span class="built_in">Delete</span>(p[now].next),<span class="built_in">Delete</span>(p[now].prev);</span><br><span class="line">p[now].val = val;</span><br><span class="line">q.<span class="built_in">push</span>(Node&#123;val,now&#125;);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《算法竞赛进阶指南》第三章 读书笔记</title>
      <link href="/2022/10/26/%E3%80%8A%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97%E3%80%8B%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/10/26/%E3%80%8A%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97%E3%80%8B%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul><li>竞赛复健,自用向整理</li><li>为简约文本,代码均省略开头部分</li><li>书中所有例题均在acwing上可以找到</li></ul><h3 id="0x20-搜索"><a href="#0x20-搜索" class="headerlink" title="0x20 搜索"></a>0x20 搜索</h3><h4 id="0x21-树与图的遍历"><a href="#0x21-树与图的遍历" class="headerlink" title="0x21 树与图的遍历"></a>0x21 树与图的遍历</h4><ul><li><p>树与图的深度优先遍历、树的dfs序、深度和重心</p><p>树与图的深度优先遍历:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">vis[u] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = head[u];i;i = edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = edge[i].v;</span><br><span class="line"><span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间戳: </p><p>即每个节点第一次被遍历到时的顺序。如某个节点第一个被遍历到,时间戳就为1,第二个遍历到就为2,以此类推</p><p>树的dfs序:</p><p>对于每个节点,在其刚进入递归和即将回溯前各记录一次该节点的编号,最后产生的一个长度为$2n$的序列就称为该树的dfs序</p><p>不难发现dfs序有一个特性: 设节点$i$在dfs序中两次出现的位置分别为$l_i$,$r_i$,则处于$(l_i,r_i)$区间内的节点就是以节点$i$为根的子树的$dfs$序,因此,通过dfs序,我们可以把很多树上问题转化为序列区间问题。</p><p>树的深度:</p><p>设节点$u$的深度为$d_u$,则其子节点的深度为$d_u+1$,以此类推</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">a[++cnt] = u;<span class="comment">//dfs序</span></span><br><span class="line">t[u] = ++time;<span class="comment">//时间戳</span></span><br><span class="line">vis[u] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = head[u];i;i = edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = edge[i].v;</span><br><span class="line"><span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">d[v] = d[u]+<span class="number">1</span>;<span class="comment">//深度</span></span><br><span class="line"><span class="built_in">Dfs</span>(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">a[++cnt] = u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>树的重心:</p><p>设$f_u$表示删除$u$节点后,产生的子树中最大的一颗的大小。$f_u$最小的节点被称为该树的重心,换句话说,删除该点后最大连通块的节点数最少</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">vis[u] = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> f = <span class="number">0</span>;<span class="comment">//最大子树大小</span></span><br><span class="line">size[u] = <span class="number">1</span>;<span class="comment">//子树大小</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = head[u];i;i = edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = edge[i].v;</span><br><span class="line"><span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line"><span class="built_in">dfs</span>(v);</span><br><span class="line">size[u]+=size[v];</span><br><span class="line">f = <span class="built_in">max</span>(f,size[v]);<span class="comment">//子节点子树大小</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">f = <span class="built_in">max</span>(f,n-size[u]);<span class="comment">//n为整棵树的节点数目</span></span><br><span class="line"><span class="keyword">if</span>(f&lt;ans)&#123;</span><br><span class="line">pos = u;<span class="comment">//重心</span></span><br><span class="line">ans = f;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图的连通块划分:</p><p>进行多次深度优先遍历,可以划分出一张无向图中的各个连通块</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">vis[u] = cnt;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = head[u];i;i = edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = edge[i].v;</span><br><span class="line"><span class="keyword">if</span>(vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">vis[v] = cnt;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">cnt++;</span><br><span class="line"><span class="built_in">Dfs</span>(i);</span><br></pre></td></tr></table></figure></li><li><p>树与图的广度优先遍历,拓扑排序</p><p>树与图的广度优先遍历:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>),vis[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line"><span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = head[u];i;i = edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = edge[i].v;</span><br><span class="line"><span class="keyword">if</span>(!vis[v]) vis[v] = <span class="number">1</span>,q.<span class="built_in">push</span>(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现,广度优先遍历是一种按照层次顺序进行遍历的方法,它有两个重要的性质:</p><p>1.只有在访问完第$i$层节点后,第$i+1$层的节点才会被访问</p><p>2.无论何时,队列中至多只有两层节点</p><p>也就是说,广度优先遍历队列中的元素满足”单调性”和”两段性”。这两条性质也是所有广度优先思想的基础</p><p>拓扑排序:</p><p>在一个有向无环图中,若一个由图中所有点构成的序列$A$对于任意一条边$(x,y)$,都满足$x$出现在$y$前面,则称序列$A$为该有向无环图的拓扑序,求解$A$的过程就称为拓扑排序</p><p>求解方法也很简单,统计每个节点的入度,图中入度为0的节点$x$,并将$x$连向的点的入度数都减1,不断重复上述步骤直到所有节点都被记录即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Topsort</span><span class="params">()</span></span>&#123;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(deg[i]==<span class="number">0</span>) q.<span class="built_in">push</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line"><span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">ans[++cnt] = u;</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = head[u];i;i = edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = edge[i].v;</span><br><span class="line">deg[v]--;</span><br><span class="line"><span class="keyword">if</span>(!deg[v]) q.<span class="built_in">push</span>(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>例题: 可达性统计</p><p>一个比较容易想到的解法是对图进行拓扑排序后倒过来统计,不过后面的子联通块会有重叠部分,不好统计,因此考虑使用一个$n$位二进制来判断每个节点能否到达,最后统计该二进制中1的个数即可。使用bitset进行二进制存储可以将复杂度优化到$O(n(n+m)/32)$,空间复杂度$O(n^2/8)$</p><p><img src="https://pic.jitudisk.com/public/2022/11/10/69337dd5071a5.png" alt=""></p><center>摘自OI wiki</center><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> head[MAXN],tot = <span class="number">1</span>,deg[MAXN],a[MAXN],M,f[MAXN];</span><br><span class="line">bitset&lt;MAXN&gt; b[MAXN];</span><br><span class="line"><span class="type">int</span> n,m,x,y;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ed</span>&#123;</span><br><span class="line"><span class="type">int</span> v,next;</span><br><span class="line">&#125;edge[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">edge[tot].v = v;</span><br><span class="line">edge[tot].next = head[u];</span><br><span class="line">head[u] = tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Topsort</span><span class="params">()</span></span>&#123;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!deg[i]) q.<span class="built_in">push</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line"><span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">a[++M] = u;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i = edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = edge[i].v;</span><br><span class="line">deg[v]--;</span><br><span class="line"><span class="keyword">if</span>(!deg[v]) q.<span class="built_in">push</span>(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n = <span class="built_in">read</span>(),m = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">x = <span class="built_in">read</span>(),y = <span class="built_in">read</span>();</span><br><span class="line"><span class="built_in">Add</span>(x,y);</span><br><span class="line">deg[y]++;</span><br><span class="line">b[x][y] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) b[i][i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) f[i] = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">Topsort</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=M;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = head[a[i]];j;j = edge[j].next)&#123;</span><br><span class="line"><span class="type">int</span> v = edge[j].v;</span><br><span class="line">b[a[i]]|=b[v];</span><br><span class="line">&#125;</span><br><span class="line">f[a[i]] = b[a[i]].<span class="built_in">count</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">cout&lt;&lt;f[i]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="0x22-深度优先搜索"><a href="#0x22-深度优先搜索" class="headerlink" title="0x22 深度优先搜索"></a>0x22 深度优先搜索</h4><ul><li><p>例题: 小猫爬山</p><p>设状态$(i,j)$表示前$i$只猫花费的费用为$j$元,对于每只猫,我们可以选择将其放入之前的购买的还有空位缆车或新买一个缆车,因此直接$dfs$枚举所有的方案,选花费最少的方案即可。</p><p>这里直接暴搜的复杂度最坏为$O(\sum\limits<em>{i=0}^{17}C</em>{18}^i)$,显然会T,考虑减枝:</p><p>首先比较容易想到的一个点是当前费用超过已知最小费用时,直接退出搜索</p><p>其次,对于枚举顺序,重量大的猫显然比重量小的猫更占空间,因此可以把猫先按重量排序,优先搜索更大的猫,减少分支数量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n,m,c[MAXN],buc[MAXN],cnt,ans = INF;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> cnt)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(cnt&gt;=ans) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(x==n+<span class="number">1</span>)&#123;</span><br><span class="line">ans = cnt;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(buc[i]+c[x]&lt;=m)&#123;</span><br><span class="line">buc[i]+=c[x];</span><br><span class="line"><span class="built_in">Dfs</span>(x+<span class="number">1</span>,cnt);</span><br><span class="line">buc[i]-=c[x];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">buc[cnt+<span class="number">1</span>] = c[x];</span><br><span class="line"><span class="built_in">Dfs</span>(x+<span class="number">1</span>,cnt+<span class="number">1</span>);</span><br><span class="line">buc[cnt+<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n = <span class="built_in">read</span>() , m = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) c[i] = <span class="built_in">read</span>();</span><br><span class="line"><span class="built_in">sort</span>(c+<span class="number">1</span>,c+n+<span class="number">1</span>),<span class="built_in">reverse</span>(c+<span class="number">1</span>,c+n+<span class="number">1</span>);</span><br><span class="line">ans = n;</span><br><span class="line"><span class="built_in">Dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>例题: 数独</p><p>枚举每一位填什么。由于这里是多组数据,直接暴搜时间复杂度过大,考虑优化:</p><p>对于枚举顺序,每次优先考虑”当前能填入的数最少”的位置显然可以更快的枚举出最终答案,对于填入的数的枚举,我们考虑使用9位二进制数来表示每行,每列,每个九宫格中能填的数的集合(第$i$位为1表示能填$i$,反之不能填),配合<code>lowbit</code>运算来加快枚举速度</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a[MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> row[MAXN],col[MAXN],Set[MAXN][MAXN],cnt[<span class="number">3010</span>];</span><br><span class="line"><span class="type">int</span> H[<span class="number">3010</span>];</span><br><span class="line"><span class="type">int</span> tot,b;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">9</span>;j++)&#123;</span><br><span class="line">cout&lt;&lt;a[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Dfs</span><span class="params">(<span class="type">int</span> now)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(now==tot)&#123;</span><br><span class="line"><span class="built_in">print</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> res = <span class="number">10</span>,x,y;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">9</span>;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i][j]==<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line"><span class="type">int</span> val = row[i]&amp;col[j]&amp;Set[(i<span class="number">-1</span>)/<span class="number">3</span>+<span class="number">1</span>][(j<span class="number">-1</span>)/<span class="number">3</span>+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span>(!val) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(cnt[val]&lt;res)&#123;</span><br><span class="line">x = i,y = j;</span><br><span class="line">res = cnt[val];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> p = row[x]&amp;col[y]&amp;Set[(x<span class="number">-1</span>)/<span class="number">3</span>+<span class="number">1</span>][(y<span class="number">-1</span>)/<span class="number">3</span>+<span class="number">1</span>];</span><br><span class="line"><span class="keyword">while</span>(p)&#123;</span><br><span class="line"><span class="type">int</span> k = H[p&amp;(-p)];</span><br><span class="line">row[x] ^= <span class="number">1</span>&lt;&lt;k,col[y] ^= <span class="number">1</span>&lt;&lt;k;</span><br><span class="line">Set[(x<span class="number">-1</span>)/<span class="number">3</span>+<span class="number">1</span>][(y<span class="number">-1</span>)/<span class="number">3</span>+<span class="number">1</span>] ^= <span class="number">1</span>&lt;&lt;k;</span><br><span class="line">a[x][y] = <span class="string">&#x27;1&#x27;</span>+k;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">Dfs</span>(now+<span class="number">1</span>)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">a[x][y] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">row[x] ^= <span class="number">1</span>&lt;&lt;k,col[y] ^= <span class="number">1</span>&lt;&lt;k;</span><br><span class="line">Set[(x<span class="number">-1</span>)/<span class="number">3</span>+<span class="number">1</span>][(y<span class="number">-1</span>)/<span class="number">3</span>+<span class="number">1</span>] ^= <span class="number">1</span>&lt;&lt;k;</span><br><span class="line">p-=p&amp;(-p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">11</span>;i++) H[<span class="number">1</span>&lt;&lt;i] = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1</span>&lt;&lt;<span class="number">9</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=i;j;j-=j&amp;(-j)) cnt[i]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++) row[i] = col[i] = (<span class="number">1</span> &lt;&lt; <span class="number">9</span>) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">9</span>;j++) Set[i][j] = (<span class="number">1</span> &lt;&lt; <span class="number">9</span>) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">b = <span class="number">0</span>;</span><br><span class="line">tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">9</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">9</span>;j++)&#123;</span><br><span class="line">cin&gt;&gt;a[i][j];</span><br><span class="line"><span class="keyword">if</span>(a[i][j]==<span class="string">&#x27;e&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(a[i][j]!=<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line"><span class="type">int</span> k = a[i][j] - <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">row[i] ^= <span class="number">1</span>&lt;&lt;k,col[j] ^= <span class="number">1</span>&lt;&lt;k;</span><br><span class="line">Set[(i<span class="number">-1</span>)/<span class="number">3</span>+<span class="number">1</span>][(j<span class="number">-1</span>)/<span class="number">3</span>+<span class="number">1</span>] ^= <span class="number">1</span>&lt;&lt;k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> tot++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Dfs</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="0x23-迭代加深"><a href="#0x23-迭代加深" class="headerlink" title="0x23 迭代加深"></a>0x23 迭代加深</h4><h4 id="0x24-广度优先搜索"><a href="#0x24-广度优先搜索" class="headerlink" title="0x24 广度优先搜索"></a>0x24 广度优先搜索</h4><ul><li><p>例题: 立体推箱子</p><p>设状态$f(i,j,0/1/2)$表示箱子的状态为”立”/“横”/“竖”,左上角坐标为$(i,j)$时的最小移动次数,转移易推,难点是细节较多</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n,m,ans[MAXN][MAXN][<span class="number">3</span>],tot,b[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line"><span class="type">char</span> a[MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> nx[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-2</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">2</span>&#125;&#125;;<span class="comment">//立 竖 横</span></span><br><span class="line"><span class="type">int</span> ny[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">-2</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> nt[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line"><span class="type">int</span> type,x,y;</span><br><span class="line">&#125;st,ed;</span><br><span class="line">queue&lt;Node&gt; q;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Check</span><span class="params">(Node k)</span></span>&#123;</span><br><span class="line"><span class="type">bool</span> is_out = k.x&lt;=n&amp;&amp;k.x&gt;=<span class="number">1</span>&amp;&amp;k.y&gt;=<span class="number">1</span>&amp;&amp;k.y&lt;=m;</span><br><span class="line"><span class="keyword">if</span>(!is_out) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(k.type==<span class="number">0</span>&amp;&amp;(a[k.x][k.y]==<span class="string">&#x27;E&#x27;</span>||a[k.x][k.y]==<span class="string">&#x27;#&#x27;</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(k.type==<span class="number">1</span>&amp;&amp;(a[k.x][k.y]==<span class="string">&#x27;#&#x27;</span>||a[k.x][k.y+<span class="number">1</span>]==<span class="string">&#x27;#&#x27;</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(k.type==<span class="number">2</span>&amp;&amp;(a[k.x+<span class="number">1</span>][k.y]==<span class="string">&#x27;#&#x27;</span>||a[k.x][k.y]==<span class="string">&#x27;#&#x27;</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Dfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">q.<span class="built_in">push</span>(st);</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">Node next;</span><br><span class="line">Node now = q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">next.x = now.x+nx[now.type][i];</span><br><span class="line">next.y = now.y+ny[now.type][i];</span><br><span class="line">next.type = nt[now.type][i];</span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">Check</span>(next)) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(ans[next.x][next.y][next.type]==<span class="number">-1</span>)&#123;</span><br><span class="line"><span class="type">int</span> val = ans[now.x][now.y][now.type]+<span class="number">1</span>;</span><br><span class="line">ans[next.x][next.y][next.type] = val;</span><br><span class="line"><span class="keyword">if</span>(next.x==ed.x&amp;&amp;next.y==ed.y&amp;&amp;next.type==ed.type) <span class="keyword">return</span> val;</span><br><span class="line">q.<span class="built_in">push</span>(next);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">cin&gt;&gt;a[i][j];</span><br><span class="line"><span class="keyword">if</span>(a[i][j]==<span class="string">&#x27;X&#x27;</span>)&#123;</span><br><span class="line">b[tot][<span class="number">0</span>] = i,b[tot][<span class="number">1</span>] = j;</span><br><span class="line">tot++;</span><br><span class="line">a[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a[i][j]==<span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">ed.x = i,ed.y = j,ed.type = <span class="number">0</span>;</span><br><span class="line">a[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(tot==<span class="number">1</span>)&#123;</span><br><span class="line">st.x = b[<span class="number">0</span>][<span class="number">0</span>],st.y = b[<span class="number">0</span>][<span class="number">1</span>],st.type = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(b[<span class="number">0</span>][<span class="number">0</span>]==b[<span class="number">1</span>][<span class="number">0</span>])&#123;</span><br><span class="line">st.y = <span class="built_in">min</span>(b[<span class="number">0</span>][<span class="number">1</span>],b[<span class="number">1</span>][<span class="number">1</span>]),st.x = b[<span class="number">0</span>][<span class="number">0</span>],st.type = <span class="number">1</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">st.x = <span class="built_in">min</span>(b[<span class="number">0</span>][<span class="number">0</span>],b[<span class="number">1</span>][<span class="number">0</span>]),st.y = b[<span class="number">0</span>][<span class="number">1</span>],st.type = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">3</span>;k++)&#123;</span><br><span class="line">ans[i][j][k] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans[st.x][st.y][st.type] = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> res = <span class="built_in">Dfs</span>();</span><br><span class="line"><span class="keyword">if</span>(!res) cout&lt;&lt;<span class="string">&quot;Impossible&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;m&amp;&amp;n&amp;&amp;m)&#123;</span><br><span class="line"><span class="built_in">Init</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>例题: 矩阵距离</p><p>多源$bfs$。把矩阵中所有为1的点或与1相邻的0压入队列作为初始状态即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n,m,b[MAXN][MAXN];</span><br><span class="line"><span class="type">char</span> a[MAXN][MAXN];</span><br><span class="line">queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt; q;</span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dfs</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; now = q.<span class="built_in">front</span>();</span><br><span class="line">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; next;</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line"><span class="type">int</span> X = now.first+dx[i],Y = now.second+dy[i];</span><br><span class="line">next.first = X;</span><br><span class="line">next.second = Y;</span><br><span class="line"><span class="keyword">if</span>(a[X][Y] == <span class="string">&#x27;0&#x27;</span>&amp;&amp;!b[X][Y])&#123;</span><br><span class="line">b[X][Y] = b[now.first][now.second]+<span class="number">1</span>;</span><br><span class="line">q.<span class="built_in">push</span>(next);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n = <span class="built_in">read</span>(),m = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">cin&gt;&gt;a[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i][j]==<span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(!b[i][j]&amp;&amp;(a[i+<span class="number">1</span>][j]==<span class="string">&#x27;1&#x27;</span>||a[i<span class="number">-1</span>][j]==<span class="string">&#x27;1&#x27;</span>||a[i][j+<span class="number">1</span>]==<span class="string">&#x27;1&#x27;</span>||a[i][j<span class="number">-1</span>]==<span class="string">&#x27;1&#x27;</span>))&#123;</span><br><span class="line">b[i][j] = <span class="number">1</span>;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(i,j));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Dfs</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">cout&lt;&lt;b[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>例题: 推箱子</p><p>毒瘤双重$bfs$。假如用最单层$bfs$来进行人和物的状态扩展,要在满足箱子移动次数的单调性的同时满足人移动次数的单调性,需要用到优先队列,但是这里有多组数据,会T(<del>UVA上的原题数据很水,能过</del>)</p><p>考虑使用状态$(i,j,0/1/2/3,k)$表示箱子在第$(i,j)$处,人在箱子的前/后/左/右时的最小移动次数为$k$,对于状态的扩展,在满足对应的限制条件时,可以选择将人移动到另一个方向,并推动一次,或者选择直接在当前方向推动一次,这样一来,箱子的移动次数就能够满足单调性</p><p>对于人移动到另一方向的最少次数,我们在内层再次进行一次$dfs$,判断现在人所在的位置能否移动到另一位置,并记录路径。注意,这里虽然能够满足箱子移动次数的单调性,但无法满足人移动次数的单调性,因此在第一次入队(被访问)时,得到的人的步数可能并非为最小值,需要使用数组$f_{i,j,k}$记录对应状态的人的最小步数,并不断进行更新</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line"><span class="type">int</span> x,y,last;</span><br><span class="line">string road;</span><br><span class="line">&#125;st,ed,box;</span><br><span class="line"><span class="type">int</span> n,m,tot;</span><br><span class="line">string ANS;</span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">char</span> dr[<span class="number">4</span>] = &#123;<span class="string">&#x27;n&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,<span class="string">&#x27;e&#x27;</span>&#125;;</span><br><span class="line"><span class="type">char</span> Dr[<span class="number">4</span>] = &#123;<span class="string">&#x27;N&#x27;</span>,<span class="string">&#x27;S&#x27;</span>,<span class="string">&#x27;W&#x27;</span>,<span class="string">&#x27;E&#x27;</span>&#125;;<span class="comment">//北南西东 </span></span><br><span class="line"><span class="type">int</span> Last[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;&#125;;</span><br><span class="line"><span class="type">char</span> a[MAXN][MAXN];</span><br><span class="line">queue&lt;Node&gt; q;</span><br><span class="line">string tmp;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x&gt;=<span class="number">1</span>&amp;&amp;x&lt;=n&amp;&amp;y&gt;=<span class="number">1</span>&amp;&amp;y&lt;=m&amp;&amp;a[x][y]!=<span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Bfs2</span><span class="params">(Node st,Node ed)</span></span>&#123;</span><br><span class="line">queue&lt;Node&gt; q;</span><br><span class="line">tmp = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="type">bool</span> vis[MAXN][MAXN];</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">st.road = <span class="string">&quot;&quot;</span>;</span><br><span class="line">q.<span class="built_in">push</span>(st);</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">Node now = q.<span class="built_in">front</span>(),next;</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span>(now.x==ed.x&amp;&amp;now.y==ed.y)&#123;</span><br><span class="line">tmp = now.road;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">next.x = now.x+dx[i];</span><br><span class="line">next.y = now.y+dy[i];</span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">check</span>(next.x,next.y)||vis[next.x][next.y]) <span class="keyword">continue</span>;</span><br><span class="line">vis[next.x][next.y] = <span class="number">1</span>;</span><br><span class="line">next.road = now.road+dr[i];</span><br><span class="line">q.<span class="built_in">push</span>(next);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count_man</span><span class="params">(Node now)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> cnt_b = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;now.road.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(now.road[i]&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;now.road[i]&lt;=<span class="string">&#x27;z&#x27;</span>) cnt_b++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt_b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Bfs1</span><span class="params">()</span></span>&#123;</span><br><span class="line">string ans;</span><br><span class="line"><span class="type">int</span> fman[MAXN][MAXN][<span class="number">5</span>]; </span><br><span class="line"><span class="built_in">memset</span>(fman,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(fman));</span><br><span class="line"><span class="type">int</span> ans_r = INF,ans_b = INF;</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">Node now = q.<span class="built_in">front</span>(),next,prev,last;</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span>(now.x==ed.x&amp;&amp;now.y==ed.y)&#123;</span><br><span class="line"><span class="type">int</span> cnt_b = <span class="number">0</span>,cnt_r = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;now.road.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(now.road[i]&gt;=<span class="string">&#x27;A&#x27;</span>&amp;&amp;now.road[i]&lt;=<span class="string">&#x27;Z&#x27;</span>) cnt_b++;</span><br><span class="line"><span class="keyword">else</span> cnt_r++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(cnt_b&lt;ans_b||(cnt_b==ans_b&amp;&amp;cnt_r&lt;ans_r))&#123;</span><br><span class="line">ans = now.road;</span><br><span class="line">ans_b = cnt_b;</span><br><span class="line">ans_r = cnt_r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">next.x = now.x+dx[i],next.y = now.y+dy[i];</span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">check</span>(next.x,next.y)) <span class="keyword">continue</span>;</span><br><span class="line"><span class="type">int</span> man_step = <span class="built_in">count_man</span>(now);</span><br><span class="line">            <span class="keyword">if</span> (man_step&gt;fman[now.x][now.y][i]) <span class="keyword">continue</span>;</span><br><span class="line">prev.x = now.x+Last[i][<span class="number">0</span>],prev.y = now.y+Last[i][<span class="number">1</span>];</span><br><span class="line">last.x = now.x+Last[now.last][<span class="number">0</span>],last.y = now.y+Last[now.last][<span class="number">1</span>];</span><br><span class="line">a[now.x][now.y] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">Bfs2</span>(last,prev))&#123;</span><br><span class="line">fman[now.x][now.y][i] = man_step;</span><br><span class="line">next.last = i;</span><br><span class="line">next.road = now.road+tmp+Dr[i];</span><br><span class="line">q.<span class="built_in">push</span>(next);</span><br><span class="line">&#125;</span><br><span class="line">a[now.x][now.y] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ans_r!=INF)&#123;</span><br><span class="line"><span class="keyword">if</span>(ans.<span class="built_in">length</span>()&lt;ANS.<span class="built_in">length</span>()||ANS==<span class="string">&quot;X&quot;</span>) ANS = ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">cin&gt;&gt;a[i][j];</span><br><span class="line"><span class="keyword">if</span>(a[i][j]==<span class="string">&#x27;S&#x27;</span>) st.x = i,st.y = j,a[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(a[i][j]==<span class="string">&#x27;T&#x27;</span>) ed.x = i,ed.y = j,a[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(a[i][j]==<span class="string">&#x27;B&#x27;</span>) box.x = i,box.y = j,a[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Node fir;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">fir.x = box.x+Last[i][<span class="number">0</span>];</span><br><span class="line">fir.y = box.y+Last[i][<span class="number">1</span>];</span><br><span class="line">box.last = i;</span><br><span class="line">a[box.x][box.y] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">check</span>(fir.x,fir.y)&amp;&amp;<span class="built_in">Bfs2</span>(st,fir)) box.road = tmp,q.<span class="built_in">push</span>(box),<span class="built_in">Bfs1</span>();</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Maze #&quot;</span>&lt;&lt;tot&lt;&lt;endl;</span><br><span class="line"><span class="keyword">if</span>(ANS==<span class="string">&quot;X&quot;</span>) cout&lt;&lt;<span class="string">&quot;Impossible.&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;ANS&lt;&lt;endl;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(cin&gt;&gt;n&gt;&gt;m&amp;&amp;n&amp;&amp;m)&#123;</span><br><span class="line">ANS = <span class="string">&quot;X&quot;</span>;</span><br><span class="line">tot++;</span><br><span class="line"><span class="built_in">Init</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="0x25-广搜变形"><a href="#0x25-广搜变形" class="headerlink" title="0x25 广搜变形"></a>0x25 广搜变形</h4><ul><li><p>例题: 电路维修</p><p>设状态$(i,j,k)$表示在$(i,j)$时,最小改变数为$k$,由于只有0/1两种代价,因此使用一个双端队列,对于能直接走到的点$(x,y)$,将状态$(x,y,k)$压入队列头部,对于不能直接走到的点,将状态$(x,y,j+1)$压入队列尾部,就能够保持队列的单调性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> T,n,m,ans[MAXN][MAXN],vis[MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">char</span> a[MAXN][MAXN];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x&gt;=<span class="number">1</span>&amp;&amp;x&lt;=n&amp;&amp;y&gt;=<span class="number">1</span>&amp;&amp;y&lt;=m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">deque&lt;Node&gt; q;</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line"><span class="built_in">memset</span>(ans,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(ans));</span><br><span class="line">q.<span class="built_in">push_front</span>(Node&#123;<span class="number">1</span>,<span class="number">1</span>&#125;);</span><br><span class="line">ans[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">Node next,now = q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop_front</span>();</span><br><span class="line"><span class="keyword">if</span>(vis[now.x][now.y]) <span class="keyword">continue</span>;</span><br><span class="line">vis[now.x][now.y] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(now.x==n&amp;&amp;now.y==m)&#123;</span><br><span class="line">cout&lt;&lt;ans[now.x][now.y]&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">next.x = now.x+dx[i];</span><br><span class="line">next.y = now.y+dy[i];</span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">check</span>(next.x,next.y)) <span class="keyword">continue</span>;</span><br><span class="line"><span class="type">int</span> X = <span class="built_in">min</span>(now.x,next.x),Y = <span class="built_in">min</span>(now.y,next.y);</span><br><span class="line"><span class="keyword">if</span>(a[X][Y]==<span class="string">&#x27;/&#x27;</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>((i==<span class="number">1</span>||i==<span class="number">2</span>)&amp;&amp;ans[now.x][now.y]&lt;ans[next.x][next.y])&#123;</span><br><span class="line">ans[next.x][next.y] = ans[now.x][now.y];</span><br><span class="line">q.<span class="built_in">push_front</span>(next);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(ans[now.x][now.y]+<span class="number">1</span>&lt;ans[next.x][next.y])&#123;</span><br><span class="line">ans[next.x][next.y] = ans[now.x][now.y]+<span class="number">1</span>;</span><br><span class="line">q.<span class="built_in">push_back</span>(next);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a[X][Y]==<span class="string">&#x27;\\&#x27;</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>((i==<span class="number">0</span>||i==<span class="number">3</span>)&amp;&amp;ans[now.x][now.y]&lt;ans[next.x][next.y])&#123;</span><br><span class="line">ans[next.x][next.y] = ans[now.x][now.y];</span><br><span class="line">q.<span class="built_in">push_front</span>(next);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(ans[now.x][now.y]+<span class="number">1</span>&lt;ans[next.x][next.y])&#123;</span><br><span class="line">ans[next.x][next.y] = ans[now.x][now.y]+<span class="number">1</span>;</span><br><span class="line">q.<span class="built_in">push_back</span>(next);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">n = <span class="built_in">read</span>(),m = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">cin&gt;&gt;a[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">n++,m++;</span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">Bfs</span>()) cout&lt;&lt;<span class="string">&quot;NO SOLUTION&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">T = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line"><span class="built_in">Solve</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>例题: 装满的油箱</p><p>本质上是个分层图最短路,设状态$(i,j,k)$表示在$i$节点,剩余$j$油量,花费$k$元,对于状态扩张,在满足对应的限制条件时,可以选择在该节点加1升油,或前往下一个节点,跑一遍$dijstra$即可。复杂度为$O(q⋅c⋅(n+m)⋅logcn)$,不开$O_2$会被极限数据卡掉(<del>实际上数据挺水的</del>)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> tot = <span class="number">1</span>,n,m,T,C,S,E,head[MAXN],a[MAXN];</span><br><span class="line"><span class="type">int</span> vis[MAXN][MAXN];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ed</span>&#123;</span><br><span class="line"><span class="type">int</span> w,v,next;</span><br><span class="line">&#125;edge[<span class="number">10010</span>&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">status</span>&#123;</span><br><span class="line"><span class="type">int</span> node,oil,cost;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> status x) <span class="type">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> cost &gt; x.cost;</span><br><span class="line">&#125; </span><br><span class="line">&#125;st,ed;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">edge[tot].v = v;</span><br><span class="line">edge[tot].w = w;</span><br><span class="line">edge[tot].next = head[u];</span><br><span class="line">head[u] = tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> ans = INF;</span><br><span class="line"><span class="type">int</span> f[MAXN][<span class="number">110</span>];</span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">f[st.node][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">priority_queue&lt;status&gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(st);</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">status u = q.<span class="built_in">top</span>(),next;</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span>(vis[u.node][u.oil]) <span class="keyword">continue</span>;</span><br><span class="line">vis[u.node][u.oil] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(u.node==E)&#123;</span><br><span class="line">cout&lt;&lt;u.cost&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u.node];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = edge[i].v,w = edge[i].w;</span><br><span class="line">next.node = v,next.oil = u.oil-w,next.cost = u.cost;</span><br><span class="line"><span class="keyword">if</span>(next.oil&gt;=<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(next.oil&gt;=<span class="number">0</span>&amp;&amp;next.cost&lt;f[v][next.oil])&#123;</span><br><span class="line">f[v][next.oil] = next.cost;</span><br><span class="line">q.<span class="built_in">push</span>(next);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(u.oil&lt;C&amp;&amp;u.cost+a[u.node]&lt;f[u.node][u.oil+<span class="number">1</span>])&#123;</span><br><span class="line">f[u.node][u.oil+<span class="number">1</span>] = u.cost+a[u.node];</span><br><span class="line">q.<span class="built_in">push</span>(status&#123;u.node,u.oil+<span class="number">1</span>,u.cost+a[u.node]&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">bfs</span>()) cout&lt;&lt;<span class="string">&quot;impossible&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n = <span class="built_in">read</span>(),m = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i] = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="built_in">read</span>(),y = <span class="built_in">read</span>(),w = <span class="built_in">read</span>();</span><br><span class="line"><span class="built_in">add</span>(x+<span class="number">1</span>,y+<span class="number">1</span>,w),<span class="built_in">add</span>(y+<span class="number">1</span>,x+<span class="number">1</span>,w);</span><br><span class="line">&#125;</span><br><span class="line">T = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line">C = <span class="built_in">read</span>(),S = <span class="built_in">read</span>(),E = <span class="built_in">read</span>();</span><br><span class="line">S++,E++;</span><br><span class="line">st.node = S,st.oil = <span class="number">0</span>,st.cost = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>例题: 噩梦</p><p>双向$bfs$,两个人一起$bfs$就行,另外题中没说能一直在一个点上不走,但其实数据中是可以呆在一个点不走的。。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line"><span class="type">int</span> x,y,t;</span><br><span class="line">&#125;boy,girl,ghost[<span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> n,m,T;</span><br><span class="line"><span class="type">char</span> a[MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> dx[<span class="number">5</span>] = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;; </span><br><span class="line"><span class="type">int</span> dy[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> (x&gt;=<span class="number">1</span>)&amp;&amp;(x&lt;=n)&amp;&amp;(y&gt;=<span class="number">1</span>)&amp;&amp;(y&lt;=m)&amp;&amp;(a[x][y]!=<span class="string">&#x27;X&#x27;</span>)&amp;&amp;(<span class="built_in">abs</span>(x-ghost[<span class="number">1</span>].x)+<span class="built_in">abs</span>(y-ghost[<span class="number">1</span>].y)&gt;<span class="number">2</span>*t)&amp;&amp;(<span class="built_in">abs</span>(x-ghost[<span class="number">2</span>].x)+<span class="built_in">abs</span>(y-ghost[<span class="number">2</span>].y)&gt;<span class="number">2</span>*t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> vis1[MAXN][MAXN],vis2[MAXN][MAXN];</span><br><span class="line"><span class="built_in">memset</span>(vis1,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis1));</span><br><span class="line"><span class="built_in">memset</span>(vis2,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis2));</span><br><span class="line">vis1[boy.x][boy.y] = <span class="number">1</span>,vis2[girl.x][girl.y] = <span class="number">1</span>;</span><br><span class="line">queue&lt;Node&gt; q1,q2;</span><br><span class="line">q1.<span class="built_in">push</span>(boy),q2.<span class="built_in">push</span>(girl);</span><br><span class="line"><span class="keyword">while</span>(!q1.<span class="built_in">empty</span>()||!q2.<span class="built_in">empty</span>())&#123;</span><br><span class="line"><span class="type">int</span> r = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">while</span>(r--)&#123;</span><br><span class="line"><span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(!q1.<span class="built_in">empty</span>())&#123;</span><br><span class="line">len = q1.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">if</span>(r==<span class="number">2</span>) ans = q1.<span class="built_in">front</span>().t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(len--)&#123;</span><br><span class="line">Node now = q1.<span class="built_in">front</span>();</span><br><span class="line">Node next;</span><br><span class="line">q1.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">check</span>(now.x,now.y,ans)) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">next.x = now.x+dx[i];</span><br><span class="line">next.y = now.y+dy[i];</span><br><span class="line">next.t = ans+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">check</span>(next.x,next.y,ans)||vis1[next.x][next.y]) <span class="keyword">continue</span>;</span><br><span class="line">vis1[next.x][next.y] = <span class="number">1</span>;</span><br><span class="line">q1.<span class="built_in">push</span>(next);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(!q2.<span class="built_in">empty</span>()) len = q2.<span class="built_in">size</span>();</span><br><span class="line"><span class="keyword">while</span>(len--)&#123;</span><br><span class="line">Node now = q2.<span class="built_in">front</span>();</span><br><span class="line">Node next;</span><br><span class="line">q2.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">check</span>(now.x,now.y,now.t)) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">next.x = now.x+dx[i];</span><br><span class="line">next.y = now.y+dy[i];</span><br><span class="line">next.t = now.t+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">check</span>(next.x,next.y,now.t)||vis2[next.x][next.y]) <span class="keyword">continue</span>;</span><br><span class="line">vis2[next.x][next.y] = <span class="number">1</span>;</span><br><span class="line">q2.<span class="built_in">push</span>(next);</span><br><span class="line"><span class="keyword">if</span>(vis2[next.x][next.y]&amp;&amp;vis1[next.x][next.y])&#123;</span><br><span class="line">cout&lt;&lt;next.t<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">T = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line">ghost[<span class="number">1</span>].x = <span class="number">0</span>;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">cin&gt;&gt;a[i][j];</span><br><span class="line"><span class="keyword">if</span>(a[i][j]==<span class="string">&#x27;M&#x27;</span>) a[i][j] = <span class="string">&#x27;.&#x27;</span>,boy.x = i,boy.y = j,boy.t = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(a[i][j]==<span class="string">&#x27;G&#x27;</span>) a[i][j] = <span class="string">&#x27;.&#x27;</span>,girl.x = i,girl.y = j,girl.t = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(a[i][j]==<span class="string">&#x27;Z&#x27;</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(ghost[<span class="number">1</span>].x==<span class="number">0</span>) ghost[<span class="number">1</span>].x = i,ghost[<span class="number">1</span>].y = j;</span><br><span class="line"><span class="keyword">else</span> ghost[<span class="number">2</span>].x = i,ghost[<span class="number">2</span>].y = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">bfs</span>()) cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="0x26-A"><a href="#0x26-A" class="headerlink" title="0x26 A*"></a>0x26 A*</h4><h4 id="0x27-IDA"><a href="#0x27-IDA" class="headerlink" title="0x27 IDA*"></a>0x27 IDA*</h4><h4 id="0x28-总结与练习"><a href="#0x28-总结与练习" class="headerlink" title="0x28 总结与练习"></a>0x28 总结与练习</h4>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>「模板」平面最近点对</title>
      <link href="/2022/10/26/%E5%B9%B3%E9%9D%A2%E6%9C%80%E8%BF%91%E7%82%B9%E5%AF%B9/"/>
      <url>/2022/10/26/%E5%B9%B3%E9%9D%A2%E6%9C%80%E8%BF%91%E7%82%B9%E5%AF%B9/</url>
      
        <content type="html"><![CDATA[<h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><p>给$n$个二维平面上的点,求平面上欧几里得距离最近的两个点</p><h4 id="算法一"><a href="#算法一" class="headerlink" title="算法一"></a>算法一</h4><p>暴力枚举每个点,时间复杂度$O(n^2)$,显然过不了太大的数据</p><h4 id="算法二"><a href="#算法二" class="headerlink" title="算法二"></a>算法二</h4><p>考虑使用分治算法。与传统的分治算法一样,将所有点按照$x$坐标排序后分为$(l,mid),(mid+1,r)$两个区间进行分别计算,不断递归下去,之后再进行答案合并。</p><p>问题的难点在于答案如何进行合并。即求出其中一个点在左区间,另一个点在右区间中的最近点对。我们先假设两个子区间中的最近点对距离为$h$,中间值为$mid$,那么对于每个点$a$,只有当$mid-h&lt;a_x&lt;mid+h$时才会产生距离小于$h$的点对,如下图:</p><p><img src="https://pic.jitudisk.com/public/2022/10/27/7fefb6c739a26.png" alt=""></p><p>现在需要的就是找到一个点$b$同样满足$mid-h&lt;b_x&lt;mid+h$且$a,b$之前的距离$＜h$。对此,我们可以先将所有的点按照$y$坐标的大小进行排序,找出所有满足$mid-h&lt;x&lt;mid+h$的点,并对于每个满足条件的点$i$,查找所有$y$坐标位于$(y_i-h,y_i]$的点进行匹配,计算答案并更新即可</p><h3 id="复杂度证明"><a href="#复杂度证明" class="headerlink" title="复杂度证明"></a>复杂度证明</h3><p>对于$y$轴的排序,我们可以使用归并排序的方法,使其复杂度降低到$O(nlogn)$</p><p>对于查找部分,每个点能匹配到的点最多只有6个,证明见下:</p><p><img src="https://pic.jitudisk.com/public/2022/10/27/fd0b2a4df1319.png" alt=""></p><p>见上图,我们考虑最坏情况,图中黄线区域即为查找范围,即处于中线上的点:</p><p>将两个$h×h$的正方形分为四个小正方形,对于每个小正方形,其对角线长为$\frac{h}{\sqrt{2}}&lt;h$因此,在一个小正方形中,最多只能存在一个点,否则会出现距离小于$h$的点对,与”两个子区间中的最近点对距离为$h$”矛盾。综上,最多只能由6个点。</p><p>总复杂度$O(nlogn)$</p><h3 id="例题-AcWing-119-袭击"><a href="#例题-AcWing-119-袭击" class="headerlink" title="例题: AcWing 119. 袭击"></a>例题: AcWing 119. 袭击</h3><p>给$2n$个点,求前$n$个点与后$n$个点能组成的最小点对距离</p><p>$1≤n≤100000$</p><p>一个很直接的做法给前$n$个点和后$n$个点打上不同的$tag$,只有在$tag$不同时才计算最大值,否则返回$INF$</p><p>但是这题直接使用这种做法会被极端数据卡掉,由于此题中存在两类点,可能会出现左右两个子区间全部都是同类点的情况,此时返回的最小值即为$INF$,后面的筛选部分会将所有点都被考虑在内,复杂度将被卡为$O(n^2)$。</p><p>因此,我们可以给每个点都增加一个随机数,排序时,若横坐标相同,则按照随机数排序,从而避免所有点都被考虑在内的情况</p><p>$code$:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//xcxc82 2022/10/26</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> raed read</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123; </span><br><span class="line"><span class="type">int</span> X=<span class="number">0</span>; <span class="type">bool</span> flag=<span class="number">1</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) flag=<span class="number">0</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">if</span>(flag) <span class="keyword">return</span> X;<span class="keyword">return</span> ~(X<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,T;</span><br><span class="line"><span class="type">double</span> INF = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">points</span>&#123;</span><br><span class="line"><span class="type">double</span> x,y;</span><br><span class="line"><span class="type">int</span> id,rd;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> points&amp;P)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">fabs</span>(x-P.x)&lt;eps)<span class="keyword">return</span> rd&lt;P.rd;</span><br><span class="line">        <span class="keyword">return</span> x&lt;P.x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;a[MAXN&lt;&lt;<span class="number">1</span>],tmp[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> mid = l+r&gt;&gt;<span class="number">1</span>,top = <span class="number">0</span>,i = l,j = mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=mid||j&lt;=r)&#123;</span><br><span class="line"><span class="keyword">while</span>((a[i].y&lt;a[j].y||j&gt;r)&amp;&amp;i&lt;=mid) tmp[++top] = a[i++];</span><br><span class="line"><span class="keyword">while</span>((a[i].y&gt;=a[j].y||i&gt;mid)&amp;&amp;j&lt;=r) tmp[++top] = a[j++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;i++) a[i] = tmp[i-l+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">dis</span><span class="params">(points a,points b)</span></span>&#123;</span><br><span class="line"><span class="type">double</span> x = a.x - b.x,y = a.y - b.y;</span><br><span class="line"><span class="keyword">if</span>(a.id==b.id) <span class="keyword">return</span> INF;</span><br><span class="line"><span class="type">double</span> res = <span class="built_in">sqrt</span>(x*x+y*y);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span> INF;</span><br><span class="line"><span class="type">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> mid_x = a[mid].x;</span><br><span class="line"><span class="type">double</span> res = <span class="built_in">min</span>(<span class="built_in">dfs</span>(l,mid),<span class="built_in">dfs</span>(mid+<span class="number">1</span>,r));</span><br><span class="line"><span class="built_in">merge</span>(l,r);</span><br><span class="line"><span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i].x&gt;mid_x-res&amp;&amp;a[i].x&lt;mid_x+res) tmp[++top] = a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=top;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=top&amp;&amp;tmp[j].y-tmp[i].y&lt;res;j++)&#123;</span><br><span class="line">res = <span class="built_in">min</span>(res,<span class="built_in">dis</span>(tmp[i],tmp[j]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">T = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line">n = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">cin&gt;&gt;a[i].x&gt;&gt;a[i].y;</span><br><span class="line">a[i].id = <span class="number">0</span>,a[i].rd = <span class="built_in">rand</span>()%<span class="number">1000000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n+<span class="number">1</span>;i&lt;=n*<span class="number">2</span>;i++)&#123;</span><br><span class="line">cin&gt;&gt;a[i].x&gt;&gt;a[i].y;</span><br><span class="line">a[i].id = <span class="number">1</span>,a[i].rd = <span class="built_in">rand</span>()%<span class="number">1000000</span>; </span><br><span class="line">&#125;</span><br><span class="line">INF=<span class="built_in">min</span>(INF,<span class="built_in">dis</span>(a[<span class="number">1</span>],a[<span class="number">2</span>*n]));</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+<span class="number">2</span>*n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.3lf\n&quot;</span>,<span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">2</span>*n));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://oi-wiki.org/geometry/nearest-points/">oi wiki - 平面最小点对</a></p><p><a href="https://www.acwing.com/solution/content/119700/">AcWing 119. 袭击(hack数据的解决思路) - 深海鱼</a></p>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cf记录</title>
      <link href="/2022/10/23/cf%E8%AE%B0%E5%BD%95/"/>
      <url>/2022/10/23/cf%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="1fd10544d79b7ce0f2fdff594f7b54c907c417ac119a8f5d412fe3edcf0a275b">4630436162ade97ba2718b7d0c4b3b63aa2ab1619d9cdbb4bb5fd57226dc61d2</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《算法竞赛进阶指南》第一章 读书笔记</title>
      <link href="/2022/10/08/%E3%80%8A%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97%E3%80%8B%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/10/08/%E3%80%8A%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B%E8%BF%9B%E9%98%B6%E6%8C%87%E5%8D%97%E3%80%8B%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul><li>竞赛复健,自用向整理</li><li>为简约文本,部分题目代码只放出关键算法部分</li><li>书中所有例题均在acwing上可以找到</li></ul><h3 id="0x00-基本算法"><a href="#0x00-基本算法" class="headerlink" title="0x00 基本算法"></a>0x00 基本算法</h3><h4 id="0x01-位运算"><a href="#0x01-位运算" class="headerlink" title="0x01 位运算"></a>0x01 位运算</h4><ul><li><p>例题1: a^b</p><ul><li><p>快速幂模板,没啥好说的,注意精度就行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">read</span>(),b = <span class="built_in">read</span>(),p = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">while</span>(b)&#123;</span><br><span class="line"><span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans = (ans*a%p)%p;</span><br><span class="line">a = a*a%p;</span><br><span class="line">b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans%p;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>例题2: 64位整数乘法</p><ul><li><p>算法1: 同理快速幂的思想,将$a×b$拆分为$a×\sum_{0}^{k-1}c_i2^i$即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">read</span>(),b = <span class="built_in">read</span>(),p = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">while</span>(b)&#123;</span><br><span class="line"><span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans = (ans+a)%p;</span><br><span class="line">a = a*<span class="number">2</span>%p;</span><br><span class="line">b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans%p;</span><br></pre></td></tr></table></figure></li><li><p>算法2: 挺nb的解法。首先,显然有$a×b\bmod p=a×b-\lfloor a×b/p \rfloor×p$,我们令$c = \lfloor a×b/p \rfloor$,由于浮点数类型的数据是通过科学计数法来记录的,且在$a,b≤p≤10^{18}$的情况下,不会超过<code>long double</code>类型的最大范围,因此可以用<code>long double</code>类型来储存$c$,由于精度问题,在刚好能被整除的情况下$c$的值可能会比预测的小1,但在取模的情况下最终的值都为0,不会影响最终结果</p><p>又因为$p&lt;2^{64}$,$a×b - c×p = a×b \bmod p ≤ p&lt;2^{64}$,因此$a×b - c×p =a×b - c×p \bmod 2^{64}$,而用<code>ull</code>的自然溢出等价于对$2^{64}$取模,因此直接用<code>ull</code>来存储答案即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">read</span>(),b = <span class="built_in">read</span>(),p = <span class="built_in">read</span>();</span><br><span class="line">a%=p,b%=p; <span class="comment">//使a,b＜p</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> c = (<span class="type">long</span> <span class="type">double</span>)a*b/p;</span><br><span class="line">ull ans = ((a*b) - (c*p))%p;</span><br><span class="line">cout&lt;&lt;ans;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>例题3: 最短Hamilton路径</p><ul><li><p>简单的状压dp,状态和转移都挺好想的,但还是因为太久没写代码导致细节问题被卡了半天/kk</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">f[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> s=<span class="number">1</span>;s&lt;=(<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>;s++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">if</span>(s&gt;&gt;(i<span class="number">-1</span>)&amp;<span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line"><span class="keyword">if</span>(j!=i&amp;&amp;s&gt;&gt;(j<span class="number">-1</span>)&amp;<span class="number">1</span>) f[s][i] = <span class="built_in">min</span>(f[s][i],f[s^(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>))][j]+dis[i][j]);</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>例题4: 起床困难综合症</p><ul><li><p>sb了,被自己的贪心顺序错误卡了半天。。考虑到位运算互不影响,可以把每一位分开考虑:对于每一位,若填0的贡献与填1的贡献相同,显然填0更优,而左边的位造成的贡献一定大于右边的位造成的贡献,因此从左往右进行贪心计算即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">30</span>;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">1</span>,y = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">k = (a[j][<span class="number">1</span>]&gt;&gt;(i<span class="number">-1</span>)&amp;<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(a[j][<span class="number">0</span>]==<span class="number">1</span>) x = x|k,y = y|k;</span><br><span class="line"><span class="keyword">if</span>(a[j][<span class="number">0</span>]==<span class="number">2</span>) x = x&amp;k,y = y&amp;k;</span><br><span class="line"><span class="keyword">if</span>(a[j][<span class="number">0</span>]==<span class="number">3</span>) x = x^k,y = y^k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ans[i]==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(y==<span class="number">1</span>) att = att+(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>));</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">1</span>) res = res+(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>)),att = att+(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(y==<span class="number">1</span>) att = att+(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>));</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">1</span>) <span class="keyword">if</span>(res+(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>))&lt;=m) res = res+(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>)),att = att+(<span class="number">1</span>&lt;&lt;(i<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;att;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>lowbit</code>运算</p><ul><li><p><code>lowbit(n)</code>表示在$n$在二进制的状态下,最低位的1和后面的所有0,如<code>lowbit(10) = 2   1010-&gt;10</code></p></li><li><p>算法: <code>lowbit(n)</code> = n&amp;(-n),证明如下: 首先显然,<code>lowbit(n)</code> = $n$&amp;(~$n+1$),~为取反符号,又因为在补码的表示下,~$n=-1-n$,故<code>lowbit(n)</code> = $n$&amp;$(-n)$</p></li><li><p><code>lowbit(n)</code>运算可以找出整数二进制表示下所有是1的位,一个简单的非哈希算法如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">20</span>;i++) H[<span class="number">1</span>&lt;&lt;i] = i; # H[<span class="number">2</span>^k] = k</span><br><span class="line"><span class="keyword">while</span>(n)&#123;</span><br><span class="line">cout&lt;&lt;H[n&amp;(-n)]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">n -= n&amp;(-n);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>也可以使用hash对空间存储进行优化,令$H[2^k \bmod 37] = k$。这里用了一个数学技巧,对于$k∈[0,35]$时,$2^k\bmod37$互不相等,且恰好取遍$[1,36]$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">lowbit2</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">36</span>;i++) H[(<span class="number">1ll</span>&lt;&lt;i)%<span class="number">37</span>] = i;</span><br><span class="line"><span class="keyword">while</span>(n)&#123;</span><br><span class="line">cout&lt;&lt;H[n&amp;(-n)]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">n -= n&amp;(-n);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="0x02-递推与递归"><a href="#0x02-递推与递归" class="headerlink" title="0x02 递推与递归"></a>0x02 递推与递归</h4><ul><li>几种常见的枚举方式与遍历方式:</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">枚举方式</th><th style="text-align:center">状态空间规模</th><th style="text-align:center">一般遍历方式</th></tr></thead><tbody><tr><td style="text-align:center">多项式</td><td style="text-align:center">$n^k$,$k$为常数</td><td style="text-align:center">循环,递推</td></tr><tr><td style="text-align:center">指数</td><td style="text-align:center">$k^n$,$k$为常数</td><td style="text-align:center">递归,位运算</td></tr><tr><td style="text-align:center">排列</td><td style="text-align:center">$n!$</td><td style="text-align:center">递归,C++ <code>next_permutation</code></td></tr><tr><td style="text-align:center">组合</td><td style="text-align:center">$C_n^m$</td><td style="text-align:center">递归+剪枝</td></tr></tbody></table></div><ul><li><p>例题: 递归实现指数型枚举:</p><ul><li>每一个数都有选/不选两种可能,状态空间规模$2^n$,代码略</li></ul></li><li><p>例题: 递归实现排列形枚举：</p><ul><li>全排列问题。状态空间规模$n!$,代码略</li></ul></li><li><p>例题: 递归实现组合型枚举:</p><ul><li>状态空间规模$C_n^m$本质上为指数型枚举的”剪枝”版本,代码略</li></ul></li><li><p>例题: 费解的开关</p><ul><li><p>首先,显然每一个开关只会按一次,考虑普通递归算法,复杂度$\prod_\limits{i=20}^{25}i$,显然会T飞。通过观察,可以发现以下两个性质</p><ul><li>点击的顺序并不影响最终结果</li><li>若固定了第一行,则满足题意的点击方案只有1种。证明: 当第1行被固定后,只能通过改变第二行的同列开关来改变, 因此,以此类推,当前$i$行被固定时,只能通过点击第$i+1$行的开关来改变第$i$行,因此相当于每一个点击位置都被固定了,故只有一种方案。</li></ul></li><li><p>有以上两个性质,考虑先通过枚举第$i$行的点击方案,然后递推出第2~5行的点击方案,统计点击数量后进行判断即可(记得特判最后一行无法实现全1的情况)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">31</span>;i++)&#123;</span><br><span class="line"><span class="type">int</span> now = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">5</span>;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>((i&gt;&gt;(j<span class="number">-1</span>))&amp;<span class="number">1</span>) <span class="built_in">change</span>(<span class="number">1</span>,j),now++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=<span class="number">5</span>;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">5</span>;k++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[j<span class="number">-1</span>][k]==<span class="number">0</span>) <span class="built_in">change</span>(j,k),vis[j][k] = <span class="number">1</span>,now++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">5</span>;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[<span class="number">5</span>][j]==<span class="number">0</span>) now = <span class="number">114514</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">back</span>(i);</span><br><span class="line">ans = <span class="built_in">min</span>(ans,now);</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br></pre></td></tr></table></figure></li></ul></li><li><p>例题: 奇怪的汉诺塔</p><ul><li><p>考虑将原问题拆解为已知子问题。设$f_i$表示4个柱子时的最小方案数,$g_i$表示3个柱子时的最小方案数,先假设当前从塔中拿走了$i$个塔,造成的移动步数为$f_i$,接着,再将剩余的$n-i$个塔移动到目标柱子上,移动步数为$g_i$,最后再将之前的$i$个塔移回去,步数$f_i$,因此递推式为</p><center>$f_n = min\{f_i×2+g_{n-i}\}(0<i<n)$</center><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i] = a[i<span class="number">-1</span>]*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">f[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">cout&lt;&lt;f[<span class="number">1</span>]&lt;&lt;endl;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;i;j++)&#123;</span><br><span class="line">f[i] = <span class="built_in">min</span>(f[i],f[j]+a[i-j]+f[j]);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;f[i]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>例题: 约数之和</p><ul><li>我们先把$A$分解质因数,表示为$\prod\limits<em>{i=1}^np_i^{c_i}$,那么$A^B$就是$\prod\limits</em>{i=1}^np<em>i^{B×c_i}$,根据乘法分配律,$A^B$的所有约束之和也就是:$\prod\limits</em>{i=1}^n\sum\limits<em>{j=0}^{B×c_i}p_i^j$,容易想到用等比数列求和来计算,但如果使用求和公式来计算,需要做除法,取模运算只对$+,-,×$有分配律,因此无法使用。考虑换一种方法对其进行求和: 设$sum(p,c) = \sum\limits</em>{j=0}^{c}p^j$,当$c$为奇数时,有:</li></ul><center>$sum(p,c)=  \sum\limits_{j=0}^{\frac{c-1}{2}}p^j+\sum\limits_{j=\frac{c+1}{2}}^{c}p^j$</center><center>$ = (1+p^{\frac{c+1}{2}})×\sum\limits_{j=0}^{\frac{c-1}{2}}p^j$</center><center>$ = (1+p^{\frac{c+1}{2}})×sum(p,\frac{c-1}{2})$</center></li><li><p>例题: 分形之城</p><ul><li><p>有点复杂的一道分治题,考虑对城市区块进行分治,计算出该点在更小的区块内的编号,然后倒推在大区块的编号即可,推式子漏加了个+1被卡了半天…</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; <span class="title">calc</span><span class="params">(<span class="type">int</span> n,<span class="type">long</span> <span class="type">long</span> m)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">make_pair</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> now = m%(<span class="number">1ll</span>&lt;&lt;(<span class="number">2</span>*(n<span class="number">-1</span>))),len = <span class="number">1ll</span>&lt;&lt;(n<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span>(now==<span class="number">0</span>) now = <span class="number">1ll</span>&lt;&lt;(<span class="number">2</span>*(n<span class="number">-1</span>));</span><br><span class="line">pair&lt;<span class="type">long</span>,<span class="type">long</span>&gt; pos = <span class="built_in">calc</span>(n<span class="number">-1</span>,now);</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> id = (m<span class="number">-1</span>)/(<span class="number">1ll</span>&lt;&lt;(<span class="number">2</span>*(n<span class="number">-1</span>)));</span><br><span class="line"><span class="type">int</span> x = pos.first,y = pos.second;</span><br><span class="line"><span class="keyword">if</span>(id==<span class="number">0</span>) <span class="keyword">return</span> <span class="built_in">make_pair</span>(y,x);</span><br><span class="line"><span class="keyword">if</span>(id==<span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">make_pair</span>(x,y+len);</span><br><span class="line"><span class="keyword">if</span>(id==<span class="number">2</span>) <span class="keyword">return</span> <span class="built_in">make_pair</span>(x+len,y+len);</span><br><span class="line"><span class="keyword">if</span>(id==<span class="number">3</span>) <span class="keyword">return</span> <span class="built_in">make_pair</span>(<span class="number">2</span>*len-y+<span class="number">1</span>,len-x+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="0x03-前缀与差分"><a href="#0x03-前缀与差分" class="headerlink" title="0x03 前缀与差分"></a>0x03 前缀与差分</h4><ul><li><p>例题: 激光炸弹</p><ul><li><p>二维前缀和板子。比较坑的一个点是此题开两个5000*5000的数组会MLE</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y&gt;&gt;w;</span><br><span class="line">sum[x+<span class="number">1</span>][y+<span class="number">1</span>]+=w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5001</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">5001</span>;j++)&#123;</span><br><span class="line">sum[i][j] += sum[i<span class="number">-1</span>][j]+sum[i][j<span class="number">-1</span>]-sum[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5001</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">5001</span>;j++)&#123;</span><br><span class="line">x = i-r&gt;<span class="number">0</span>?i-r:<span class="number">0</span>,y = j-r&gt;<span class="number">0</span>?j-r:<span class="number">0</span>;</span><br><span class="line">now = sum[i][j] - sum[x][j] - sum[i][y] + sum[x][y];</span><br><span class="line">ans = <span class="built_in">max</span>(ans,now);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>例题: 增减序列</p><ul><li><p>差分练习题。对于第一问,设$b<em>i$的正数和为$p$,负数和为$q$,修改$[l,r]$区间,等价于修改$b_i$和$b</em>{j+1}$,不难发现修改时,一共只有三种方法:1.修改$[b_1,b_n]$ 2.修改$[b_i,b_j]$ $(1&lt;i≤j≤n)$ 3.修改$b_n$ 显然先用方法2所用的次数最少,最后只有$b_n$会有剩余,这时再使用法1和法3去修改$b_n$即可,答案即为$max{p,q}$</p><p>对于第二问,只有在修改$b_1$时,才会产生新的方案,因此答案即为法1能使用的次数+1,即$|p-q|+1$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">b[i] = a[i] - a[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span>(b[i]&lt;<span class="number">0</span>) p-=b[i];</span><br><span class="line"><span class="keyword">else</span> q+=b[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(p==q)&#123;</span><br><span class="line">cout&lt;&lt;p&lt;&lt;endl&lt;&lt;<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="built_in">max</span>(p,q)&lt;&lt;endl&lt;&lt;<span class="built_in">abs</span>(p-q)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>例题: 最高的牛</p><ul><li><p>差分入门题,对每次操作,相当于对$[l,r]$区间内的牛身高$-1$,直接对差分数组进行修改即可。比较坑的点是题目中的数据有重复的,需要判断之前是否出现过,且用数组存储会MLE,需要用到<code>map</code>来存储</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;pair&lt;<span class="built_in">int</span>,<span class="built_in">int</span>&gt;,<span class="built_in">bool</span>&gt; vis;</span><br><span class="line"><span class="built_in">int</span> main()&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;p&gt;&gt;h&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="built_in">int</span> a,b;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line"><span class="keyword">if</span>(a&gt;b) swap(a,b);</span><br><span class="line"><span class="keyword">if</span>(vis[make_pair(a,b)]) <span class="keyword">continue</span>;</span><br><span class="line">q[a+<span class="number">1</span>]--,q[b]++;</span><br><span class="line">vis[make_pair(a,b)]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">q[i] = q[i-<span class="number">1</span>]+q[i];</span><br><span class="line">cout&lt;&lt;q[i]+h&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="0x04-二分"><a href="#0x04-二分" class="headerlink" title="0x04 二分"></a>0x04 二分</h4><ul><li><p>整数集合上的二分:</p><ul><li><p>在单调序列中查找$≥x$的最小值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line"><span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(a[mid]&gt;=x) r = mid;</span><br><span class="line"><span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在单调序列中查找$≤x$的最大值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line"><span class="type">int</span> mid = (l+r+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(a[mid]&lt;=x) l = mid;</span><br><span class="line"><span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现上述的两个<code>mid</code>的取法是不同的,若法2也是用法1的取法,会在最后一层二分时进入死循环</p></li><li><p>总而言之,正确的二分写法分为三个步骤:</p><ul><li>分析问题,确定可行区间,以及<code>mid</code>归属哪一段</li><li>分析结果,选择两种配套方式中的其中一种</li><li>二分的终止条件为$l==r$,该值就是所求值,这也是使用这种二分方案的好处之一</li></ul></li><li><p>仔细观察<code>mid</code>的取法,还会发现:法1的<code>mid</code>不会取到<code>r</code>这个值,法二的<code>mid</code>不会取到<code>l</code>这个值。可以利用这一性质来处理无解的情况,把二者的区间分别扩大为$[1,n+1]$和$[0,n]$,若二分终止于这个越界下标上,则说明$a$不存在该所求数</p></li></ul></li><li><p>实数域上的二分:</p><ul><li><p>确定好所需精度<code>eps</code>以$l+eps&lt;r$为循环条件即可,一般需要保留$k$位小数时,取$eps = 10^{-(k+2)}$:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(l+eps&lt;r)&#123;</span><br><span class="line">    <span class="type">double</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">calc</span>(mid)) r = mid;<span class="keyword">else</span> l = mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>有时精度不易控制,可以干脆直接采用固定循环次数的二分法:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;</span><br><span class="line">    <span class="type">double</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">calc</span>(mid)) r = mid;<span class="keyword">else</span> l = mid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>三分求单峰函数极值</p><ul><li>用于处理单峰函数,即拥有唯一极大值,在极大值左边严格单调增,右边严格单调减,此时,定义两个点<code>lmid</code>与<code>rmid</code>,通过大小判断,即可求出所需的极大值</li></ul></li><li><p>例题: 最佳牛序列</p><ul><li><p>很巧妙的思路转化。考虑二分平均值$x$,对于每一个$x$,判断序列中是否有一段长度为$m(m≥F)$的序列和$sum_j - sum_i≥x×m$$(j-i=m+1)$,因此要求的就是$max{sum_j - min{sum_i}}$。只需要枚举$j$的值,并且不断更新$min{sum_i}$即可。计算完后,若最大值大于$x×m$,往右搜,否则往左搜</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">calc</span><span class="params">(<span class="type">double</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) sum[i]-=i*x;</span><br><span class="line"><span class="type">double</span> min_sum = <span class="number">0</span>;</span><br><span class="line"><span class="type">double</span> ans = <span class="number">-114514</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=f;i&lt;=n;i++)&#123;</span><br><span class="line">ans = <span class="built_in">max</span>(ans,sum[i] - min_sum);</span><br><span class="line">min_sum = <span class="built_in">min</span>(min_sum,sum[i-f+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) sum[i]+=i*x;</span><br><span class="line"><span class="keyword">if</span>(ans&gt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>例题: 特殊序列</p><ul><li><p>思路很简单,假设已经排好了前$i$个数,对于第$i+1$个数,进行二分判断插入的位置即可。不过我之前并没有写过交互题所以不太会代码的实现….</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">specialSort</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">        v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>,r = v.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="type">int</span> mid = (l+r+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">compare</span>(v[mid],i)) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">compare</span>(v[r],i)) r--;</span><br><span class="line">v.<span class="built_in">push_back</span>(i);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=v.<span class="built_in">size</span>()<span class="number">-2</span>;j&gt;r;j--) <span class="built_in">swap</span>(v[j],v[j+<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="0x05-排序"><a href="#0x05-排序" class="headerlink" title="0x05 排序"></a>0x05 排序</h4><ul><li><p>离散化</p><ul><li><p>将无穷大的集合中的若干个元素映射为有限集合以便于统计的方法。具体来讲就是将值域范围过大的数组$a_n$排序去重后得到有序数组$b_m$,在$b$数组的下标$i$与$b_i$之间建立映射关系,若要查询整数$a_j$被$1$~$m$中的哪个数代替,只需在数组$b$中二分查找$a_j$的值即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">discrete</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">1</span>||a[i]!=a[i<span class="number">-1</span>]) q[++top] = a[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">lower_bound</span>(b+<span class="number">1</span>,b+m+<span class="number">1</span>,x) - b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>例题: 电影</p><ul><li><p>将每个人的语言离散化,并用数组统计每个语言的使用人数,然后查询每部电影能看懂和听懂的人数即可。需要注意的是这里可能会出现一部电影都没人能看懂的情况,因此要将目标电影的下标初始化为1</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">discrete</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">1</span>||a[i]!=a[i<span class="number">-1</span>])&#123;</span><br><span class="line">q[++top] = a[i];</span><br><span class="line">&#125;</span><br><span class="line">cnt[top]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> l = <span class="number">1</span>,r = top;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line"><span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(q[mid]==x) <span class="keyword">return</span> mid;</span><br><span class="line"><span class="keyword">if</span>(q[mid]&gt;x) r = mid<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>例题: 货仓选址</p><ul><li><p>中位数定理入门题。结论: 将货仓定在所有商店的中位数处时,距离之和最小。具体证明可以用反证法来证明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i] = <span class="built_in">read</span>();</span><br><span class="line"><span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line"><span class="type">int</span> k = (n+<span class="number">1</span>)/<span class="number">2</span>,ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">ans+=<span class="built_in">abs</span>(a[i]-a[k]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>例题: 七夕祭</p><ul><li><p>好题。之前也写过题解<a href="https://xcxc82.github.io/2020/10/17/ac105/">AcWing 105. 七夕祭</a>。不难发现,上下交换和左右交换是互不影响的,因此我们可以把原问题拆解为行与列的两个子问题来解决。假设题目中没有环的限制,那显然就是一道经典贪心问题”均分纸牌”。设平均值为$e$,前缀和为$g<em>i$,答案就为$\sum\limits</em>{i = 1}^n|g_i -i×e|$。</p><p>设$b<em>i = a_i - e$,答案即为$\sum\limits</em>{i = 1}^n|sum<em>i|$,其中$sum_n$在有解时必为0。对于环形问题,我们只去要断环成链,去枚举从哪个位置开始即可。假设从第$k+1$个数开始,那么答案即为$\sum\limits</em>{i = 1}^n|sum_i - sum_k|$,显然这就又回到了之前例题中的”中位数问题”,因此只需将$sum$排序,取中位数即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">cal_r</span><span class="params">()</span></span>&#123;</span><br><span class="line">sum_r/=n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) row[i]-=sum_r;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) R[i] = R[i<span class="number">-1</span>]+row[i];</span><br><span class="line"><span class="built_in">sort</span>(R+<span class="number">1</span>,R+n+<span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> k = (n+<span class="number">1</span>)/<span class="number">2</span>,i = k+<span class="number">1</span>,tot = <span class="number">1</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(tot&lt;=n)&#123;</span><br><span class="line">res+=<span class="built_in">abs</span>(R[i] - R[k]);</span><br><span class="line">tot++,i++;</span><br><span class="line"><span class="keyword">if</span>(i==n+<span class="number">1</span>) i = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">cal_c</span><span class="params">()</span></span>&#123;</span><br><span class="line">sum_c/=m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) col[i]-=sum_c;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) C[i] = C[i<span class="number">-1</span>]+col[i];</span><br><span class="line"><span class="built_in">sort</span>(C+<span class="number">1</span>,C+m+<span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> k = (m+<span class="number">1</span>)/<span class="number">2</span>,i = k+<span class="number">1</span>,tot = <span class="number">1</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(tot&lt;=m)&#123;</span><br><span class="line">res+=<span class="built_in">abs</span>(C[i] - C[k]);</span><br><span class="line">tot++,i++;</span><br><span class="line"><span class="keyword">if</span>(i==m+<span class="number">1</span>) i = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>例题: 动态中位数</p><ul><li><p>对顶堆做法: 考虑开两一个大根堆,一个小根堆,前者存储$[1,n/2]$,后者存储$[n/2+1,n]$,每次$i$为奇数时输出小根堆的头元素即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; maxheap;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt; &gt; minheap;</span><br><span class="line"><span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line">id = <span class="built_in">read</span>(),n = <span class="built_in">read</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>,id,(n+<span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">a = <span class="built_in">read</span>();</span><br><span class="line">maxheap.<span class="built_in">push</span>(a);</span><br><span class="line"><span class="keyword">if</span>(minheap.<span class="built_in">size</span>()&amp;&amp;minheap.<span class="built_in">top</span>()&lt;maxheap.<span class="built_in">top</span>())&#123;<span class="comment">//我是煞笔,一开始把minheap.size()放在后面被卡了半天==</span></span><br><span class="line"><span class="type">int</span> a = minheap.<span class="built_in">top</span>(),b = maxheap.<span class="built_in">top</span>();</span><br><span class="line">minheap.<span class="built_in">pop</span>(),maxheap.<span class="built_in">pop</span>();</span><br><span class="line">minheap.<span class="built_in">push</span>(b),maxheap.<span class="built_in">push</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(maxheap.<span class="built_in">size</span>()&gt;minheap.<span class="built_in">size</span>()+<span class="number">1</span>)&#123;</span><br><span class="line">minheap.<span class="built_in">push</span>(maxheap.<span class="built_in">top</span>());</span><br><span class="line">maxheap.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i&amp;<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,maxheap.<span class="built_in">top</span>());</span><br><span class="line">tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(tot==<span class="number">10</span>) <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>),tot = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(tot!=<span class="number">0</span>) <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>例题: 超快速排序</p><ul><li><p>归并排序求逆序对</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> b[MAXN],top = <span class="number">0</span>,mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> i = l,j = mid+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;=mid||j&lt;=r)&#123;</span><br><span class="line"><span class="keyword">while</span>((j&gt;r)&amp;&amp;i&lt;=mid) cnt+=mid+<span class="number">1</span>-j,b[++top] = a[i],i++;</span><br><span class="line"><span class="keyword">while</span>(a[i]&lt;=a[j]&amp;&amp;i&lt;=mid) cnt+=mid+<span class="number">1</span>-j,b[++top] = a[i],i++;</span><br><span class="line"><span class="keyword">while</span>(a[i]&gt;a[j]&amp;&amp;j&lt;=r) b[++top] = a[j],j++;</span><br><span class="line"><span class="keyword">while</span>(i&gt;mid&amp;&amp;j&lt;=r) b[++top] = a[j],j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;i++)&#123;</span><br><span class="line">a[i] = b[i-l+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r) <span class="keyword">return</span>; </span><br><span class="line"><span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">sort</span>(l,mid),<span class="built_in">sort</span>(mid+<span class="number">1</span>,r);</span><br><span class="line"><span class="built_in">merge</span>(l,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>例题: 奇数码问题</p><ul><li><p>把每个矩阵当成一个$n^2$的数组来看。当$0$移动时,有两种可能:1.和自己相邻的值交换 2.和自己相邻的两组的相同位置移动</p><p>对于1操作,显然没有改变数组的逆序对个数(0不考虑在内),对于操作2,假设被移动的数为$a$,中间的间隔中大于$a$的数为$c_1$,小于$a$的数为$c2$,那么逆序对的变化数量就为$c_1±c_2$,由于$n$为奇数,两个数之间的间隔显然只为偶数,因此$c_1±c_2$只可能为偶数,不会对逆序对的奇偶性产生影响,只要判断两种状态的逆序对奇偶性是否相同即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line">t = <span class="number">0</span>,cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n*n;i++)&#123;</span><br><span class="line">cin&gt;&gt;k;</span><br><span class="line"><span class="keyword">if</span>(k!=<span class="number">0</span>) a[++t] = k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(<span class="number">1</span>,n*n<span class="number">-1</span>);</span><br><span class="line">c1 = <span class="built_in">abs</span>(cnt);</span><br><span class="line">cnt = <span class="number">0</span>,t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n*n;i++)&#123;</span><br><span class="line">cin&gt;&gt;k;</span><br><span class="line"><span class="keyword">if</span>(k!=<span class="number">0</span>) a[++t] = k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(<span class="number">1</span>,n*n<span class="number">-1</span>);</span><br><span class="line">c2 = <span class="built_in">abs</span>(cnt);</span><br><span class="line"><span class="keyword">if</span>((c1&amp;<span class="number">1</span>)!=(c2&amp;<span class="number">1</span>)) <span class="built_in">puts</span>(<span class="string">&quot;NIE&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;TAK&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="0x06-倍增"><a href="#0x06-倍增" class="headerlink" title="0x06 倍增"></a>0x06 倍增</h4><ul><li><p>例题: 天才ACM</p><ul><li><p>好题。首先对于校验值,将数列$a$进行排序,显然选$a$中最大的数和最小的数为一对,次大和次小的数一对,以此类推,可以使答案最大化,用数学归纳法易证。接下来用倍增的方式枚举区间长度,检查是否可行,若可行,可以先将新区间进行排序,后用归并排序合并进原数列,时间复杂度可以从$O(nlog^2n)$降低到$O(nlogn)$。有个sb把不可行的段也合并进去了,但我不说是谁(</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//xcxc82 2022/10/15</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">500010</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> X=<span class="number">0</span>; <span class="type">bool</span> flag=<span class="number">1</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) flag=<span class="number">0</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">if</span>(flag) <span class="keyword">return</span> X;<span class="keyword">return</span> ~(X<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> T,n,m,lim,a[MAXN],b[MAXN],c[MAXN],tot;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> mid,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">tot = l;</span><br><span class="line"><span class="type">int</span> i = l,j = mid;</span><br><span class="line"><span class="keyword">while</span>(i&lt;mid||j&lt;=r)&#123;</span><br><span class="line"><span class="keyword">while</span>((b[j]&gt;b[i]||j&gt;r)&amp;&amp;i&lt;mid) c[tot++] = b[i],i++;</span><br><span class="line"><span class="keyword">while</span>((b[j]&lt;=b[i]||i&gt;=mid)&amp;&amp;j&lt;=r) c[tot++] = b[j],j++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> mid,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=mid;i&lt;=r;i++) b[i] = a[i];</span><br><span class="line"><span class="built_in">sort</span>(b+mid,b+r+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">merge</span>(l,mid,r);</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;=r-l+<span class="number">1</span>&gt;&gt;<span class="number">1</span> &amp;&amp; i&lt;=m; i++)</span><br><span class="line">        res+=((c[r-i+<span class="number">1</span>]-c[l+i<span class="number">-1</span>])*(c[r-i+<span class="number">1</span>]-c[l+i<span class="number">-1</span>]));</span><br><span class="line"><span class="keyword">if</span> (res&lt;=lim)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=l; i&lt;=r; i++)</span><br><span class="line">            b[i]=c[i];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">T = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line">n = <span class="built_in">read</span>(),m = <span class="built_in">read</span>(),lim = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i] = <span class="built_in">read</span>();</span><br><span class="line"><span class="type">int</span> len = <span class="number">1</span>,i = <span class="number">1</span>,ans = <span class="number">0</span>,last = <span class="number">1</span>,j;</span><br><span class="line"><span class="type">int</span> l = <span class="number">1</span>,r = <span class="number">1</span>;</span><br><span class="line">b[<span class="number">1</span>] = a[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">while</span>(l&lt;=n)&#123;</span><br><span class="line">len = <span class="number">1</span>;</span><br><span class="line">r = l;</span><br><span class="line"><span class="keyword">while</span>(len&gt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(r&gt;n) r = n;</span><br><span class="line"><span class="keyword">if</span>(r+len&lt;=n&amp;&amp;<span class="built_in">check</span>(l,r+<span class="number">1</span>,r+len))&#123;</span><br><span class="line">r = r+len;</span><br><span class="line">len = len&lt;&lt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(r==n) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> len = len&gt;&gt;<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">ans++;</span><br><span class="line">l = r+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>例题: 奶牛排队</p><ul><li><p>ST表模板题。定义$f<em>{i,j}$表示在区间$[l,l+2^j-1]$的最大值,有递推公式:$f</em>{i,j} = max{f<em>{i,j-1},f</em>{i+2^{j-1},j-1}}$</p><p>对于查询区间$[l,r]$,只需要找到一个$k$,使得$2^k&lt;r-l+1&lt;2^{k+1}$,即$log<em>2(r-l+1)$,最后返回$max{f</em>{l,k},f_{r-2^k+1,k}}$即可。中间会有重叠部分,但并不影响最终结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//xcxc82 2022/10/20</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">50010</span>,T = <span class="number">25</span>;</span><br><span class="line"><span class="type">int</span> MIN[MAXN][T],MAX[MAXN][T];</span><br><span class="line"><span class="type">int</span> n,m,a[MAXN],l,r;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query_MAX</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> k = <span class="built_in">log</span>(r-l+<span class="number">1</span>)/<span class="built_in">log</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">max</span>(MAX[l][k],MAX[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query_MIN</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> k = <span class="built_in">log</span>(r-l+<span class="number">1</span>)/<span class="built_in">log</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">min</span>(MIN[l][k],MIN[r-(<span class="number">1</span>&lt;&lt;k)+<span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n = <span class="built_in">read</span>(),m = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i] = <span class="built_in">read</span>(),MAX[i][<span class="number">0</span>] = a[i],MIN[i][<span class="number">0</span>] = a[i];</span><br><span class="line"><span class="type">int</span> t = <span class="built_in">log</span>(n)/<span class="built_in">log</span>(<span class="number">2</span>)+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;t;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n-(<span class="number">1</span>&lt;&lt;j)+<span class="number">1</span>;i++)&#123;</span><br><span class="line">MAX[i][j] = <span class="built_in">max</span>(MAX[i][j<span class="number">-1</span>],MAX[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]);</span><br><span class="line">MIN[i][j] = <span class="built_in">min</span>(MIN[i][j<span class="number">-1</span>],MIN[i+(<span class="number">1</span>&lt;&lt;j<span class="number">-1</span>)][j<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">l = <span class="built_in">read</span>(),r = <span class="built_in">read</span>();</span><br><span class="line">cout&lt;&lt;<span class="built_in">query_MAX</span>(l,r) - <span class="built_in">query_MIN</span>(l,r)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="0x07-贪心"><a href="#0x07-贪心" class="headerlink" title="0x07 贪心"></a>0x07 贪心</h4><ul><li><p>常用证明思路:</p><ul><li>微扰(邻项交换): 证明在任意局面下,任何最最优决策的改变都会造成整体局面的偏差。经常以排序为贪心策略的证明。</li><li>范围缩放: 证明任何对局部最优策略的范围扩展都不会对最终结果造成偏差。类似数学归纳?</li><li>决策包容性: 证明在任意局面下,作出局部最优决策后,在问题状态空间中的可达集合包含了作出其他任何决策后的可达集合。换言之,这个局部最优策略提供的可能性包含了其他所有策略提供的可能性(说实话不是很懂QAQ)</li><li>反证法</li><li>数学归纳法</li></ul></li><li><p>例题: 防晒</p><ul><li><p>结论: 按$L$端点降序排序$/$按$R$端点升序排序,然后对于每头牛,找到防晒值最大$/$最小的一瓶能用且有剩余的防晒霜使用</p></li><li><p>证明: 首先对于每头牛,都有$L$,$R$两个条件限制,考虑先将其中一个进行排序,考虑对$L$进行降序排序: 排序后,假设第$i$头牛能用的两个防晒霜的防晒值为$x,y$且$x<y$, 对于第$i+1$头牛,因为有了$L_i>L_{i+1}$的限制,因此第$i$头牛能用的防晒霜只有三种可能: 1.能用x,y 2.能用x不能用y 3.不能用x,y 由于每头牛造成的贡献一样,显然对于第$i$头牛,用$y$的策略更优,以此类推。对$R$进行升序排序也同理</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">c = <span class="built_in">read</span>(),l = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=c;i++) cow[i].minS = <span class="built_in">read</span>(),cow[i].maxS = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=l;i++) item[i].spf = <span class="built_in">read</span>(),item[i].cover = <span class="built_in">read</span>();</span><br><span class="line"><span class="built_in">sort</span>(cow+<span class="number">1</span>,cow+c+<span class="number">1</span>,cmp);</span><br><span class="line"><span class="built_in">sort</span>(item+<span class="number">1</span>,item+l+<span class="number">1</span>,cmp2);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=c;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=l;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(item[j].spf&lt;=cow[i].maxS&amp;&amp;item[j].spf&gt;=cow[i].minS&amp;&amp;item[j].cover)&#123;</span><br><span class="line">item[j].cover--,ans++;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>例题: 畜栏预定</p><ul><li><p>比较显然的结论,让每头牛去最早能去的围栏里吃饭最优。若每一个围栏能吃饭,则新开一个围栏。用一个二叉堆来维护即可。由于这里还需输出编号,因此需要把编号也存入大根堆中,这里有一个小trick,就是把结束时间变负数存入堆中,这样大根堆就能当小根堆来用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n,cnt,b[MAXN];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cow</span>&#123;</span><br><span class="line"><span class="type">int</span> l,r,id,index;</span><br><span class="line">&#125;a[MAXN];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(cow a,cow b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.l&lt;b.l;</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt; q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">a[i].l = <span class="built_in">read</span>(),a[i].r = <span class="built_in">read</span>();</span><br><span class="line">a[i].index = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(q.<span class="built_in">size</span>()&amp;&amp;-q.<span class="built_in">top</span>().first&lt;a[i].l)&#123;</span><br><span class="line">a[i].id = q.<span class="built_in">top</span>().second;</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(-a[i].r,a[i].id));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">a[i].id = ++cnt;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(-a[i].r,a[i].id));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">b[a[i].index] = a[i].id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">cout&lt;&lt;b[i]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>例题: 雷达设备</p><ul><li>解法一: 计算出每个点$i$的两个相交圆的坐标,记为$L_i,R_i$,对$R_i$进行升序排序,先在$R_1$处放置一个圆,然后判断后面的每个圆的$L_i$是否大于当前放置的最后的一个圆的坐标,若小于,说明范围不够,需要新建一个圆,更新最后一个圆的坐标,反之不用</li><li>解法二:具体处理方法同理解法一,不同之处是对$L_i$进行升序排序,由于对$L_i$排序后按照上述思路进行计算,会出现当前放置的最后一个圆的坐标$pos$大于$R_i$的情况,因此枚举时需要不断更新$pos$的值,使$pos = min(pos,R_i)$</li><li>上述的贪心做法可以使用反证法来证明。书上用的是决策包容性…但我看不太懂QAQ</li></ul></li><li><p>例题: 国王游戏</p><ul><li><p>经典老题了。用领项交换来证明即可。懒得写高精,给我用python水过去了(((</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">n = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">a,b = <span class="built_in">map</span>(<span class="built_in">int</span>,<span class="built_in">input</span>().split())</span><br><span class="line">ans = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    ans.append([<span class="built_in">int</span>(j) <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">input</span>().split()])</span><br><span class="line">ans.sort(key=<span class="keyword">lambda</span> x: (x[<span class="number">0</span>]*x[<span class="number">1</span>]))</span><br><span class="line">s = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">    s = <span class="built_in">max</span>(s,a // ans[i][<span class="number">1</span>]) <span class="comment"># python中//代表整除</span></span><br><span class="line">    a*=ans[i][<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>例题: 给树染色</p><ul><li>挺神奇的贪心。<del>等我复习完图论再来补</del></li></ul></li></ul><h4 id="总结与练习"><a href="#总结与练习" class="headerlink" title="总结与练习"></a>总结与练习</h4><ul><li><p>练习: 飞行员兄弟</p><ul><li><p>dfs即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//xcxc82 2022/10/10</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ans</span>&#123;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line">&#125;A[MAXN];</span><br><span class="line"><span class="type">char</span> s[MAXN];</span><br><span class="line"><span class="type">int</span> a[MAXN][MAXN],vis[MAXN][MAXN],ans,top,res[MAXN][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> X[MAXN],Y[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++) a[x][i] = <span class="number">1</span>-a[x][i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++) a[i][y] = <span class="number">1</span>-a[i][y];</span><br><span class="line">a[x][y] = <span class="number">1</span>-a[x][y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">fin</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">4</span>;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i][j]!=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">5</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">fin</span>())&#123;</span><br><span class="line"><span class="keyword">if</span>(top&lt;ans)&#123;</span><br><span class="line">ans = top;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=top;i++)&#123;</span><br><span class="line">res[i][<span class="number">0</span>] = A[i].x,res[i][<span class="number">1</span>] = A[i].y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">A[++top].x = i,A[top].y = j;</span><br><span class="line"><span class="built_in">change</span>(i,j);</span><br><span class="line"><span class="keyword">if</span>(j+<span class="number">1</span>&lt;=<span class="number">4</span>) <span class="built_in">f</span>(i,j+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">f</span>(i+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">change</span>(i,j),top--;</span><br><span class="line"><span class="keyword">if</span>(j+<span class="number">1</span>&lt;=<span class="number">4</span>) <span class="built_in">f</span>(i,j+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">f</span>(i+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>练习: 占卜DIY</p><ul><li><p>简单模拟。一开始题没看清把输入顺序看反了= =</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> now = a[<span class="number">13</span>].<span class="built_in">front</span>();</span><br><span class="line">a[<span class="number">13</span>].<span class="built_in">pop_front</span>();</span><br><span class="line"><span class="keyword">while</span>(life)&#123;</span><br><span class="line"><span class="keyword">if</span>(now==<span class="number">13</span>)&#123;</span><br><span class="line">now = a[<span class="number">13</span>].<span class="built_in">front</span>();</span><br><span class="line">a[<span class="number">13</span>].<span class="built_in">pop_front</span>();</span><br><span class="line">life--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">a[now].<span class="built_in">push_front</span>(now);</span><br><span class="line"><span class="type">int</span> k = a[now].<span class="built_in">back</span>();</span><br><span class="line">a[now].<span class="built_in">pop_back</span>();</span><br><span class="line">cnt[now]++;</span><br><span class="line">now = k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">12</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(cnt[i]&gt;=<span class="number">4</span>) ans++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>练习: 分形</p><ul><li><p>简单dfs</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(b,<span class="string">&#x27; &#x27;</span>,<span class="built_in">sizeof</span>(b));</span><br><span class="line"><span class="type">int</span> N = <span class="built_in">pow</span>(<span class="number">3</span>,n<span class="number">-2</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=N;j++)&#123;</span><br><span class="line">b[i][j] = a[i][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>*N+<span class="number">1</span>;j&lt;=N*<span class="number">3</span>;j++)&#123;</span><br><span class="line">b[i][j] = b[i][j<span class="number">-2</span>*N];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>*N+<span class="number">1</span>;i&lt;=N*<span class="number">3</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=N;j++)&#123;</span><br><span class="line">b[i][j] = b[i<span class="number">-2</span>*N][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>*N+<span class="number">1</span>;j&lt;=N*<span class="number">3</span>;j++)&#123;</span><br><span class="line">b[i][j] = b[i][j<span class="number">-2</span>*N];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=N+<span class="number">1</span>;i&lt;=N*<span class="number">2</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=N+<span class="number">1</span>;j&lt;=N*<span class="number">2</span>;j++)&#123;</span><br><span class="line">b[i][j] = a[i-N][j-N];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(n==T)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N*<span class="number">3</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=N*<span class="number">3</span>;j++)&#123;</span><br><span class="line">cout&lt;&lt;b[i][j];</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N*<span class="number">3</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=N*<span class="number">3</span>;j++)&#123;</span><br><span class="line">a[i][j] = b[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">solve</span>(n+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>练习: 袭击</p><ul><li>平面最近点对模板题。具体见<a href="https://xcxc82.github.io/2022/10/26/%E5%B9%B3%E9%9D%A2%E6%9C%80%E8%BF%91%E7%82%B9%E5%AF%B9/">「模板」平面最近点对</a></li></ul></li><li><p>练习: 防线</p><ul><li><p>二分。考虑到只有一个奇数,设前$i$个数的和为$sum_i$,显然若$sum_i$为奇数,则该数在前$i$个数中,否则后面; 由于此题范围过大,开不了完整数组,考虑用类似惰性计算的方式,在每次二分的时候再进行计算前缀和</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> T,n,S[MAXN],E[MAXN],D[MAXN],cnt,L,R,ans;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(S[i]&lt;=r)&#123;</span><br><span class="line"><span class="keyword">if</span>(E[i]&lt;=r)&#123;</span><br><span class="line">ans+=(E[i]-S[i])/D[i]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">ans+=(r-S[i])/D[i]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ans&amp;<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">T = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line">cnt = <span class="number">0</span>,ans = <span class="number">0</span>;</span><br><span class="line">L = <span class="number">1145141919</span>,R = <span class="number">0</span>;</span><br><span class="line">n = <span class="built_in">raed</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">S[i] = <span class="built_in">raed</span>(),E[i] = <span class="built_in">raed</span>(),D[i] = <span class="built_in">read</span>();</span><br><span class="line">cnt+=(E[i] - S[i])/D[i]+<span class="number">1</span>;</span><br><span class="line">L = <span class="built_in">min</span>(S[i],L);</span><br><span class="line">R = <span class="built_in">max</span>(E[i],R);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>((cnt&amp;<span class="number">1</span>)==<span class="number">0</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;There&#x27;s no weakness.&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> l = L,r = R;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line"><span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line"><span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(l&gt;=S[i]&amp;&amp;l&lt;=E[i])&#123;</span><br><span class="line"><span class="keyword">if</span>((l-S[i])%D[i]==<span class="number">0</span>) ans++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;l&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>练习: 赶牛入圈</p><ul><li><p>二分+离散化。考虑对每个点的$X$坐标和$Y$坐标进行离散化,并计算其二维前缀和。对于那些不存在的点$(a,b)$,去找到第一个$≤a$的被记录的$X$坐标和第一个$≤b$的$Y$坐标即可。之后二分其长度,进行计算即可。对于计算的范围,选择所有记录了的$X$坐标和记录了的$Y$坐标进行组合即可</p><p>由于这题点的范围只有$10000$,因此可以直接枚举记并录每个点的代表值,不用再去二分</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//xcxc82 2022/10/25</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> raed read</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">510</span>;</span><br><span class="line"><span class="type">int</span> c,n,l,r,top_x,top_y;</span><br><span class="line"><span class="type">int</span> sum[MAXN][MAXN],X[<span class="number">10010</span>],Y[<span class="number">10010</span>],x[MAXN],y[MAXN];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">grass</span>&#123;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line">&#125;a[MAXN];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=X[k];i&lt;=top_x;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=Y[k];j&lt;=top_y;j++)&#123;</span><br><span class="line"><span class="type">int</span> x0 = <span class="number">0</span>,y0 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(x[i] - k&gt;=<span class="number">0</span>) x0 = X[x[i] - k];</span><br><span class="line"><span class="keyword">if</span>(y[j] - k&gt;=<span class="number">0</span>) y0 = Y[y[j] - k];</span><br><span class="line"><span class="keyword">if</span>(sum[i][j] - sum[x0][j] - sum[i][y0]+sum[x0][y0]&gt;=c) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">l = <span class="number">114514</span>;</span><br><span class="line">c = <span class="built_in">read</span>(),n = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">a[i].x = <span class="built_in">read</span>(),a[i].y = <span class="built_in">read</span>();</span><br><span class="line">r = <span class="built_in">max</span>(r,a[i].x),l = <span class="built_in">min</span>(l,a[i].x);</span><br><span class="line">r = <span class="built_in">max</span>(r,a[i].y),l = <span class="built_in">min</span>(l,a[i].y);</span><br><span class="line">X[a[i].x]++,Y[a[i].y]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10000</span>;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(X[i]) x[++top_x] = i;</span><br><span class="line">X[i] = top_x;</span><br><span class="line"><span class="keyword">if</span>(Y[i]) y[++top_y] = i;</span><br><span class="line">Y[i] = top_y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) sum[X[a[i].x]][Y[a[i].y]]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=top_x;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=top_y;j++)&#123;</span><br><span class="line">sum[i][j] = sum[i][j]+sum[i<span class="number">-1</span>][j]+sum[i][j<span class="number">-1</span>]-sum[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line"><span class="type">int</span> mid = l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line"><span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>练习: 糖果传递</p><ul><li><p>思路同理七夕祭那道</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n,a[MAXN];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> sum[MAXN],ans,S; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i] = <span class="built_in">read</span>(),S = S+a[i];</span><br><span class="line">S/=n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]-=S;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) sum[i] = sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line"><span class="built_in">sort</span>(sum+<span class="number">1</span>,sum+n+<span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> k = (n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> tot = <span class="number">1</span>,i = k+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(tot&lt;=n)&#123;</span><br><span class="line">ans+=<span class="built_in">abs</span>(sum[i]-sum[k]);</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">if</span>(i==n+<span class="number">1</span>) i = <span class="number">1</span>;</span><br><span class="line">tot++; </span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>练习: 士兵</p><ul><li><p>对于$y$坐标,显然可以直接用中位数定理,对于$x$坐标,先对其进行排序,假设以$p$为起点开始排,则总消耗步数为$\sum\limits_{i = 1}^n|x_i -i+1- p|$,也就是说对$x_i-i+1$进行排序后选择中位数即可。</p><p>ps: 其实这里的$-i+1$是任何递增量为1的序列都行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n,ans,l,r,c[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">a[i].x = <span class="built_in">raed</span>(),a[i].y = <span class="built_in">raed</span>();</span><br><span class="line">c[i] = a[i].x; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(c+<span class="number">1</span>,c+n+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) c[i]-=i+<span class="number">114514</span>;</span><br><span class="line"><span class="built_in">sort</span>(c+<span class="number">1</span>,c+n+<span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> k = c[(n+<span class="number">1</span>)/<span class="number">2</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">ans+=<span class="built_in">abs</span>(c[i] - k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>,cmp2);</span><br><span class="line">k = a[(n+<span class="number">1</span>)/<span class="number">2</span>].y;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">ans+=<span class="built_in">abs</span>(a[i].y - k);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>练习: 数的进制转换</p><ul><li><p>还是要写高精(悲)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sss</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>练习: 耍杂技的牛</p><ul><li><p>邻项交换+推柿子。</p><p>假设交换第$k$和第$k+1$头牛,交换前两者的风险值分别为$\sum\limits<em>{i=1}^{k}w_i-s</em>{k+1}$,$\sum\limits<em>{i=1}^{k-1}w_i-s</em>{k}$</p><p>交换后则分别为$\sum\limits<em>{i=1}^{k-1}w_i-s</em>{k+1}$,$\sum\limits<em>{i=1}^{k-1}w_i+w</em>{k+1}-s_k$,显然只有前者的最大值大于后者的最大值时交换更优,化简一下,就是:</p><center>$max(w_k - s_{k+1},-s_k)＞max(w_{i+1}-s_i,-s_{i+1})$</center><p>由于$w$,$s$均为正整数,因此$-s<em>k&lt;w</em>{k+1}-s<em>k$,$-s</em>{k+1}<w_k-s_{k+1}$,因此两个式子里的最大值即为$w_{k+1}-s_k$,$w_k - s_k+1$,也就是说,当$w_k - s_{k+1}>w_{i+1}-s_i$时,进行交换即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//xcxc82 2022/10/25</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> raed read</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">500010</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> X=<span class="number">0</span>; <span class="type">bool</span> flag=<span class="number">1</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) flag=<span class="number">0</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">if</span>(flag) <span class="keyword">return</span> X;<span class="keyword">return</span> ~(X<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,ans;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cow</span>&#123;</span><br><span class="line"><span class="type">int</span> w,s;</span><br><span class="line">&#125;a[MAXN];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(cow a,cow b)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>((b.s - a.s)&gt;a.w - b.w) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n = <span class="built_in">raed</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">a[i].w = <span class="built_in">raed</span>(),a[i].s = <span class="built_in">raed</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>,cmp);</span><br><span class="line"><span class="type">int</span> ans = -a[n].s;</span><br><span class="line"><span class="type">int</span> cnt = a[n].w;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">ans = <span class="built_in">max</span>(ans,cnt-a[i].s);</span><br><span class="line">cnt+=a[i].w;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>练习: 最大的和</p><ul><li><p>二维最大字段和,枚举区间,进行最大字段和计算即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//xcxc82 2022/10/25</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> raed read</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">110</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> X=<span class="number">0</span>; <span class="type">bool</span> flag=<span class="number">1</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) flag=<span class="number">0</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">if</span>(flag) <span class="keyword">return</span> X;<span class="keyword">return</span> ~(X<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,a[MAXN][MAXN],sum[MAXN][MAXN],ans,MAX[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ans = <span class="number">-1145141919</span>;</span><br><span class="line">n = <span class="built_in">raed</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">a[i][j] = <span class="built_in">raed</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">sum[i][j] = sum[i][j<span class="number">-1</span>]+a[j][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>;l&lt;=n;l++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> r=l;r&lt;=n;r++)&#123;</span><br><span class="line"><span class="built_in">memset</span>(MAX,<span class="number">0</span>,<span class="built_in">sizeof</span>(MAX));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="type">int</span> S = sum[i][r] - sum[i][l<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span>(MAX[i<span class="number">-1</span>]&gt;=<span class="number">0</span>) MAX[i] = MAX[i<span class="number">-1</span>]+S;</span><br><span class="line"><span class="keyword">else</span> MAX[i] = S;</span><br><span class="line">ans = <span class="built_in">max</span>(MAX[i],ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>练习: 任务</p><ul><li><p>显然做贡献大的任务更优</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> ACM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《python编程从入门到实践》读书笔记</title>
      <link href="/2022/09/27/%E3%80%8Apython%E7%BC%96%E7%A8%8B%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/09/27/%E3%80%8Apython%E7%BC%96%E7%A8%8B%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%AE%9E%E8%B7%B5%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul><li>打*的为补充内容,原书中未提到</li><li>省略了书中与其他语言用法相同或类似的章节</li><li>参考资料:<ul><li>书籍 《python编程从入门到实践》</li><li><a href="https://www.liaoxuefeng.com/wiki/1016959663602400">廖雪峰的官方网站 Python教程</a></li><li><a href="https://zhuanlan.zhihu.com/p/98994486">Python的set集合详解 - 叶湘伦</a></li><li><a href="https://www.cnblogs.com/LemonSqueezz/p/14738821.html">「Python学习笔记」Python修饰器-VanGy</a></li><li><a href="https://www.cnblogs.com/luckyblock/p/16755832.html">「学习笔记」python 杂记 - Luckyblock </a></li><li><del>百度百科</del></li></ul></li></ul><center>第一部分 基础知识</center><h3 id="第一章-起步"><a href="#第一章-起步" class="headerlink" title="第一章 起步"></a>第一章 起步</h3><h4 id="1-1-搭建编译环境"><a href="#1-1-搭建编译环境" class="headerlink" title="1.1 搭建编译环境"></a>1.1 搭建编译环境</h4><ul><li>自行百度下载安装即可</li></ul><h4 id="1-2-在windows系统中搭建python编程环境"><a href="#1-2-在windows系统中搭建python编程环境" class="headerlink" title="1.2 在windows系统中搭建python编程环境"></a>1.2 在windows系统中搭建python编程环境</h4><ul><li><p>在cmd中输入python 若出现python提示符 <code&gt;&gt;&gt;></code> 则说明安装成功</p></li><li><p>关于sublime text设置中文的问题：</p><ul><li><p>在sublime tex主界面中按下<code>ctrl+shift+b</code> ，输入install，点击第一个出现的install package</p></li><li><p>等待一会后在弹出的搜索框中搜索chinese,安装第一个后重启软件即可</p></li></ul></li></ul><h4 id="1-3-运行Hello-World程序"><a href="#1-3-运行Hello-World程序" class="headerlink" title="1.3 运行Hello World程序"></a>1.3 运行Hello World程序</h4><ul><li><h5 id="1-3-1-配置sublime-text"><a href="#1-3-1-配置sublime-text" class="headerlink" title="1.3.1 配置sublime text"></a>1.3.1 配置sublime text</h5><ul><li>选择菜单 &gt; <code>build system</code> &gt; <code>new build system</code> , 选择python即可</li></ul></li><li><h5 id="1-3-2-运行程序hello-world-py"><a href="#1-3-2-运行程序hello-world-py" class="headerlink" title="1.3.2 运行程序hello_world.py"></a>1.3.2 运行程序hello_world.py</h5><ul><li>新建完后输入代码即可</li></ul></li></ul><h4 id="1-4解决安装问题"><a href="#1-4解决安装问题" class="headerlink" title="1.4解决安装问题"></a>1.4解决安装问题</h4><ul><li>略</li></ul><h4 id="1-5从终端运行python程序"><a href="#1-5从终端运行python程序" class="headerlink" title="1.5从终端运行python程序"></a>1.5从终端运行python程序</h4><ul><li>终端里固定到文件路径后输入<code>python 文件名.py</code> 即可</li></ul><h3 id="第二章-变量和简单数据类型"><a href="#第二章-变量和简单数据类型" class="headerlink" title="第二章  变量和简单数据类型"></a>第二章  变量和简单数据类型</h3><h4 id="2-1-运行hello-world时发生的情况"><a href="#2-1-运行hello-world时发生的情况" class="headerlink" title="2.1 运行hello_world时发生的情况"></a>2.1 运行hello_world时发生的情况</h4><ul><li>略</li></ul><h4 id="2-2-变量"><a href="#2-2-变量" class="headerlink" title="2.2 变量"></a>2.2 变量</h4><ul><li>变量的命名: 变量名 = 变量值 和c++不同的是，python可以不加变量类型定义,命名规则和其他语言相同</li></ul><h4 id="2-3-字符串"><a href="#2-3-字符串" class="headerlink" title="2.3 字符串"></a>2.3 字符串</h4><ul><li><p>注: python中的字符串单双引号均可使用,单个字符取出和其他语言相同</p><ul><li>使用方法修改字符串大小写(见下代码):</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&quot;wAb lab dAbdab&quot;</span></span><br><span class="line"><span class="built_in">print</span>(a.title()) <span class="comment">#每个单词的开头字符转为大写</span></span><br><span class="line"><span class="built_in">print</span>(a.upper()) <span class="comment">#全部改为大写</span></span><br><span class="line"><span class="built_in">print</span>(a.lower()) <span class="comment">#全部改为小写</span></span><br><span class="line">a = <span class="number">5</span>*<span class="string">&quot;abc&quot;</span> <span class="comment"># 5个abc</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>在字符串中使用变量: 具体用法见下代码</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a,b = <span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span></span><br><span class="line">c = <span class="string">f&quot;python <span class="subst">&#123;a&#125;</span> <span class="subst">&#123;b&#125;</span>&quot;</span><span class="comment">#当然直接用加号也可以</span></span><br></pre></td></tr></table></figure></li></ul><ul><li>换行符的使用: 制表符: <code>\t</code> 换行符: <code>\n</code></li></ul><ul><li><p>删除空白部分(见下代码)</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">&quot;  xcxc82  &quot;</span></span><br><span class="line"><span class="built_in">print</span>(a.rstrip()) <span class="comment">#右边空白删除 &#x27;  xcxc82&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(a.lstrip()) <span class="comment">#左边空白删除 &#x27;xcxc82  &#x27;</span></span><br><span class="line"><span class="built_in">print</span>(a.strip()) <span class="comment">#全部空白删除  &#x27;xcxc82&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="2-4-数"><a href="#2-4-数" class="headerlink" title="2.4 数"></a>2.4 数</h4><ul><li><p>运算符号: 略。需要注意的是py中用 ** 代表 乘方运算, //代表整除运算</p></li><li><p>浮点数与整数: 若多个操作的数中有一个浮点数,结果总是浮点数</p></li><li><p>数中的下划线: 书写很大的数字时,可以用下划线进行分割,使其更清晰易读</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">14_000_000_000</span></span><br></pre></td></tr></table></figure></li><li><p>注释: python中 # 为注释标识</p></li></ul><h3 id="第三章-列表介绍"><a href="#第三章-列表介绍" class="headerlink" title="第三章 列表介绍"></a>第三章 列表介绍</h3><h4 id="3-1-列表-list-是什么"><a href="#3-1-列表-list-是什么" class="headerlink" title="3.1 列表(list)是什么"></a>3.1 列表(list)是什么</h4><ul><li>由一系列按特定顺序排列的元素组成,和数组用法类似,具体定义和用法见下代码</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">size = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>]</span><br><span class="line">size[<span class="number">0</span>] = <span class="string">&#x27;d&#x27;</span> <span class="comment">#和数组一样 下标从0开始</span></span><br><span class="line"><span class="built_in">print</span>(size[-n]) <span class="comment">#-n代表倒数第n个列表元素</span></span><br></pre></td></tr></table></figure><h4 id="3-2-添加，删除元素"><a href="#3-2-添加，删除元素" class="headerlink" title="3.2 添加，删除元素"></a>3.2 添加，删除元素</h4><ul><li>见代码</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">size.append(<span class="string">&#x27;e&#x27;</span>) <span class="comment">#在末尾添加元素</span></span><br><span class="line">size.insert(n,<span class="string">&#x27;e&#x27;</span>) <span class="comment">#在第n处插入元素</span></span><br><span class="line"><span class="keyword">del</span> size[<span class="number">0</span>] <span class="comment">#删除size[0]</span></span><br><span class="line"><span class="built_in">print</span>(size.pop()) <span class="comment">#弹出最后一个值 且可以将其作为变量使用 size.pop(x)则表示弹出第x个数值</span></span><br><span class="line">size.remove(<span class="string">&#x27;a&#x27;</span>) <span class="comment">#删除列表中第一个值为&#x27;a&#x27;的元素</span></span><br></pre></td></tr></table></figure><h4 id="3-3-列表的各种操作"><a href="#3-3-列表的各种操作" class="headerlink" title="3.3 列表的各种操作"></a>3.3 列表的各种操作</h4><ul><li>排序</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">size.sort() <span class="comment">#永久性的修改排列顺序,且再也无法恢复到之前的顺序</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(size)) <span class="comment">#输出排序后的size的值 但并不改变size本身</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(size,reverse=<span class="literal">True</span>)) <span class="comment">#倒序输出 注意python里的True和False开头都要大写</span></span><br></pre></td></tr></table></figure><ul><li>倒序</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size.reverse() <span class="comment"># 倒序</span></span><br></pre></td></tr></table></figure><ul><li>长度</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lengh = <span class="built_in">len</span>(size) <span class="comment"># 获取列表长度,len函数也可以用来获取元组,字符串,字典的长度</span></span><br></pre></td></tr></table></figure><h3 id="第四章-操作列表"><a href="#第四章-操作列表" class="headerlink" title="第四章 操作列表"></a>第四章 操作列表</h3><h4 id="4-1-遍历列表"><a href="#4-1-遍历列表" class="headerlink" title="4.1 遍历列表"></a>4.1 遍历列表</h4><ul><li>具体用法见下:</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sizes = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>] </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> sizes: <span class="comment"># i将遍历sizes中的每一个值</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>) <span class="comment">#带缩进的行都会被包括在循环中 sublime text中按tab可增加缩进</span></span><br><span class="line"><span class="built_in">print</span>(i)</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;bye&quot;</span>) <span class="comment">#不连续的行也会被包括</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> sizes:</span><br><span class="line">    <span class="built_in">print</span>(i) <span class="comment">#遍历列表中所有为1的值</span></span><br></pre></td></tr></table></figure><ul><li>关于冒号的用法: python中禁止出现冒号下什么都不加的情况,若要什么都不进行,可在”:”下加上<code>pass</code></li><li>*若要实现像其他的语言里那样的下表索引,可以使用Python内置的<code>enumerate</code>函数来实现:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sizes = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">for</span> i,key <span class="keyword">in</span> <span class="built_in">enumerate</span>(sizes):</span><br><span class="line">    <span class="built_in">print</span>(i,key)</span><br><span class="line"><span class="comment"># 0 1/1 1/2 4</span></span><br></pre></td></tr></table></figure><h4 id="4-2-避免缩进错误"><a href="#4-2-避免缩进错误" class="headerlink" title="4.2 避免缩进错误"></a>4.2 避免缩进错误</h4><ul><li>略</li></ul><h4 id="4-3-创建数值列表"><a href="#4-3-创建数值列表" class="headerlink" title="4.3 创建数值列表"></a>4.3 创建数值列表</h4><ul><li>函数range()与list()的使用:</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sizes = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">5</span>): <span class="comment">#遍历1到4,5不包括在内</span></span><br><span class="line"><span class="built_in">print</span>(i)</span><br><span class="line">nums = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">6</span>)) <span class="comment"># 若要创建连续数字列表,可直接用list()将range()的结果转化为列表</span></span><br><span class="line">nums2 = <span class="built_in">list</span>(<span class="built_in">range</span>(x,y,z)) <span class="comment">#表示从x开始数,每次加z,知道达到或超过y(类似其他语言中的for循环)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">1</span>,<span class="number">5</span>))) <span class="comment"># 输出:[1,2,3,4,5]</span></span><br></pre></td></tr></table></figure><ul><li>对数字列表执行简单的统计计算</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sizes = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line">max_size = <span class="built_in">max</span>(sizes) <span class="comment">#最大</span></span><br><span class="line">min_size = <span class="built_in">min</span>(sizes) <span class="comment">#最小</span></span><br><span class="line">sum_size = <span class="built_in">sum</span>(sizes) <span class="comment">#求和</span></span><br></pre></td></tr></table></figure><ul><li>*列表生成式(列表解析): 简单示例见下</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums = [i**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">5</span>)] <span class="comment"># 格式:[表达式+循环] 1 4 9 16</span></span><br><span class="line">nums = [m+n <span class="keyword">for</span> m <span class="keyword">in</span> <span class="string">&#x27;ABC&#x27;</span> n <span class="keyword">in</span> <span class="string">&#x27;XYZ&#x27;</span>] <span class="comment">#可以使用多层循环来生成全排列</span></span><br><span class="line">nums = [i**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">5</span>) <span class="keyword">if</span> i%<span class="number">2</span>==<span class="number">0</span>] <span class="comment">#筛选出为偶数的数</span></span><br><span class="line">nums = [i**<span class="number">2</span> <span class="keyword">if</span> i%<span class="number">2</span>==<span class="number">0</span> <span class="keyword">else</span> -i**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">5</span>)] <span class="comment">#若满足表达式则正常生成,否则按照else后的内容生成</span></span><br></pre></td></tr></table></figure><ul><li>在列表生成式中使用if else<ul><li>if在for后: 当<code>if</code>在<code>for</code>后时,代表对元素进行条件筛选,不能加<code>else</code>,示例见上</li><li>if在for前: <code>if</code>在<code>for</code>前时,代表的是一个对元素进行判断的表达式,必须加上<code>else</code>,否则无法计算出结果,示例见上</li></ul></li></ul><h4 id="4-4-使用列表的一部分"><a href="#4-4-使用列表的一部分" class="headerlink" title="4.4 使用列表的一部分"></a>4.4 使用列表的一部分</h4><ul><li>切片(前闭后开): 用法见下</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sizes = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line"><span class="built_in">print</span>(sizes[<span class="number">0</span>:<span class="number">3</span>]) <span class="comment"># 0到3</span></span><br><span class="line"><span class="built_in">print</span>(sizes[:<span class="number">4</span>])  <span class="comment"># 开头到4</span></span><br><span class="line"><span class="built_in">print</span>(sizes[<span class="number">2</span>:])  <span class="comment"># 2到结尾</span></span><br><span class="line"><span class="built_in">print</span>(sizes[<span class="number">2</span>:]) <span class="comment"># 全部</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> sizes[<span class="number">0</span>:<span class="number">3</span>] <span class="comment">#遍历0到3</span></span><br></pre></td></tr></table></figure><ul><li>复制列表</li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">size = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line">size2 = size <span class="comment">#将size2关联到已与size2相关的列表,本质上两个变量指向同一个列表</span></span><br><span class="line">size2 = size[:] <span class="comment">#将size的切片副本复制给size2</span></span><br></pre></td></tr></table></figure><h4 id="4-5-元组-tuple"><a href="#4-5-元组-tuple" class="headerlink" title="4.5 元组(tuple)"></a>4.5 元组(tuple)</h4><ul><li>一系列不可修改的元素,称为 <strong>元组</strong> 具体用法如下</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">nums = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>)</span><br><span class="line">nums = (<span class="number">1</span>,) <span class="comment">#元组是由逗号标识的,若要定义只包含一个元素的元组,必须要在这个元素后面加上逗号</span></span><br><span class="line"><span class="comment"># nums[0] = 2 试图修改元组的操作是禁止的</span></span><br><span class="line">nums = (<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>) <span class="comment">#元组内的元素无法被修改,但可以给储存元组的变量重新赋值,以此来达到修改元组的目的</span></span><br></pre></td></tr></table></figure><h4 id="4-6-设置代码格式"><a href="#4-6-设置代码格式" class="headerlink" title="4.6 设置代码格式"></a>4.6 设置代码格式</h4><ul><li>略 <del>只要不是毒瘤码风都行</del></li></ul><h3 id="第五章-if语句"><a href="#第五章-if语句" class="headerlink" title="第五章 if语句"></a>第五章 if语句</h3><h4 id="5-1简单示例"><a href="#5-1简单示例" class="headerlink" title="5.1简单示例"></a>5.1简单示例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nums = (<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>) </span><br><span class="line"><span class="keyword">if</span> nums[<span class="number">0</span>]==<span class="number">1</span>:</span><br><span class="line">    <span class="built_in">print</span>(nums[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(nums[<span class="number">1</span>]) </span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="5-2-条件测试"><a href="#5-2-条件测试" class="headerlink" title="5.2 条件测试"></a>5.2 条件测试</h4><ul><li>python中可以用关键字<code>in</code>来检测某个值是否在列表中,如下:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="number">1</span> <span class="keyword">in</span> nums:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;true&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;false&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>其他用法和其他语言相同,略。</li></ul><h4 id="5-3-if语句"><a href="#5-3-if语句" class="headerlink" title="5.3 if语句"></a>5.3 if语句</h4><ul><li>略,同其他语言。需要注意的是python中的<code>if - else if</code>要缩写成<code>if - elif</code>。</li></ul><h4 id="5-4-使用if语句处理列表"><a href="#5-4-使用if语句处理列表" class="headerlink" title="5.4 使用if语句处理列表"></a>5.4 使用if语句处理列表</h4><ul><li>确定列表是否为空时 和其他语言一样写<code>if 变量名</code>即可</li></ul><h4 id="5-5设置if语句格式"><a href="#5-5设置if语句格式" class="headerlink" title="5.5设置if语句格式"></a>5.5设置if语句格式</h4><ul><li>略，看自己习惯。</li></ul><h3 id="第六章-字典-dict-与集合-set"><a href="#第六章-字典-dict-与集合-set" class="headerlink" title="第六章 字典(dict)与集合(set)"></a>第六章 字典(dict)与集合(set)</h3><h4 id="6-1-一个简单的字典"><a href="#6-1-一个简单的字典" class="headerlink" title="6.1 一个简单的字典"></a>6.1 一个简单的字典</h4><ul><li>在python中,字典是一系列键值对。每个键都与一个值关联,类似c++中的结构体。具体定义法如下:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">person = &#123;<span class="string">&#x27;name&#x27;</span> : <span class="string">&#x27;田所浩二&#x27;</span>,<span class="string">&#x27;id&#x27;</span> : <span class="number">114514</span>&#125; <span class="comment"># d = &#123;key1 : value1, key2 : value2... &#125;</span></span><br><span class="line"><span class="built_in">print</span>(person[<span class="string">&#x27;name&#x27;</span>]) <span class="comment"># 引用name对应的值</span></span><br><span class="line">person[<span class="string">&#x27;age&#x27;</span>] = <span class="number">24</span> <span class="comment"># 添加一个名为&#x27;age&#x27;的键值对\</span></span><br><span class="line"><span class="keyword">del</span> person[<span class="string">&#x27;age&#x27;</span>] <span class="comment">#删除键值对</span></span><br><span class="line">datastruct = &#123;</span><br><span class="line">    <span class="number">1</span> : <span class="string">&#x27;segmenttree&#x27;</span>,</span><br><span class="line">    <span class="number">2</span> : <span class="string">&#x27;stack&#x27;</span>,</span><br><span class="line">    <span class="number">3</span> : <span class="string">&#x27;queue&#x27;</span>,</span><br><span class="line">    <span class="number">4</span> : <span class="string">&#x27;array&#x27;</span></span><br><span class="line">&#125; <span class="comment"># 较大的字典可用此方法定义</span></span><br><span class="line">like = person.get(<span class="string">&#x27;like&#x27;</span> , <span class="string">&#x27;not found&#x27;</span>) <span class="comment"># 若字典中有该指定键 则返回对应的值,否则返回第二个参数(默认为none)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(person.keys()).index(<span class="string">&#x27;id&#x27;</span>)) <span class="comment"># 取出字典键中id对应的下标</span></span><br></pre></td></tr></table></figure><ul><li>需要注意的是,字典的key是<strong>不能重复的</strong>,如果出现重复的则后面的value会替换到前面的</li></ul><h4 id="6-2-使用字典"><a href="#6-2-使用字典" class="headerlink" title="6.2 使用字典"></a>6.2 使用字典</h4><ul><li>见上代码。</li></ul><h4 id="6-3-遍历字典"><a href="#6-3-遍历字典" class="headerlink" title="6.3 遍历字典"></a>6.3 遍历字典</h4><ul><li>几种写法见下</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">person = &#123;<span class="string">&#x27;name&#x27;</span> : <span class="string">&#x27;田所浩二&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;id&#x27;</span> : <span class="number">114514</span>,</span><br><span class="line">          <span class="string">&#x27;age&#x27;</span> : <span class="number">24</span></span><br><span class="line">         &#125;</span><br><span class="line"><span class="keyword">for</span> i,j <span class="keyword">in</span> person.items(): <span class="comment"># 遍历所有键值对,item()返回一个键值对应表</span></span><br><span class="line">    <span class="built_in">print</span>(i,j)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> person.keys(): <span class="comment"># 遍历字典中的所有键,keys()返回每一个键</span></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> person.values(): <span class="comment"># 遍历字典中的所有值,values()返回每一个值</span></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">sorted</span>(person.values()): <span class="comment"># 按特定顺序遍历字典中的所有键,值同理,要确保所有的键或值为同一类型</span></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><h4 id="6-4-字典与列表的比较"><a href="#6-4-字典与列表的比较" class="headerlink" title="*6.4 字典与列表的比较"></a>*6.4 字典与列表的比较</h4><ul><li><p>与列表相比,字典有两个特点:</p><ul><li>查找和插入的速度很快,不会随着<code>key</code>的增加而变慢</li><li>需要占用大量的内存,内存浪费多</li></ul></li><li><p>而list恰恰相反。因此,dict是在用空间换取时间的一种方法,适用于占用空间小但需要高速查找的地方</p></li></ul><h4 id="6-5-嵌套"><a href="#6-5-嵌套" class="headerlink" title="6.5 嵌套"></a>6.5 嵌套</h4><ul><li>字典列表: 同理普通列表,将字典加入列表即可</li><li>在字典中存储列表: 将列表写入字典中即可</li><li>字典中储存字典: 同理</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">a0,a1,a2 = &#123;&#125;,&#123;&#125;,&#123;&#125;</span><br><span class="line"><span class="built_in">id</span> = [a0,a1,a2] <span class="comment"># 字典加入列表</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>):</span><br><span class="line">    new = []</span><br><span class="line">    <span class="built_in">id</span>.append(new)</span><br><span class="line">person = &#123;<span class="string">&#x27;name&#x27;</span> : <span class="string">&#x27;xcxc82&#x27;</span>, <span class="comment"># 在字典中存储列表</span></span><br><span class="line">          <span class="string">&#x27;id&#x27;</span> : [<span class="number">163</span>,<span class="number">186</span>]</span><br><span class="line">         &#125;</span><br><span class="line">users = &#123; <span class="comment">#字典中储存字典</span></span><br><span class="line">    <span class="string">&#x27;alice&#x27;</span> : &#123;</span><br><span class="line">        <span class="string">&#x27;age&#x27;</span> : <span class="number">16</span>,</span><br><span class="line">        <span class="string">&#x27;id&#x27;</span> : <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="string">&#x27;bob&#x27;</span> : &#123;</span><br><span class="line">        <span class="string">&#x27;age&#x27;</span> : <span class="number">18</span>,</span><br><span class="line">        <span class="string">&#x27;id&#x27;</span> : <span class="number">2</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-6-集合-set"><a href="#6-6-集合-set" class="headerlink" title="*6.6 集合(set)"></a>*6.6 集合(set)</h4><ul><li>集合(set)是一个无序不重复元素集,<code>set</code>集合类需要的参数必须是可迭代的，如：序列、字典等。具体创建方法如下:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">set</span>([<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]) <span class="comment"># set([]) 列表 </span></span><br><span class="line">s = <span class="built_in">set</span>((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)) <span class="comment"># set(()) 元组 </span></span><br><span class="line">s = <span class="built_in">set</span>(&#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;alice&#x27;</span>,<span class="string">&#x27;age&#x27;</span>:<span class="number">18</span>&#125;) <span class="comment"># 字典 需要注意的是，set只取了字典的key</span></span><br><span class="line">s = <span class="built_in">set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>]) <span class="comment"># set具有自动去重功能</span></span><br><span class="line"><span class="built_in">print</span>(s) <span class="comment"># 1,2,3,4  注意,输出内容有序不代表set是有序的,只是说明集合内里有这几个元素(不同的输出中顺序可能不同)</span></span><br></pre></td></tr></table></figure><ul><li>集合的添加有<code>add</code>和<code>update</code>两种方式,但它们在添加元素时是有区别的,具体见下:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">s.add(<span class="number">123</span>) <span class="comment"># 把传入的元素作为一个整体并入到集合中</span></span><br><span class="line">s.update(<span class="string">&#x27;789&#x27;</span>) <span class="comment"># 把传入的元素拆分为单个字符,并如集合中,update()方法只支持字符串类型。</span></span><br><span class="line"><span class="built_in">print</span>(s)</span><br></pre></td></tr></table></figure><ul><li><p>discard()方法: <code>discard</code>为集合特有的方法。<code>discard</code>方法和<code>remove</code>方法的用法相同,但<code>remove</code>若找不到指定元素会报错,而<code>discard</code>不会。集合的其他方法用法基本和列表相同,需要注意的是集合是无序的,因此集合中的pop()方法删除的是集合中的一个随机元素</p></li><li><p>多个<code>set</code>可以做数学上的交集,并集等操作,具体见下:</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="built_in">set</span>([<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line">s2 = <span class="built_in">set</span>([<span class="number">1</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">0</span>])</span><br><span class="line">s3 = s1|s2 <span class="comment"># 并集</span></span><br><span class="line">s3 = s1&amp;s2 <span class="comment"># 交集</span></span><br><span class="line">s3 = s1-s2 <span class="comment"># 差集 返回的结果是在集合st1中但不在集合st2中的元素的集合</span></span><br><span class="line">s3 = s1.difference(s2) <span class="comment"># 查看两个集合的不同之处，也相当于差集</span></span><br></pre></td></tr></table></figure><ul><li>集合可以用<code>&gt;,&lt;,&gt;=,==</code>等判断符号来判断某个集合是否完全包含另一个集合。</li></ul><h3 id="第七章-迭代器与生成器"><a href="#第七章-迭代器与生成器" class="headerlink" title="* 第七章 迭代器与生成器"></a>* 第七章 迭代器与生成器</h3><h4 id="7-1-迭代与迭代器"><a href="#7-1-迭代与迭代器" class="headerlink" title="*7.1 迭代与迭代器"></a>*7.1 迭代与迭代器</h4><ul><li>用for遍历一个可迭代(Iterable)的对象的过程,称为迭代(Iteration)</li><li>可以被<code>next()</code>函数调用并不断返回下一个值的对象称为迭代器(Iterator)</li><li>迭代器 ≠ 可迭代对象,如<code>list</code>,<code>str</code>,<code>dict</code>都是可迭代对象,但不是迭代器</li><li>若要知道一个对象是否为可迭代对象或迭代器,可以使用<code>collections.abc</code>中的<code>Iterable</code>与<code>Iterator</code>类型判断：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterator</span><br><span class="line">a = <span class="string">&#x27;12345&#x27;</span></span><br><span class="line">b = <span class="number">12345</span></span><br><span class="line">g = (i**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(a, Iterable)) <span class="comment"># T 判断a是否为可迭代对象 是返回true 否则返回false</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(b, Iterable)) <span class="comment"># F</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(g, Iterator)) <span class="comment"># T 判断g是否为迭代器</span></span><br></pre></td></tr></table></figure><ul><li>可以用<code>iter</code>函数将可迭代对象转变为迭代器,例如<code>iter([1,2,3])</code></li><li>为什么<code>list</code>、<code>dict</code>、<code>str</code>等数据类型不是<code>Iterator</code>？<ul><li>这是因为Python的<code>Iterator</code>对象表示的是一个数据流，Iterator对象可以被<code>next()</code>函数调用并不断返回下一个数据，直到没有数据时抛出<code>StopIteration</code>错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过<code>next()</code>函数实现按需计算下一个数据，所以<code>Iterator</code>的计算是惰性的，只有在需要返回下一个数据时它才会计算。 —-摘自<a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017323698112640">廖雪峰的官方网站</a></li></ul></li></ul><h4 id="7-2-生成器-generator"><a href="#7-2-生成器-generator" class="headerlink" title="*7.2 生成器(generator)"></a>*7.2 生成器(generator)</h4><ul><li><p>python中,按照某种算法一边循环一边计算从而推算出新元素的机制,称为生成器(generator)</p></li><li><p>generator中保存的是算法,初始时没有任何值。在需要取出generator中的值时,可以选择调用<code>next</code>函数或直接用<code>for</code>进行迭代。调用<code>next</code>函数时,会计算generator中的下一个值,并返回该值,直到计算到最后一个值后,没有下一个值,若再次调用会跳出<code>StopIteration</code>错误</p></li><li><p>创建方法:</p><ul><li>第一种方法很简单,只需要将列表生成式中的<code>[]</code>改为<code>()</code>即可,示例见下</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">g = (i**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(g)) <span class="comment">#用next函数返回下一个值</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> g: <span class="comment">#直接用函数进行迭代,取出每一个值</span></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><ul><li>如果一个函数定义中包含<code>yield</code>关键字,则称它为生成器(generator)函数,当表达式的方法无法描述出需要的算法时,可以使用generator函数来创建生成器</li><li><code>yield</code>语句在每次调用<code>next()</code>的时候执行,返回下一个元素,再次执行时从上次返回的<code>yield</code>语句处继续执行。示例见下:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params">n</span>):</span><br><span class="line">    i,a,b = <span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= n:</span><br><span class="line">        <span class="keyword">yield</span> b <span class="comment"># 返回值</span></span><br><span class="line">        a,b = b,a + b</span><br><span class="line">        i+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">g = fib(<span class="number">10</span>) <span class="comment">#生成前十项斐波那契数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> g:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><ul><li>调用generator函数会创建一个generator对象, 多次调用generator函数会创建多个相互独立的generator。</li><li>示例:打印杨辉三角</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">paska</span>(<span class="params">n</span>):</span><br><span class="line">    i , last =<span class="number">1</span> , [<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">while</span> i &lt;= n:</span><br><span class="line">        j , now = <span class="number">1</span>, [<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">while</span> j&lt;i-<span class="number">1</span>:</span><br><span class="line">            now.append(last[j]+last[j-<span class="number">1</span>])</span><br><span class="line">            j+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i!=<span class="number">1</span>:</span><br><span class="line">            now.append(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">yield</span> now</span><br><span class="line">        last = now</span><br><span class="line">        i+=<span class="number">1</span></span><br><span class="line">g = paska(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> g:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure></li></ul><h3 id="第八章-用户输入与while循环"><a href="#第八章-用户输入与while循环" class="headerlink" title="第八章 用户输入与while循环"></a>第八章 用户输入与while循环</h3><h4 id="8-1-函数input-的工作原理"><a href="#8-1-函数input-的工作原理" class="headerlink" title="8.1 函数input()的工作原理"></a>8.1 函数input()的工作原理</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a,b = <span class="built_in">input</span>(<span class="string">&quot;pls input a: &quot;</span>),<span class="built_in">input</span>(<span class="string">&quot;pls input b&quot;</span>) <span class="comment"># &quot;&quot;里为提示词</span></span><br><span class="line">c,d = (<span class="built_in">input</span>().split()) <span class="comment"># input().split()可在一行中同时输入多个值 未加split时无法像c++那样把空格作为分隔符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">int</span>(a)+<span class="built_in">int</span>(b)) <span class="comment"># 默认类型为字符串 需用int()函数转化为数值</span></span><br></pre></td></tr></table></figure><h4 id="8-2-while循环介绍"><a href="#8-2-while循环介绍" class="headerlink" title="8.2 while循环介绍"></a>8.2 while循环介绍</h4><ul><li>具体用法示例:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i&lt;=<span class="number">5</span>:</span><br><span class="line">    i+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">4</span> = <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">break</span> <span class="comment"># break与continue和其他语言用法相同</span></span><br></pre></td></tr></table></figure><h4 id="8-3-使用while循环处理列表和字典"><a href="#8-3-使用while循环处理列表和字典" class="headerlink" title="8.3 使用while循环处理列表和字典"></a>8.3 使用while循环处理列表和字典</h4><ul><li>具体用法示例</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pets = [<span class="string">&#x27;cat&#x27;</span>,<span class="string">&#x27;cat&#x27;</span>,<span class="string">&#x27;cat&#x27;</span>,<span class="string">&#x27;dog&#x27;</span>,<span class="string">&#x27;bird&#x27;</span>]</span><br><span class="line"><span class="keyword">while</span> <span class="string">&#x27;cat&#x27;</span> <span class="keyword">in</span> pets: </span><br><span class="line">    pets.remove(<span class="string">&#x27;cat&#x27;</span>) <span class="comment"># 删除所有值为&#x27;cat&#x27;的元素 其它用法较为简单 不写了</span></span><br></pre></td></tr></table></figure><h3 id="第九章-函数"><a href="#第九章-函数" class="headerlink" title="第九章 函数"></a>第九章 函数</h3><h4 id="9-1-定义函数"><a href="#9-1-定义函数" class="headerlink" title="9.1 定义函数"></a>9.1 定义函数</h4><ul><li>用法示例</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cal</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="built_in">print</span>(a+b)</span><br><span class="line">cal(<span class="number">3</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure><h4 id="9-2-传递实参"><a href="#9-2-传递实参" class="headerlink" title="9.2 传递实参"></a>9.2 传递实参</h4><ul><li>默认值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cal</span>(<span class="params">a,b = <span class="number">4</span></span>): <span class="comment"># 若调用时没传参,则使用默认参数</span></span><br><span class="line">    <span class="built_in">print</span>(a+b)</span><br><span class="line">cal(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><h4 id="9-3-返回值"><a href="#9-3-返回值" class="headerlink" title="9.3 返回值"></a>9.3 返回值</h4><ul><li>返回简单值</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cal</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(cal(<span class="number">3</span>,<span class="number">4</span>)) <span class="comment">#同理c++中的非void函数</span></span><br></pre></td></tr></table></figure><h4 id="9-4-传递列表"><a href="#9-4-传递列表" class="headerlink" title="9.4 传递列表"></a>9.4 传递列表</h4><ul><li>同理。将列表作为实参传进去即可</li><li>禁止函数修改列表：将实参后加上<code>[:]</code>后即可 表示切片副本</li></ul><h4 id="9-5-传递任意数量的实参"><a href="#9-5-传递任意数量的实参" class="headerlink" title="9.5 传递任意数量的实参"></a>9.5 传递任意数量的实参</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">scanf</span>(<span class="params">*name</span>): <span class="comment"># 形参*name可以让python创建一个名为name的空元组,并将收到的值全部封装进该元组中</span></span><br><span class="line">    <span class="built_in">print</span>(name)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">build</span>(<span class="params">name,ID,**user_info</span>): <span class="comment"># 形参**user_info可以让python创建一个名为user_info的空字典</span></span><br><span class="line">    user_info[<span class="string">&#x27;id&#x27;</span>] = ID</span><br><span class="line">    user_info[<span class="string">&#x27;name&#x27;</span>] = name</span><br><span class="line">    <span class="keyword">return</span> user_info</span><br><span class="line">scanf(<span class="string">&#x27;alice&#x27;</span>,<span class="string">&#x27;bob&#x27;</span>)</span><br><span class="line">scanf(<span class="string">&#x27;kamak&#x27;</span>,<span class="string">&#x27;john&#x27;</span>,<span class="string">&#x27;lucy&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="9-6-将函数储存在模块中"><a href="#9-6-将函数储存在模块中" class="headerlink" title="9.6 将函数储存在模块中"></a>9.6 将函数储存在模块中</h4><ul><li>要让函数是可导入的 得在同目录下创建一个新的程序文件,且删除所有主程序(否则导入后主程序也会被一起执行)</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># def cal(a,b):</span></span><br><span class="line"><span class="comment"># print(int(a)+int(b)) 函数文件func.py</span></span><br><span class="line"><span class="keyword">import</span> func <span class="comment"># 导入整个模块(包括主程序)</span></span><br><span class="line">func.cal(<span class="number">3</span>,<span class="number">4</span>) <span class="comment"># 调用模块函数</span></span><br><span class="line"><span class="keyword">import</span> func <span class="keyword">as</span> cal <span class="comment"># 给指定模块重命名</span></span><br><span class="line"><span class="keyword">from</span> func <span class="keyword">import</span> cal <span class="comment"># 导入特定函数</span></span><br><span class="line"><span class="keyword">from</span> func <span class="keyword">import</span> cal <span class="keyword">as</span> add <span class="comment"># 给指定函数重命名</span></span><br><span class="line"><span class="keyword">from</span> func <span class="keyword">import</span> * <span class="comment"># 导入模块中的所有函数(不包括主程序)</span></span><br><span class="line"><span class="comment">#只导入函数时,调用时无需加模块名前缀</span></span><br></pre></td></tr></table></figure><ul><li>更多有关模块的内容见补充章节:模块</li></ul><h4 id="9-7-函数编写指南"><a href="#9-7-函数编写指南" class="headerlink" title="9.7 函数编写指南"></a>9.7 函数编写指南</h4><ul><li>略</li><li>有关函数的更多知识见补充章节:函数式编程</li></ul><h3 id="第十章-类"><a href="#第十章-类" class="headerlink" title="第十章 类"></a>第十章 类</h3><h4 id="10-1-创建和使用类"><a href="#10-1-创建和使用类" class="headerlink" title="10.1 创建和使用类"></a>10.1 创建和使用类</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">dog</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age</span>): <span class="comment"># 类似初始化</span></span><br><span class="line">        self.name = name <span class="comment">#属性</span></span><br><span class="line">        self.age = age</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sit</span>(<span class="params">self</span>): <span class="comment">#方法</span></span><br><span class="line">        <span class="built_in">print</span>(self.name+<span class="string">&quot;is now sitting&quot;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">roll</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.name+<span class="string">&quot;rolled over!&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">dog1 = dog(<span class="string">&#x27;peter&#x27;</span>,<span class="number">4</span>) <span class="comment">#创建实例</span></span><br><span class="line">dog1.sit() <span class="comment">#调用方法</span></span><br></pre></td></tr></table></figure><ul><li>关于方法<strong> init </strong>(): <ul><li>类中的函数都称为<strong>方法</strong>。<code>init</code>是一种特殊的方法,每当创建该类的新实例时，python都会自动运行它,此方法中务必确保<code>init</code><strong>两边各有两个下划线</strong>  (方便起见,下文中的双下划线均省略)</li><li>在<code>init</code>方法的定义中,形参<code>self</code>必不可少,且必须位于其他形参前面。在调用该方法创建示例时,将自动传入实参<code>self</code>,它是一个指向实例本身的引用,让示例能够访问类中的属性和方法（说白了就是个代表实例的形参）</li></ul></li></ul><h4 id="10-2-使用类和示例"><a href="#10-2-使用类和示例" class="headerlink" title="10.2 使用类和示例"></a>10.2 使用类和示例</h4><ul><li>给属性指定默认值: 在<code>init</code>方法中给属性赋一个固定的值即可</li><li>修改属性的值: 一种方法是直接用赋值语句修改属性的值,另一种方法是通过调用方法来修改属性的值,见下代码:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">dog</span>:</span><br><span class="line">    <span class="comment">#省略#</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update_age</span>(<span class="params">self,age</span>):</span><br><span class="line">        self.age = age </span><br><span class="line">        </span><br><span class="line">dog1 = dog(<span class="string">&#x27;peter&#x27;</span>,<span class="number">4</span>) </span><br><span class="line">dog1.update_age(<span class="number">5</span>) <span class="comment"># 无需访问属性 直接在内部更新</span></span><br></pre></td></tr></table></figure><h4 id="10-3-继承"><a href="#10-3-继承" class="headerlink" title="10.3 继承"></a>10.3 继承</h4><ul><li>编写类时, 并非总是从空白开始,如果要编写的类是另一个现成类的特殊版本,可以使用<strong>继承</strong>。一个类继承另一个类时,将自动获得另一个类的所有属性和方法。原有的类称为<strong>父类</strong>,新类称为<strong>子类</strong>。具体定义规则见下:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">dog</span>: <span class="comment">#父类</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sit</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.name+<span class="string">&quot;is now sitting&quot;</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">roll</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(self.name+<span class="string">&quot;rolled over!&quot;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Golden_Retriever</span>(<span class="title class_ inherited__">dog</span>): <span class="comment"># 定义子类时,必须在括号中加入父类的名称</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,age</span>): <span class="comment"># 接受创建dog实例所需要的信息</span></span><br><span class="line">        <span class="built_in">super</span>.__init__(name,age) <span class="comment"># super()是一种特殊函数,允许调用父类的方法</span></span><br><span class="line">        self.cost = <span class="number">1500</span> <span class="comment"># 初始化子类的特有属性</span></span><br></pre></td></tr></table></figure><ul><li>重写父类的方法: 在子类中定义一个与父类方法同名的方法,python将不会考虑这个父类的方法,而只关注在子类中定义的方法</li><li>将实例用作属性: 当类的细节添加的越来越多时,属性和方法清单以及文件都越来越长,在这种情况下,可以将类的一部分提取出来,作为一个独立的类,示例见下:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">info</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,ID,socre</span>):</span><br><span class="line">        self.<span class="built_in">id</span> = ID</span><br><span class="line">        self.socre = socre</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_ID</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;ID is &quot;</span>+<span class="built_in">str</span>(self.<span class="built_in">id</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">student</span>:</span><br><span class="line">    <span class="keyword">def</span>  <span class="title function_">__init__</span>(<span class="params">self,name,age,ID,socre</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.info = info(ID,socre) <span class="comment">#添加一个self.info的属性,新建一个info示例</span></span><br><span class="line"></span><br><span class="line">koishi = student(<span class="string">&#x27;koishi&#x27;</span>,<span class="number">18</span>,<span class="number">514</span>,<span class="number">114</span>)</span><br><span class="line">koishi.info.get_ID()</span><br></pre></td></tr></table></figure><h4 id="10-4-导入类"><a href="#10-4-导入类" class="headerlink" title="10.4 导入类"></a>10.4 导入类</h4><ul><li>同理前面的函数导入,略</li></ul><h4 id="10-5-python标准库"><a href="#10-5-python标准库" class="headerlink" title="10.5 python标准库"></a>10.5 python标准库</h4><ul><li><code>randint</code>与<code>choice</code>函数:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint <span class="comment"># 从random模块中导入randint函数</span></span><br><span class="line"><span class="built_in">print</span>(randint(<span class="number">1</span>,<span class="number">6</span>)) <span class="comment"># 随机生成1~6中的一个数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> choice <span class="comment"># 导入choice函数 </span></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="built_in">print</span>(choice(a)) <span class="comment"># 从a列表中随机选出一个值</span></span><br></pre></td></tr></table></figure><h4 id="10-6-类编码风格"><a href="#10-6-类编码风格" class="headerlink" title="10.6 类编码风格"></a>10.6 类编码风格</h4><ul><li>类的命名多采用驼峰命名法,即将类名中的每个单词首字母都大写,而不使用下划线。实例名和模块都采用小写模式,并在单词间加上下划线。</li></ul><h3 id="第十一章-文件和异常"><a href="#第十一章-文件和异常" class="headerlink" title="第十一章 文件和异常"></a>第十一章 文件和异常</h3><h4 id="11-1-从文件中读取数据"><a href="#11-1-从文件中读取数据" class="headerlink" title="11.1 从文件中读取数据"></a>11.1 从文件中读取数据</h4><ul><li>示例:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;test/pi.txt&#x27;</span>) <span class="keyword">as</span> file_object: <span class="comment">#打开test目录下的pi.txt 同目录的直接加文件名即可</span></span><br><span class="line">    pi = file_object.read() <span class="comment">#读取文本</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> flie_object: <span class="comment">#逐行读取文本</span></span><br><span class="line">        <span class="built_in">print</span>(i)</span><br><span class="line">    lines = file_object.readlines() <span class="comment">#readlines()函数能逐行读取文件,并储存在一个列表中</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(pi) <span class="comment">#书上说打印时多一格空行然而我这并没有==</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ps: 不知道是不是我自己编译器的问题... 这里的flie_object:下面只能包括一行代码==</span></span><br></pre></td></tr></table></figure><h4 id="11-2-写入文件"><a href="#11-2-写入文件" class="headerlink" title="11.2 写入文件"></a>11.2 写入文件</h4><ul><li>示例:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;test/sigma.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> si:</span><br><span class="line">    si.write(<span class="string">&quot;sigma is a math character&quot;</span>) <span class="comment"># 写入字符</span></span><br></pre></td></tr></table></figure><ul><li>这里的第二个实参<code>w</code>表示了文件的打开模式,<code>w</code>即代表写入模式。打开文件时,可指定读取模式<code>r</code>,写入模式<code>w</code>,附加模式<code>a</code>和读写模式<code>r+</code>。默认模式为读取模式</li><li>附加模式和写入模式的区别:写入模式会覆盖所有原内容,而附加模式只会将写入文件的行添加到文件末尾</li><li>如果指定的文件不存在,python会帮你创建一个新文件</li></ul><h4 id="11-3-异常"><a href="#11-3-异常" class="headerlink" title="11.3 异常"></a>11.3 异常</h4><ul><li><code>ZeroDivisionError</code>异常: 顾名思义,python中禁止出现除以0的情况</li><li><code>FileNotFoundError</code>异常: 顾名思义,文件名无法找到</li><li>使用<code>try-expect</code>避免程序错误: 通过提前预知程序出错的地方防止程序出错,可提高代码的防御能力。示例:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a , b = <span class="built_in">int</span>(<span class="built_in">input</span>()),<span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    c = a/b <span class="comment"># 测试是否合法</span></span><br><span class="line"><span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;you can&#x27;t divide by zero&quot;</span>) <span class="comment"># 若出错 输出该报错信息,否则照常运行</span></span><br><span class="line"><span class="keyword">else</span>: <span class="built_in">print</span>(a/b)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;alice.text&#x27;</span>) <span class="keyword">as</span> f: <span class="comment"># 同理</span></span><br><span class="line">        content = f.read()</span><br><span class="line"><span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">    <span class="keyword">pass</span> <span class="comment"># </span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    words = content.split() <span class="comment"># split()函数可以以空格为分隔符将字符串拆分为多个部分,并储存在一个列表中</span></span><br></pre></td></tr></table></figure><h4 id="11-4-存储数据"><a href="#11-4-存储数据" class="headerlink" title="11.4 存储数据"></a>11.4 存储数据</h4><ul><li><p>什么是<code>json</code>: 用户关闭程序时,几乎总要保留他们提供的信息(如游戏中的各种设置),一种简单的方式是使用模块<code>json</code>来存储数据。<code>json</code>能让简单的python数据结构转储到文件中,并在程序再次运行时加载该文件的数据,重要的是,<code>json</code>的数据格式并非python专用的,因此能够以<code>json</code>格式存储的数据与使用其他编程语言的人分享。</p></li><li><p>使用<code>json.dump</code>和<code>json.load</code></p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">file = <span class="string">&#x27;a.json&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f: <span class="comment"># 添加json文件</span></span><br><span class="line">    json.dump(a,f) <span class="comment"># 在json文件中写入a</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file) <span class="keyword">as</span> f:</span><br><span class="line">    b = json.load(f) <span class="comment">#加载json文件中的信息,赋给b</span></span><br></pre></td></tr></table></figure><ul><li>案例演示: 用户信息输入</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line">file = <span class="string">&#x27;name.json&#x27;</span></span><br><span class="line"><span class="keyword">try</span>: <span class="comment"># 检测是否有存储姓名,若无,则新建一个</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file) <span class="keyword">as</span> f: </span><br><span class="line">       name = json.load(f)</span><br><span class="line">       <span class="built_in">print</span>(name)</span><br><span class="line"><span class="keyword">except</span> FileNotFoundError:</span><br><span class="line">    name = <span class="built_in">input</span>()</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        json.dump(name, f)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;welcome! &quot;</span>+name)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;welcome back! &quot;</span>+name)</span><br></pre></td></tr></table></figure><h3 id="第十二章-测试代码"><a href="#第十二章-测试代码" class="headerlink" title="第十二章 测试代码"></a>第十二章 测试代码</h3><h4 id="12-1-测试函数"><a href="#12-1-测试函数" class="headerlink" title="12.1 测试函数"></a>12.1 测试函数</h4><ul><li>使用python中自带的单元测试来测试函数:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> unittest <span class="comment"># 导入模块unittest</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cal</span>(<span class="params">a,b</span>):</span><br><span class="line"><span class="keyword">return</span> (a+b)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FuncTest</span>(unittest.TestCase): <span class="comment"># 建立类用于一系列的单元测试。注意,此类必须继承unittest.TestCase类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_answer</span>(<span class="params">self</span>):</span><br><span class="line">answer = cal(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">self.assertEqual(answer,<span class="number">7</span>) <span class="comment"># unittest中的断言方法,用于核实预测与结果是否一致。注意E要大写</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>: </span><br><span class="line">unittest.main()</span><br><span class="line"><span class="comment"># __name__是python的一个内置函数,若此文件作为主程序使用,则__name__被设为__main__,在这里,调用</span></span><br><span class="line"><span class="comment"># unittest.main()来运行测试样例。如果此文件被测试框架导入,该变量值将不是__main__,因此不调用函数</span></span><br></pre></td></tr></table></figure><ul><li>各种断言方法:</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">用途</th></tr></thead><tbody><tr><td style="text-align:center">assertEqual(a,b)</td><td style="text-align:center">核实 a == b</td></tr><tr><td style="text-align:center">assertNotEqual(a,b)</td><td style="text-align:center">核实 a != b</td></tr><tr><td style="text-align:center">assertTrue(x)</td><td style="text-align:center">核实x为True</td></tr><tr><td style="text-align:center">assertFalse(x)</td><td style="text-align:center">核实x为False</td></tr><tr><td style="text-align:center">assertIn(item,list)</td><td style="text-align:center">核实item在list中</td></tr><tr><td style="text-align:center">assertNotIn(item,list)</td><td style="text-align:center">核实item不在list中</td></tr></tbody></table></div><h4 id="12-2-测试类"><a href="#12-2-测试类" class="headerlink" title="12.2 测试类"></a>12.2 测试类</h4><ul><li>和测试函数类似,测试类主要是测试类中方法的行为</li><li>方法<code>setUp</code>: 创建一个调查对象以及一个答案列表,使测试更为简单方便,具体用法略。</li></ul><h3 id="第十三章-函数式编程"><a href="#第十三章-函数式编程" class="headerlink" title="*第十三章 函数式编程"></a>*第十三章 函数式编程</h3><h4 id="13-1-高阶函数"><a href="#13-1-高阶函数" class="headerlink" title="13.1 高阶函数"></a>13.1 高阶函数</h4><ul><li>Python中的函数,有以下两个特点:<ul><li>变量可以指向函数: 以<code>abs()</code>函数为例子,函数名<code>abs</code>可以赋给变量,如<code>f = abs</code> 此时,调用<code>f</code> 等价于调用<code>abs</code></li><li>函数名也是变量: 如<code>abs = 10</code> <code>abs = max</code>等语句,可以将函数名指向其他对象,此时若再次调用abs,</li></ul></li><li>若一个函数就能接收另一个函数作为参数，该函数就称之为高阶函数,如下就是一个简单的例子:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mul</span>(<span class="params">a,b,cal</span>): <span class="comment">#将函数作为参数传入</span></span><br><span class="line">    <span class="keyword">return</span> cal(a+b)*cal(a+b)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(mul(<span class="number">6</span>,<span class="number">4</span>,add))</span><br></pre></td></tr></table></figure><ul><li><p>map/reduce函数:</p><ul><li><code>map</code>函数接受两个参数,一个是函数,一个是可迭代对象<code>Iterable</code>,<code>map</code>将传入的函数作用到序列中的每一个元素,并并把结果作为<code>Iterator</code>返回,示例见下:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="keyword">return</span> a**<span class="number">2</span></span><br><span class="line">a = <span class="built_in">map</span>(f,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]) <span class="comment"># 计算平方</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">b = <span class="built_in">map</span>(<span class="built_in">str</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]) <span class="comment"># int转str</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(b)) <span class="comment">#list函数可以将迭代器中的值遍历一遍,存入到列表中。且调用完后迭代器生成完了所有元素</span></span><br></pre></td></tr></table></figure><ul><li><code>reduce</code>函数把一个函数作用到一个序列<code>[a1,a2,a3,...]</code>上,且这个函数必须能传入两个参数,<code>reduce</code>把结果继续和序列的下一个元素做累积计算,直观的讲就是:<code>reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</code> ,示例见下:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce <span class="comment"># reduce函数需要先从库中导入</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line">a = reduce(f,[<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>]) <span class="comment">#求和</span></span><br></pre></td></tr></table></figure><ul><li>不过这个例子没啥用,下面给一个更加综合的例子:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce <span class="comment"># 字符串转数字</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">str2int</span>(<span class="params">s</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(s)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">return</span> a*<span class="number">10</span>+b</span><br><span class="line"><span class="built_in">print</span>(reduce(add,<span class="built_in">map</span>(str2int,[<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;4&#x27;</span>])))</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>filter:</p><ul><li>和<code>map</code>函数一样,<code>filter</code>函数也接收一个函数和一个序列。<code>filter</code>函数将函数的返回值作用于每个元素,来决定该元素是否被抛弃,一个简单的示例见下:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">odd</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="keyword">return</span> a%<span class="number">2</span>==<span class="number">1</span></span><br><span class="line">a = [<span class="number">1</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">filter</span>(odd,a))) <span class="comment"># 判断是否为奇数(注意,filter函数的返回值也是Iterator)</span></span><br></pre></td></tr></table></figure><ul><li>一个更为复杂的例子,用filter实现回文数判断:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">hw</span>(<span class="params">a</span>):</span><br><span class="line">    x,n,b=<span class="number">0</span>,a,<span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n&gt;<span class="number">0</span>:</span><br><span class="line">        x = n%<span class="number">10</span></span><br><span class="line">        b = b*<span class="number">10</span>+x</span><br><span class="line">        n = <span class="built_in">int</span>(n/<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">if</span> a==b:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">a = [<span class="number">1234321</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">34</span>,<span class="number">32</span>,<span class="number">323</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">filter</span>(hw,a)))</span><br></pre></td></tr></table></figure></li><li><p>sorted:</p><ul><li><code>sorted</code>函数默认为升序排序,前面写过,若要实现降序排序,可以通过改变其内部参数<code>reverse</code>来实现,同时,<code>sorted</code>也可以通过传入外部函数来确定排序方法,示例见下:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cmp</span>(<span class="params">a</span>): <span class="comment">#字符串与数字类型一起排序</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(a, <span class="built_in">int</span>):</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">        <span class="keyword">if</span> (i&lt;<span class="string">&#x27;0&#x27;</span> <span class="keyword">or</span> i&gt;<span class="string">&#x27;9&#x27;</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(a, <span class="built_in">str</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(a)</span><br><span class="line"></span><br><span class="line">a = [<span class="string">&quot;114514&quot;</span>,<span class="string">&quot;koishi&quot;</span>,<span class="number">19</span>,<span class="number">810</span>,<span class="string">&quot;satori&quot;</span>,<span class="string">&quot;54&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">sorted</span>(a,key = cmp)) <span class="comment"># [&#x27;koishi&#x27;, &#x27;satori&#x27;, 19, &#x27;54&#x27;, 810, &#x27;114514&#x27;]</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="13-2-返回函数"><a href="#13-2-返回函数" class="headerlink" title="13.2 返回函数"></a>13.2 返回函数</h4><ul><li>高阶函数除了可以接受其他函数作为参数外,还可以将函数作为返回值,例子如下:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">lazy_sum</span>(<span class="params">*a</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sum</span>():</span><br><span class="line">        s = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">            s = s+i</span><br><span class="line">        <span class="keyword">return</span> s</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span></span><br><span class="line"></span><br><span class="line">s = lazy_sum(<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>) <span class="comment"># 当调用lazy_sum时,返回的是结果,而不是函数</span></span><br><span class="line"><span class="built_in">print</span>(s()) <span class="comment"># 只有调用s时,才返回真正的求和结果</span></span><br></pre></td></tr></table></figure><ul><li>能够读取其他函数内部变量的函数,称为<strong>闭包</strong>（Closure）。上面的内部函数<code>sum</code>就是一个闭包</li><li>注意,每次调用外层函数时,所返回的都是一个新的内层函数,即使传入的参数是一样的</li><li>一个需要注意的问题是,返回的函数并没有立刻执行，而是直到调用了自身后才执行。来看一个例子:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">count</span>():</span><br><span class="line">    fs = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">f</span>():</span><br><span class="line">             <span class="keyword">return</span> i*i <span class="comment">#期望输出1,4,9</span></span><br><span class="line">        fs.append(f)</span><br><span class="line">    <span class="keyword">return</span> fs</span><br><span class="line"></span><br><span class="line">a,b,c = count()</span><br><span class="line"><span class="built_in">print</span>(a(),b(),c()) <span class="comment"># 9 9 9</span></span><br></pre></td></tr></table></figure><ul><li>上述代码中,我们认为的输出应该是<code>1 4 9</code>,而事实并非如此。原因就在于<code>f</code>函数内部引用了变量<code>i</code>,但它并非立刻执行。在我们第一次调用外层函数<code>count</code>后,循环已经执行完成了,因此此时<code>i</code>的值为3,而<code>f</code>函数是在调用<code>a,b,c</code>时才执行的,此时<code>i</code>的值已经为<code>3</code>了,故输出为<code>9 9 9</code></li><li>上面的例子也告诉了我们,返回函数不要使用循环变量或后续会发生变化的变量,若真要引用循环变量,可以再创建一个函数来绑定当前的值,例子如下:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">count</span>():</span><br><span class="line">    fs = []</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a</span>): <span class="comment"># 绑定a的值</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">g</span>():</span><br><span class="line">            <span class="keyword">return</span> a*a</span><br><span class="line">        <span class="keyword">return</span> g</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">4</span>):</span><br><span class="line">        fs.append(f(i))</span><br><span class="line">    <span class="keyword">return</span> fs</span><br></pre></td></tr></table></figure><ul><li><p>这种在调用时才进行计算的方法成为”惰性计算”(类似于线段树中的懒标记)</p></li><li><p>在内层函数中,若对外层变量<code>x</code>进行<code>x = x+1</code>等赋值操作,会把外层变量<code>x</code>当作内层函数的局部变量,从而因未初始化而产生报错,因此要在内层函数中加入一个<code>nonlocal x</code>的声明。加上声明后,解释器就会把<code>x</code>看作外层函数的局部变量</p></li></ul><h4 id="13-3-匿名函数"><a href="#13-3-匿名函数" class="headerlink" title="13.3 匿名函数"></a>13.3 匿名函数</h4><ul><li>python中,若所需函数较为简单,可以使用匿名函数<code>lambda</code>,用法示例如下:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="keyword">lambda</span> x:x*x</span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="keyword">return</span> a*a</span><br></pre></td></tr></table></figure><ul><li>其中,冒号前为传入的参数(可传入多个),冒号后为返回的表达式。同样的,匿名函数也可以作为返回值返回</li><li>一个较为复杂的例子: 用<code>lambda</code>与<code>filter</code>函数实现埃式筛:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fn</span>(): <span class="comment"># 生成无限序列</span></span><br><span class="line">  i = <span class="number">2</span></span><br><span class="line">  <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">yield</span> i</span><br><span class="line">    <span class="keyword">if</span> i==<span class="number">2</span>: i+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> :i+=<span class="number">2</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">a</span>): <span class="comment"># 筛选函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">lambda</span> x:x%a!=<span class="number">0</span></span><br><span class="line">g = fn()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">  n = <span class="built_in">next</span>(g)</span><br><span class="line">  <span class="keyword">if</span> n&lt;<span class="number">100</span>: <span class="comment"># 因为是无限序列 要加上退出判断</span></span><br><span class="line">    <span class="built_in">print</span>(n)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  g = <span class="built_in">filter</span>(f(n),g) <span class="comment"># 筛选</span></span><br></pre></td></tr></table></figure><h4 id="13-4-装饰器-decorator"><a href="#13-4-装饰器-decorator" class="headerlink" title="13.4 装饰器(decorator)"></a>13.4 装饰器(decorator)</h4><ul><li>装饰器(decorator)就是用于拓展原函数功能的一种函数,一个简单的例子如下:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">log</span>(<span class="params">func</span>):</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args,**kw</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;call %s():&#x27;</span> %func.__name__)<span class="comment"># 在运行函数前输出&quot;call 函数名()&quot;,func.__name__即为函数名</span></span><br><span class="line">    <span class="keyword">return</span> func(*args,**kw)</span><br><span class="line">  <span class="keyword">return</span> wrapper</span><br><span class="line"><span class="meta">@log</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">now</span>():</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;2022-10-9&quot;</span>)</span><br><span class="line">now()</span><br></pre></td></tr></table></figure><ul><li>下面来一步步解释上述代码:<ul><li><code>wrapper</code>函数的参数定义是<code>(*args,**kw)</code>,因此可以接受任何参数,在<code>wrapper</code>函数中,首先先打印日志,紧接着再调用原函数。</li><li><code>now</code>函数上面的<code>@log</code>,等价于执行<code>now = log(now)</code>。由于<code>log</code>是一个装饰器,所以,原来的<code>now</code>函数任然存在,只是现在同名的<code>now</code>变量指向了新的函数。最后,在调用<code>now</code>函数时,返回中的<code>wrapper</code>被执行</li></ul></li><li>如果decorator本身需要传入参数,那就需要再嵌套一层返回decorator的函数:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">log</span>(<span class="params">text</span>): <span class="comment"># 自定义log的文本</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">warpper</span>(<span class="params">*arg,**hw</span>):</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;%s %s(): &quot;</span> %(text,func.__name__))</span><br><span class="line">      <span class="keyword">return</span> func(*arg,**hw)</span><br><span class="line">    <span class="keyword">return</span> warpper</span><br><span class="line">  <span class="keyword">return</span> decorator</span><br><span class="line"><span class="meta">@log(<span class="params"><span class="string">&#x27;execute&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">now</span>():</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;2022-10-9&quot;</span>)</span><br><span class="line"></span><br><span class="line">now()</span><br></pre></td></tr></table></figure><ul><li>与两层嵌套相比,三层嵌套的返回等价于<code>now = log(&#39;execute&#39;)(now)</code>,先调用<code>log</code>函数,返回的是’decorator’函数,再调用返回的<code>decorator</code>函数,最终返回的是<code>warpper</code>函数</li><li>最后,还有一个问题,由于返回的函数的函数名为’warpper’,原函数的<code>__name__</code>属性也被改成了’warpper’,因此,还要调用<code>functools</code>中的<code>warps</code>函数,将<code>now</code>的一些属性赋给<code>wrapper</code>:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log</span>(<span class="params">text</span>):</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">decorator</span>(<span class="params">func</span>):</span><br><span class="line"><span class="meta">    @functools.wraps(<span class="params">func</span>) </span><span class="comment"># 等价于warpper = functools.wraps(warpper)</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">warpper</span>(<span class="params">*arg,**hw</span>):</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;%s %s(): &quot;</span> %(text,func.__name__))</span><br><span class="line">      <span class="keyword">return</span> func(*arg,**hw)</span><br><span class="line">    <span class="keyword">return</span> warpper</span><br><span class="line">  <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@log(<span class="params"><span class="string">&#x27;execute&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">now</span>():</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;2022-10-9&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="13-5-偏函数-partial-function"><a href="#13-5-偏函数-partial-function" class="headerlink" title="13.5 偏函数(partial function)"></a>13.5 偏函数(partial function)</h4><ul><li><code>int</code>函数可以通过提供额外的参数<code>base</code>来进行多进制转换,例如<code>int(&#39;x&#39;,base = 2)</code>,可以将二进制数x转换为十进制整数,当我们有多个数需要进行转换时,可以定义函数来简化计算,例如:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">d_to_b</span>(<span class="params">x, base=<span class="number">2</span></span>): <span class="comment"># 二进制转十进制</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(x, base)</span><br><span class="line">a = d_to_b(<span class="string">&#x27;100101&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure><ul><li>偏函数(partial function),就是指把一个函数的某些参数给固定住,并返回一个新的函数。上面就是偏函数的一种传统写法。同时,我们也可以使用<code>functools</code>中的<code>functools.partial</code>来帮我们简化代码:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line">d_to_b = functools.partial(<span class="built_in">int</span>,base=<span class="number">2</span>)</span><br><span class="line">a = <span class="string">&#x27;100101&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(d_to_b(a))</span><br></pre></td></tr></table></figure><ul><li>实际上,创建偏函数时,可以接受函数对象,可变参数<code>*arg</code>,关键字参数<code>**kw</code>这三个参数。例如上面的<code>base = 2</code>,等价于传入<code>&#123;&#39;base&#39;,2&#125;</code></li><li>另一个例子,给<code>max</code>函数添加固定比较对象:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line">max2 = functools.partial(<span class="built_in">max</span>,<span class="number">10</span>) <span class="comment">#等价于把10作为*arg的一部分加到最左边</span></span><br><span class="line"><span class="built_in">print</span>(max2(<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">19</span>,<span class="number">8</span>))</span><br></pre></td></tr></table></figure><h3 id="第十四章-模块"><a href="#第十四章-模块" class="headerlink" title="*第十四章 模块"></a>*第十四章 模块</h3><h4 id="14-1模块标准模板与作用域"><a href="#14-1模块标准模板与作用域" class="headerlink" title="14.1模块标准模板与作用域"></a>14.1模块标准模板与作用域</h4><ul><li>模块标准文件模板:<ul><li>其中第一第二行是标准注释,第1行注释可以让这个此文件直接在Unix/Linux/Mac上运行,第2行注释表示.py文件本身使用标准UTF-8编码。</li><li>第4行是一个字符串,表示模块的文档注释，任何模块代码的第一个字符串都被视为模块的文档注释。</li><li>第6行使用<code>__author__</code>变量把作者写进去，这样当你公开源代码后别人就可以看到自己的名字。接下来的部分就是正文了</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27; a test module &#x27;</span></span><br><span class="line"></span><br><span class="line">__author__ = <span class="string">&#x27;xcxc82&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>作用域<ul><li>正常的函数默认都是公开(public)的, 若要在模块中封装一些函数和变量,说明其只能在模块内部使用(private), 可以在其名字前加上<code>_</code>或<code>__</code>来表示此函数<strong>不应该</strong>被直接引用(不是”不能”被直接引用,python中没有一个方法可以完全限制访问private函数或变量)</li><li>外部不需要引用的函数全部定义成private,只有外部需要的函数定义成public</li></ul></li></ul><h4 id="14-2-安装第三方模块"><a href="#14-2-安装第三方模块" class="headerlink" title="14.2 安装第三方模块"></a>14.2 安装第三方模块</h4><ul><li>在cmd中输入<code>npm install xxx</code>,表示安装xxx模块。一般来说，第三方库都会在Python官方的<a href="https://pypi.python.org/">pypi.python.org</a>网站注册，要安装一个第三方库，必须先知道该库的名称，可以在官网或者pypi上搜索,安装好后,就可以使用该模块了</li><li>不过,用上述方法一个个的安装模块,属实有点费力,因此也可以使用<a href="https://www.anaconda.com/">Anaconda</a>进行安装,这是一个基于Python的数据处理和科学计算平台，内置了许多有用的第三方库，装上Anaconda，就相当于安装了数十个第三方模块,非常的简单使用</li><li>模块搜索路径: 当我们试图加载一个模块时,python会在指定的路径下搜索对应的文件,若找不到,就会进行报错。默认情况下,python会搜索当前目录、所有已安装的内置模块和第三方模块,搜索路径放在<code>sys</code>模块的<code>path</code>变量中:</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span>(sys.path)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[&#x27;C:\\Users\\16349\\Desktop\\python&#x27;, </span></span><br><span class="line"><span class="string">&#x27;C:\\Users\\16349\\AppData\\Local\\Programs\\Python\\Python310\\python310.zip&#x27;, </span></span><br><span class="line"><span class="string">&#x27;C:\\Users\\16349\\AppData\\Local\\Programs\\Python\\Python310\\DLLs&#x27;, </span></span><br><span class="line"><span class="string">&#x27;C:\\Users\\16349\\AppData\\Local\\Programs\\Python\\Python310\\lib&#x27;, </span></span><br><span class="line"><span class="string">&#x27;C:\\Users\\16349\\AppData\\Local\\Programs\\Python\\Python310&#x27;, </span></span><br><span class="line"><span class="string">&#x27;C:\\Users\\16349\\AppData\\Local\\Programs\\Python\\Python310\\lib\\site-packages&#x27;]</span></span><br><span class="line"><span class="string">[Finished in 314ms]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><ul><li>若想要自己添加自己的搜索目录,有两种方法,一种是直接添加到<code>sys.path</code>中,这种方法在运行结束后便会失效; 第二种方法是添加环境变量<code>PYTHONPATH</code>来改变</li></ul><center>第二部分 项目</center><h2 id="项目1-外星人入侵"><a href="#项目1-外星人入侵" class="headerlink" title="项目1 外星人入侵"></a>项目1 外星人入侵</h2><h3 id="第十五章-武装飞船"><a href="#第十五章-武装飞船" class="headerlink" title="第十五章 武装飞船"></a>第十五章 武装飞船</h3><p>十二月csp认证打完后再写</p>]]></content>
      
      
      <categories>
          
          <category> 大学学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础乐理知识笔记</title>
      <link href="/2022/07/31/%E5%9F%BA%E7%A1%80%E4%B9%90%E7%90%86%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/07/31/%E5%9F%BA%E7%A1%80%E4%B9%90%E7%90%86%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>对应b站教程:<a href="https://www.bilibili.com/video/BV14p4y1e7TV?p=1&amp;vd_source=51e3f6ab44e8fbb799044e19b28f9f8b">https://www.bilibili.com/video/BV14p4y1e7TV?p=1&amp;vd_source=51e3f6ab44e8fbb799044e19b28f9f8b</a></p><h2 id="唱名”与记住“唱名”的方法"><a href="#唱名”与记住“唱名”的方法" class="headerlink" title="唱名”与记住“唱名”的方法"></a>唱名”与记住“唱名”的方法</h2><ul><li>唱名: 在演唱旋律时为方便唱谱而采用的名称,如用”1234567”代表”do re mi fa sol la si” </li></ul><h2 id="简谱的构造-调号、拍号、情绪与速度的意义"><a href="#简谱的构造-调号、拍号、情绪与速度的意义" class="headerlink" title="简谱的构造(调号、拍号、情绪与速度的意义)"></a>简谱的构造(调号、拍号、情绪与速度的意义)</h2><ul><li>调号: 确定唱名和音名间的关系(音调的高低位置)</li><li>拍号:决定音乐的律动</li><li>情绪与速度:怎么唱,唱的速度(情绪一定程度上也代表速度)</li></ul><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/al5g31so.png" alt=""></p><center>简谱中起决定作用的部分</center><h2 id="音名-钢琴键盘-初步理解-1-C"><a href="#音名-钢琴键盘-初步理解-1-C" class="headerlink" title="音名,钢琴键盘  初步理解 1=C"></a>音名,钢琴键盘  初步理解 1=C</h2><ul><li>调号形式:唱名=音名(例: 1=C,1=A,1=D等等)</li><li>音名:对固定高度的音所定的名称(CDEFGAB),音名的位置<strong>永远不变</strong>(无论什么情况,无论什么乐器)</li><li>钢琴键盘:由9个基本结构单元组组成,其中一个组里含有5个黑键和7个白键,黑白键地位等同,每组白键自左到右分别为”C D E F G A B”,第1组和第9组不完整,共88个键</li></ul><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/m9r5qpbh.png" alt=""></p> <center>钢琴的基本结构单元</center><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ns0rsdxf.png" alt=""></p><center>88键钢琴键盘</center><ul><li>“1=C”的意义:确定唱名与音名间的对应关系,1=C即表示唱名”do”对应音名C,”234567”依次对应”DEFGAB”,<strong>只有在1=C时,”234567”全在白键上,其他情况不同</strong></li></ul><h2 id="升降号、黑键的音名-重升重降号、等音扩展篇"><a href="#升降号、黑键的音名-重升重降号、等音扩展篇" class="headerlink" title="升降号、黑键的音名  重升重降号、等音扩展篇"></a>升降号、黑键的音名  重升重降号、等音扩展篇</h2><ul><li>升号:♯  降号:♭ </li></ul><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/cidxthit.png" alt=""></p><center>升降号的意义</center><ul><li><img src="https://cdn.luogu.com.cn/upload/image_hosting/xofu4mwv.png" alt=""></li></ul><center>重升/降号的表示</center><ul><li>黑键的音名: 升降号+白键音名</li></ul><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/3asmnsay.png" alt=""></p><center>升/降号的使用</center><ul><li><p>同一音名的不同写法称为等音,在某些特定的环境中使用等音写法可以更具连贯性,易理解</p></li><li><p>钢琴键盘自左到右,音的频率逐渐变大,音逐渐变高</p></li></ul><h2 id="纯八度是什么"><a href="#纯八度是什么" class="headerlink" title="纯八度是什么"></a>纯八度是什么</h2><ul><li><p>两个音的频率越接近简单的整数比,听上去就会越相近,和谐</p></li><li><p>相邻两组中相同音名的两个音的频率比为1:2时,称为纯八度</p></li></ul><h2 id="音的分组、中央C、标准音"><a href="#音的分组、中央C、标准音" class="headerlink" title="音的分组、中央C、标准音"></a>音的分组、中央C、标准音</h2><ul><li>赫尔姆霍茨法: 见下图</li></ul><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/5ldb0dq4.png" alt=""></p><center>赫尔姆霍茨法的命名规则</center><ul><li>科学音调记号法:见下图</li></ul><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/nlhg8ibw.png" alt=""></p><center>科学音调记号法的命名规则</center><ul><li>中央C: 指C4(c)</li><li>标准音:国际通用的标准高度音,即A4(a)</li></ul><h2 id="高音点、低音点"><a href="#高音点、低音点" class="headerlink" title="高音点、低音点"></a>高音点、低音点</h2><ul><li>区分不同组中的唱名。命名规则见下图</li></ul><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/z33lssyl.png" alt=""></p><h2 id="音域、1-C到底是哪组的C"><a href="#音域、1-C到底是哪组的C" class="headerlink" title="音域、1=C到底是哪组的C"></a>音域、1=C到底是哪组的C</h2><ul><li>音域: 乐器所能发出的音高的范围。钢琴的音域为A0~C8</li><li>正常人声的音域大约G3~D5,为简化乐谱,大多数简谱中的1=C都为C4</li></ul><h2 id="半音、全音"><a href="#半音、全音" class="headerlink" title="半音、全音"></a>半音、全音</h2><ul><li>半音:指相邻的两个音之间的距离</li><li>全音:半音x2</li></ul><h2 id="乐音、噪音、乐音体系、音列"><a href="#乐音、噪音、乐音体系、音列" class="headerlink" title="乐音、噪音、乐音体系、音列"></a>乐音、噪音、乐音体系、音列</h2><ul><li>乐音:振动规则,频率稳定的音</li><li>噪音:振动不规则,频率不稳定的音(打击乐器多为噪音乐器)</li><li>乐音体系:音乐中使用到的所有乐音的总和。绝大部分情况下为88个音</li><li>音列:乐音体系中,取若干乐音,有序的排列起来,称为音列</li></ul><h2 id="音级、基本音级、变化音级"><a href="#音级、基本音级、变化音级" class="headerlink" title="音级、基本音级、变化音级"></a>音级、基本音级、变化音级</h2><ul><li>音级:乐音体系中的每一个音,都叫做音级</li><li>基本音级: 具有独立名称，不带有升降记号的音级 (CDEFGAB)</li><li>变化音级: 升降号+基本音级</li></ul><h2 id="自然半音、变化半音、自然全音、变化全音"><a href="#自然半音、变化半音、自然全音、变化全音" class="headerlink" title="自然半音、变化半音、自然全音、变化全音"></a>自然半音、变化半音、自然全音、变化全音</h2><ul><li>自然半音,自然全音: 忽略升降符号,两个音的音名字母部分相邻。如#C-D为自然半音,#E-XF为自然全音</li><li>变化半音,变化全音: 反过来,字母部分不同。如♭B-C,♭G-♭♭A</li></ul><h2 id="1234567的内在规则"><a href="#1234567的内在规则" class="headerlink" title="1234567的内在规则"></a>1234567的内在规则</h2><ul><li>见下图</li></ul><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/e16otlmq.png" alt=""></p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/l2fcqd2q.png" alt=""></p><h2 id="调式、自然大调式"><a href="#调式、自然大调式" class="headerlink" title="调式、自然大调式"></a>调式、自然大调式</h2><ul><li><p>调式:若干高低不同的乐音,围绕某一有稳定感的中心音,按一定的音程关系组织在一起,成为一个有机的体系 (<del>人话:若干个音按某种规则排列</del>)</p></li><li><p>自然大调式: 简称大调。具体规则如下图。</p></li><li>自然大调从X音开始,就称为X大调(如C大调,D大调)</li></ul><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ns0v8556.png" alt=""></p><h2 id="音阶是什么、有什么用-关于调式、音阶的一个萌新常见误区"><a href="#音阶是什么、有什么用-关于调式、音阶的一个萌新常见误区" class="headerlink" title="音阶是什么、有什么用  关于调式、音阶的一个萌新常见误区"></a>音阶是什么、有什么用  关于调式、音阶的一个萌新常见误区</h2><ul><li>音阶:将调式中的音,从以主音开始到以主音结束,由低到高(叫做上行),或者由高到低(叫做下行),以阶梯状排列起来,就叫做音阶。</li><li>特点<ul><li>主音开始,主音结束(有始有终)</li><li>音阶是有序性的(方向性)</li><li>包含该调式中的所有音(完整性)</li></ul></li><li>误区: 调式,音阶不只有一个组</li></ul><h2 id="黑键出发的自然大调、等音调、音阶的选择"><a href="#黑键出发的自然大调、等音调、音阶的选择" class="headerlink" title="黑键出发的自然大调、等音调、音阶的选择"></a>黑键出发的自然大调、等音调、音阶的选择</h2><ul><li>等音调: 发音相同表示不同的调号</li><li>音阶中的相邻的两个音的字母必须连续</li><li>方便起见,含有重升重降号的音阶基本不使用</li></ul><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ayr0qb7p.png" alt=""></p><h2 id="等音调扩展篇、何为一共十五个大调"><a href="#等音调扩展篇、何为一共十五个大调" class="headerlink" title="等音调扩展篇、何为一共十五个大调"></a>等音调扩展篇、何为一共十五个大调</h2><ul><li>见下图</li></ul><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/4d2xvy43.png" alt=""></p><h2 id="调号总结篇"><a href="#调号总结篇" class="headerlink" title="调号总结篇"></a>调号总结篇</h2><ul><li>前面所有</li></ul><h2 id="模唱、相对音高的练习方式"><a href="#模唱、相对音高的练习方式" class="headerlink" title="模唱、相对音高的练习方式"></a>模唱、相对音高的练习方式</h2><ul><li>多唱</li></ul><h2 id="为什么要有这么多调号？"><a href="#为什么要有这么多调号？" class="headerlink" title="为什么要有这么多调号？"></a>为什么要有这么多调号？</h2><ul><li>适用不同的音域</li></ul><h2 id="如何构建大调音阶"><a href="#如何构建大调音阶" class="headerlink" title="如何构建大调音阶"></a>如何构建大调音阶</h2><ul><li>略 前面写过</li></ul><h2 id="7的发音是Si还是Ti"><a href="#7的发音是Si还是Ti" class="headerlink" title="7的发音是Si还是Ti"></a>7的发音是Si还是Ti</h2><ul><li>自己决定 没必要过于区分</li></ul><h2 id="升降号写音名左边还是右边"><a href="#升降号写音名左边还是右边" class="headerlink" title="升降号写音名左边还是右边"></a>升降号写音名左边还是右边</h2><ul><li>乐谱写左边,书面上无所谓</li></ul><h2 id="调性是什么"><a href="#调性是什么" class="headerlink" title="调性是什么"></a>调性是什么</h2><ul><li>调式: 未指定主音(例自然大调,自然小调)</li><li>调性: 指定了主音的调式(如C自然大调,D自然小调)</li></ul><h2 id="XX大调的音乐中能够出现XX大调音阶中没有的音吗"><a href="#XX大调的音乐中能够出现XX大调音阶中没有的音吗" class="headerlink" title="XX大调的音乐中能够出现XX大调音阶中没有的音吗"></a>XX大调的音乐中能够出现XX大调音阶中没有的音吗</h2><ul><li>可以 偶尔出现不是原本调里的音,是为了凸显新奇感</li><li>艺术行业的理论是一种对成品的归纳和总结,只能尽可能还原真相,目的是为了帮助后来者快速入门,不能做到百分百精确</li></ul><h2 id="首调与固定调"><a href="#首调与固定调" class="headerlink" title="首调与固定调"></a>首调与固定调</h2><ul><li><p>首调: 无论什么大调,都把该大调的首音当作1,234567以此为标准延续</p></li><li><p>固定调: 永远把唱名1234567与音名CDEFGAB对应</p></li><li><p>各自的优势与适用场景:</p><ul><li>首调更能体现相对音高,固定调更能体现绝对音高</li><li>首调适合歌唱与可变调的乐器</li><li>固定调适合不可变调的乐器 (如钢琴)</li></ul></li></ul><h2 id="相对音感与绝对音感"><a href="#相对音感与绝对音感" class="headerlink" title="相对音感与绝对音感"></a>相对音感与绝对音感</h2><ul><li>相对音感: 在有参考音的前提下分辨各个音之间的相对音高的能力。可以练</li><li>绝对音感: 无参考音就能分辨各个音,要天赋</li></ul><h2 id="原调、移调、转调、离调"><a href="#原调、移调、转调、离调" class="headerlink" title="原调、移调、转调、离调"></a>原调、移调、转调、离调</h2><ul><li><p>原调: 一首音乐本身的调。</p></li><li><p>移调: 将一首音乐的所有音调整到其他调上</p></li><li>转调: 将一首音乐的部分音调整到其他音上,并长时间处于新调,且基本上要在新调上结束</li><li>离调: 将一首音乐的小部分调整到其他音上,并快速返回原调</li></ul><h2 id="简谱需要移调吗？"><a href="#简谱需要移调吗？" class="headerlink" title="简谱需要移调吗？"></a>简谱需要移调吗？</h2><ul><li>使用首调时,仅需改变调号</li><li>使用固定调时要改变正文</li></ul><h2 id="高八度低八度算不算跑调"><a href="#高八度低八度算不算跑调" class="headerlink" title="高八度低八度算不算跑调"></a>高八度低八度算不算跑调</h2><ul><li>不算</li><li>自己唱的舒服就行</li></ul><h2 id="音名为什么有时候分组，有时候不分组"><a href="#音名为什么有时候分组，有时候不分组" class="headerlink" title="音名为什么有时候分组，有时候不分组"></a>音名为什么有时候分组，有时候不分组</h2><ul><li>对于一些在所有组上都适用的知识</li><li>对于 EGBD/3572 之类的形容,是从左到右按照从低到高的顺序排列的,哪怕要跨越组</li></ul><h2 id="不太明确的乐理题"><a href="#不太明确的乐理题" class="headerlink" title="不太明确的乐理题"></a>不太明确的乐理题</h2><p>略</p><h2 id="调号章节哪些东西还没有讲？为什么？什么时候讲"><a href="#调号章节哪些东西还没有讲？为什么？什么时候讲" class="headerlink" title="调号章节哪些东西还没有讲？为什么？什么时候讲?"></a>调号章节哪些东西还没有讲？为什么？什么时候讲?</h2><ul><li>其他调式,五度圈,还原号等等</li></ul><h2 id="拍号部分开始，认识音符"><a href="#拍号部分开始，认识音符" class="headerlink" title="拍号部分开始，认识音符"></a>拍号部分开始，认识音符</h2><ul><li>$\dfrac{X}{Y}$的意义: 以Y分音符(的时长)为一拍,每小节有X拍(的时长)</li><li>音符: 用来形容音的长短。几个常见的音符表示如下图所示:</li></ul><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/3cezewyr.png" alt=""></p><center>图中一个小方块表示一个时间单位，时间单位的长度由情绪与速度决定</center><ul><li>二全音符/倍全音符: 时间为全音符的两倍(不常用)</li></ul><h2 id="什么是一拍"><a href="#什么是一拍" class="headerlink" title="什么是一拍"></a>什么是一拍</h2><ul><li>拍: 音乐中的时长单位</li><li>以Y分音符为一拍 $⟺$ 一拍的长度等于一个Y分音符的长度 (大多数情况下都是Y=4或Y=8)</li></ul><h2 id="小节，小节线，终止线"><a href="#小节，小节线，终止线" class="headerlink" title="小节，小节线，终止线"></a>小节，小节线，终止线</h2><ul><li>见下图</li></ul><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/x7fxn0hd.png" alt=""></p><ul><li>小节线的作用:<ul><li>均分每一小节</li><li>预示强弱关系</li></ul></li></ul><h2 id="看懂拍号的意义"><a href="#看懂拍号的意义" class="headerlink" title="看懂拍号的意义"></a>看懂拍号的意义</h2><p>总结</p><h2 id="附点，复附点"><a href="#附点，复附点" class="headerlink" title="附点，复附点"></a>附点，复附点</h2><ul><li>附点:见下图</li></ul><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/x35e1frh.png" alt=""></p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/jsjinse2.png" alt=""></p><center>附点来源于五线谱中的概念,附点二分音符在五线谱中有点</center><ul><li>复附点: 延长第一个附点代表的值的一半</li></ul><h2 id="延音线"><a href="#延音线" class="headerlink" title="延音线"></a>延音线</h2><ul><li>延音线:用与组合无法使用常规方式表达的拍数</li><li>一个音跨越小节时必须使用延音线,不可使用横线</li><li>必须连接相同的音</li></ul><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/8jwcf32p.png" alt=""></p><h2 id="连线"><a href="#连线" class="headerlink" title="连线"></a>连线</h2><ul><li>歌谱中,某一个字对应几个音的时候,需要用连线将这几个音连接起来</li><li>框起来的部分,要唱(奏)得连贯</li><li>绝大多数情况下连线连的是不同的音</li></ul><h2 id="休止符"><a href="#休止符" class="headerlink" title="休止符"></a>休止符</h2><ul><li>见下图</li></ul><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/5w8l0x7x.png" alt=""></p><ul><li><p>其他长度的休止符和音符一样加附点或用延音线即可</p></li><li><p>简谱中常常将下方有横线的音符与休止符的横线连接起来</p></li><li>小节线、音符、休止符之间无任何其他停顿</li></ul><h2 id="常见的拍号，强弱关系"><a href="#常见的拍号，强弱关系" class="headerlink" title="常见的拍号，强弱关系"></a>常见的拍号，强弱关系</h2><ul><li>无论什么拍号,每小节第一拍都是”强拍”,并且每小节只有这一个”强拍”</li><li>不同的拍号预示着不同的强弱关系</li><li>“强拍” “弱拍”并不是说强拍的音量一定响,弱拍的音量一定弱</li><li>额外拓展(看看就行)<ul><li>旋律中的长音符,稳定音,通常处于强拍短音符,不稳定音通常处于弱拍</li><li>和声通常要在强拍进行变化,弱拍进行保持</li><li>不同的强弱关系还影响旋律的动机,织体的写法,配器的选择,速度的选择等等</li></ul></li></ul><h2 id="单拍子、复拍子"><a href="#单拍子、复拍子" class="headerlink" title="单拍子、复拍子"></a>单拍子、复拍子</h2><ul><li>单拍子: 每小节只有一个强拍,并且也<strong>存在</strong>弱拍(如2/4拍,3/8拍)</li><li>复拍子:由相同的单拍子组合起来的(如4/4拍,6/8拍)</li><li>如果某个拍号是由多个拍号组合而成的,那么每小节的第二个强拍开始,都要变成次强拍</li></ul><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/5o1xh4y0.png" alt=""></p><h2 id="混合拍子"><a href="#混合拍子" class="headerlink" title="混合拍子"></a>混合拍子</h2><ul><li><p>混合拍子:<strong>不同</strong>的单拍子组成的拍子</p></li><li><p>一种混合拍子的组合顺序有多种可能,如(5/4拍有2/4+3/4和3/4+2/4两种可能)</p></li></ul><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/1zv6qnsp.png" alt=""></p><ul><li>复合拍子第一拍后的强拍子均为次强拍,没有”次次强拍”的说法</li></ul><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/wck43ia2.png" alt=""></p><h2 id="一拍子、散拍子"><a href="#一拍子、散拍子" class="headerlink" title="一拍子、散拍子"></a>一拍子、散拍子</h2><ul><li>一拍子: 每小节只有一拍且这一拍是强拍(一般只有在戏曲中能见到)</li><li>X拍子: 指每小节有X拍的拍子</li><li>散拍子: 符号类似一个”艹”。无固定小节线,拍数,强弱关系,一般用于戏曲音乐中,由演奏者自由发挥</li></ul><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/si47nfvi.png" alt=""></p><h2 id="变换拍子、交错拍子"><a href="#变换拍子、交错拍子" class="headerlink" title="变换拍子、交错拍子"></a>变换拍子、交错拍子</h2><ul><li>变换拍子: 一首音乐演奏时拍子发生了变换</li><li>写法见下图。大多数情况下左上角只写开始的拍子</li></ul><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/osnwiowp.png" alt=""></p><ul><li>交错拍子: 一首音乐由多个乐器演奏时,各乐器的拍子不同(很少用到)</li></ul><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/jp1iw9pq.png" alt=""></p><h2 id="小节序号"><a href="#小节序号" class="headerlink" title="小节序号"></a>小节序号</h2><ul><li>标在某些小节开始处的数字</li></ul><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/4hp49n93.png" alt=""></p><ul><li>小节序号最主要的作用是方便查找</li><li>很多乐谱没有小节序号,要自己标记</li><li>小节序号通常标在换行之后的第一个小节</li><li>有一些会以五或十小节为单位标记小节序号</li><li>小节序号标在小节线的正上方或者稍微偏右</li><li>第一小节不用标</li></ul><h2 id="弱起小节、弱起"><a href="#弱起小节、弱起" class="headerlink" title="弱起小节、弱起"></a>弱起小节、弱起</h2><ul><li>弱起小节:音乐不是从强拍开始的,是从弱拍或者次强拍开始的。弱起小节是不完整的小节(拍数不够)</li></ul><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/sizvigbm.png" alt=""></p><ul><li><p>补充</p><ul><li>拥有弱起小节的音乐有些时候在这段音乐的最后一个小节也是不完整的</li><li>弱起小节不算第一小节,第一小节一定要在由强拍且完整的节拍上</li><li>弱起小节必须是完整的。如下图中加上了前导0的完整小节不能被称之为弱起小节</li></ul><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/202axy3w.png" alt=""></p><ul><li>弱起:指旋律从非强拍的位置开始</li></ul><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/jp5i61ox.png" alt=""></p></li></ul><h2 id="情绪与速度、具体的速度、BPM"><a href="#情绪与速度、具体的速度、BPM" class="headerlink" title="情绪与速度、具体的速度、BPM"></a>情绪与速度、具体的速度、BPM</h2><ul><li><p>具体速度的表达方式</p><ul><li><p>每分钟X拍</p></li><li><p>♩ = X  每分钟有X个四分音符</p></li><li>X BPM(beats per minute,和方法1含义相同)</li></ul></li></ul><h2 id="抽象的速度"><a href="#抽象的速度" class="headerlink" title="抽象的速度"></a>抽象的速度</h2><ul><li>抽象的速度<ul><li>意文largo等,中文广板等,慢中快速等 (看看就行)</li><li>与”速度”看似无直接关系的副词,如激烈的,欢快的,悲伤的等</li></ul></li></ul><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/71kdjxlt.png" alt=""></p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/zykyx8l9.png" alt=""></p><ul><li>如果同时出现BPM与抽象副词,以BPM为准</li></ul><h2 id="节拍器与使用"><a href="#节拍器与使用" class="headerlink" title="节拍器与使用"></a>节拍器与使用</h2><ul><li>基本上是个音乐软件都会有的功能,照着用就行</li></ul><h2 id="拍号、情绪与速度总结篇"><a href="#拍号、情绪与速度总结篇" class="headerlink" title="拍号、情绪与速度总结篇"></a>拍号、情绪与速度总结篇</h2><ul><li>略</li></ul><h2 id="打拍子（1）-V字打拍法"><a href="#打拍子（1）-V字打拍法" class="headerlink" title="打拍子（1）-V字打拍法"></a>打拍子（1）-V字打拍法</h2><ul><li>四分音符打一拍,一个V字(一上一下),其他整数类拍以此类推</li></ul><h2 id="打拍子（2）-休止符打法"><a href="#打拍子（2）-休止符打法" class="headerlink" title="打拍子（2）-休止符打法"></a>打拍子（2）-休止符打法</h2><ul><li>嘴停手不停</li><li>最开始练习时,休止符可以先念作”空”</li></ul><h2 id="打拍子（3）-二八"><a href="#打拍子（3）-二八" class="headerlink" title="打拍子（3）-二八"></a>打拍子（3）-二八</h2><ul><li>二八: 两个八分音符</li><li>唱法:下去的时候唱第一个音,上来的时候唱第二个音</li></ul><h2 id="打拍子（4）-四十六"><a href="#打拍子（4）-四十六" class="headerlink" title="打拍子（4）-四十六"></a>打拍子（4）-四十六</h2><ul><li>四十六: 四个十六分音符</li><li>唱法:上下都发两次音</li></ul><h2 id="打拍子（5）-前八后十六、前十六后八"><a href="#打拍子（5）-前八后十六、前十六后八" class="headerlink" title="打拍子（5）-前八后十六、前十六后八"></a>打拍子（5）-前八后十六、前十六后八</h2><ul><li>一个八分音符+两个十六分音符</li><li>原理一样 多练</li></ul><h2 id="打拍子（6）-前附点、后附点"><a href="#打拍子（6）-前附点、后附点" class="headerlink" title="打拍子（6）-前附点、后附点"></a>打拍子（6）-前附点、后附点</h2><h2 id="打拍子（7）-小切分"><a href="#打拍子（7）-小切分" class="headerlink" title="打拍子（7）-小切分"></a>打拍子（7）-小切分</h2><h2 id="打拍子（8）-一拍内的变体"><a href="#打拍子（8）-一拍内的变体" class="headerlink" title="打拍子（8）-一拍内的变体"></a>打拍子（8）-一拍内的变体</h2><h2 id="打拍子（9）-大附点与变体"><a href="#打拍子（9）-大附点与变体" class="headerlink" title="打拍子（9）-大附点与变体"></a>打拍子（9）-大附点与变体</h2><h2 id="打拍子（10）-大切分与变体"><a href="#打拍子（10）-大切分与变体" class="headerlink" title="打拍子（10）-大切分与变体"></a>打拍子（10）-大切分与变体</h2>]]></content>
      
      
      <categories>
          
          <category> 音乐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 基础乐理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>绘画记录</title>
      <link href="/2022/07/31/%E7%BB%98%E7%94%BB%E8%AE%B0%E5%BD%95/"/>
      <url>/2022/07/31/%E7%BB%98%E7%94%BB%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="978416782fd83a5f3f1c401dd2a554f247c3a30b3728c9ec8db81b0b6ea771f7">4630436162ade97ba2718b7d0c4b3b632387b86b41c24be2b4e2e5674a0e5e2907e141d3549a1b8f51f98364158dd3b57ac6c7b7ae025e51fe7231dd55d0cecc7ddc7ae0269377559163a2bb4b6d54b34378a697fe395ec9fdebe9eb22103104a03d4425cb599bc4f6ccef086f63b02762c3b407a0bbdd86bfd2bc3c0f422f3225cdbb14ec303b1dff41ae724a70ed725a58e8f5e8800b19e7e7cd4f0844c96c0ac54906d893a0e8122c45b3dd5d93132f6689158ab1f7f3fec69cf35ecb6b7a8cf05031ef50e0cc0b7681a60f7fa5d2013388dc0b87236dfde1230040c07251ba51c134f5d5abe719bceff13aab4bdec327cfbb1953780681131cc9b7aa7595cc25eaed46ba8354904fe2553cc78ce9308b1e2e957071851ef30a3021672bcee9d1de9e6729af748ac0b7cc9c69068ad975977064a72a497c0199bc7c849ace5ad254f9a57926790ece2f0d8ffe0996e0e6780ddc810e8675a24cfce396c79b6bbd325260599c559fc44292b9d6374739afd6afd0d7680277738b4a58def994e256bcbc72319b4c70c942e12bd3c177946dfffa7eb1f12be3747c55cdb5fb378c1f85b213fc54dcd04f497af1c13ce7e18c3c490c6f1cb287aad64b654e75d30345e903f914453a34ae32f5192a9225cb8fadaeffd477b095495db22d98c4348e13cdc2a2bd715dcbf709c504c7034dfd150caa223e1f427f61debe542fcf75ffc1c1e7945b8f2c98b4cd768e13236534a20f830abc2c3fd464a36b9b0b46b324961886ce103fada0535e1505bc38391be3d09e355b4fc73ddae648cdb17b42a55184793b36e0301c37ddba0db7fd62f2e63780e0c1213670f8f8f8b827d6f0c6e2369dfad730c6911c1e1bc0422f77c4cca31f900d2b7978e5db3abeb6475954945217dbb39697beaf756debfa92ab0c071204a717a15361ffae4bc051f30a6da40e80fd03e2022fba11187508b1b464ebfc98b026dd36594beb5b3d26346c3b9e8c5e4a1c9140ed736099c356fc21</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 绘画 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>v大预科作业第二周</title>
      <link href="/2022/07/08/v%E5%A4%A7%E9%A2%84%E7%A7%91%E4%BD%9C%E4%B8%9A%E7%AC%AC%E4%BA%8C%E5%91%A8/"/>
      <url>/2022/07/08/v%E5%A4%A7%E9%A2%84%E7%A7%91%E4%BD%9C%E4%B8%9A%E7%AC%AC%E4%BA%8C%E5%91%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="DAY1"><a href="#DAY1" class="headerlink" title="DAY1"></a>DAY1</h2><p>感觉这个色彩组合临摹目前来说对我没啥用处…</p><p>考虑明天换个东西做做</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/xj1izccz.png" alt=""></p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/o7qjq059.png" alt=""></p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/bo4q7m2p.png" alt=""></p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/fopzqf9d.png" alt=""></p><h2 id="DAY2"><a href="#DAY2" class="headerlink" title="DAY2"></a>DAY2</h2><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/xhxnsbod.png" alt=""></p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/mgpa5agy.png" alt=""></p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/20j7isx9.png" alt=""></p><h2 id="DAY3"><a href="#DAY3" class="headerlink" title="DAY3"></a>DAY3</h2><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/rlmijh66.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 绘画 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 预科作业 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>v大预科作业第一周</title>
      <link href="/2022/07/02/v%E5%A4%A7%E9%A2%84%E7%A7%91%E4%BD%9C%E4%B8%9A%E7%AC%AC%E4%B8%80%E5%91%A8/"/>
      <url>/2022/07/02/v%E5%A4%A7%E9%A2%84%E7%A7%91%E4%BD%9C%E4%B8%9A%E7%AC%AC%E4%B8%80%E5%91%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="DAY1"><a href="#DAY1" class="headerlink" title="DAY1"></a>DAY1</h2><p>这量就离谱</p><p>从早上九点一直画到晚上十点多才画完= =</p><p>终究还是我太菜了/kk</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/mtx9gumm.png" alt=""></p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/9tw63rc9.png" alt=""></p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/4dia4e3o.png" alt=""></p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/rlah1j27.png" alt=""></p><h2 id="DAY-2"><a href="#DAY-2" class="headerlink" title="DAY 2"></a>DAY 2</h2><p>把最恶心的十个单体练习搞定了</p><p>剩下的明天搞</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/c2rbm3ws.png" alt=""></p><h2 id="DAY-3"><a href="#DAY-3" class="headerlink" title="DAY 3"></a>DAY 3</h2><p>把昨天没做的补完了</p><p>感觉手感比第一天好多了</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ra4l48mb.png" alt=""></p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/xpon3tyt.png" alt=""></p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ecj3opjx.png" alt=""></p><h2 id="day4"><a href="#day4" class="headerlink" title="day4"></a>day4</h2><p>单体练习有一些细节还没画完 懒得补了(</p><p>衣玖的衣服是真nm难画…</p><p> <img src="https://cdn.luogu.com.cn/upload/image_hosting/lchyu9kk.png" alt=""></p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/milzyu7b.png" alt=""></p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/j707cogi.png" alt=""></p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/2a8vxfdi.png" alt=""></p><h2 id="day5"><a href="#day5" class="headerlink" title="day5"></a>day5</h2><p><del>休息了一整天</del></p><p>随便画了点自己喜欢的东西</p>]]></content>
      
      
      <categories>
          
          <category> 绘画 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 预科作业 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P6835 [Cnoi2020]线形生物</title>
      <link href="/2021/02/12/p6835/"/>
      <url>/2021/02/12/p6835/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p><strong><a href="https://www.luogu.com.cn/problem/solution/P6835">原题面</a></strong></p><p>有$n+1$个点,对于每个点$i(i≤n)$都有一条连向$i+1$的边,形成一条链,并在其中加入$m$条返祖边</p><p>现在从1号节点出发，每次等概率的前往到一个相邻的节点，求走到第$n+1$个点的期望步数</p><p>$n,m≤10^6$</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>设$E_{x→y}$表示从$x$点走到$y$点的期望步数，$k_i$表示第$i$个点的返祖边条数</p><p>有转移：</p><center>$~~~~~E_{x→x+1} = \dfrac{1}{k_x+1}×1+\dfrac{1}{k_x+1}×\sum\limits_{(x,y)∈E}E_{y→x+1}+1$</center><center>$= 1+\dfrac{1}{k_x+1}×\sum\limits_{(x,y)∈E}E_{y→x+1}$</center><p>根据期望的线性性质,有$E<em>{x→y} =\sum\limits</em>{i=x}^{y-1}E_{i→i+1}$,代回原式：</p><center>$E_{x→x+1} = 1+\dfrac{1}{k_x+1}×\sum\limits_{(x,y)∈E}\sum\limits_{i=y}^{x-1}E_{i→i+1}+\dfrac{k_x×E_{x→x+1}}{k_x+1}$</center><center>$E_{x→x+1} = 1+k_x+\sum\limits_{(x,y)∈E}\sum\limits_{i=y}^{x-1}E_{i→i+1}$</center><p>维护一下前缀和即可,$\sum\limits<em>{i=x}^{y-1}E</em>{i→i+1}$既为所求答案</p><p>时间复杂度$O(n+m)$</p><h2 id="code"><a href="#code" class="headerlink" title="$code$"></a>$code$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//xcxc82 2021/2/9/20:50 </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mo 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1000010</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> X=<span class="number">0</span>; <span class="type">bool</span> flag=<span class="number">1</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) flag=<span class="number">0</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">if</span>(flag) <span class="keyword">return</span> X;<span class="keyword">return</span> ~(X<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line"><span class="type">int</span> to,from,next;</span><br><span class="line">&#125;e[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> head[MAXN&lt;&lt;<span class="number">2</span>],cnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">e[++cnt].next = head[u];</span><br><span class="line">e[cnt].from = u;</span><br><span class="line">e[cnt].to = v;</span><br><span class="line">head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> id,n,m,out[MAXN],sum[MAXN],f[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    id = <span class="built_in">read</span>(),n =<span class="built_in">read</span>(),m = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="type">int</span> u = <span class="built_in">read</span>(),v =<span class="built_in">read</span>();</span><br><span class="line"><span class="built_in">add</span>(u,v);</span><br><span class="line">out[u]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">1</span>;u&lt;=n;u++)&#123;</span><br><span class="line">f[u] = <span class="number">1</span>+out[u];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = e[i].to;</span><br><span class="line">f[u] = (f[u]+(sum[u<span class="number">-1</span>]-sum[v<span class="number">-1</span>]+mo)%mo)%mo;</span><br><span class="line">&#125;</span><br><span class="line">sum[u] = (sum[u<span class="number">-1</span>]+f[u])%mo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,sum[n]);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>OI时期的最后一篇博客</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P4046 [JSOI2010]快递服务</title>
      <link href="/2021/01/24/p4046/"/>
      <url>/2021/01/24/p4046/</url>
      
        <content type="html"><![CDATA[<p><strong><a href="https://www.luogu.com.cn/problem/P4046">题目链接</a> <a href="https://www.luogu.com.cn/problem/SP703">双倍经验</a></strong></p><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有$m$个位置,从位置$p$移动到位置$q$需要花费$c(p,q)$的价钱,但并不保证$c(p,q)≠c(q,p)$</p><p>现在有三个员工,初始位置在$1,2,3$和有$n$个请求，任何时刻只有一名员工可以移动，且不允许同一位置上有 $2$ 个以上员工。第 $i$ 个请求发生在位置 $p_i$,公司必须按照顺序,派一名员工到位置 $p_i$去完成请求</p><p>求公司的最小花费。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>设$f(i,x,y,z)$表示解决完前$i$个请求时,三个员工分别在$x,y,z$处时的最小花费,转移:</p><p>$f(i+1,p<em>{i+1},y,z) = min{f(i,x,y,z)+c(x,p</em>{i+1})}\qquad (p_{i+1}≠y≠z)$</p><p>$f(i+1,x,p<em>{i+1},z) = min{f(i,x,y,z)+c(y,p</em>{i+1})}\qquad (x≠p_{i+1}≠z)$</p><p>$f(i+1,x,y,p<em>{i+1}) = min{f(i,x,y,z)+c(z,p</em>{i+1})}\qquad (x≠y≠p_{i+1})$</p><p>时空复杂度$O(nm^3)$,无论是在时间上还是空间上都接受不了</p><p>考虑优化:</p><p>可以发现,在完成第$i$个任务时,一定有一个人站在$p_i$的位置上,也就是说,这个人的信息是”多余”的,只需要记录另外两个人的位置</p><p>设$f(i,x,y)$表示解决前$i$个请求时,三个员工分别在$x,y,p_i$时的最小花费,转移:</p><p>$f(i+1,p<em>i,y) = min{f(i,x,y)+c(x,p</em>{i+1})}\qquad (p<em>i≠y≠p</em>{i+1})$</p><p>$f(i+1,x,y) = min{f(i,x,y)+c(p<em>i,p</em>{i+1})}\qquad (x≠y≠p_{i+1})$</p><p>$f(i+1,x,p<em>i) = min{f(i,x,y)+c(y,p</em>{i+1})}\qquad (x≠p<em>i≠p</em>{i+1})$</p><p>时间复杂度$O(nm^2)$,再用滚动数组优化一下空间即可</p><h2 id="code"><a href="#code" class="headerlink" title="$code$"></a>$code$</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">xcxc82</span><br><span class="line">*/</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define inf 1e9+10</span><br><span class="line">const int MAXN = 210;</span><br><span class="line">int T,L,n;</span><br><span class="line">inline int read()&#123;</span><br><span class="line">int X=0; bool flag=1; char ch=getchar();</span><br><span class="line">while(ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;) &#123;if(ch==&#x27;-&#x27;) flag=0; ch=getchar();&#125;</span><br><span class="line">while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) &#123;X=(X&lt;&lt;1)+(X&lt;&lt;3)+ch-&#x27;0&#x27;; ch=getchar();&#125;</span><br><span class="line">if(flag) return X;return ~(X-1);</span><br><span class="line">&#125;</span><br><span class="line">int f[2][MAXN][MAXN];</span><br><span class="line">int val[MAXN][MAXN],a[MAXN*5];</span><br><span class="line">int main()&#123;</span><br><span class="line">memset(f,0x3f,sizeof(f));</span><br><span class="line">L = read();</span><br><span class="line">for(int i=1;i&lt;=L;i++)&#123;</span><br><span class="line">for(int j=1;j&lt;=L;j++)&#123;</span><br><span class="line">val[i][j] = read();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    a[0] = 3;</span><br><span class="line">f[0][1][2] = 0;</span><br><span class="line">int now;</span><br><span class="line">while(cin&gt;&gt;now) a[++n] = now;</span><br><span class="line">for(int i=0;i&lt;=n-1;i++)&#123;</span><br><span class="line">memset(f[i+1&amp;1],0x3f,sizeof(f[i+1&amp;1]));</span><br><span class="line">for(int x=1;x&lt;=L;x++)&#123;</span><br><span class="line">for(int y=1;y&lt;=L;y++)&#123;</span><br><span class="line">if(x==y||x==a[i]||y==a[i]) continue;</span><br><span class="line">f[i+1&amp;1][a[i]][y] = min(f[i+1&amp;1][a[i]][y],f[i&amp;1][x][y]+val[x][a[i+1]]);</span><br><span class="line">f[i+1&amp;1][x][y] = min(f[i+1&amp;1][x][y],f[i&amp;1][x][y]+val[a[i]][a[i+1]]);</span><br><span class="line">f[i+1&amp;1][x][a[i]] = min(f[i+1&amp;1][x][a[i]],f[i&amp;1][x][y]+val[y][a[i+1]]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int ans = 0x3f3f3f3f;</span><br><span class="line"></span><br><span class="line">for(int i=1;i&lt;=L;i++) </span><br><span class="line"> for(int j=1;j&lt;=L;j++) </span><br><span class="line">  ans = min(ans,f[n&amp;1][i][j]);</span><br><span class="line">  </span><br><span class="line">printf(&quot;%d&quot;,ans);</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P5774 [JSOI2016]病毒感染</title>
      <link href="/2021/01/19/p5774/"/>
      <url>/2021/01/19/p5774/</url>
      
        <content type="html"><![CDATA[<p><strong><a href="https://www.luogu.com.cn/problem/P5774">题目链接</a></strong></p><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有$N$个小镇爆发了疫情,其中第$i$个小镇每天会死$a_i$个人,现在从第一个小镇出发,每一天可以选择:</p><ul><li><p>走向一个相邻的村庄,若往左走,则必须把之前所有未治愈村庄全部治愈</p></li><li><p>治疗目前所在的村庄,这一天内该村庄内不会有任何人死去</p></li></ul><p>求最少死亡人数</p><p>$n≤3000,a_i≤10^9$</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>可以发现,每个村庄只可能在第一次被经过或第二次被经过时治愈被治愈,换句话说,<strong>在区间$[l,r]$进行一次往返走$(l \Rightarrow r \Rightarrow l \Rightarrow r)$可以治愈该区间内的所有村庄</strong>,并且总过程就是由一连串的”往返走”组成的</p><p>不妨先设$f(i)$表示治疗前$i$个村庄的最少死亡人数,$v(i,j)$表示在区间$[l,r]$进行一次往返走后该区间的最少死亡人数,转移也比较好推,就是细节比较多:</p><center>$f(i) = min \{f(j)+(4×(i-j)+2)×\sum\limits_{x=i+1}^n+v(i+1,j)\}(0≤j＜i)$</center><p>显然这个$v(i,j)$也是可以用$DP$预处理出来的,分类讨论治愈的时间,有转移:</p><center> $v(i,j) = v(i+1,j)+ \begin{cases}2×\sum\limits_{x=i+1}^ja_x\\3×(j-i)×a_i+\sum\limits_{x=i+1}^ja_x\end{cases}$ </center><p>时间复杂度$O(n^2)$</p><h2 id="code"><a href="#code" class="headerlink" title="$code$"></a>$code$</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//xcxc82 2021/1/19/22:03</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define int long long</span><br><span class="line">const int MAXN = 3010;</span><br><span class="line">inline int read()&#123;</span><br><span class="line">int X=0; bool flag=1; char ch=getchar();</span><br><span class="line">while(ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;) &#123;if(ch==&#x27;-&#x27;) flag=0; ch=getchar();&#125;</span><br><span class="line">while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) &#123;X=(X&lt;&lt;1)+(X&lt;&lt;3)+ch-&#x27;0&#x27;; ch=getchar();&#125;</span><br><span class="line">if(flag) return X;return ~(X-1);</span><br><span class="line">&#125;</span><br><span class="line">int n,a[MAXN];</span><br><span class="line">int v[MAXN][MAXN],sum[MAXN]; </span><br><span class="line">int f[MAXN];</span><br><span class="line">signed main()&#123;</span><br><span class="line">   n =read();</span><br><span class="line">   for(int i=1;i&lt;=n;i++) a[i] = read(),sum[i] = sum[i-1]+a[i];</span><br><span class="line">   memset(f,0x3f,sizeof(f));</span><br><span class="line">   memset(v,0x3f,sizeof(v));</span><br><span class="line">   f[0]=0;</span><br><span class="line">   for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">v[i][i] = 0;</span><br><span class="line">&#125;</span><br><span class="line">for(int len=1;len&lt;=n-1;len++)&#123;</span><br><span class="line"> for(int i=1;i+len&lt;=n;i++)&#123;</span><br><span class="line">int j=i+len;</span><br><span class="line">v[i][j] = v[i+1][j]+min(2*(sum[j]-sum[i]),a[i]*3*len+sum[j]-sum[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">for(int j=0;j&lt;i;j++)&#123;</span><br><span class="line">f[i] = min(f[j]+v[j+1][i]+(4*(i-j)-2)*(sum[n]-sum[i]),f[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%lld&quot;,f[n]);</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P2577 [ZJOI2004]午餐</title>
      <link href="/2021/01/16/p2577/"/>
      <url>/2021/01/16/p2577/</url>
      
        <content type="html"><![CDATA[<p><strong><a href="https://www.luogu.com.cn/problem/P2577">题目链接</a></strong></p><p>重构于$2020/1/16$</p><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有$n$个人去排队吃饭,每个人都有一个吃饭时间$a_i$和打饭时间$b_i$,一共有两个打饭窗口,要求安排一种分队和排队方案使得所有人都吃完饭的时间尽量早,输出最佳方案下所有人吃完饭的时刻</p><p>$n,a_i,b_i≤200$</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>猜个结论,<strong>吃饭吃的越慢的人排在越前面</strong>,用邻项交换法易证。这样每个人的吃饭顺序就是固定的了</p><p>先来考虑只有一个窗口的情况,不难发现总时间是由<strong>最后一个吃完饭的人的吃饭时间</strong>和<strong>他前面的总排队时间</strong>组成的,设$sum_i$表示前$i$个人打饭的时间,那么全部都吃完饭的时间为$max{sum_i+b_i}$</p><p>再回来看两个窗口时的情况,受只有一个窗口的情况的启发,一个比较好想到的状态是设$f(i,j,k)$表示在前$i$个人中,在$1$窗口排队的总时间为$j$,在$2$窗口排队的总时间为$k$的最早吃完时间,转移显然:</p><p>$f(i,j,k) = min\begin{cases}max{f(i-1,j-a_i,k),j+b_i}&amp;j≥a_i\max{f(i-1,j,k-a_i),k+b_i}&amp;k≥a_i\end{cases}(j+k = sum_i)$</p><p>时间复杂度$O(n×max{t}^2)$,得分$50pts$</p><p>发现<strong>在窗口$2$排队的时间为在窗口$1$排队的时间的补集</strong>,可以直接用总时间减去在窗口$1$排队的时间得出,因此$k$维度可以去掉</p><p>设$f(i,j)$表示在前$i$个人中,在$1$窗口排队的总时间为$j$时的最早吃完时间,转移:</p><p>$f(i,j) = min\begin{cases}max{f(i-1,j-a_i),j+b_i}&amp;j≥a_i\max{f(i-1,j),sum_i-j+b_i}\end{cases}$</p><p>时间复杂度$O(n×max{t})$</p><h2 id="code"><a href="#code" class="headerlink" title="$code$"></a>$code$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">210</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> f[MAXN][MAXN*MAXN];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span>&#123;</span><br><span class="line"><span class="type">int</span> wait,eat;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt;(person k) <span class="type">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> eat&gt;k.eat;</span><br><span class="line">&#125;</span><br><span class="line">&#125;d[MAXN];</span><br><span class="line"><span class="type">int</span> sum[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">cin&gt;&gt;d[i].wait&gt;&gt;d[i].eat;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(d+<span class="number">1</span>,d+<span class="number">1</span>+n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">sum[i] = sum[i<span class="number">-1</span>] + d[i].wait;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=sum[i];j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(j&gt;=d[i].wait) f[i][j] = <span class="built_in">min</span>(f[i][j],<span class="built_in">max</span>(f[i<span class="number">-1</span>][j-d[i].wait],j+d[i].eat));</span><br><span class="line">f[i][j] = <span class="built_in">min</span>(f[i][j],<span class="built_in">max</span>(f[i<span class="number">-1</span>][j],sum[i]-j+d[i].eat));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">1145141919</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=sum[n];i++)&#123;</span><br><span class="line">ans = <span class="built_in">min</span>(ans , f[n][i]);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing277. 饼干</title>
      <link href="/2021/01/15/acwing277/"/>
      <url>/2021/01/15/acwing277/</url>
      
        <content type="html"><![CDATA[<p><strong><a href="https://www.acwing.com/problem/content/279/">题目链接</a></strong></p><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有$m$块饼干,$n$个人,每个人都有一个贪婪度,第$i$个人的贪婪度为$g_i$,如果有$a_i$个人拿到的饼干数比第$i$个人多,那么他就会产生$g_i×a_i$的怨气,求一种排列方式,使得每个人至少分到一块饼干且怨气和最小</p><p>$n≤30,n≤m≤5000$</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>发现这个贡献计算是有后效性的,不太好搞</p><p>先来尝试猜个结论:<strong>越贪的人吃越多的饼干</strong>,用邻项交换易证。这样每个人分到的饼干数就是单调不上升的了</p><p>也就是说,<strong>要计算第$i$个人的贡献,我们只需要知道第$i$个人前面有几个人和他分到的饼干数相等</strong>，一个比较NAIVE的想法是设$f(i,j,k)$表示在前$i$个人中,一共分了$j$块饼干,第$i$个人分到$k$块时的最小怨气值和</p><p>转移也比较显然,枚举前面有几个人和他分到的饼干数相等:</p><p>$f(i,j,k) = min\begin{cases}min(f(i-1,j-k,p)+g<em>i×(i-1))&amp;{j-k≥p×(i-1),p&gt;k})\min(f(i-p,j-p×k,k)+\sum</em>{b=i-p+1}^ig_b×(i-p-1))&amp;{j-p×k≥(i-p-1)×k}\end{cases}$</p><p>时间复杂度$O(nm^3)$</p><p><del>数据似乎比较水(,可以拿个80pts左右的样子</del></p><p>现在来考虑优化</p><p>可以发现,我们<strong>只关心每个人分到的饼干数之间的相对大小</strong>,而不关心其具体数值,因此我们可以尝试去把前面那个状态的$k$维度去掉</p><p>设$f(i,j)$表示在前$i$个人中共分了$j$块饼干的最小怨气值和</p><p>如果第$i$个人分到的饼干数不为$1$,<strong>前$i$个人共分到$j$块饼干等价于每人少分一块饼干,既$f(i,j-i)$</strong>,因为每个人拿到的饼干数之间的相对大小没有变,总贡献也不会变</p><p>如果第$i$个人分到的饼干数为$1$,那么就可以枚举他前面有多少个人分到的饼干数也为$1$</p><p>转移方程$:$</p><center>$f(i,j) = min\begin{cases}f(i,j-i)&{j≥i}\\min(f(k,j-(i-k))+\sum_{x=k+1}^ig_i×k)&{j≥i-k}\end{cases}$</center><h2 id="code"><a href="#code" class="headerlink" title="$code$"></a>$code$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//xcxc82</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">80pts</span></span><br><span class="line"><span class="comment">memset(f,0x3f,sizeof(f));</span></span><br><span class="line"><span class="comment">memset(f[1],0,sizeof(f[1]));</span></span><br><span class="line"><span class="comment">  for(int i=2;i&lt;=n;i++)&#123;</span></span><br><span class="line"><span class="comment">    for(int j=1;j&lt;=m;j++)&#123;</span></span><br><span class="line"><span class="comment">      for(int k=1;k&lt;j;k++)&#123;</span></span><br><span class="line"><span class="comment">    for(int p=k+1;p&lt;=j;p++)&#123;</span></span><br><span class="line"><span class="comment">    if(j-k&lt;p*(i-1)||j&lt;k) continue;</span></span><br><span class="line"><span class="comment">    f[i][j][k] = min(f[i][j][k],f[i-1][j-k][p]+g[i]*(i-1));</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">for(int p=1;p&lt;=i-1;p++)&#123;//注意要特判p=i-1,j-p×k!=k的情况</span></span><br><span class="line"><span class="comment">if(j-p*k&lt;(i-p-1)*k||j&lt;p*k||(p==i-1&amp;&amp;j-p*k!=k)) continue;</span></span><br><span class="line"><span class="comment"> f[i][j][k] = min(f[i][j][k],f[i-p][j-p*k][k]+(i-p-1)*(sum[i]-sum[i-p]));</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">5010</span>;</span><br><span class="line"><span class="type">int</span> sum[MAXN],n,m,f[MAXN/<span class="number">100</span>][MAXN];</span><br><span class="line"><span class="type">int</span> l1[MAXN/<span class="number">100</span>][MAXN],l2[MAXN/<span class="number">100</span>][MAXN],ans[MAXN/<span class="number">100</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cookie</span>&#123;</span><br><span class="line"><span class="type">int</span> g,ind;</span><br><span class="line">&#125;a[MAXN];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(cookie x,cookie y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x.g&gt;y.g;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SUM</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sum[j] - sum[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> X=<span class="number">0</span>; <span class="type">bool</span> flag=<span class="number">1</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) flag=<span class="number">0</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">if</span>(flag) <span class="keyword">return</span> X;<span class="keyword">return</span> ~(X<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">print</span>(l1[i][j],l2[i][j]);</span><br><span class="line"><span class="keyword">if</span>(i==l1[i][j])&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>;x&lt;=i;x++) ans[a[x].ind]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">for</span>(<span class="type">int</span> x=l1[i][j]+<span class="number">1</span>;x&lt;=i;x++) ans[a[x].ind] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n = <span class="built_in">read</span>(),m = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i].g = <span class="built_in">read</span>(),a[i].ind = i;</span><br><span class="line"><span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>,cmp); </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) sum[i] = sum[i<span class="number">-1</span>]+a[i].g;</span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=m;j++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;i;k++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[k][j-(i-k)]+k*<span class="built_in">SUM</span>(k+<span class="number">1</span>,i)&lt;f[i][j])&#123;</span><br><span class="line">    f[i][j] = f[k][j-(i-k)]+k*<span class="built_in">SUM</span>(k+<span class="number">1</span>,i);</span><br><span class="line">    l1[i][j] = k,l2[i][j] = j-(i-k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(f[i][j-i]&lt;f[i][j])&#123;</span><br><span class="line">f[i][j] = f[i][j-i];</span><br><span class="line">l1[i][j] = i,l2[i][j] = j-i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[n][m]);</span><br><span class="line"><span class="built_in">print</span>(n,m);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,ans[i]);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOIP2020 字符串匹配</title>
      <link href="/2021/01/08/noip2020-2/"/>
      <url>/2021/01/08/noip2020-2/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P7114">题目链接</a></p><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给一个字符串$S$,求$S=(AB)^iC$的方案数,其中$F(A)≤F(C)$,$F(S)$表示字符串 $S$ 中出现奇数次的字符的数量</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>设$cnt_i$表示奇数字符数小于等于$i$的$A$的个数</p><p>枚举$AB$的长度,然后用$KMP$的$next$数组去枚举循环次数$i$,将小于等于$C$中奇数字符的数量的$A$的方案数,也就是$cnt_{j}$($j$为$C$中出现奇数次字符从数量)加到答案中,并更新一下$cnt$</p><p>最坏时间复杂度$O(n×(logn+26))$,不开$O2$ $92$~$96$pts,开$O2$稳过</p><h2 id="code"><a href="#code" class="headerlink" title="$code$"></a>$code$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">xcxc82</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = (<span class="number">1</span>&lt;&lt;<span class="number">20</span>)+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> X=<span class="number">0</span>; <span class="type">bool</span> flag=<span class="number">1</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) flag=<span class="number">0</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">if</span>(flag) <span class="keyword">return</span> X;<span class="keyword">return</span> ~(X<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> pre[MAXN],suf[MAXN],next[MAXN],pre_value[<span class="number">30</span>];</span><br><span class="line"><span class="type">int</span> buc[<span class="number">30</span>];</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">30</span>];</span><br><span class="line"><span class="type">int</span> T,n;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans;</span><br><span class="line">string s;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line"><span class="built_in">memset</span>(pre,<span class="number">0</span>,<span class="built_in">sizeof</span>(pre));</span><br><span class="line"><span class="built_in">memset</span>(suf,<span class="number">0</span>,<span class="built_in">sizeof</span>(suf));</span><br><span class="line"><span class="built_in">memset</span>(next,<span class="number">0</span>,<span class="built_in">sizeof</span>(next));</span><br><span class="line"><span class="built_in">memset</span>(buc,<span class="number">0</span>,<span class="built_in">sizeof</span>(buc));</span><br><span class="line"><span class="built_in">memset</span>(pre_value,<span class="number">0</span>,<span class="built_in">sizeof</span>(pre_value));</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kmp</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;s[i]!=s[j+<span class="number">1</span>]) j = next[j];</span><br><span class="line"><span class="keyword">if</span>(s[i]==s[j+<span class="number">1</span>]) j++;</span><br><span class="line">next[i] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">T = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">clear</span>();</span><br><span class="line">cin&gt;&gt;s;</span><br><span class="line">s = <span class="string">&#x27; &#x27;</span>+s;</span><br><span class="line">n = s.<span class="built_in">length</span>()<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!vis[s[i]-<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>]) vis[s[i]-<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>] = <span class="number">1</span>,cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">kmp</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="type">int</span> now = s[i]-<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>;</span><br><span class="line">buc[now]++;</span><br><span class="line"><span class="keyword">if</span>(buc[now]&amp;<span class="number">1</span>) pre[i] = pre[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> pre[i] = pre[i<span class="number">-1</span>]<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(buc,<span class="number">0</span>,<span class="built_in">sizeof</span>(buc));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line"><span class="type">int</span> now = s[i]-<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>;</span><br><span class="line">buc[now]++;</span><br><span class="line"><span class="keyword">if</span>(buc[now]&amp;<span class="number">1</span>) suf[i] = suf[i+<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> suf[i] = suf[i+<span class="number">1</span>]<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i&gt;<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;n;j+=i)&#123;</span><br><span class="line"><span class="keyword">if</span>((i%(j-next[j])==<span class="number">0</span>&amp;&amp;j/(j-next[j])&gt;<span class="number">1</span>)||(j==i))</span><br><span class="line">ans+=(<span class="type">long</span> <span class="type">long</span>)(pre_value[suf[j+<span class="number">1</span>]]);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=pre[i];j&lt;=cnt;j++)&#123;</span><br><span class="line">pre_value[j]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>USACO05DEC Cleaning Shifts S</title>
      <link href="/2021/01/01/usaco05dec/"/>
      <url>/2021/01/01/usaco05dec/</url>
      
        <content type="html"><![CDATA[<h2 id="P4644-USACO05DEC-Cleaning-Shifts-S"><a href="#P4644-USACO05DEC-Cleaning-Shifts-S" class="headerlink" title="P4644 [USACO05DEC]Cleaning Shifts S"></a>P4644 [USACO05DEC]Cleaning Shifts S</h2><h3 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h3><p>有$n$条贴纸,第$i$条贴纸可以将第$a_i$到$b_i$段覆盖,售价为$c_i$,现在要用若干条贴纸覆盖纸带上第$L$~$R$个格子,求至少要花费多少钱</p><p>$1≤n≤25000,1≤L≤R≤10^6$</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>设$f(i)$表示覆盖$L~i$区间所需要的最少花费,将贴纸按右端点升序排序,有显然的转移:<center>$f(b(i)) = min(f(j))+c(i))~~~~~~~~~{a(i)-1≤j≤b(i)}$</center></p><p>再用线段树来维护一下$min(f(j))$即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//xcxc82 2021/7/30</span></span><br><span class="line"><span class="comment">//f[b[i]] = min(f[j])+c(a[i]-1&lt;=j&lt;b[i])</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson (node&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson (node&lt;&lt;1|1)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> X=<span class="number">0</span>; <span class="type">bool</span> flag=<span class="number">1</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) flag=<span class="number">0</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">if</span>(flag) <span class="keyword">return</span> X;<span class="keyword">return</span> ~(X<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> f[MAXN];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st</span>&#123;</span><br><span class="line"><span class="type">int</span> min;</span><br><span class="line">&#125;tree[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;</span><br><span class="line">tree[node].min = <span class="built_in">min</span>(tree[lson].min,tree[rson].min);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">tree[node].min = f[l];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">build</span>(lson,l,mid);</span><br><span class="line"><span class="built_in">build</span>(rson,mid+<span class="number">1</span>,r);</span><br><span class="line"><span class="built_in">pushup</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(x&lt;=l&amp;&amp;y&gt;=r)&#123;</span><br><span class="line"><span class="keyword">return</span> tree[node].min;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans = inf;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=mid) ans = <span class="built_in">min</span>(ans,<span class="built_in">query</span>(lson,l,mid,x,y));</span><br><span class="line"><span class="keyword">if</span>(y&gt;mid) ans = <span class="built_in">min</span>(ans,<span class="built_in">query</span>(rson,mid+<span class="number">1</span>,r,x,y));</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">tree[node].min = v;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=mid) <span class="built_in">modify</span>(lson,l,mid,x,v);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">modify</span>(rson,mid+<span class="number">1</span>,r,x,v);</span><br><span class="line"><span class="built_in">pushup</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> l,r,n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">v</span>&#123;</span><br><span class="line"><span class="type">int</span> l,r,v;</span><br><span class="line">&#125;val[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">S</span><span class="params">(<span class="type">const</span> v &amp;x, <span class="type">const</span> v &amp;y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x.r &lt; y.r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">n = <span class="built_in">read</span>(),l = <span class="built_in">read</span>(),r = <span class="built_in">read</span>();</span><br><span class="line">l++,r++;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">val[i].l = <span class="built_in">read</span>(),val[i].r = <span class="built_in">read</span>(),val[i].v = <span class="built_in">read</span>();</span><br><span class="line">val[i].l++,val[i].r++;</span><br><span class="line"><span class="keyword">if</span>(val[i].l&lt;l) val[i].l = l;</span><br><span class="line"><span class="keyword">if</span>(val[i].r&gt;r) val[i].r = r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(val+<span class="number">1</span>,val+<span class="number">1</span>+n,S);</span><br><span class="line">f[l<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> ans = inf;</span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>,l<span class="number">-1</span>,r);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(val[i].l&gt;val[i].r) <span class="keyword">continue</span>;</span><br><span class="line">f[val[i].r] = <span class="built_in">min</span>(f[val[i].r],<span class="built_in">query</span>(<span class="number">1</span>,l<span class="number">-1</span>,r,val[i].l<span class="number">-1</span>,val[i].r)+val[i].v);</span><br><span class="line"><span class="keyword">if</span>(val[i].r&gt;=r)&#123;</span><br><span class="line">ans = <span class="built_in">min</span>(ans,f[val[i].r]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">modify</span>(<span class="number">1</span>,l<span class="number">-1</span>,r,val[i].r,f[val[i].r]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ans==inf) cout&lt;&lt;<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;ans;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P7076 [CSP-S2020] 动物园</title>
      <link href="/2020/12/27/p7076/"/>
      <url>/2020/12/27/p7076/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a><a href="https://www.luogu.com.cn/problem/P7076">题目链接</a></h3><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>显然,只有在动物不需要购买一种饲料且该种饲料有要求时才不合法</p><p>注意要特判$n = 0,x = 64$的情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">xcxc82</span><br><span class="line">*/</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define lson node&lt;&lt;1</span><br><span class="line">#define rson node&lt;&lt;1|1</span><br><span class="line">#define int unsigned long long</span><br><span class="line">const int MAXN = 10010;</span><br><span class="line">int k,c,n,m;</span><br><span class="line">inline int read()&#123;</span><br><span class="line">int X=0; bool flag=1; char ch=getchar();</span><br><span class="line">while(ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;) &#123;if(ch==&#x27;-&#x27;) flag=0; ch=getchar();&#125;</span><br><span class="line">while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) &#123;X=(X&lt;&lt;1)+(X&lt;&lt;3)+ch-&#x27;0&#x27;; ch=getchar();&#125;</span><br><span class="line">if(flag) return X;return ~(X-1);</span><br><span class="line">&#125;</span><br><span class="line">int status,buy;</span><br><span class="line">signed main()&#123;</span><br><span class="line">n = read(),m = read(),c = read(),k = read();</span><br><span class="line"></span><br><span class="line">for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">int am = read();</span><br><span class="line">status|=am;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">int p =  read(),q = read();</span><br><span class="line">buy|=(1ull&lt;&lt;p);</span><br><span class="line">&#125;</span><br><span class="line">int x = 0;</span><br><span class="line">for(int i=0;i&lt;=k-1;i++)&#123;</span><br><span class="line">int s = (status&gt;&gt;i)&amp;1,b = (buy&gt;&gt;i)&amp;1;</span><br><span class="line">if((!s&amp;&amp;!b)||(s|b&amp;&amp;s)) x++; </span><br><span class="line">&#125;</span><br><span class="line">if(x==64&amp;&amp;n==0)&#123;</span><br><span class="line">cout&lt;&lt;&quot;18446744073709551616&quot;;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;(1ull&lt;&lt;x)-n;</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SP1557 GSS2 - Can you answer these queries II</title>
      <link href="/2020/12/11/sp1557/"/>
      <url>/2020/12/11/sp1557/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/SP1557">题目链接</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出长度为$n$的序列$a_i$，$q$ 次询问，求最大子段和，相同的数只算一次</p><p>$1 ≤ n,q≤ 100000$</p><p>$-100000≤a_i≤100000$</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>没有修改操作,考虑离线处理</p><p>正序扫描序列加入每个元素,并在线段树中的每个叶子节点$i$维护区间$[i,j]$去掉重复元素后的区间和($j$为目前扫描到的位置)</p><h3 id="如何去重"><a href="#如何去重" class="headerlink" title="如何去重"></a>如何去重</h3><p>定义$pre[i]$表示$i$上一次出现的位置</p><p>如果一个元素$a_i$在$pre[a_i]$的位置出现过了,那就只在区间$[pre[a_i]+1,i]$中加入它(区间加),相当于自动完成了去重</p><h3 id="如何处理询问"><a href="#如何处理询问" class="headerlink" title="如何处理询问"></a>如何处理询问</h3><p>把每个询问离线下来,按右端点排序,对于每个询问$[l,r]$,在加入$a<em>r$后查询$max(a_i+a</em>{i+1}…+a_{j-1}+a_j)$  $l≤i≤j≤r$(区间查询),既区间$[l,r]$中的<strong>历史最大值</strong></p><h3 id="如何维护历史最大值"><a href="#如何维护历史最大值" class="headerlink" title="如何维护历史最大值"></a>如何维护历史最大值</h3><p>线段树中的下放操作有较大的”时间差”,直接和当前值取max肯定不行</p><p>于是我们在线段树中维护四个值：最大去重和, 历史最大去重和, 历史最大标记, 目前标记</p><p>下放一个节点时,用该节点的历史最大标记去更新子节点的历史最大去重和和历史最大标记即可</p><h2 id="code"><a href="#code" class="headerlink" title="$code$"></a>$code$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson node&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson node&lt;&lt;1|1</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100010</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> X=<span class="number">0</span>; <span class="type">bool</span> flag=<span class="number">1</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) flag=<span class="number">0</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">if</span>(flag) <span class="keyword">return</span> X;</span><br><span class="line"><span class="keyword">return</span> ~(X<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,a[MAXN],pre[<span class="number">20</span>*MAXN],ans[MAXN];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">query</span>&#123;</span><br><span class="line"><span class="type">int</span> l,r,id;</span><br><span class="line">&#125;q[MAXN];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(query a,query b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.r&lt;b.r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st</span>&#123;</span><br><span class="line"><span class="type">int</span> max,hismax;</span><br><span class="line"><span class="type">int</span> tag,histag;</span><br><span class="line">&#125;tree[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;</span><br><span class="line">tree[node].max = <span class="built_in">max</span>(tree[lson].max,tree[rson].max);</span><br><span class="line">tree[node].hismax = <span class="built_in">max</span>(tree[lson].hismax,tree[rson].hismax);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">tree[node].hismax = <span class="built_in">max</span>(tree[node].hismax,tree[fa].histag+tree[node].max);<span class="comment">//更新历史最大值和历史最大tag</span></span><br><span class="line">tree[node].histag = <span class="built_in">max</span>(tree[node].histag,tree[fa].histag+tree[node].tag);</span><br><span class="line">tree[node].max+=tree[fa].tag;</span><br><span class="line">tree[node].tag+=tree[fa].tag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PUSHDOWN</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!tree[node].tag) <span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">pushdown</span>(lson,node);</span><br><span class="line"><span class="built_in">pushdown</span>(rson,node);</span><br><span class="line">tree[node].histag = tree[node].tag = <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=l&amp;&amp;y&gt;=r)&#123;</span><br><span class="line">tree[node].max+=val,tree[node].tag+=val;</span><br><span class="line">tree[node].hismax = <span class="built_in">max</span>(tree[node].hismax,tree[node].max);</span><br><span class="line">tree[node].histag = <span class="built_in">max</span>(tree[node].histag,tree[node].tag);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">PUSHDOWN</span>(node);</span><br><span class="line"><span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=mid) <span class="built_in">modify</span>(lson,l,mid,x,y,val);</span><br><span class="line"><span class="keyword">if</span>(y&gt;mid) <span class="built_in">modify</span>(rson,mid+<span class="number">1</span>,r,x,y,val);</span><br><span class="line"><span class="built_in">pushup</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=l&amp;&amp;y&gt;=r)&#123;</span><br><span class="line"><span class="keyword">return</span> tree[node].hismax;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">PUSHDOWN</span>(node);</span><br><span class="line"><span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(y&lt;=mid) <span class="keyword">return</span> <span class="built_in">query</span>(lson,l,mid,x,y);</span><br><span class="line"><span class="keyword">if</span>(x&gt;mid) <span class="keyword">return</span> <span class="built_in">query</span>(rson,mid+<span class="number">1</span>,r,x,y);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">query</span>(lson,l,mid,x,y),<span class="built_in">query</span>(rson,mid+<span class="number">1</span>,r,x,y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i] = <span class="built_in">read</span>();</span><br><span class="line">m = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">    q[i].l = <span class="built_in">read</span>(),q[i].r = <span class="built_in">read</span>();</span><br><span class="line">    q[i].id = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(q+<span class="number">1</span>,q+<span class="number">1</span>+m,cmp);</span><br><span class="line"><span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,pre[a[i]+<span class="number">100000</span>]+<span class="number">1</span>,i,a[i]);</span><br><span class="line">pre[a[i]+<span class="number">100000</span>] = i;</span><br><span class="line"><span class="keyword">while</span>(i==q[j].r&amp;&amp;j&lt;=m) ans[q[j].id] = <span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,q[j].l,q[j].r),j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans[i]);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P4556 [Vani有约会]雨天的尾巴 /【模板】线段树合并</title>
      <link href="/2020/11/22/p4556/"/>
      <url>/2020/11/22/p4556/</url>
      
        <content type="html"><![CDATA[<h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给一颗$n$个节点的树,现在有$m$次操作,每次选择两个节点$u$,$v$,对$u$到$v$的路径上的每个节点都发放一袋$z$类型的物品</p><p>求所有操作完成后,每个点存放最多的是哪种物品</p><p>$n,m≤10^5,z≤10^9$</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>线段树合并模板题</p><p>差分+离散化一下</p><p>每次操作时将$u$和$v$的权值线段树中的$z$位置$+1$,$lca(u,v)$和$fa_{lca(u,v)}$中的$z$位置$-1$,所有操作完成后再$dfs$一遍合并子树</p><p>复杂度$(n+m)log(n+m)$</p><h2 id="code"><a href="#code" class="headerlink" title="$code$"></a>$code$</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN = 100010;</span><br><span class="line">int n,m;</span><br><span class="line">int f[MAXN][21],dep[MAXN];</span><br><span class="line"></span><br><span class="line">inline int read()&#123;</span><br><span class="line">int X=0; bool flag=1; char ch=getchar();</span><br><span class="line">while(ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;) &#123;if(ch==&#x27;-&#x27;) flag=0; ch=getchar();&#125;</span><br><span class="line">while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) &#123;X=(X&lt;&lt;1)+(X&lt;&lt;3)+ch-&#x27;0&#x27;; ch=getchar();&#125;</span><br><span class="line">if(flag) return X;</span><br><span class="line">return ~(X-1);</span><br><span class="line">&#125;</span><br><span class="line">struct st&#123;</span><br><span class="line">int lson,rson,val,pos;</span><br><span class="line">&#125;tree[MAXN*100];</span><br><span class="line">int tot,root[MAXN];</span><br><span class="line">struct e&#123;</span><br><span class="line">int v,next;</span><br><span class="line">&#125;edge[MAXN&lt;&lt;1];</span><br><span class="line">int head[MAXN&lt;&lt;1],cnt;</span><br><span class="line">void add(int u,int v)&#123;</span><br><span class="line">edge[++cnt].v = v;</span><br><span class="line">edge[cnt].next = head[u];</span><br><span class="line">head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line">struct Lca&#123;</span><br><span class="line">void dfs(int u,int fa)&#123;</span><br><span class="line">dep[u] = dep[fa]+1;</span><br><span class="line">f[u][0] = fa;</span><br><span class="line">for(int i=1;(1&lt;&lt;i)&lt;=dep[u];i++)&#123;</span><br><span class="line">f[u][i] = f[f[u][i-1]][i-1];</span><br><span class="line">&#125;</span><br><span class="line">for(int i=head[u];i;i=edge[i].next)&#123;</span><br><span class="line">int v = edge[i].v;</span><br><span class="line">if(v==fa) continue;</span><br><span class="line">dfs(v,u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    int lca(int u,int v)&#123;</span><br><span class="line">if(dep[u]&gt;dep[v]) swap(u,v);</span><br><span class="line">for(int i=20;i&gt;=0;i--)&#123;</span><br><span class="line">if(dep[u]&lt;=dep[v]-(1&lt;&lt;i)) v = f[v][i];</span><br><span class="line">&#125;</span><br><span class="line">if(u==v) return u;</span><br><span class="line">for(int i=20;i&gt;=0;i--)&#123;</span><br><span class="line">if(f[u][i]!=f[v][i])&#123;</span><br><span class="line">u = f[u][i];</span><br><span class="line">v = f[v][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return f[u][0];</span><br><span class="line">&#125;</span><br><span class="line">&#125;LCA;</span><br><span class="line"></span><br><span class="line">void pushup(int node)&#123;</span><br><span class="line">tree[node].val = max(tree[tree[node].lson].val,tree[tree[node].rson].val);</span><br><span class="line">tree[node].pos = tree[tree[node].lson].val&gt;=tree[tree[node].rson].val?tree[tree[node].lson].pos:tree[tree[node].rson].pos;</span><br><span class="line">&#125; </span><br><span class="line">void insert(int &amp;node,int l,int r,int pos,int val)&#123;</span><br><span class="line">if(!node) node = ++tot;</span><br><span class="line">if(l==r)&#123;</span><br><span class="line">tree[node].val += val;</span><br><span class="line">tree[node].pos = l;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">int mid = (l+r)&gt;&gt;1;</span><br><span class="line">if(pos&lt;=mid) insert(tree[node].lson,l,mid,pos,val);</span><br><span class="line">else if(pos&gt;mid)insert(tree[node].rson,mid+1,r,pos,val);</span><br><span class="line">pushup(node);</span><br><span class="line">&#125;</span><br><span class="line">int merge(int a,int b,int l,int r)&#123;</span><br><span class="line">if(!b) return a;</span><br><span class="line">if(!a) return b;</span><br><span class="line">if(l==r)&#123;</span><br><span class="line">tree[a].val+=tree[b].val;</span><br><span class="line">tree[a].pos = tree[a].val?l:0;</span><br><span class="line">return a;</span><br><span class="line">&#125;</span><br><span class="line">int mid = (l+r)&gt;&gt;1;</span><br><span class="line">tree[a].lson = merge(tree[a].lson,tree[b].lson,l,mid);</span><br><span class="line">tree[a].rson = merge(tree[a].rson,tree[b].rson,mid+1,r);</span><br><span class="line">pushup(a);</span><br><span class="line">return a; </span><br><span class="line">&#125;</span><br><span class="line">int len;</span><br><span class="line">int a[MAXN],b[MAXN],c[MAXN];</span><br><span class="line">int value[MAXN];</span><br><span class="line">int ans[MAXN];</span><br><span class="line">int getid(int x)&#123;</span><br><span class="line">return lower_bound(value+1,value+1+len,c[x]) - value;</span><br><span class="line">&#125;</span><br><span class="line">void dfs2(int u,int fa)&#123;</span><br><span class="line">for(int i=head[u];i;i=edge[i].next)&#123;</span><br><span class="line">int v = edge[i].v;</span><br><span class="line">if(v==fa) continue;</span><br><span class="line">dfs2(v,u);</span><br><span class="line">merge(root[u],root[v],1,len);</span><br><span class="line">&#125;</span><br><span class="line">ans[u] = tree[root[u]].pos;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">n = read(),m = read();</span><br><span class="line">for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">int u = read(),v = read();</span><br><span class="line">add(u,v),add(v,u);</span><br><span class="line">&#125;</span><br><span class="line">LCA.dfs(1,0);</span><br><span class="line">for(int i=1;i&lt;=n;i++) root[i] = ++tot; </span><br><span class="line">for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">a[i] =read(),b[i] = read(),c[i] = read();</span><br><span class="line">value[i] = c[i];</span><br><span class="line">&#125;</span><br><span class="line">sort(value+1,value+1+m);</span><br><span class="line">len = unique(value+1,value+1+m)-(value+1);</span><br><span class="line">for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">int x = a[i],y = b[i],z = getid(i);</span><br><span class="line">int fa = LCA.lca(x,y);</span><br><span class="line">int Fa = f[fa][0];</span><br><span class="line">insert(root[x],1,len,z,1);</span><br><span class="line">insert(root[y],1,len,z,1);</span><br><span class="line">insert(root[fa],1,len,z,-1);</span><br><span class="line">if(Fa) insert(root[Fa],1,len,z,-1);</span><br><span class="line">&#125;</span><br><span class="line">dfs2(1,0);</span><br><span class="line">for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">printf(&quot;%d\n&quot;,value[ans[i]]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P3224 [HNOI2012]永无乡</title>
      <link href="/2020/11/22/p3224/"/>
      <url>/2020/11/22/p3224/</url>
      
        <content type="html"><![CDATA[<h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给一颗$n$个节点带点权图,现在有$m$次操作,操作分为两种:</p><ul><li><p>询问当前与$u$联通的第$k$大权值是哪个</p></li><li><p>连接两个节点$u,v$</p></li></ul><p>$n,m≤10^5$</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>并查集+线段树合并</p><p>维护一个并查集,在合并两个节点$u$和$v$的时候把它们的线段树也合并起来</p><p>复杂度$(n+m)logn$</p><h2 id="code"><a href="#code" class="headerlink" title="$code$"></a>$code$</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN = 100010;</span><br><span class="line">int fa[MAXN];</span><br><span class="line">inline int read()&#123;</span><br><span class="line">int X=0; bool flag=1; char ch=getchar();</span><br><span class="line">while(ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;) &#123;if(ch==&#x27;-&#x27;) flag=0; ch=getchar();&#125;</span><br><span class="line">while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) &#123;X=(X&lt;&lt;1)+(X&lt;&lt;3)+ch-&#x27;0&#x27;; ch=getchar();&#125;</span><br><span class="line">if(flag) return X;</span><br><span class="line">return ~(X-1);</span><br><span class="line">&#125;</span><br><span class="line">struct st&#123;</span><br><span class="line">int lson,rson,val,pos;</span><br><span class="line">&#125;tree[MAXN*100];</span><br><span class="line">int tot,root[MAXN];</span><br><span class="line">int val[MAXN];</span><br><span class="line">int n,m;</span><br><span class="line">void pushup(int node)&#123;</span><br><span class="line">tree[node].val = tree[tree[node].lson].val+tree[tree[node].rson].val;</span><br><span class="line">&#125;</span><br><span class="line">void insert(int &amp;node,int l,int r,int pos,int val,int ind)&#123;</span><br><span class="line">if(!node) node = ++tot;</span><br><span class="line">if(l==r)&#123;</span><br><span class="line">tree[node].val+=val;</span><br><span class="line">tree[node].pos = ind;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">int mid = (l+r)&gt;&gt;1;</span><br><span class="line">if(pos&lt;=mid) insert(tree[node].lson,l,mid,pos,val,ind);</span><br><span class="line">else if(pos&gt;mid) insert(tree[node].rson,mid+1,r,pos,val,ind);</span><br><span class="line">pushup(node);</span><br><span class="line">&#125;</span><br><span class="line">int query(int node,int l,int r,int k)&#123;</span><br><span class="line">if(!node||tree[node].val&lt;k)&#123;</span><br><span class="line">  return -1;</span><br><span class="line">&#125; </span><br><span class="line">if(l==r)&#123;</span><br><span class="line">return tree[node].pos;</span><br><span class="line">&#125;</span><br><span class="line">int mid =(l+r)&gt;&gt;1;</span><br><span class="line">if(k&lt;=tree[tree[node].lson].val) return query(tree[node].lson,l,mid,k);</span><br><span class="line">else return query(tree[node].rson,mid+1,r,k-tree[tree[node].lson].val);</span><br><span class="line">&#125;</span><br><span class="line">int merge(int node1,int node2,int l,int r)&#123;</span><br><span class="line">if(!node1) return node2;</span><br><span class="line">if(!node2) return node1;</span><br><span class="line">if(l==r)&#123;</span><br><span class="line">if(tree[node2].pos)&#123;</span><br><span class="line">tree[node1].pos = tree[node2].pos;</span><br><span class="line">tree[node1].val += tree[node2].val;</span><br><span class="line">&#125;</span><br><span class="line">return node1;</span><br><span class="line">&#125;</span><br><span class="line">int mid =(l+r)&gt;&gt;1;</span><br><span class="line">tree[node1].lson = merge(tree[node1].lson,tree[node2].lson,l,mid);</span><br><span class="line">tree[node1].rson = merge(tree[node1].rson,tree[node2].rson,mid+1,r);</span><br><span class="line">pushup(node1);</span><br><span class="line">return node1;</span><br><span class="line">&#125;</span><br><span class="line">int find(int x)&#123;</span><br><span class="line">if(fa[x]==x) return x;</span><br><span class="line">return fa[x] = find(fa[x]);</span><br><span class="line">&#125; </span><br><span class="line">int main()&#123;</span><br><span class="line">n = read(),m = read();</span><br><span class="line">for(int i=1;i&lt;=n;i++)&#123;val[i] = read();</span><br><span class="line">fa[i] = i;</span><br><span class="line">insert(root[i],1,n,val[i],1,i);</span><br><span class="line">&#125; </span><br><span class="line">for(int i=1;i&lt;=m;i++) &#123;</span><br><span class="line">int u = read(),v = read();</span><br><span class="line">int x = find(u),y = find(v);</span><br><span class="line">fa[y] = x; </span><br><span class="line">root[x] = merge(root[x],root[y],1,n);</span><br><span class="line">&#125;</span><br><span class="line">int q = read();</span><br><span class="line">for(int i=1;i&lt;=q;i++)&#123;</span><br><span class="line">char c;</span><br><span class="line">cin&gt;&gt;c;</span><br><span class="line">int u = read(),v = read();</span><br><span class="line">int x = find(u),y = find(v);</span><br><span class="line">if(c==&#x27;B&#x27;)&#123;</span><br><span class="line">if(x==y) continue;</span><br><span class="line">fa[y] = x;</span><br><span class="line">root[x] = merge(root[x],root[y],1,n);</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">    cout&lt;&lt;query(root[x],1,n,v)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P4130 [NOI2007]项链工厂</title>
      <link href="/2020/11/21/p4130/"/>
      <url>/2020/11/21/p4130/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4130">间隙</a></p><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给一个串包含$n$个珠子的项链,其中第$i$个珠子的颜色是$c_i$</p><p>现在要求维护以下几个操作:</p><p><img src="https://img2020.cnblogs.com/blog/2092833/202011/2092833-20201120232612748-2008256197.png" alt=""></p><p><img src="https://img2020.cnblogs.com/blog/2092833/202011/2092833-20201120232626190-1424942522.png" alt=""></p><p>$n,m≤500000$</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>细节巨多的一道线段树题</p><p>调了将近四个小时/kk</p><p>如果没有翻转操作,这就是个线段树裸题</p><p>不难发现,翻转操作只是把顺时针旋转变成了逆时针旋转</p><p>维护两个变量$r$和$k$,分别代表旋转的幅度和是否翻转,然后就可以通过计算轻松搞出查询区间了</p><h3 id="亿点细节"><a href="#亿点细节" class="headerlink" title="亿点细节"></a>亿点细节</h3><ul><li><p>区间颜色全部相同时要特判</p></li><li><p>旋转后区间要翻转</p></li><li><p>注意题目中给的是一个环,因此要特判$l≤r$和$l＞r$的情况</p></li><li><p>区间赋值相加tag,傻逼!</p></li><li><p>交换操作用原数列数据,傻逼!</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int MAXN = 500010;</span><br><span class="line">#define lson node&lt;&lt;1</span><br><span class="line">#define rson node&lt;&lt;1|1 </span><br><span class="line">inline int read()&#123;</span><br><span class="line">int X=0; bool flag=1; char ch=getchar();</span><br><span class="line">while(ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;) &#123;if(ch==&#x27;-&#x27;) flag=0; ch=getchar();&#125;</span><br><span class="line">while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) &#123;X=(X&lt;&lt;1)+(X&lt;&lt;3)+ch-&#x27;0&#x27;; ch=getchar();&#125;</span><br><span class="line">if(flag) return X;</span><br><span class="line">return ~(X-1);</span><br><span class="line">&#125;</span><br><span class="line">int n,m,a[MAXN];</span><br><span class="line">int now;</span><br><span class="line">int T[MAXN];</span><br><span class="line">int cnt = 0;</span><br><span class="line">bool is_rotate;</span><br><span class="line">struct st&#123;</span><br><span class="line">int l,r,val,tag;</span><br><span class="line">&#125;tree[MAXN&lt;&lt;2];</span><br><span class="line">stack&lt;st&gt; s;</span><br><span class="line">void pushdown(int node)&#123;</span><br><span class="line">if(!tree[node].tag) return;</span><br><span class="line">tree[lson].l = tree[lson].r = tree[rson].l = tree[rson].r = tree[node].tag;</span><br><span class="line">tree[lson].tag = tree[node].tag;</span><br><span class="line">tree[rson].tag = tree[node].tag;</span><br><span class="line">tree[lson].val = tree[rson].val = 1;</span><br><span class="line">tree[node].tag = 0;</span><br><span class="line">&#125;</span><br><span class="line">void pushup(int node)&#123;</span><br><span class="line">tree[node].l = tree[lson].l;</span><br><span class="line">tree[node].r = tree[rson].r;</span><br><span class="line">if(tree[lson].r == tree[rson].l)&#123;</span><br><span class="line">tree[node].val = tree[lson].val+tree[rson].val -1;</span><br><span class="line">&#125;</span><br><span class="line">else tree[node].val = tree[lson].val+tree[rson].val;</span><br><span class="line">&#125;</span><br><span class="line">void build(int node,int l,int r)&#123;</span><br><span class="line">if(l==r)&#123;</span><br><span class="line">tree[node].l = tree[node].r = a[l];</span><br><span class="line">tree[node].val = 1;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">int mid = (l+r)&gt;&gt;1;</span><br><span class="line">build(lson,l,mid);</span><br><span class="line">build(rson,mid+1,r);</span><br><span class="line">pushup(node);</span><br><span class="line">&#125;</span><br><span class="line">int query(int node,int l,int r,int x,int y)&#123;</span><br><span class="line">if(x&lt;=l&amp;&amp;y&gt;=r)&#123;</span><br><span class="line">return tree[node].val;</span><br><span class="line">&#125;</span><br><span class="line">pushdown(node);</span><br><span class="line">int mid = (l+r)&gt;&gt;1;</span><br><span class="line">if(x&lt;=mid&amp;&amp;y&gt;mid) return query(lson,l,mid,x,y)+query(rson,mid+1,r,x,y)-(tree[lson].r==tree[rson].l);</span><br><span class="line">if(x&lt;=mid) return query(lson,l,mid,x,y);</span><br><span class="line">if(y&gt;mid) return query(rson,mid+1,r,x,y);</span><br><span class="line">pushup(node);</span><br><span class="line">&#125;</span><br><span class="line">st find(int node,int l,int r,int x,int y)&#123;</span><br><span class="line">if(x&lt;=l&amp;&amp;y&gt;=r)&#123;</span><br><span class="line">return tree[node];</span><br><span class="line">&#125;</span><br><span class="line">pushdown(node);</span><br><span class="line">int mid = (l+r)&gt;&gt;1;</span><br><span class="line">if(x&lt;=mid) return find(lson,l,mid,x,y);</span><br><span class="line">if(y&gt;mid) return find(rson,mid+1,r,x,y);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*int merge2()&#123;</span><br><span class="line">int ans = 0;</span><br><span class="line">st last;</span><br><span class="line">while(!s.empty())&#123;</span><br><span class="line">st a = s.top();</span><br><span class="line">s.pop();</span><br><span class="line">ans+=a.val;</span><br><span class="line">if(a.l==last.r) ans--;</span><br><span class="line">last = a;</span><br><span class="line">//cout&lt;&lt;&quot;[&quot;&lt;&lt;a.l&lt;&lt;&quot; &quot;&lt;&lt;a.r&lt;&lt;&quot;]&quot;&lt;&lt;&quot; &quot;&lt;&lt;a.val&lt;&lt;&quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">return ans;</span><br><span class="line">&#125;*/</span><br><span class="line">void modify(int node,int l,int r,int x,int y,int val)&#123;</span><br><span class="line">if(x&lt;=l&amp;&amp;y&gt;=r)&#123;</span><br><span class="line">tree[node].val = 1;</span><br><span class="line">tree[node].tag = val;</span><br><span class="line">tree[node].l = tree[node].r = val;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">pushdown(node);</span><br><span class="line">int mid = (l+r)&gt;&gt;1;</span><br><span class="line">if(x&lt;=mid) modify(lson,l,mid,x,y,val);</span><br><span class="line">if(y&gt;mid) modify(rson,mid+1,r,x,y,val);</span><br><span class="line">pushup(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void calc(int &amp;x,int &amp;y)&#123;</span><br><span class="line">if(!is_rotate)</span><br><span class="line">    &#123;</span><br><span class="line">        if(x&gt;=now+1)x=x-now;</span><br><span class="line">        else x=n-now+x;</span><br><span class="line">        if(y&gt;=now+1) y=y-now;</span><br><span class="line">        else y=n-now+y;</span><br><span class="line">    &#125;else</span><br><span class="line">    &#123;</span><br><span class="line">        if(x&lt;=now+1)x=now-x+2;</span><br><span class="line">        else x=now+n-x+2;</span><br><span class="line">        if(y&lt;=now+1) y=now-y+2;</span><br><span class="line">        else y=now+n-y+2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">int main()&#123;</span><br><span class="line">n = read(),m = read();</span><br><span class="line">for(int i=1;i&lt;=n;i++) a[i] = read();</span><br><span class="line">    build(1,1,n);</span><br><span class="line">    int t;</span><br><span class="line">    t = read();</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">    char opt[2];</span><br><span class="line">    cin&gt;&gt;opt;</span><br><span class="line">    if(opt[0]==&#x27;R&#x27;)&#123;</span><br><span class="line">    int k = read();</span><br><span class="line">    now = (now+k)%n;</span><br><span class="line">&#125;</span><br><span class="line">else if(opt[0]==&#x27;F&#x27;)&#123;</span><br><span class="line">is_rotate = !is_rotate;</span><br><span class="line">now = (n-now)%n;</span><br><span class="line">&#125;</span><br><span class="line">else if(opt[0]==&#x27;P&#x27;)&#123;</span><br><span class="line">int l = read(),r = read(),val = read();</span><br><span class="line">calc(l,r);</span><br><span class="line">if(is_rotate) swap(l,r);</span><br><span class="line">if(l&lt;=r) modify(1,1,n,l,r,val);</span><br><span class="line">else modify(1,1,n,l,n,val),modify(1,1,n,1,r,val);</span><br><span class="line">&#125;</span><br><span class="line">else if(opt[0]==&#x27;C&#x27;&amp;&amp;opt[1]!=&#x27;S&#x27;)&#123;</span><br><span class="line">if(tree[1].l!=tree[1].r) cout&lt;&lt;tree[1].val&lt;&lt;endl;//T[++cnt] = tree[1].val;</span><br><span class="line">else cout&lt;&lt;max(1,tree[1].val - 1)&lt;&lt;endl;//T[++cnt] = tree[1].val-1;</span><br><span class="line">&#125;</span><br><span class="line">else if(opt[0]==&#x27;S&#x27;)&#123;</span><br><span class="line">int l =read(),r = read();</span><br><span class="line">calc(l,r);</span><br><span class="line">st a = find(1,1,n,l,l);</span><br><span class="line">st b = find(1,1,n,r,r);</span><br><span class="line">modify(1,1,n,l,l,b.l);</span><br><span class="line">modify(1,1,n,r,r,a.l);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">int l = read(),r = read();</span><br><span class="line">calc(l,r);</span><br><span class="line">if(is_rotate) swap(l,r);</span><br><span class="line">//cout&lt;&lt;&quot;[&quot;&lt;&lt;l&lt;&lt;&quot; &quot;&lt;&lt;r&lt;&lt;&quot;]&quot;&lt;&lt;endl;</span><br><span class="line">if(l&lt;=r) cout&lt;&lt;query(1,1,n,l,r)&lt;&lt;endl;</span><br><span class="line">else&#123;</span><br><span class="line">cout&lt;&lt;max(1,query(1,1,n,l,n)+query(1,1,n,1,r)-(tree[1].l==tree[1].r))&lt;&lt;endl; </span><br><span class="line">&#125;</span><br><span class="line"> // T[++cnt] = merge();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P3354 [IOI2005]Riv 河流</title>
      <link href="/2020/11/14/p3354/"/>
      <url>/2020/11/14/p3354/</url>
      
        <content type="html"><![CDATA[<h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给一颗$n$个节点的树,根节点是一个伐木场,每个节点都有一个村庄,每个村庄的每根木头运送到其父亲的代价是$d_i$,现在要建立$k$个伐木场,每个村庄有$w_i$根木头要沿树边运到最近的伐木场,求最小代价</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>树形$dp$</p><p>一开始比较容易想到的是设$f(i,j)$表示在$i$的子树中建立$j$个伐木场所花费的最小代价</p><p>发现无法得知一个节点的上一个伐木场在哪,即无法计算代价,考虑在状态中记录上一个伐木场的位置</p><p>设$f(i,j,k)$表示上一个伐木场的位置是$j$,$i$的子树中建立$j$个伐木场所花费的代价</p><p>有显然的转移:</p><center>$f(u,j,k) = min\{f(u,j,k-l)+min(f(v,v,l),f(v,j,l))\}(1≤l≤k)$</center><p>亿点细节:</p><ul><li><p>记得删除不合法的状态,详细见代码</p></li><li><p>枚举$j$时要先判断$j$是否在$u$的祖先中</p></li></ul><h2 id="code"><a href="#code" class="headerlink" title="$code$"></a>$code$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf (1&lt;&lt;30)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> head[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">e</span>&#123;</span><br><span class="line"><span class="type">int</span> v,w,next;</span><br><span class="line">&#125;edge[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> n,K;</span><br><span class="line"><span class="type">int</span> c[MAXN],f[MAXN][MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> is_fa[MAXN];</span><br><span class="line"><span class="type">int</span> dis[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">edge[++cnt].v = v;</span><br><span class="line">edge[cnt].next = head[u];</span><br><span class="line">edge[cnt].w = w;</span><br><span class="line">head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">is_fa[u] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++) <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=K;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!is_fa[i]) f[u][i][j] = inf;<span class="comment">//除去不合法状态</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">0</span>||u!=i) f[u][i][j] = (dis[u] - dis[i])*c[u];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(j!=<span class="number">0</span>) f[u][i][j] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> f[u][i][j] = inf;<span class="comment">//显然在u=i且j=0时状态不合法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = edge[i].v;</span><br><span class="line">dis[v] = edge[i].w+dis[u];</span><br><span class="line"><span class="built_in">dfs</span>(v);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!is_fa[j]) <span class="keyword">continue</span>;<span class="comment">//判断是否为祖先</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=K;k&gt;=<span class="number">0</span>;k--)&#123;</span><br><span class="line">f[u][j][k]+=f[v][j][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> s=<span class="number">1</span>;s&lt;=k;s++)&#123;</span><br><span class="line">f[u][j][k] = <span class="built_in">min</span>(f[u][j][k],f[u][j][k-s]+<span class="built_in">min</span>(f[v][v][s],f[v][j][s]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">is_fa[u] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;K;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="type">int</span> u,w;</span><br><span class="line">cin&gt;&gt;c[i]&gt;&gt;u&gt;&gt;w;</span><br><span class="line"><span class="built_in">add</span>(u,i,w);</span><br><span class="line">dis[i] = w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">cout&lt;&lt;f[<span class="number">0</span>][<span class="number">0</span>][K];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF10D LCIS</title>
      <link href="/2020/11/08/cf10d/"/>
      <url>/2020/11/08/cf10d/</url>
      
        <content type="html"><![CDATA[<p><del>考完水篇博客放松一下</del></p><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>求两个串的最长公共上升子序列。</p><p>$1≤n,m≤500$</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>设$f(i,j)$表示$a$串中前$i$个字符,$b$串中前$j$个字符构成以$b_j$结尾的$LCIS$长度</p><p>有显然的转移:</p><ul><li>$a_i = b_j$时</li></ul><p>$f(i,j) = max\left{f(i-1,k)\right}+1(0≤k&lt;j,b_k&lt;a_i)$</p><ul><li>$a_i≠b_j$时</li></ul><p>$f(i,j) = f(i-1,j)$</p><h2 id="code"><a href="#code" class="headerlink" title="$code$"></a>$code$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">510</span>;</span><br><span class="line"><span class="type">int</span> f[MAXN][MAXN],n,m,k,last[MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> a[MAXN],b[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> now)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">print</span>(i<span class="number">-1</span>,last[i][now]);</span><br><span class="line"><span class="keyword">if</span>(last[i][now]!=now)</span><br><span class="line">cout&lt;&lt;b[now]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">cin&gt;&gt;m;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) cin&gt;&gt;b[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(b[j]==a[i]) f[i][j] = f[i<span class="number">-1</span>][k]+<span class="number">1</span>,last[i][j] = k;</span><br><span class="line"><span class="keyword">else</span> f[i][j] = f[i<span class="number">-1</span>][j],last[i][j] = j;</span><br><span class="line"><span class="keyword">if</span>(b[j]&lt;a[i]&amp;&amp;f[i<span class="number">-1</span>][j]&gt;f[i<span class="number">-1</span>][k]) k = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(f[n][i]&gt;f[n][ans]) ans = i;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;f[n][ans]&lt;&lt;endl;</span><br><span class="line"><span class="built_in">print</span>(n,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SP263 PERIOD - Period</title>
      <link href="/2020/11/06/sp263/"/>
      <url>/2020/11/06/sp263/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>如果一个字符串$S$是由一个字符串$T$重复$K$次形成的，则称$T$是$S$的循环元。使$K$最大的字符串$T$称为$S$的最小循环元，此时的$K$称为最大循环次数。</p><p>现给一个给定长度为N的字符串$S$，对$S$的每一个前缀$S[1$~$i]$，如果它的最大循环次数大于$1$，则输出该前缀的长度和最大循环次数。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="引理"><a href="#引理" class="headerlink" title="引理"></a>引理</h3><p>$S[1$-$i]$具有长度$len&lt;i$的循环元的充要条件是$len$能整除$i$并且$S[len+1$-$i]=S[1$~$i-len]$(即$i-len$是$KMP$算法中$next[i]$的”候选择”)</p><h3 id="证明"><a href="#证明" class="headerlink" title="证明:"></a>证明:</h3><p>首先,$len$能作为$S$的循环元,必须满足$len$能整除$i$,且$S[len+1$-$i]$和$S[1$-$i-len]$都是由$i/len-1$个循环元构成的,即$S[len+1$-$i]=S[1$-$i-len]$</p><p>其次,分别从$S[len+1$-$i]$和$S[1$-$i-len]$取前$len$个字符,可以发现$S[len+1$-$2*len]$ $=$ $S[1$-$len]$,依此类推,可以发现$S[len+1$-$i]$和$S[1$-$i-len]$是以$len$为间隔错位对齐的,故$S[1$-$len]$是$S$的循环元</p><p>证毕</p><h2 id="code"><a href="#code" class="headerlink" title="$code$"></a>$code$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1000010</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> next[MAXN];</span><br><span class="line"><span class="type">char</span> s[MAXN],s2[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;s[i]!=s[j+<span class="number">1</span>]) j = next[j];</span><br><span class="line"><span class="keyword">if</span>(s[i]==s[j+<span class="number">1</span>]) j++;</span><br><span class="line">next[i] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line"><span class="type">int</span> now = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line">now++;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;s[i];</span><br><span class="line"><span class="built_in">pre</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Test case #%d\n&quot;</span>, now);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">if</span>(i%(i-next[i])==<span class="number">0</span>&amp;&amp;i/(i-next[i])&gt;<span class="number">1</span>)&#123;</span><br><span class="line">cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;i/(i-next[i])&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《算法竞赛进阶指南》-李煜东</p><h1 id="CSP2020-RP"><a href="#CSP2020-RP" class="headerlink" title="CSP2020 RP++"></a>CSP2020 RP++</h1>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P4735 最大异或和(可持久化trie树模板)</title>
      <link href="/2020/10/31/p4735/"/>
      <url>/2020/10/31/p4735/</url>
      
        <content type="html"><![CDATA[<p><strong><a href="https://www.luogu.com.cn/problem/P4735">间隙</a></strong></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个非负整数序列 ${a}$，初始长度为$n$。</p><p>有 $m$ 个操作，有以下两种操作类型：</p><p>A x：添加操作，表示在序列末尾添加一个数 $x$，序列的长度 $n+1$。</p><p>Q l r x：询问操作，你需要找到一个位置 $p$，满足$x⊕a[p]⊕a[p+1]⊕…⊕a[N]⊕x$最大，输出最大是多少。</p><p>$N,M≤300000$</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>可持久化trie树模板</p><p>设$s[i]$表示前$i$个数$⊕$起来的结果,根据异或的性质:</p><p>$a<em>p⊕a</em>{p+1}⊕…⊕a[n]⊕x = s[p-1]⊕s[n]⊕x$</p><p>对于添加操作,直接插入即可</p><p>对于查询操作:</p><p>维护一个数组$b_i$,表示节点$b_i$的子树中的最大版本号(最大下标)</p><p>显然,只有在最大版本号不小于$l-1$时该节点才合法,在合法的前提下尽可能地往与当前位相反的指针走</p><h2 id="code"><a href="#code" class="headerlink" title="$code$"></a>$code$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">600010</span>;</span><br><span class="line"><span class="type">int</span> n,m,child[MAXN*<span class="number">24</span>][<span class="number">2</span>], tot;</span><br><span class="line"><span class="type">int</span> s[MAXN],a[MAXN],root[MAXN],maxindex[MAXN*<span class="number">24</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;</span><br><span class="line">maxindex[node] = <span class="built_in">max</span>(maxindex[child[node][<span class="number">0</span>]],maxindex[child[node][<span class="number">1</span>]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> now,<span class="type">int</span> ind,<span class="type">int</span> last)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(now&lt;<span class="number">0</span>)&#123;</span><br><span class="line">maxindex[node] = ind;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> c = s[ind]&gt;&gt;now&amp;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(last) child[node][c^<span class="number">1</span>] = child[last][c^<span class="number">1</span>];</span><br><span class="line">child[node][c] = ++tot;</span><br><span class="line"><span class="built_in">insert</span>(child[node][c],now<span class="number">-1</span>,ind,child[last][c]);</span><br><span class="line"><span class="built_in">update</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> now,<span class="type">int</span> val,<span class="type">int</span> limit)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(now&lt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> s[maxindex[node]]^val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> c = val&gt;&gt;now&amp;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(maxindex[child[node][c^<span class="number">1</span>]]&gt;=limit)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">query</span>(child[node][c^<span class="number">1</span>],now<span class="number">-1</span>,val,limit);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">query</span>(child[node][c],now<span class="number">-1</span>,val,limit);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">maxindex[<span class="number">0</span>] = <span class="number">-1</span>;<span class="comment">//坑</span></span><br><span class="line">root[<span class="number">0</span>] = ++tot;</span><br><span class="line"><span class="built_in">insert</span>(root[<span class="number">0</span>],<span class="number">23</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">s[i] = s[i<span class="number">-1</span>]^x;</span><br><span class="line">root[i] = ++tot;</span><br><span class="line"><span class="built_in">insert</span>(root[i],<span class="number">23</span>,i,root[i<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="type">char</span> opt[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,opt);</span><br><span class="line"><span class="keyword">if</span>(opt[<span class="number">0</span>]==<span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;val);</span><br><span class="line">root[++n] = ++tot;</span><br><span class="line">s[n] = s[n<span class="number">-1</span>]^val;</span><br><span class="line"><span class="built_in">insert</span>(root[n],<span class="number">23</span>,n,root[n<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="type">int</span> l,r,x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;x);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">query</span>(root[r<span class="number">-1</span>],<span class="number">23</span>,x^s[n],l<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P4551 最长异或路径(01trie模板)</title>
      <link href="/2020/10/31/p4551/"/>
      <url>/2020/10/31/p4551/</url>
      
        <content type="html"><![CDATA[<p><strong><a href="https://www.luogu.com.cn/problem/P4551">间隙</a></strong></p><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给定一棵$n$个点的带权树，求最长的异或路径。</p><p>异或路径指的是指两个结点之间唯一路径上的所有边权的异或</p><p>$1≤n≤100000$</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>01trie模板</p><p>设$f<em>i$表示从根节点到$i$节点的异或路径,有显然的递推公式:$f_v = f</em>{fa}⊕edge.w$</p><p>根据异或的性质,$x$到$y$之间的异或路径即为$f_v⊕f_u$($a⊕a = 0$,即路径上重合的一部分恰好抵消)</p><p>于是可以将每个$f_i$的二进制串从左到右插入到一颗$trie$树中,并在查询时尽可能地往与当前位相反的指针走即可</p><h2 id="code"><a href="#code" class="headerlink" title="$code$"></a>$code$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">e</span>&#123;</span><br><span class="line"><span class="type">int</span> u,v,w,next;</span><br><span class="line">&#125;edge[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> head[MAXN&lt;&lt;<span class="number">1</span>],cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">++cnt;</span><br><span class="line">edge[cnt].w = w;</span><br><span class="line">edge[cnt].u = u;</span><br><span class="line">edge[cnt].v = v;</span><br><span class="line">edge[cnt].next = head[u];</span><br><span class="line">head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> child[MAXN*<span class="number">40</span>][<span class="number">2</span>],tot = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> a[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = edge[i].v;</span><br><span class="line"><span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">a[v] = a[u]^edge[i].w;</span><br><span class="line"><span class="built_in">dfs</span>(v,u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">30</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="type">int</span> now = a&gt;&gt;i&amp;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(!child[p][now]) child[p][now] = ++tot;</span><br><span class="line">p = child[p][now];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">findmax</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">30</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="type">int</span> now = a&gt;&gt;i&amp;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(child[p][now^<span class="number">1</span>])&#123;</span><br><span class="line">res|=<span class="number">1</span>&lt;&lt;i;</span><br><span class="line">p = child[p][now^<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">p = child[p][now];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans = <span class="built_in">max</span>(ans,res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line"><span class="type">int</span> u,v,w;</span><br><span class="line">cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line"><span class="built_in">add</span>(u,v,w);</span><br><span class="line"><span class="built_in">add</span>(v,u,w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">insert</span>(a[i]);</span><br><span class="line"><span class="built_in">findmax</span>(a[i]);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【模板】manacher算法</title>
      <link href="/2020/10/23/manacher%E7%AE%97%E6%B3%95/"/>
      <url>/2020/10/23/manacher%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>看进阶指南的时候看到的算法,正好最近<del>没啥事干</del>来学一下</p><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给一个长度为$n$字符串$S$,求$S$中的最长回文字串</p><p>$n≤1.1×10^7$</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h2 id="算法一"><a href="#算法一" class="headerlink" title="算法一"></a>算法一</h2><p>暴力</p><p>枚举每个点能扩散到的最大长度</p><p>时间复杂度$O(n^2)$</p><hr><h2 id="算法二"><a href="#算法二" class="headerlink" title="算法二"></a>算法二</h2><p>$hash+$二分</p><p>建立出$S$的前后缀$hash$值,然后二分答案,找到最大扩展长度</p><p>时间复杂度$O(nlogn)$</p><hr><h2 id="算法三"><a href="#算法三" class="headerlink" title="算法三"></a>算法三</h2><p>$manacher$<del>麻辣串</del>算法</p><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p>1.在每两个字符间插入一个额外字符,以去掉偶回文串的情况</p><hr><p>2.定义$r_i$表示以$i$为中心时的最大回文半径</p><p>$R$表示当前情况能扩展到的最右字符$(即最右回文右端点)$,$mid$表示最右回文的中心</p><p>考虑每个新进来的字符的情况:</p><p>$1.$ $i∈[mid,R]$</p><p>显然,$i$有一个关于$mid$的对称点$j = mid×2-i$,根据对称性,$j$周围的字符和$i$周围的字符一定相同,于是可以先用$r<em>j$去更新$r_i$,即$r_i = min(r</em>{mid×2-i},r_{mid}-i+mid)$,(右侧不能大于$R$,否则处于未知的位置,无法保证正确性),最后再去试试$i$还能不能扩展,同时更新$R$和$mid$的值</p><p>$2.$ $i∈(R,n]$</p><p>此时$i$处于一个未知的位置,因此只能暴力扩展,同时更新$R$和$mid$的值</p><p>最后的答案即为$(2*max(r_i)-2)/2 = max(r_i)-1$,由于$R$最多会向右移$n$次,因此总时间复杂度为线性($O(n)$)</p><h2 id="code"><a href="#code" class="headerlink" title="$code$"></a>$code$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">91000000</span>;</span><br><span class="line"><span class="type">char</span> c[MAXN];</span><br><span class="line"><span class="type">char</span> s[MAXN];</span><br><span class="line"><span class="type">int</span> L[MAXN],R[MAXN]; </span><br><span class="line"><span class="type">int</span> MAX_R;</span><br><span class="line"><span class="type">int</span> r[MAXN],len,mid; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">manacher</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(MAX_R&gt;i&amp;&amp;mid&lt;=i) r[i] = <span class="built_in">min</span>(r[mid*<span class="number">2</span>-i],r[mid]-i+mid);</span><br><span class="line"><span class="keyword">else</span> r[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(s[i+r[i]]==s[i-r[i]]) r[i]++;</span><br><span class="line"><span class="keyword">if</span>(i+r[i]&gt;MAX_R)&#123;</span><br><span class="line">mid = i;</span><br><span class="line">MAX_R = r[i]+i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;c;</span><br><span class="line">s[<span class="number">0</span>] =<span class="string">&#x27;#&#x27;</span>,s[<span class="number">1</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">len = <span class="built_in">strlen</span>(c); </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">s[i*<span class="number">2</span>+<span class="number">2</span>] = c[i];</span><br><span class="line">s[i*<span class="number">2</span>+<span class="number">3</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">&#125; </span><br><span class="line">len = len*<span class="number">2</span>+<span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">-114514</span>;</span><br><span class="line"><span class="built_in">manacher</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">ans = <span class="built_in">max</span>(ans,r[i]);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans<span class="number">-1</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing 105. 七夕祭</title>
      <link href="/2020/10/17/ac105/"/>
      <url>/2020/10/17/ac105/</url>
      
        <content type="html"><![CDATA[<h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个$n×m$的矩阵,矩阵上有$t$个点有摊位,两个摊位相邻,当且仅当它们在同一行或同一列的相邻位置上,且每一行和每一列的第一个位置和最后一个位置也算作相邻</p><p>求至少需要交换多少个相邻摊位,能使得各行各列上的摊位数均相等</p><p>$1≤n,m≤100000$</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>经过观察可以发现交换上下相邻两个的节点只会改变某两行中的摊位数,交换左右两个相邻的节点只会改变某两列中的摊位数,因此可以把原问题拆成两个问题:</p><p>1.至少移动多少个相邻摊位可以使各行中的摊位数相同</p><p>2.至少移动多少个想来摊位可以使各列中的摊位数相同</p><p>先来考虑不是环形的情况</p><p>设$a[i]$表示第$i$行中的摊位数量</p><p>显然,这是个经典的均分纸牌问题,最终答案即为$\sum_{i=1}^n|a[i]-\dfrac{t}{m}|$,列也同理</p><p>对于加上环形的情况,一种比较好想的处理方法是断换成链,枚举断开哪个点,但对于$1≤n,m≤100000$的数据范围肯定会T飞,考虑优化;</p><p>设$sum[i]$表示$\sum_{i=1}^n|a[i]-\dfrac{t}{m}|$,即$|a[i]-\dfrac{t}{m}|$的前缀和</p><p>假设在第$k$个人后把环断开</p><p>显然,对于区间$[k+1,n]$的行,其前缀和为$sum[i]-sum[k]$</p><p>对于区间$[1,k]$之间的行,其前缀和为$sum[i]+sum[n]-sum[k]$</p><p>又因为$sum[m]$必定是$0$,因此前缀和的变化就是每个位置都减掉$sum[k]$</p><p>答案即为$\sum_{i=1}^n|sum[i]-sum[k]|$</p><p>把每个$sum[i]$都看作数轴上的一个点,那么就变成了一个经典的中位数最短距离问题:</p><p>在一个数轴上有$n$个点,从中选出一个点,使得其他的点到该点的距离之和最小</p><p>将$sum$排序后取中位数即可</p><p>总复杂度$O(nlogn+mlogm)$</p><h2 id="code"><a href="#code" class="headerlink" title="$code$"></a>$code$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m,t;</span><br><span class="line"><span class="type">int</span> row[MAXN];</span><br><span class="line"><span class="type">int</span> col[MAXN];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ROW</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> sum[MAXN];</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> unneed = t/n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) row[i]-=t/n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) sum[i] = sum[i<span class="number">-1</span>]+row[i];</span><br><span class="line"><span class="built_in">sort</span>(sum+<span class="number">1</span>,sum+n+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n/<span class="number">2</span>;i++) ans+=sum[n-i+<span class="number">1</span>]-sum[i];</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">COL</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> sum[MAXN];</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> unneed = t/m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) col[i]-=t/m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) sum[i] = sum[i<span class="number">-1</span>]+col[i];</span><br><span class="line"><span class="built_in">sort</span>(sum+<span class="number">1</span>,sum+m+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m/<span class="number">2</span>;i++) ans+=sum[m-i+<span class="number">1</span>]-sum[i];</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m&gt;&gt;t;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;i++)&#123;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">row[x]++;</span><br><span class="line">col[y]++;</span><br><span class="line">cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(cnt%n==<span class="number">0</span>&amp;&amp;cnt%m==<span class="number">0</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;both &quot;</span>;</span><br><span class="line">cout&lt;&lt;<span class="built_in">ROW</span>()+<span class="built_in">COL</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(cnt%n==<span class="number">0</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;row &quot;</span>;</span><br><span class="line">cout&lt;&lt;<span class="built_in">ROW</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(cnt%m==<span class="number">0</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;column &quot;</span>;</span><br><span class="line">cout&lt;&lt;<span class="built_in">COL</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;impossible&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P4141 消失之物</title>
      <link href="/2020/10/09/p4141/"/>
      <url>/2020/10/09/p4141/</url>
      
        <content type="html"><![CDATA[<h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给$n$个物品和一个容量为$m$的背包,设$cnt(i,x)$表示删去某个物品$i$时填满容量为$x$的背包的方案数</p><p>求所有的$cnt(i,x)$</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>容斥+$dp$</p><p>和<a href="https://www.luogu.com.cn/problem/P1450"><strong>P1450 [HAOI2008]硬币购物</strong></a>大同小异的解法</p><p>总方案数 $=$ 不删去物品时的方案数 $-$ 不合法的方案数</p><p>设$f[j]$表示不删去任何物品时背包容量为$j$时的方案数,$g[j]$表示删去物品$i$时填充容量为$j$的背包的方案数</p><p>对于不删去物品时方案数,直接跑一遍01背包即可，对于不合法的方案数:</p><p>当且仅当一个方案使用了第$i$个物品时该改方案不合法,有一个比较容易想到的转移,即:</p><p>$g[j] = f[j] - f[j-w[i]]$</p><p><del>显然是错的</del>,因为在$f[j-w[i]]$中可能也有$w[i]$的贡献</p><p>因此因改为:</p><p>$g[j] = f[j] - g[j-w[i]]$</p><h2 id="code"><a href="#code" class="headerlink" title="$code$"></a>$code$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">2010</span>;</span><br><span class="line"><span class="type">int</span> f[MAXN],w[MAXN],n,m;</span><br><span class="line"><span class="type">int</span> ie[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">ie[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;w[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=m;j&gt;=w[i];j--)&#123;</span><br><span class="line">f[j]+=f[j-w[i]];</span><br><span class="line">f[j]%=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;w[i];j++)&#123;</span><br><span class="line">ie[j] = f[j];</span><br><span class="line">ie[j]%=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=w[i];j&lt;=m;j++)&#123;</span><br><span class="line">ie[j] = (f[j] - ie[j-w[i]]+<span class="number">10</span>)%<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++) cout&lt;&lt;ie[j];</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>听说ZJ今年复赛晋级人数要下降30%…怕不是要初赛AFO了/kk</del></p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P2827 蚯蚓</title>
      <link href="/2020/10/05/p2827/"/>
      <url>/2020/10/05/p2827/</url>
      
        <content type="html"><![CDATA[<h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给$n$个数,$m$次操作,每次操作都将最大的一个数$K$分割为$p×K$和$K-p×K$两个数,每次操作后未被切割的数都会长长$q$,现在要求:</p><p>1.第$1t,2t,3t,…$次操作时被切割的数的大小($t$为给定参数)</p><p>2.操作完成后排名为$1t,2t,3t,…$的数的大小</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="算法一"><a href="#算法一" class="headerlink" title="算法一"></a>算法一</h3><p>直接开一个堆来模拟</p><p>可以获得$90pts$的<del>超高</del>分</p><p>复杂度约为$O(mlogn)$</p><h2 id="code"><a href="#code" class="headerlink" title="$code$"></a>$code$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> X=<span class="number">0</span>; <span class="type">bool</span> flag=<span class="number">1</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) flag=<span class="number">0</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">if</span>(flag) <span class="keyword">return</span> X;</span><br><span class="line"><span class="keyword">return</span> ~(X<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt;que;</span><br><span class="line"><span class="type">int</span> n,m,q,u,v,t;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n = <span class="built_in">read</span>(),m =<span class="built_in">read</span>(),q =<span class="built_in">read</span>(),u =<span class="built_in">read</span>(),v =<span class="built_in">read</span>(),t =<span class="built_in">read</span>();</span><br><span class="line"><span class="type">int</span> qy;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">qy = <span class="built_in">read</span>();</span><br><span class="line">que.<span class="built_in">push</span>(qy);</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">double</span> px = (<span class="type">double</span>)u/v;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="type">int</span> now = que.<span class="built_in">top</span>()+val;</span><br><span class="line">val+=q;</span><br><span class="line">que.<span class="built_in">pop</span>();</span><br><span class="line"><span class="type">int</span> xx = (<span class="type">double</span>)(px*now),yy = now - xx;</span><br><span class="line">xx-=val,yy-=val;</span><br><span class="line">que.<span class="built_in">push</span>(xx),que.<span class="built_in">push</span>(yy);</span><br><span class="line"><span class="keyword">if</span>(i%t==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,now);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"><span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line"><span class="type">int</span> now = que.<span class="built_in">top</span>()+val;</span><br><span class="line">que.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span>(T%t==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,now);</span><br><span class="line">T++;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法二"><a href="#算法二" class="headerlink" title="算法二"></a>算法二</h2><p>通过观察可以发现:</p><p>假设有两个数$x$和$y$,且$x≥y$,那么两个数被切割后分别为</p><p>$p×x$和$(1-p)×x$,$p×y$和$(1-p)×y$</p><p>易得</p><p>$p×x≥p×y$,$(1-p)×x≥(1-p)×y$</p><p>说明被切割后的两个数具有单调性</p><p>可以开三个队列,一个存储经排序后的原数,另外两个分别存储被切割后的两个数</p><p>每次操作时取三个队首中最大的一个,并弹出即可</p><p>复杂度为$O(m+nlogn)$</p><h2 id="code-1"><a href="#code-1" class="headerlink" title="$code$"></a>$code$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> X=<span class="number">0</span>; <span class="type">bool</span> flag=<span class="number">1</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) flag=<span class="number">0</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">if</span>(flag) <span class="keyword">return</span> X;</span><br><span class="line"><span class="keyword">return</span> ~(X<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt;q1,q2,q3;</span><br><span class="line"><span class="type">int</span> n,m,q,u,v,t;</span><br><span class="line"><span class="type">int</span> a[<span class="number">100005</span>];</span><br><span class="line"><span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> x&gt;y;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">choise</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">1</span>) q1.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">2</span>) q2.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">else</span> q3.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> n = <span class="built_in">read</span>(),m =<span class="built_in">read</span>(),q =<span class="built_in">read</span>(),u =<span class="built_in">read</span>(),v =<span class="built_in">read</span>(),t =<span class="built_in">read</span>();</span><br><span class="line"><span class="type">int</span> qy;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">a[i] = <span class="built_in">read</span>();</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">double</span> px = (<span class="type">double</span>)u/v;</span><br><span class="line"><span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>,cmp);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">q1.<span class="built_in">push</span>(a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="type">int</span> que,now = <span class="number">-11451419</span>;</span><br><span class="line"><span class="keyword">if</span>(!q1.<span class="built_in">empty</span>()&amp;&amp;q1.<span class="built_in">front</span>()+val&gt;now) now = q1.<span class="built_in">front</span>()+val,que = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(!q2.<span class="built_in">empty</span>()&amp;&amp;q2.<span class="built_in">front</span>()+val&gt;now) now = q2.<span class="built_in">front</span>()+val,que = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(!q3.<span class="built_in">empty</span>()&amp;&amp;q3.<span class="built_in">front</span>()+val&gt;now) now = q3.<span class="built_in">front</span>()+val,que = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">choise</span>(que);</span><br><span class="line">val+=q;</span><br><span class="line"><span class="type">int</span> xx = (<span class="type">double</span>)(px*now),yy = now - xx;</span><br><span class="line">xx-=val,yy-=val;</span><br><span class="line">q2.<span class="built_in">push</span>(xx),q3.<span class="built_in">push</span>(yy);</span><br><span class="line"><span class="keyword">if</span>(i%t==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,now);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"><span class="keyword">while</span>(!(q1.<span class="built_in">empty</span>()&amp;&amp;q2.<span class="built_in">empty</span>()&amp;&amp;q3.<span class="built_in">empty</span>()))&#123;</span><br><span class="line"><span class="type">int</span> que,now = <span class="number">-11451419</span>;</span><br><span class="line"><span class="keyword">if</span>(!q1.<span class="built_in">empty</span>()&amp;&amp;q1.<span class="built_in">front</span>()+val&gt;now) now = q1.<span class="built_in">front</span>()+val,que = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(!q2.<span class="built_in">empty</span>()&amp;&amp;q2.<span class="built_in">front</span>()+val&gt;now) now = q2.<span class="built_in">front</span>()+val,que = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(!q3.<span class="built_in">empty</span>()&amp;&amp;q3.<span class="built_in">front</span>()+val&gt;now) now = q3.<span class="built_in">front</span>()+val,que = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">choise</span>(que);</span><br><span class="line"><span class="keyword">if</span>(T%t==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,now);</span><br><span class="line">T++; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P2679 子串</title>
      <link href="/2020/10/05/p2679/"/>
      <url>/2020/10/05/p2679/</url>
      
        <content type="html"><![CDATA[<p>update on 2021/1/24</p><p><strong><a href="https://www.luogu.com.cn/problem/P2679">题目链接</a></strong></p><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给两个字符串$A$和$B$,从字符串 $A$ 中取出 $k$ 个互不重叠的非空子串，把这 $k$ 个子串按照其在字符串 $A$ 中出现的顺序依次连接起来得到一个新的字符串,求有多少种方案可以使这个新串和字符串$B$相等</p><p>$1≤n≤1000,1≤m≤200,1≤k≤m$</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>设$f(i,j,k,0/1)$表示在$A$中的前$i$个字符,$B$中前$j$个字符,一共拆了$k$个字串,第$i$个字符选$/$不选的方案数,分类讨论拼接的情况,有显然的转移:</p><p>$f(i,j,k,1) = f(i-1,j-1,k,0)+f(i-1,j-1,k-1,1)+f_(i-1,j-1,k,1)$</p><p>$f(i,j,k,0) = f(i-1,j,k,1)+f(i-1,j,k,0)$</p><p>再用滚动数组优化一下即可</p><p>时间复杂度$O(nmk)$</p><h2 id="code"><a href="#code" class="headerlink" title="$code$"></a>$code$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//90pts</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mo 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN =<span class="number">1005</span>;</span><br><span class="line"><span class="type">int</span> f[<span class="number">1005</span>][<span class="number">110</span>][<span class="number">110</span>][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> n,m,k0;</span><br><span class="line">string a,b;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>; </span><br><span class="line">cin&gt;&gt;n&gt;&gt;m&gt;&gt;k0;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">a = <span class="string">&#x27; &#x27;</span>+a;</span><br><span class="line">b = <span class="string">&#x27; &#x27;</span>+b;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">f[i][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=k0;k++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]==b[j])&#123;</span><br><span class="line">f[i][j][k][<span class="number">0</span>] = (f[i<span class="number">-1</span>][j][k][<span class="number">1</span>]+f[i<span class="number">-1</span>][j][k][<span class="number">0</span>])%mo;</span><br><span class="line">f[i][j][k][<span class="number">1</span>] = ((f[i<span class="number">-1</span>][j<span class="number">-1</span>][k<span class="number">-1</span>][<span class="number">0</span>]+f[i<span class="number">-1</span>][j<span class="number">-1</span>][k<span class="number">-1</span>][<span class="number">1</span>])%mo+f[i<span class="number">-1</span>][j<span class="number">-1</span>][k][<span class="number">1</span>])%mo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">f[i][j][k][<span class="number">0</span>] = (f[i<span class="number">-1</span>][j][k][<span class="number">1</span>]+f[i<span class="number">-1</span>][j][k][<span class="number">0</span>])%mo;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;(f[n][m][k0][<span class="number">0</span>]+f[n][m][k0][<span class="number">1</span>])%mo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mo 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN =<span class="number">1005</span>;</span><br><span class="line"><span class="type">int</span> f[<span class="number">2</span>][<span class="number">205</span>][MAXN][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> n,m,k0;</span><br><span class="line">string a,b;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> now = <span class="number">1</span>;</span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] =  <span class="number">1</span>;</span><br><span class="line">f[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] =  <span class="number">1</span>;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m&gt;&gt;k0;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">a = <span class="string">&#x27; &#x27;</span>+a;</span><br><span class="line">b = <span class="string">&#x27; &#x27;</span>+b;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=k0;k++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]==b[j])&#123;</span><br><span class="line">f[now][j][k][<span class="number">0</span>] = (f[now^<span class="number">1</span>][j][k][<span class="number">1</span>]+f[now^<span class="number">1</span>][j][k][<span class="number">0</span>])%mo;</span><br><span class="line">f[now][j][k][<span class="number">1</span>] = ((f[now^<span class="number">1</span>][j<span class="number">-1</span>][k<span class="number">-1</span>][<span class="number">0</span>]+f[now^<span class="number">1</span>][j<span class="number">-1</span>][k<span class="number">-1</span>][<span class="number">1</span>])%mo+f[now^<span class="number">1</span>][j<span class="number">-1</span>][k][<span class="number">1</span>])%mo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">f[now][j][k][<span class="number">0</span>] = (f[now^<span class="number">1</span>][j][k][<span class="number">1</span>]+f[now^<span class="number">1</span>][j][k][<span class="number">0</span>])%mo;</span><br><span class="line">f[now][j][k][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">now^=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;(f[n&amp;<span class="number">1</span>][m][k0][<span class="number">0</span>]+f[n&amp;<span class="number">1</span>][m][k0][<span class="number">1</span>])%mo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P3959 宝藏</title>
      <link href="/2020/10/04/p3959/"/>
      <url>/2020/10/04/p3959/</url>
      
        <content type="html"><![CDATA[<h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给一张$n$个点$m$条边的图,求出一颗生成树,生成树中的每条边的边权为该边的边权$w$$×$该边的深度$dep$,求生成树的最小权值和</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>枚举每个点暴力$dfs$肯定会$T$飞</p><p>发现$n≤12$且有重复状态,考虑状态压缩；</p><p>设$f[i][j][k]$表示当前点集为$i$,且父亲为$j$,深度为$j$时的最小代价</p><p>枚举集合$i$的子集$s$和$u$的儿子$v$</p><p>当且仅当子集合法时,有转移:</p><p>$f[i][u][k] = min(f[s][j][k]+f[s$^$i][v][k+1]+edge(u,v)×k)$</p><p>$(u∈s,v∈s$^$i,edge(u,v)!=inf)$</p><p>采用记忆化搜索的形式来实现</p><p>要注意的是当一个状态被访问过且该状态的$f$数组还未被更新时也要特判</p><h2 id="code"><a href="#code" class="headerlink" title="$code$"></a>$code$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">15</span>;</span><br><span class="line"><span class="type">int</span> n,m,ans;</span><br><span class="line"><span class="type">int</span> edge[MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> f[<span class="number">1</span>&lt;&lt;(MAXN)][MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> vis[<span class="number">1</span>&lt;&lt;(MAXN)][MAXN][MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> status,<span class="type">int</span> u,<span class="type">int</span> dep)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(f[status][u][dep]!=<span class="number">-1</span>) <span class="keyword">return</span> f[status][u][dep];</span><br><span class="line"><span class="keyword">if</span>(vis[status][u][dep]) <span class="keyword">return</span> inf;</span><br><span class="line">vis[status][u][dep] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(status==(<span class="number">1</span>&lt;&lt;(u<span class="number">-1</span>))) <span class="keyword">return</span> f[status][u][dep] = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> ans = inf;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> s = status;s;s = (s<span class="number">-1</span>) &amp; status)&#123;</span><br><span class="line"><span class="keyword">if</span>(!(s&amp;(<span class="number">1</span>&lt;&lt;(u<span class="number">-1</span>)))) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> v=<span class="number">1</span>;v&lt;=n;v++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!(status&amp;(<span class="number">1</span>&lt;&lt;(v<span class="number">-1</span>)))||edge[u][v] == edge[<span class="number">0</span>][<span class="number">0</span>]) <span class="keyword">continue</span>;</span><br><span class="line">ans = <span class="built_in">min</span>(ans,<span class="built_in">dfs</span>(s,u,dep)+<span class="built_in">dfs</span>((s^status),v,dep+<span class="number">1</span>)+edge[u][v]*dep);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f[status][u][dep] = ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">ans = inf;</span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">-1</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line"><span class="built_in">memset</span>(edge,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(edge));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="type">int</span> u,v,w;</span><br><span class="line">cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">edge[u][v] = edge[v][u] = <span class="built_in">min</span>(edge[u][v],w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">ans = <span class="built_in">min</span>(ans,<span class="built_in">dfs</span>((<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>,i,<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P5628 【AFOI-19】面基</title>
      <link href="/2020/10/04/p5628/"/>
      <url>/2020/10/04/p5628/</url>
      
        <content type="html"><![CDATA[<h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给一颗$n$个节点的带边权树,每条边权的值为边两端的端点所形成的子树的乘积,求</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>换根$dp$板子题(或者说是树上容斥?)</p><p>细节有点坑</p><p>设$f[u][j]$表示以$u$为根,距离$u$小于等于$k$的边权和</p><p>先以任意一个节点$u$为根,计算$u$的子树对$u$的贡献,即$f[u][j] = \sum f[v][j-1]$</p><p>接下来从$u$去转移到其他节点</p><p>新节点的边权和 $=$ 父亲对它的贡献$+$子树对它的贡献 $-$ 重复的部分</p><p>易得转移$:$</p><p>$f[v][j] =f[v][j]+ f[u][j-1]-f[v]<a href="j≥2">j-2</a>$</p><p><strong>几个坑点</strong></p><ul><li><p>$j=1$要特判</p></li><li><p>一个点能截断所有与该点相连的道路,因此道路的距离可能为$k+1$</p></li></ul><h2 id="code"><a href="#code" class="headerlink" title="$code$"></a>$code$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">30010</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">int</span> ans = <span class="number">-114514191919</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">e</span>&#123;</span><br><span class="line"><span class="type">int</span> u,v,w,next;</span><br><span class="line">&#125;edge[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> head[MAXN],val[MAXN];</span><br><span class="line"><span class="type">int</span> n,k,cnt = <span class="number">1</span>,size[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">++cnt;</span><br><span class="line">edge[cnt].u = u;</span><br><span class="line">edge[cnt].v = v;</span><br><span class="line">edge[cnt].next = head[u];</span><br><span class="line">head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> f[MAXN][<span class="number">310</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">size[u] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = edge[i].v;</span><br><span class="line"><span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs1</span>(v,u);</span><br><span class="line">size[u]+=size[v];</span><br><span class="line">edge[i].w = size[v]*(n-size[v]); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = edge[i].v;</span><br><span class="line"><span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=k+<span class="number">1</span>;j++)&#123;</span><br><span class="line">f[u][j]+=edge[i].w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs2</span>(v,u);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=k+<span class="number">1</span>;j++)</span><br><span class="line">     f[u][j]+=f[v][j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(u!=<span class="number">1</span>)&#123;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=k+<span class="number">1</span>;i&gt;=<span class="number">2</span>;i--)&#123;</span><br><span class="line">f[u][i] += f[fa][i<span class="number">-1</span>] - f[u][i<span class="number">-2</span>];</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">ans = <span class="built_in">max</span>(ans , f[u][k+<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = edge[i].v;</span><br><span class="line"><span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">f[v][<span class="number">1</span>]+=edge[i].w;</span><br><span class="line"><span class="built_in">dp</span>(v,u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="type">int</span> u,v;</span><br><span class="line">cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line"><span class="built_in">add</span>(u,v),<span class="built_in">add</span>(v,u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">dp</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P1967 货车运输</title>
      <link href="/2020/10/03/p1967/"/>
      <url>/2020/10/03/p1967/</url>
      
        <content type="html"><![CDATA[<h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给一张$n$个点,$m$条边的带边权无向图,现在有$q$次询问,每次询问都给一个$x$和$y$,求$x$到$y$的路径上长度最小的边的大小</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>大水题</p><p>先跑一遍最小生成树</p><p>然后把点权转成边权,上树剖即可</p><h2 id="code"><a href="#code" class="headerlink" title="$code$"></a>$code$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson (node&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson (node&lt;&lt;1|1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 1145141919</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">20010</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">e</span>&#123;</span><br><span class="line"><span class="type">int</span> u,v,w,next;</span><br><span class="line">&#125;edge[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">koishi</span>&#123;</span><br><span class="line"><span class="type">int</span> u,v,w;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> koishi &amp;k)<span class="type">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> w&gt;k.w;</span><br><span class="line">&#125;</span><br><span class="line">&#125;a[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> head[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> w[MAXN&lt;&lt;<span class="number">2</span>],n,m;</span><br><span class="line"><span class="type">int</span> dep[MAXN],son[MAXN],fa[MAXN],size[MAXN],faa[MAXN];</span><br><span class="line"><span class="type">int</span> id[MAXN],val[MAXN],tot = <span class="number">0</span>,cnt = <span class="number">1</span>,top[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(faa[x]==x) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> faa[x] = <span class="built_in">find</span>(faa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">edge[cnt].u = u;</span><br><span class="line">edge[cnt].v = v;</span><br><span class="line">edge[cnt].w = w;</span><br><span class="line">edge[cnt].next = head[u];</span><br><span class="line">head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> f,<span class="type">int</span> deep)</span></span>&#123;</span><br><span class="line">dep[u] = deep;</span><br><span class="line">fa[u] = f;</span><br><span class="line">size[u] = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> maxson = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = edge[i].v;</span><br><span class="line"><span class="keyword">if</span>(v==f) <span class="keyword">continue</span>;</span><br><span class="line">w[v] = edge[i].w;</span><br><span class="line"><span class="built_in">dfs1</span>(v,u,deep+<span class="number">1</span>);</span><br><span class="line">size[u]+=size[v];</span><br><span class="line"><span class="keyword">if</span>(size[v]&gt;maxson)&#123;</span><br><span class="line">son[u] = v;</span><br><span class="line">maxson = size[v];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> topf)</span></span>&#123;</span><br><span class="line">id[u] = ++tot;</span><br><span class="line">val[tot] = u;</span><br><span class="line">top[u] = topf;</span><br><span class="line"><span class="keyword">if</span>(!son[u]) <span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">dfs2</span>(son[u],topf);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = edge[i].v;</span><br><span class="line"><span class="keyword">if</span>(v==son[u]||v==fa[u]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs2</span>(v,v);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st</span>&#123;</span><br><span class="line"><span class="type">int</span> minn,l,r,tag;</span><br><span class="line">&#125;tree[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;</span><br><span class="line">tree[node].minn = <span class="built_in">min</span>(tree[lson].minn,tree[rson].minn);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">tree[node].l = l,tree[node].r = r;</span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">tree[node].minn = w[val[l]];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">build</span>(lson,l,mid);</span><br><span class="line"><span class="built_in">build</span>(rson,mid+<span class="number">1</span>,r);</span><br><span class="line"><span class="built_in">update</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(x&lt;=tree[node].l&amp;&amp;tree[node].r&lt;=y)&#123;</span><br><span class="line"><span class="keyword">return</span> tree[node].minn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> mid = (tree[node].l+tree[node].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> now = inf;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=mid) now = <span class="built_in">min</span>(now,<span class="built_in">query</span>(lson,x,y));</span><br><span class="line"><span class="keyword">if</span>(y&gt;mid) now = <span class="built_in">min</span>(now,<span class="built_in">query</span>(rson,x,y));</span><br><span class="line"><span class="keyword">return</span> now;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qb</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> ans = inf;</span><br><span class="line"><span class="keyword">while</span>(top[u]!=top[v])&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]]) <span class="built_in">swap</span>(u,v);</span><br><span class="line">ans=<span class="built_in">min</span>(ans,<span class="built_in">query</span>(<span class="number">1</span>,id[top[u]],id[u]));</span><br><span class="line">u = fa[top[u]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dep[u]&gt;dep[v]) <span class="built_in">swap</span>(u,v);</span><br><span class="line">ans=<span class="built_in">min</span>(ans,<span class="built_in">query</span>(<span class="number">1</span>,id[u]+<span class="number">1</span>,id[v]));</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">faa[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="built_in">find</span>(a[i].u),y = <span class="built_in">find</span>(a[i].v);</span><br><span class="line"><span class="keyword">if</span>(x!=y)&#123;</span><br><span class="line">faa[x] = y;</span><br><span class="line"><span class="built_in">add</span>(a[i].u,a[i].v,a[i].w),<span class="built_in">add</span>(a[i].v,a[i].u,a[i].w);</span><br><span class="line">tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(tot==n<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(w,<span class="number">-1</span>,<span class="built_in">sizeof</span>(w));</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">cin&gt;&gt;a[i].u&gt;&gt;a[i].v&gt;&gt;a[i].w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+m);</span><br><span class="line"><span class="built_in">kruskal</span>();</span><br><span class="line"><span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="type">int</span> q;</span><br><span class="line">cin&gt;&gt;q;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line"><span class="type">int</span> xx = <span class="built_in">find</span>(x),yy = <span class="built_in">find</span>(y);</span><br><span class="line"><span class="keyword">if</span>(xx!=yy) cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="built_in">qb</span>(x,y)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>水博客好爽啊</del></p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P3953 逛公园</title>
      <link href="/2020/10/03/p3953/"/>
      <url>/2020/10/03/p3953/</url>
      
        <content type="html"><![CDATA[<h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一张$n$个点$m$条边的有向图,求出从$1$号点到$n$号点长度$≤d+k$的路径条数($d$表示从$1$到$n$的最短路长度)</p><p>$n≤100000,m≤200000,k≤50$</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>注意到$k≤50$,考虑$dp$</p><h3 id="dp"><a href="#dp" class="headerlink" title="$dp$"></a>$dp$</h3><p>设$f[i][j]$表示走到$i$这个点时有$j$步可多走且到达终点时恰好走完$j$步的方案数</p><p>假设有一条要转移的边$(u,v,w)$</p><p>那么到达$u$时走的总路程即为$d_u+k-j$</p><p>再从$u$走到$v$就走了$d_u+k-j+w$</p><p>剩下的步数即为$k +d_v- (d_u+k-j+w)  = d_v - d_u+j-w$</p><p>易得转移:</p><p>$f[u][j] = f[v][d_v - d_u+j-w]$</p><p>使用记忆化搜索来实现</p><h3 id="判零环"><a href="#判零环" class="headerlink" title="判零环"></a>判零环</h3><p>此题最坑的地方</p><p>一个比较容易想到的处理方式是在$dfs$的时候记录状态是否出现过,若一个状态出现过两次则说明产生了零环</p><p>但不是所有的零环都会被跑，如果有一个零环被经过时的路径总和大于$k+d_n$,那他就不会被经过</p><p>可以建个反图,然后跑一遍原图的最短路和反图的最短路,然后枚举每个点,判断该点是否满足$d1_i+d2_i≤k+d1_n$,若不满足,则打上一个标记,在$dfs$的时候特判即可</p><p><strong>几个坑点</strong></p><ul><li>$dp$时要判断状态是否合法</li></ul><h2 id="code"><a href="#code" class="headerlink" title="$code$"></a>$code$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100005</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">e</span>&#123;</span><br><span class="line"><span class="type">int</span> to,next,w;</span><br><span class="line">&#125;edge1[MAXN&lt;&lt;<span class="number">1</span>],edge2[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="comment">//----------------------------------edge</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line"><span class="type">int</span> index,dist;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> node &amp;x)<span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> dist&gt;x.dist;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//----------------------------------</span></span><br><span class="line">priority_queue&lt;node&gt; q;</span><br><span class="line"><span class="type">int</span> dis1[MAXN],dis2[MAXN],cnt1,cnt2,head1[MAXN],head2[MAXN],vis[MAXN],n;</span><br><span class="line"><span class="type">int</span> f[MAXN][<span class="number">60</span>];</span><br><span class="line"><span class="type">bool</span> ch[MAXN][<span class="number">60</span>];</span><br><span class="line"><span class="type">bool</span> c[MAXN];</span><br><span class="line"><span class="type">int</span> m,k,p;</span><br><span class="line"><span class="comment">//----------------------------------</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">edge1[++cnt1].next = head1[u];</span><br><span class="line">edge1[cnt1].to = v;</span><br><span class="line">edge1[cnt1].w = w;</span><br><span class="line">head1[u] = cnt1;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">edge2[++cnt2].next = head2[u];</span><br><span class="line">edge2[cnt2].to = v;</span><br><span class="line">edge2[cnt2].w = w;</span><br><span class="line">head2[u] = cnt2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//----------------------------------++edge</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dij1</span><span class="params">(<span class="type">int</span> now)</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">node h = &#123;now,<span class="number">0</span>&#125;;</span><br><span class="line">q.<span class="built_in">push</span>(h);</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">node u = q.<span class="built_in">top</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span>(vis[u.index]) <span class="keyword">continue</span>;</span><br><span class="line">vis[u.index] = <span class="number">1</span>;</span><br><span class="line">dis1[u.index] = u.dist;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head1[u.index];i;i=edge1[i].next)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[edge1[i].to]) <span class="keyword">continue</span>;</span><br><span class="line">h.dist = u.dist+edge1[i].w;</span><br><span class="line">h.index = edge1[i].to;</span><br><span class="line">q.<span class="built_in">push</span>(h);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dij2</span><span class="params">(<span class="type">int</span> now)</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">node h = &#123;now,<span class="number">0</span>&#125;;</span><br><span class="line">q.<span class="built_in">push</span>(h);</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">node u = q.<span class="built_in">top</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span>(vis[u.index]) <span class="keyword">continue</span>;</span><br><span class="line">vis[u.index] = <span class="number">1</span>;</span><br><span class="line">dis2[u.index] = u.dist;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head2[u.index];i;i=edge2[i].next)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[edge2[i].to]) <span class="keyword">continue</span>;</span><br><span class="line">h.dist = u.dist+edge2[i].w;</span><br><span class="line">h.index = edge2[i].to;</span><br><span class="line">q.<span class="built_in">push</span>(h);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//----------------------------------dij</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">cnt1 = cnt2 = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="built_in">sizeof</span>(c));</span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">-1</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line"><span class="built_in">memset</span>(head1,<span class="number">0</span>,<span class="built_in">sizeof</span>(head1));</span><br><span class="line"><span class="built_in">memset</span>(head2,<span class="number">0</span>,<span class="built_in">sizeof</span>(head2));</span><br><span class="line"><span class="built_in">memset</span>(ch,<span class="number">0</span>,<span class="built_in">sizeof</span>(ch));</span><br><span class="line"><span class="built_in">memset</span>(dis1,<span class="number">127</span>,<span class="built_in">sizeof</span>(dis1));</span><br><span class="line"><span class="built_in">memset</span>(dis2,<span class="number">127</span>,<span class="built_in">sizeof</span>(dis2));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//----------------------------------clear</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> lest)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(ch[now][lest]) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(f[now][lest]!=<span class="number">-1</span>) <span class="keyword">return</span> f[now][lest];</span><br><span class="line">ch[now][lest] = <span class="number">1</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> sum  = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(now==n&amp;&amp;lest==<span class="number">0</span>) sum++;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head1[now];i;i=edge1[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = edge1[i].to;</span><br><span class="line"><span class="keyword">if</span>(!c[v]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(dis1[v]+lest-dis1[now]-edge1[i].w&lt;<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="type">int</span> val = <span class="built_in">dfs</span>(v,dis1[v]-dis1[now]+lest-edge1[i].w);</span><br><span class="line"><span class="keyword">if</span>(val==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">sum+=val;</span><br><span class="line">sum%=p;</span><br><span class="line">&#125;</span><br><span class="line">f[now][lest] = sum;</span><br><span class="line">ch[now][lest] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> sum;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//----------------------------------dfs</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">clear</span>();</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;p;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="type">int</span> u,v,w;</span><br><span class="line">cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line"><span class="built_in">add1</span>(u,v,w);</span><br><span class="line"><span class="built_in">add2</span>(v,u,w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dij1</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">dij2</span>(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(dis1[i]+dis2[i]&gt;k+dis1[n]) <span class="keyword">continue</span>;</span><br><span class="line">c[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> b = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=k;i++)&#123;</span><br><span class="line"><span class="type">int</span> now = <span class="built_in">dfs</span>(<span class="number">1</span>,i);</span><br><span class="line"><span class="keyword">if</span>(now==<span class="number">-1</span>)&#123;</span><br><span class="line">b = <span class="literal">false</span>;</span><br><span class="line">cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">ans+=now;</span><br><span class="line">ans%=p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(b) cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础数论</title>
      <link href="/2020/10/02/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA/"/>
      <url>/2020/10/02/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="1-同余及其基本性质"><a href="#1-同余及其基本性质" class="headerlink" title="1.同余及其基本性质"></a>1.同余及其基本性质</h2><p>1.$a\equiv b\pmod{m}-&gt;ac \equiv bc\pmod{m}$</p><p>2.$a\equiv b\pmod{m},c\equiv d\pmod{m}-&gt;a+b \equiv b+d\pmod{m}$</p><p>3.$a\equiv b\pmod{m},c\equiv d\pmod{m}-&gt;ab \equiv bd\pmod{m}$</p><p>4.$a\equiv b\pmod{m}-&gt;a^n \equiv b^n\pmod{m}$</p><p>小推理:如果有$a\equiv b\pmod{m}$,对任意多项式$f(x) = r<em>kx^k+r</em>{k-1}x^{k-1}+..+r_1x+r_0$,都有$f(a) = f(b)\pmod{m}$</p><h2 id="2-剩余系"><a href="#2-剩余系" class="headerlink" title="2.剩余系"></a>2.剩余系</h2><p>概念:</p><ul><li><p>设$S \subseteq Z$,如果任意整数都与$S$中正好一个元素关于模$m$同余,则称$S$是模$m$的一个<strong>完全剩余系</strong></p></li><li><p>与$m$互素的数构成的集合称为模$m$的一个<strong>既约剩余系</strong></p></li><li><p><strong>欧拉函数</strong>:$φ(m)$表示所有不大于$m$且与$m$互素的正整数的个数</p></li></ul><p>定理1:$a∈Z$,$m$是正整数,若$(a,m) = 1$那么有$a^{φ(m)}\equiv 1\pmod{m}$——-(<strong>欧拉定理</strong>)</p><p>定理2:如果$a∈Z$,$p$是素数,则$a^p \equiv a\pmod{p}$,特别的,若$P$不整除$a$,则$a^{p-1}\equiv 1 \pmod{p}$——-(<strong>费马小定理</strong>)</p><h3 id="欧拉函数及其一些性质"><a href="#欧拉函数及其一些性质" class="headerlink" title="欧拉函数及其一些性质:"></a>欧拉函数及其一些性质:</h3><ul><li><p>$φ(m) = \prod\limits_{p|m}(1-\dfrac{1}{p})$——-(欧拉函数表达式)</p></li><li><p>当$a$与$b$互质时,$φ(ab) = φ(a)φ(b)$——-(数论函数基本定理)</p></li><li><p>若$p$是质数且$a≥1$,有$φ(m) = p^a - p^{a-1}$</p></li><li><p>$(a,b) = d$,有$φ(ab) = φ(a)φ(b)\dfrac{d}{φ(d)}$</p></li></ul><p>证明:</p><center>\begin{split}\dfrac{φ(ab)}{ab}&=\prod\limits_{p|ab}(1-\dfrac{1}{p})\\&=\dfrac{\prod\limits_{p|a}(1-\dfrac{1}{p})\prod\limits_{p|b}(1-\dfrac{1}{p})}{\prod\limits_{p|d}(1-\dfrac{1}{p})}\\&=\dfrac{\dfrac{φ(a)}{a}\dfrac{φ(b)}{b}}{\dfrac{φ(d)}{d}}\\&=\dfrac{φ(a)φ(b)}{ab}·\dfrac{d}{φ(d)}\end{split}</center><p>因此$φ(ab) = φ(a)φ(b)\dfrac{d}{φ(d)}$</p><p>证毕。</p><ul><li><p>设$p$为质数,若$p|n$且$p^2|n$,则$φ(n) = φ(\dfrac{n}{p})·p$</p></li><li><p>设$p$为质数,若$p|n$且$p^2!|n$,则$φ(n) = φ(\dfrac{n}{p})·(p-1)$</p></li></ul><p><del>其实这玩意当时是我写着练习latex格式用的</del></p><p><del>未来有空或许会补完?</del></p><p>2022/6/30</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P1081 开车旅行</title>
      <link href="/2020/10/02/p1081/"/>
      <url>/2020/10/02/p1081/</url>
      
        <content type="html"><![CDATA[<h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有$n$个城市,每个城市都有一个海拔$h_i$,两个城市$i,j$之间的距离为$|h_i-h_j|$,现在有两个人$A$和$B$轮流向东开车,$A$每次会选择一个距离第二近的城市,$B$每次会选择一个第一进的城市,当开到最后一个城市或距离超过$x$时停止开车,现在要求:</p><p> 对于一个给定的$x = x_0$,$A$开车距离与$B$开车的距离比值最小,（如果小 $B$ 的行驶路程为 $0$，此时的比值可视为无穷大，且两个无穷大视为相等）,若有多个城市满足,输出海拔最低的那个</p><p>$m$次询问，每次给一个$x$和出发城市$s$,求小$A$开车行驶的总路程数和小$B$开车行驶的总路程数</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>可以发现很多城市下一次的开车决策是不变的,考虑先去把每个城市下一次开到的点预处理出来</p><p>先把所有的值排一次序,建立双向链表</p><p>从$[1,n]$枚举每个城市</p><p>显然离城市$i$最近和次近的城市即为$i-2,i-1,i+1,i+2$中的两个</p><p>每次选完后把该城市删除即可</p><p>先来看第一问</p><p>直接枚举每个点,暴力模拟开车过程肯定是不行的,复杂度过不了</p><p>发现中间很多开车过程都是无用的,考虑倍增优化</p><p>设$f<em>{i,j,0/1}$表示从$j$城市出发,开车$2^i$天,$A/B$先开车开到的城市,$dis</em>{0/1,i,j,0/1}$表示$A/B$从城市$j$出发,开了$2^i$天,$A/B$形式的距离</p><p>根据倍增的性质($2^i = 2^{i-1}×2^{i-1}$),有转移:</p><p>$f<em>{i,j,k} = f</em>{i-1,f(i-1,j,k),k}$ </p><p>$dis<em>{0/1,i,j,k} = dis</em>{0/1,i-1,f<em>{i-1,j,k}}+dis</em>{0/1,i-1,j,k}$  </p><p>注意:$i=1$时前后两天不是同一个人开车,需要特判</p><p>枚举每个点,像$LCA$那样从大到小往前跳即可</p><p>操作2也同理</p><p> <strong>几个坑点</strong></p><ul><li><p>链表中要判定当前位置的前驱和后继不存在的情况</p></li><li><p>$i=1$时要特判</p></li><li><p>比值的除法要转化为乘法,否则会出现一些奇奇怪怪的精度问题</p></li><li><p>注意特判$B$开车距离为$0$时的情况</p></li></ul><h2 id="code"><a href="#code" class="headerlink" title="$code$"></a>$code$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//细节有亿点多</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> now ((i==1)?k^1:k)<span class="comment">//i=1时的特判</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100005</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">int</span> ansa = <span class="number">1</span>,ansb,best;</span><br><span class="line"><span class="type">int</span> pos[MAXN],n;</span><br><span class="line"><span class="type">int</span> f[<span class="number">30</span>][MAXN][<span class="number">2</span>],dis[<span class="number">2</span>][<span class="number">30</span>][MAXN][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> x0,s,x,m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cc</span>&#123;</span><br><span class="line"><span class="type">int</span> min1,min2;</span><br><span class="line">&#125;drive[MAXN];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">c</span>&#123;</span><br><span class="line"><span class="type">int</span> id,pre,next,val;</span><br><span class="line">&#125;city[MAXN];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(c a,c b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.val&lt;b.val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">g</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> id)</span></span>&#123;<span class="comment">//选次大的城市</span></span><br><span class="line"><span class="keyword">if</span>(!a) <span class="keyword">return</span> city[b].id;<span class="comment">//特判不存在的情况</span></span><br><span class="line"><span class="keyword">if</span>(!b) <span class="keyword">return</span> city[a].id;</span><br><span class="line"><span class="keyword">if</span>(city[id].val-city[a].val&lt;=city[b].val-city[id].val)</span><br><span class="line"><span class="keyword">return</span> city[a].id;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> city[b].id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="comment">//删除操作</span></span><br><span class="line"><span class="keyword">if</span>(city[x].next) city[city[x].next].pre = city[x].pre;</span><br><span class="line"><span class="keyword">if</span>(city[x].pre) city[city[x].pre].next = city[x].next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prepare</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">sort</span>(city+<span class="number">1</span>,city+<span class="number">1</span>+n,cmp);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) pos[city[i].id] = i,city[i].next = i+<span class="number">1</span>,city[i].pre = i<span class="number">-1</span>;<span class="comment">//建立链表和映射</span></span><br><span class="line">city[<span class="number">1</span>].pre = <span class="number">0</span>,city[n].next = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="type">int</span> pre = city[pos[i]].pre,next = city[pos[i]].next;</span><br><span class="line"><span class="keyword">if</span>(pre&amp;&amp;(city[pos[i]].val - city[pre].val&lt;=city[next].val-city[pos[i]].val||!next))&#123;</span><br><span class="line">drive[i].min2 = city[pre].id;</span><br><span class="line">drive[i].min1 = <span class="built_in">g</span>(city[pre].pre,next,pos[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">drive[i].min2 = city[next].id;</span><br><span class="line">drive[i].min1 = <span class="built_in">g</span>(pre,city[next].next,pos[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">del</span>(pos[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">cin&gt;&gt;city[i].val;</span><br><span class="line">city[i].id = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">prepare</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">if</span>(drive[i].min1)&#123;</span><br><span class="line">f[<span class="number">0</span>][i][<span class="number">0</span>] = drive[i].min1;</span><br><span class="line">dis[<span class="number">0</span>][<span class="number">0</span>][i][<span class="number">0</span>] = <span class="built_in">abs</span>(city[pos[i]].val - city[pos[drive[i].min1]].val);</span><br><span class="line">dis[<span class="number">1</span>][<span class="number">0</span>][i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(drive[i].min2)&#123;</span><br><span class="line">f[<span class="number">0</span>][i][<span class="number">1</span>] = drive[i].min2;</span><br><span class="line">dis[<span class="number">0</span>][<span class="number">0</span>][i][<span class="number">1</span>]= <span class="number">0</span>;</span><br><span class="line">dis[<span class="number">1</span>][<span class="number">0</span>][i][<span class="number">1</span>] = <span class="built_in">abs</span>(city[pos[i]].val - city[pos[drive[i].min2]].val);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> t = ((<span class="built_in">log</span>(n)/<span class="built_in">log</span>(<span class="number">2</span>)+<span class="number">1</span>));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;i++)&#123;<span class="comment">//转移</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=<span class="number">1</span>;k++)&#123;</span><br><span class="line"><span class="keyword">if</span>(f[i<span class="number">-1</span>][j][k]) f[i][j][k] = f[i<span class="number">-1</span>][f[i<span class="number">-1</span>][j][k]][now];</span><br><span class="line"><span class="keyword">if</span>(f[i][j][k])&#123;</span><br><span class="line">dis[<span class="number">0</span>][i][j][k] = dis[<span class="number">0</span>][i<span class="number">-1</span>][j][k]+dis[<span class="number">0</span>][i<span class="number">-1</span>][f[i<span class="number">-1</span>][j][k]][now];</span><br><span class="line">dis[<span class="number">1</span>][i][j][k] = dis[<span class="number">1</span>][i<span class="number">-1</span>][j][k]+dis[<span class="number">1</span>][i<span class="number">-1</span>][f[i<span class="number">-1</span>][j][k]][now];</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cin&gt;&gt;x0;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="type">int</span> disa =<span class="number">0</span>,disb = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> k = <span class="number">0</span>,value = x0;</span><br><span class="line"><span class="type">int</span> s = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=t;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line"><span class="keyword">if</span>(f[j][s][k]&amp;&amp;value&gt;=dis[<span class="number">0</span>][j][s][k]+dis[<span class="number">1</span>][j][s][k])&#123;<span class="comment">//倍增跳</span></span><br><span class="line">value-=dis[<span class="number">0</span>][j][s][k]+dis[<span class="number">1</span>][j][s][k];</span><br><span class="line">disa+=dis[<span class="number">0</span>][j][s][k],disb+=dis[<span class="number">1</span>][j][s][k];</span><br><span class="line"><span class="keyword">if</span>(!j) k^=<span class="number">1</span>;</span><br><span class="line">s = f[j][s][k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!disb) disa = <span class="number">1</span>;<span class="comment">//disb为0时,比值为无限大</span></span><br><span class="line"><span class="keyword">if</span>(disa*ansb&lt;disb*ansa)&#123;<span class="comment">//除转乘</span></span><br><span class="line">ansa = disa,ansb = disb,best = i;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(disa*ansb==disb*ansa&amp;&amp;city[pos[i]].val&gt;city[pos[best]].val)&#123;<span class="comment">//选海拔低的那个点</span></span><br><span class="line">ansa = disa,ansb = disb,best = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;best&lt;&lt;endl;</span><br><span class="line">cin&gt;&gt;m;</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line"><span class="type">int</span> x0,s;</span><br><span class="line">cin&gt;&gt;s&gt;&gt;x0;</span><br><span class="line"><span class="type">int</span> disa =<span class="number">0</span>,disb = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> k = <span class="number">0</span>,value = x0;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=t;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line"><span class="keyword">if</span>(f[j][s][k]&amp;&amp;value&gt;=dis[<span class="number">0</span>][j][s][k]+dis[<span class="number">1</span>][j][s][k])&#123;</span><br><span class="line">value-=dis[<span class="number">0</span>][j][s][k]+dis[<span class="number">1</span>][j][s][k];</span><br><span class="line">disa+=dis[<span class="number">0</span>][j][s][k],disb+=dis[<span class="number">1</span>][j][s][k];</span><br><span class="line"><span class="keyword">if</span>(!j) k^=<span class="number">1</span>;</span><br><span class="line">s = f[j][s][k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;disa&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;disb&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P1450 [HAOI2008]硬币购物</title>
      <link href="/2020/09/30/p1450/"/>
      <url>/2020/09/30/p1450/</url>
      
        <content type="html"><![CDATA[<h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有 $4$ 种硬币。面值分别为 $c_1,c_2,c_3,c_4$</p><p>现在有$d_i$枚 $i$ 种硬币,要买一个价值为$s$的商品,求购买方案总数</p><p>$s≤10^5$ </p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>容斥$+dp$</p><p>挺nb的一道$dp$</p><p>如果直接做一次多重背包,显然$T$飞</p><p>通过观察可以发现, 总方案数$=$无硬币数量限制的方案总数$-$不合法的方案数</p><h4 id="对于无硬币数量限制的方案"><a href="#对于无硬币数量限制的方案" class="headerlink" title="对于无硬币数量限制的方案:"></a>对于无硬币数量限制的方案:</h4><p>设$f[i]$表示无硬币数量限制时买$i$元钱的物品有多少种购买方法</p><p>直接上完全背包的板子即可</p><h4 id="对于不合法的方案"><a href="#对于不合法的方案" class="headerlink" title="对于不合法的方案:"></a>对于不合法的方案:</h4><p>一个方案不合法,当且仅当他花了$d_i$以上个硬币</p><p>方案数即为$f<a href="s≥(d_i+1">s - (d_i+1)×c_i</a>×c<em>i)$,将答案减去$\sum</em>{i=1} ^4f<a href="s≥(d_i+1">s - (d_i+1)×c_i</a>×c_i)$即可</p><p>但由于两种方案间可能会有交集,会将两个方案的交集多减一次,需要容斥</p><p>对于任意两个方案集合$N$和$M$,有:</p><p>$N∩M = N+M-N∪M =f[s - (d_N+1)×c_N -(d_M+1)×c_M]$</p><p>将两种方案数的交集重新加进答案即可</p><p><img src="https://img2020.cnblogs.com/blog/2092833/202009/2092833-20200930224735277-917935686.png" alt=""></p><p>同时,由于交集之间可能还会有交集,又会加重,需要再次减去交集和交集间的交集,方法和前面的类似,以此类推</p><p>使用二进制枚举子集或直接手动枚举每种情况即可</p><h2 id="code"><a href="#code" class="headerlink" title="$code$"></a>$code$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ie(i) ((d[i]+1)*c[i])</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100000</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long </span></span><br><span class="line"><span class="type">int</span> f[MAXN+<span class="number">10</span>],n,d[<span class="number">10</span>],c[<span class="number">10</span>],m;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++) cin&gt;&gt;c[i];</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=c[i];j&lt;=MAXN;j++)</span><br><span class="line">f[j]+=f[j-c[i]];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"><span class="keyword">while</span>(n--)&#123;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/*if(s&gt;=ie(1)) ans-=f[s-ie(1)];</span></span><br><span class="line"><span class="comment">  if(s&gt;=ie(2)) ans-=f[s-ie(2)];</span></span><br><span class="line"><span class="comment">  if(s&gt;=ie(3)) ans-=f[s-ie(3)];</span></span><br><span class="line"><span class="comment">  if(s&gt;=ie(4)) ans-=f[s-ie(4)];</span></span><br><span class="line"><span class="comment">      if(s&gt;=ie(1)+ie(2)) ans+=f[s-ie(1)-ie(2)];</span></span><br><span class="line"><span class="comment">  if(s&gt;=ie(1)+ie(3)) ans+=f[s-ie(1)-ie(3)];</span></span><br><span class="line"><span class="comment">  if(s&gt;=ie(1)+ie(4)) ans+=f[s-ie(1)-ie(4)];</span></span><br><span class="line"><span class="comment">  if(s&gt;=ie(2)+ie(3)) ans+=f[s-ie(2)-ie(3)];</span></span><br><span class="line"><span class="comment">  if(s&gt;=ie(2)+ie(4)) ans+=f[s-ie(2)-ie(4)];</span></span><br><span class="line"><span class="comment">  if(s&gt;=ie(3)+ie(4)) ans+=f[s-ie(3)-ie(4)];</span></span><br><span class="line"><span class="comment">  if(s&gt;=ie(1)+ie(2)+ie(4)) ans-=f[s-ie(1)-ie(2)-ie(4)];</span></span><br><span class="line"><span class="comment">  if(s&gt;=ie(1)+ie(2)+ie(3)) ans-=f[s-ie(1)-ie(2)-ie(3)];</span></span><br><span class="line"><span class="comment">  if(s&gt;=ie(1)+ie(3)+ie(4)) ans-=f[s-ie(1)-ie(3)-ie(4)];</span></span><br><span class="line"><span class="comment">  if(s&gt;=ie(2)+ie(3)+ie(4)) ans-=f[s-ie(2)-ie(3)-ie(4)];</span></span><br><span class="line"><span class="comment">  if(s&gt;=ie(1)+ie(2)+ie(3)+ie(4)) ans+=f[s-ie(1)-ie(2)-ie(3)-ie(4)];*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">4</span>;j++) cin&gt;&gt;d[j];</span><br><span class="line">cin&gt;&gt;m;</span><br><span class="line">ans = f[m];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> s=<span class="number">1</span>;s&lt;=<span class="number">15</span>;s++)&#123;</span><br><span class="line"><span class="type">int</span> now = m, k=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> sub = s,j=<span class="number">1</span>;sub;sub&gt;&gt;=<span class="number">1</span>,j++)</span><br><span class="line"><span class="keyword">if</span>(sub&amp;<span class="number">1</span>) k^=<span class="number">1</span>,now-=<span class="built_in">ie</span>(j);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(now&gt;=<span class="number">0</span>) k?ans-=f[now]:ans+=f[now];</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P3891 [GDOI2014]采集资源</title>
      <link href="/2020/09/29/p3891/"/>
      <url>/2020/09/29/p3891/</url>
      
        <content type="html"><![CDATA[<h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有$m$块钱,$n$种苦工,每个苦工都有一个购入值$a_i$和每秒收入$b_i$,求让总钱数达到$t$的最少时间</p><p>$n≤100，m,t≤1000, a_i,b_i≤2^{31}$</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>考虑到每秒钟的决策和花费金钱数及当前每秒收入量有关,且这里的<strong>每秒收入量数值较大</strong>,不妨设$f(i,j)$表示在前$i$秒总钱数为$j$时的每秒收入量</p><p>设该秒花费的钱数为$k$,花$k$元钱能买到的最大收入量为$v_k$,有显然的转移: </p><center>$f(i,j) = max(f(i-1,j+k-f(i-1,j+k)-v_k)+v_k)$</center><p>总钱数达到$t$时输出$i$即可</p><p>小坑点:初始钱数大于t时直接输出0</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//xcxc82 2021/7/30</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1010</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> X=<span class="number">0</span>; <span class="type">bool</span> flag=<span class="number">1</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) flag=<span class="number">0</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">if</span>(flag) <span class="keyword">return</span> X;<span class="keyword">return</span> ~(X<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,t;</span><br><span class="line"><span class="type">int</span> a[MAXN],b[MAXN];</span><br><span class="line"><span class="type">int</span> f[MAXN][MAXN],g[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n = <span class="built_in">read</span>(),m = <span class="built_in">read</span>(),t = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">if</span>(m&gt;=t)&#123;</span><br><span class="line">cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">a[i] =<span class="built_in">read</span>(),b[i] = <span class="built_in">read</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">-1</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line"><span class="built_in">memset</span>(g,<span class="number">-1</span>,<span class="built_in">sizeof</span>(g));</span><br><span class="line">g[<span class="number">0</span>] = <span class="number">0</span>,f[<span class="number">0</span>][m] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=a[i];j&lt;=<span class="number">1000</span>;j++)&#123;</span><br><span class="line">g[j] = <span class="built_in">max</span>(g[j],g[j-a[i]]+b[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">1000</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=t;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(f[i][j]!=<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=j;k++)&#123;</span><br><span class="line">f[i+<span class="number">1</span>][j-k+g[k]+f[i][j]] = <span class="built_in">max</span>(g[k]+f[i][j],f[i+<span class="number">1</span>][j-k+g[k]+f[i][j]]);</span><br><span class="line"><span class="keyword">if</span>(j-k+g[k]+f[i][j]&gt;=t)&#123;</span><br><span class="line">cout&lt;&lt;i+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重构于2021/7/30</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>splay学习笔记</title>
      <link href="/2020/09/26/splay%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/09/26/splay%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p>一种二叉树的树形数据结构，其定义如下：</p><ul><li><p>左子树上的所有节点的权值均小于其根节点的权值</p></li><li><p>右子树上的所有节点的权值均大于其根节点的权值</p></li><li><p>二叉搜索树的左右子树均为二叉搜索树</p></li></ul><h1 id="Splay"><a href="#Splay" class="headerlink" title="Splay"></a>Splay</h1><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>一种自平衡二叉搜索树，通过不断将某个节点旋转到根节点,使得整棵树仍然满足二叉查找树的性质，且保持平衡而不至于退化为链</p><h3 id="维护的信息"><a href="#维护的信息" class="headerlink" title="维护的信息"></a>维护的信息</h3><div class="table-container"><table><thead><tr><th style="text-align:right">$root$</th><th style="text-align:right">$tot$</th><th style="text-align:right">$fa[i]$</th><th style="text-align:right">$child[i][0/1]$</th><th style="text-align:right">$val[i]$</th><th style="text-align:right">$cnt[i]$</th><th style="text-align:right">$size[i]$</th></tr></thead><tbody><tr><td style="text-align:right">根节点</td><td style="text-align:right">节点总数</td><td style="text-align:right">父亲</td><td style="text-align:right">左右儿子</td><td style="text-align:right">点权</td><td style="text-align:right">出现次数</td><td style="text-align:right">子树大小</td></tr></tbody></table></div><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul><li><p>$update(x)$ 更新$x$节点的$size$</p></li><li><p>$clear(x)$ 摧毁节点$x$</p></li><li><p>$get(x)$ 判断$x$是其父亲的左儿子还是右儿子</p></li></ul><h3 id="code"><a href="#code" class="headerlink" title="$code$"></a>$code$</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;child[x][<span class="number">0</span>] = child[x][<span class="number">1</span>] = size[x] = fa[x] = val[x] = <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">if</span>(!x) <span class="keyword">return</span>; size[x] = size[child[x][<span class="number">0</span>]]+size[child[x][<span class="number">1</span>]]+<span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x==child[fa[x]][<span class="number">1</span>];&#125;</span><br></pre></td></tr></table></figure><ul><li><h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2></li></ul><p>为调换$Splay$中父子节点的位置,我们使用旋转操作,将一个节点向上移动一个位置,并保证:</p><ul><li><p>整棵$Splay$的中序遍历不变</p></li><li><p>受影响的节点维护的信息依然正确有效</p></li><li><p>$root$必须指向旋转后的根节点</p></li></ul><h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><p><img src="https://img2020.cnblogs.com/blog/2092833/202009/2092833-20200926185814991-1893107179.gif" alt=""></p><p>$Splay$中的旋转分为两种,左旋和右旋,这里以右旋为例:</p><p>旋转分为四个步骤$:$</p><p>(假设需要旋转的节点为$x$,其父亲为$y$)</p><p>$1.$将$y$的左儿子指向$x$的右儿子,且$x$的右儿子的父亲指向$y$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">child[y][<span class="number">0</span>] = child[x][<span class="number">1</span>];</span><br><span class="line">fa[child[x][<span class="number">1</span>]] = y;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>$2.$将$x$的右儿子指向$y$，且$y$的父亲指向$x$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">child[x][<span class="number">1</span>] = y;</span><br><span class="line">fa[y] = x;</span><br></pre></td></tr></table></figure><p>$3.$如果$y$还有父亲$z$,将$y$原来在$z$中所在的位置指向$x$,且$x$的父亲指向$y$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fa[x] = z;</span><br><span class="line">child[z][y==child[z][<span class="number">1</span>]] = x;</span><br></pre></td></tr></table></figure><p>$4.$更新$x$和$y$的$size$</p><h3 id="code-1"><a href="#code-1" class="headerlink" title="$code$"></a>$code$</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> y = fa[x],z=fa[y];</span><br><span class="line"><span class="type">int</span> chy = <span class="built_in">get</span>(x),chx = chy^<span class="number">1</span>;</span><br><span class="line">child[y][chy] = child[x][chx];</span><br><span class="line">fa[child[x][chx]] = y;</span><br><span class="line">child[x][chx] = y;</span><br><span class="line">fa[y] = x;</span><br><span class="line">fa[x] = z;</span><br><span class="line"><span class="keyword">if</span>(z) child[z][y==child[z][<span class="number">1</span>]] = x;</span><br><span class="line"><span class="built_in">update</span>(y),<span class="built_in">update</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h2 id="Splay-操作"><a href="#Splay-操作" class="headerlink" title="$Splay$操作"></a>$Splay$操作</h2></li></ul><p>$Splay$规定,每访问一个节点后,都要强制将该节点旋转到根的位置</p><h3 id="具体步骤-1"><a href="#具体步骤-1" class="headerlink" title="具体步骤"></a>具体步骤</h3><p>为保证不退化成链,$Splay$操作一共分三步</p><p>$1.$如果父节点为目标位置,则向上旋转</p><p>$2.$如果<strong>当前节点与父节点的“关系”和父节点与祖父节点的“关系”相同</strong>，则先旋转父节点，再旋转自身</p><p>$3.$如果不满足以上条件,则将自身连续旋转两次</p><p>重复以上操作,直到旋转到根</p><h3 id="code-2"><a href="#code-2" class="headerlink" title="$code$"></a>$code$</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> goal)</span></span>&#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> f; (f=fa[x])!=goal; <span class="built_in">rotate</span>(x))&#123;</span><br><span class="line">    <span class="keyword">if</span> (fa[f]!=goal) <span class="built_in">rotate</span>(<span class="built_in">get</span>(x)==<span class="built_in">get</span>(f)?f:x);</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> (!goal) root=x;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2></li></ul><p>设插入的值为$k$</p><ul><li>若树为空树,直接插入根</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!root)&#123;</span><br><span class="line">val[++tot] = k;</span><br><span class="line">cnt[tot]++;</span><br><span class="line">root = tot;</span><br><span class="line"><span class="built_in">update</span>(root);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>否则,根据二叉搜索树的性质向下查找,直到查找到权值等于$k$的节点或空节点</li></ul><p>同时需要将该节点$Splay$到根的位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> now = root,f = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(val[now]==k)&#123;</span><br><span class="line">cnt[now]++;</span><br><span class="line"><span class="built_in">update</span>(now);</span><br><span class="line"><span class="built_in">update</span>(f);</span><br><span class="line"><span class="built_in">Splay</span>(now);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">f = now;</span><br><span class="line">now = child[now][val[now]&lt;k];</span><br><span class="line"><span class="keyword">if</span>(!now)&#123;</span><br><span class="line">val[++tot] = k;</span><br><span class="line">cnt[tot]++;</span><br><span class="line">fa[tot] = f;</span><br><span class="line">child[f][val[f]&lt;k] = tot;</span><br><span class="line"><span class="built_in">update</span>(tot);</span><br><span class="line"><span class="built_in">update</span>(f);</span><br><span class="line"><span class="built_in">Splay</span>(tot);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h2 id="排名"><a href="#排名" class="headerlink" title="排名"></a>排名</h2></li><li><h3 id="查询给定值的排名"><a href="#查询给定值的排名" class="headerlink" title="查询给定值的排名"></a>查询给定值的排名</h3><p>设$x$为需要查询的值</p></li></ul><p>根据二叉搜索树的性质:</p><ul><li><p>若$x$比当前节点的权值小,向左子树查找</p></li><li><p>若$x$比当前节点的权值大，将答案$ans$加上左子树的$size$和当前节点$cnt$的大小,向其右子树查找。</p></li><li><p>若$x$与当前节点的权值相同,返回$ans+1$</p></li></ul><h3 id="code-3"><a href="#code-3" class="headerlink" title="$code$"></a>$code$</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">rank</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>,now = root;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(k&lt;val[now]) now = child[now][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">ans+=size[child[now][<span class="number">0</span>]];</span><br><span class="line"><span class="keyword">if</span>(k==val[now])&#123;</span><br><span class="line"><span class="built_in">Splay</span>(now);</span><br><span class="line"><span class="keyword">return</span> ans+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">ans+=cnt[now];</span><br><span class="line">now = child[now][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h3 id="查询给定排名的值"><a href="#查询给定排名的值" class="headerlink" title="查询给定排名的值"></a>查询给定排名的值</h3></li></ul><p>设$k$为剩余排名,根据二叉搜索树的性质:</p><ul><li><p>若$k$小于左子树的$size$且左子树非空,向左子树查找</p></li><li><p>否则将$k$减去左子树的大小和根的$cnt$</p><p>若此时$k$的值小于等于$0$,返回根节点的权值</p><p>否则继续向右子树查找</p><h3 id="code-4"><a href="#code-4" class="headerlink" title="$code$"></a>$code$</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">kth</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> now = root;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(child[now][<span class="number">0</span>]&amp;&amp;k&lt;=size[child[now][<span class="number">0</span>]])&#123;</span><br><span class="line">now = child[now][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">k-=cnt[now]+size[child[now][<span class="number">0</span>]];</span><br><span class="line"><span class="keyword">if</span>(k&lt;=<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">Splay</span>(now);</span><br><span class="line"><span class="keyword">return</span> val[now];</span><br><span class="line">&#125;</span><br><span class="line">now = child[now][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><h2 id="前驱-amp-amp-后继"><a href="#前驱-amp-amp-后继" class="headerlink" title="前驱&amp;&amp;后继"></a>前驱&amp;&amp;后继</h2></li></ul><p>一个数的前驱定义为小于$x$的最大的数</p><p>后继定义为大于$x$的最小的数</p><p>显然,一个数的前驱是其左子树中最靠右的节点,后继是其右子树的最靠左的节点</p><p>将$x$旋转到根后查询即可</p><h3 id="code-5"><a href="#code-5" class="headerlink" title="$code$"></a>$code$</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pre</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="type">int</span> now = child[root][<span class="number">0</span>];</span><br><span class="line">     <span class="keyword">while</span>(child[now][<span class="number">1</span>]) now = child[now][<span class="number">1</span>];</span><br><span class="line">     <span class="keyword">return</span> now;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="type">int</span> now = child[root][<span class="number">1</span>];</span><br><span class="line">   <span class="keyword">while</span>(child[now][<span class="number">0</span>]) now = child[now][<span class="number">0</span>];</span><br><span class="line">   <span class="keyword">return</span> now;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li><h2 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h2></li></ul><p>首先将要删除的节点$x$旋转到根的位置</p><ul><li>如果有不止一个$x$,那么直接将$cnt[x]$减$1$即可</li></ul><p>否则</p><ul><li><p>若没有儿子节点,直接将当前节点清空</p></li><li><p>若只有一个儿子,清空当前节点,再把根节点跟新为儿子</p></li><li><p>若有两个儿子,先将$x$的前驱旋转到根,并将$x$的右子树连接到$x$的前驱上</p></li></ul><h3 id="code-6"><a href="#code-6" class="headerlink" title="$code$"></a>$code$</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="built_in">rank</span>(k);</span><br><span class="line"><span class="keyword">if</span>(cnt[root]&gt;<span class="number">1</span>)&#123;</span><br><span class="line">cnt[root]--;</span><br><span class="line"><span class="built_in">update</span>(root);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!child[root][<span class="number">0</span>]&amp;&amp;!child[root][<span class="number">1</span>])&#123;</span><br><span class="line"><span class="built_in">clear</span>(root);</span><br><span class="line">root = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!child[root][<span class="number">0</span>])&#123;</span><br><span class="line"><span class="type">int</span> now = root;</span><br><span class="line">root = child[root][<span class="number">1</span>];</span><br><span class="line">fa[root] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">clear</span>(now);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!child[root][<span class="number">1</span>])&#123;</span><br><span class="line"><span class="type">int</span> now = root;</span><br><span class="line">root = child[root][<span class="number">0</span>];</span><br><span class="line">fa[root] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">clear</span>(now);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> now = root,x = <span class="built_in">pre</span>();</span><br><span class="line">fa[child[now][<span class="number">1</span>]] = x;</span><br><span class="line">child[x][<span class="number">1</span>] = child[now][<span class="number">1</span>];</span><br><span class="line"><span class="built_in">clear</span>(now);</span><br><span class="line"><span class="built_in">update</span>(root);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100005</span>;</span><br><span class="line"><span class="type">int</span> child[MAXN][<span class="number">2</span>],size[MAXN],root,tot,fa[MAXN],val[MAXN],cnt[MAXN];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ci(Q) scanf(<span class="string">&quot;%d&quot;</span>,&amp;Q)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">splay</span>&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;size[x] = size[child[x][<span class="number">0</span>]]+size[child[x][<span class="number">1</span>]]+cnt[x];&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x==child[fa[x]][<span class="number">1</span>];&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;fa[x] = child[x][<span class="number">0</span>] = child[x][<span class="number">1</span>] = size[x] = val[x] = cnt[x] = <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> y = fa[x] , z = fa[y];</span><br><span class="line"><span class="type">int</span> chy = <span class="built_in">pd</span>(x) ,chx = chy^<span class="number">1</span>;</span><br><span class="line">child[y][chy] = child[x][chx];</span><br><span class="line">fa[child[x][chx]] = y;</span><br><span class="line">child[x][chx] = y,fa[y] = x,fa[x] = z;</span><br><span class="line"><span class="keyword">if</span>(z) child[z][y==child[z][<span class="number">1</span>]] = x;</span><br><span class="line"><span class="built_in">update</span>(x),<span class="built_in">update</span>(y);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Splay</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> f = fa[x];f=fa[x],f;<span class="built_in">rotate</span>(x))&#123;</span><br><span class="line"><span class="keyword">if</span>(fa[f]) <span class="built_in">rotate</span>(<span class="built_in">pd</span>(x)==<span class="built_in">pd</span>(f)?f:x);</span><br><span class="line">&#125;</span><br><span class="line">root = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!root)&#123;</span><br><span class="line">val[++tot] = k;</span><br><span class="line">cnt[tot]++;</span><br><span class="line">root = tot;</span><br><span class="line"><span class="built_in">update</span>(root);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> now = root,f = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(val[now]==k)&#123;</span><br><span class="line">cnt[now]++;</span><br><span class="line"><span class="built_in">update</span>(now);</span><br><span class="line"><span class="built_in">update</span>(f);</span><br><span class="line"><span class="built_in">Splay</span>(now);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">f = now;</span><br><span class="line">now = child[now][val[now]&lt;k];</span><br><span class="line"><span class="keyword">if</span>(!now)&#123;</span><br><span class="line">val[++tot] = k;</span><br><span class="line">cnt[tot]++;</span><br><span class="line">fa[tot] = f;</span><br><span class="line">child[f][val[f]&lt;k] = tot;</span><br><span class="line"><span class="built_in">update</span>(tot);</span><br><span class="line"><span class="built_in">update</span>(f);</span><br><span class="line"><span class="built_in">Splay</span>(tot);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rank</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>,now = root;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(k&lt;val[now]) now = child[now][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">ans+=size[child[now][<span class="number">0</span>]];</span><br><span class="line"><span class="keyword">if</span>(k==val[now])&#123;</span><br><span class="line"><span class="built_in">Splay</span>(now);</span><br><span class="line"><span class="keyword">return</span> ans+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">ans+=cnt[now];</span><br><span class="line">now = child[now][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kth</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> now = root;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(child[now][<span class="number">0</span>]&amp;&amp;k&lt;=size[child[now][<span class="number">0</span>]])&#123;</span><br><span class="line">now = child[now][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">k-=cnt[now]+size[child[now][<span class="number">0</span>]];</span><br><span class="line"><span class="keyword">if</span>(k&lt;=<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">Splay</span>(now);</span><br><span class="line"><span class="keyword">return</span> val[now];</span><br><span class="line">&#125;</span><br><span class="line">now = child[now][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pre</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> now = child[root][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">while</span>(child[now][<span class="number">1</span>]) now = child[now][<span class="number">1</span>];</span><br><span class="line"><span class="built_in">Splay</span>(now);</span><br><span class="line"><span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> now = child[root][<span class="number">1</span>];</span><br><span class="line"><span class="keyword">while</span>(child[now][<span class="number">0</span>]) now = child[now][<span class="number">0</span>];</span><br><span class="line"><span class="built_in">Splay</span>(now);</span><br><span class="line"><span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="built_in">rank</span>(k);</span><br><span class="line"><span class="keyword">if</span>(cnt[root]&gt;<span class="number">1</span>)&#123;</span><br><span class="line">cnt[root]--;</span><br><span class="line"><span class="built_in">update</span>(root);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!child[root][<span class="number">0</span>]&amp;&amp;!child[root][<span class="number">1</span>])&#123;</span><br><span class="line"><span class="built_in">clear</span>(root);</span><br><span class="line">root = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!child[root][<span class="number">0</span>])&#123;</span><br><span class="line"><span class="type">int</span> now = root;</span><br><span class="line">root = child[root][<span class="number">1</span>];</span><br><span class="line">fa[root] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">clear</span>(now);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!child[root][<span class="number">1</span>])&#123;</span><br><span class="line"><span class="type">int</span> now = root;</span><br><span class="line">root = child[root][<span class="number">0</span>];</span><br><span class="line">fa[root] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">clear</span>(now);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> now = root,x = <span class="built_in">pre</span>();</span><br><span class="line">fa[child[now][<span class="number">1</span>]] = x;</span><br><span class="line">child[x][<span class="number">1</span>] = child[now][<span class="number">1</span>];</span><br><span class="line"><span class="built_in">clear</span>(now);</span><br><span class="line"><span class="built_in">update</span>(root);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;tree;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n,op,x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;op,&amp;x);</span><br><span class="line"><span class="keyword">if</span>(op==<span class="number">1</span>) tree.<span class="built_in">insert</span>(x);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>) tree.<span class="built_in">del</span>(x);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,tree.<span class="built_in">rank</span>(x));</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">4</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,tree.<span class="built_in">kth</span>(x));</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">5</span>) tree.<span class="built_in">insert</span>(x),<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,val[tree.<span class="built_in">pre</span>()]),tree.<span class="built_in">del</span>(x);</span><br><span class="line"><span class="keyword">else</span> tree.<span class="built_in">insert</span>(x),<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,val[tree.<span class="built_in">next</span>()]),tree.<span class="built_in">del</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文艺平衡树-Splay维护区间信息"><a href="#文艺平衡树-Splay维护区间信息" class="headerlink" title="文艺平衡树(Splay维护区间信息)"></a>文艺平衡树(Splay维护区间信息)</h2><h3 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h3><p>给一个长度为$n$的序列,序列中第$a_i$项的初始值为$i$</p><p>有$m$次区间翻转操作,输出经过 $m$ 次变换后的结果</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>按点的编号建立一颗$Splay$</p><p>每次翻转时</p><p>先将$val = l-1$和$val = r+1$的节点分别转到根和根的儿子节点</p><p>根据$Splay$的性质,整颗树的中序遍历不变</p><p>因此只需要将$child[child[root][1]][0]$下的所有子树交换</p><p>通过给打懒标记的方式来实现交换操作即可</p><h3 id="code-7"><a href="#code-7" class="headerlink" title="$code$"></a>$code$</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100005</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">114514191</span>;</span><br><span class="line"><span class="type">int</span> child[MAXN][<span class="number">2</span>],a[MAXN],size[MAXN],root,tot,fa[MAXN],val[MAXN],cnt[MAXN],tag[MAXN];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Splay</span>&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!tag[x]) <span class="keyword">return</span>;</span><br><span class="line">tag[child[x][<span class="number">1</span>]]^=<span class="number">1</span>;</span><br><span class="line">tag[child[x][<span class="number">0</span>]]^=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">swap</span>(child[x][<span class="number">1</span>],child[x][<span class="number">0</span>]);</span><br><span class="line">tag[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;size[x] = size[child[x][<span class="number">0</span>]]+size[child[x][<span class="number">1</span>]]+cnt[x];&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x==child[fa[x]][<span class="number">1</span>];&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;fa[x] = child[x][<span class="number">0</span>] = child[x][<span class="number">1</span>] = size[x] = val[x] = cnt[x] = <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> y = fa[x] , z = fa[y];</span><br><span class="line"><span class="type">int</span> chy = <span class="built_in">pd</span>(x) ,chx = chy^<span class="number">1</span>;</span><br><span class="line">child[y][chy] = child[x][chx];</span><br><span class="line">fa[child[x][chx]] = y;</span><br><span class="line">child[x][chx] = y,fa[y] = x,fa[x] = z;</span><br><span class="line"><span class="keyword">if</span>(z) child[z][y==child[z][<span class="number">1</span>]] = x;</span><br><span class="line"><span class="built_in">update</span>(x),<span class="built_in">update</span>(y);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> now = ++tot;</span><br><span class="line">fa[now] = f;</span><br><span class="line">cnt[now]++;</span><br><span class="line">val[now] = a[mid];</span><br><span class="line">    size[now]++;</span><br><span class="line">    child[now][<span class="number">0</span>] = <span class="built_in">build</span>(l,mid<span class="number">-1</span>,now);</span><br><span class="line">    child[now][<span class="number">1</span>] = <span class="built_in">build</span>(mid+<span class="number">1</span>,r,now);</span><br><span class="line">    <span class="built_in">update</span>(now);</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> goal)</span></span>&#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> f; (f=fa[x])!=goal; <span class="built_in">rotate</span>(x))&#123;</span><br><span class="line">    <span class="keyword">if</span> (fa[f]!=goal) <span class="built_in">rotate</span>(<span class="built_in">pd</span>(x)==<span class="built_in">pd</span>(f)?f:x);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">if</span> (!goal) root=x;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">kth</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> now = root;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">pushdown</span>(now);</span><br><span class="line"><span class="keyword">if</span>(child[now][<span class="number">0</span>]&amp;&amp;k&lt;=size[child[now][<span class="number">0</span>]])&#123;</span><br><span class="line">now = child[now][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="type">int</span> t = cnt[now]+size[child[now][<span class="number">0</span>]];</span><br><span class="line"><span class="keyword">if</span>(k&lt;=t)&#123;</span><br><span class="line"><span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line">k-=t;</span><br><span class="line">now = child[now][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"> <span class="type">int</span> l = <span class="built_in">kth</span>(x<span class="number">-1</span>),r = <span class="built_in">kth</span>(y+<span class="number">1</span>);</span><br><span class="line"> <span class="built_in">splay</span>(l,<span class="number">0</span>),<span class="built_in">splay</span>(r,l);</span><br><span class="line"> <span class="type">int</span> now = child[root][<span class="number">1</span>];</span><br><span class="line"> now = child[now][<span class="number">0</span>];</span><br><span class="line"> tag[now]^=<span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"> <span class="built_in">pushdown</span>(x);</span><br><span class="line"> <span class="keyword">if</span>(child[x][<span class="number">0</span>]) <span class="built_in">dfs</span>(child[x][<span class="number">0</span>]);</span><br><span class="line"> <span class="keyword">if</span>(val[x]!=inf&amp;&amp;val[x]!=-inf) cout&lt;&lt;val[x]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"> <span class="keyword">if</span>(child[x][<span class="number">1</span>]) <span class="built_in">dfs</span>(child[x][<span class="number">1</span>]); </span><br><span class="line"> &#125;</span><br><span class="line">&#125;tree; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">a[<span class="number">1</span>] = -inf,a[n+<span class="number">2</span>] = inf;<span class="comment">//给区间[1,n]的序列翻转</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i+<span class="number">1</span>] = i;</span><br><span class="line">root = tree.<span class="built_in">build</span>(<span class="number">1</span>,n+<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="type">int</span> l,r;</span><br><span class="line">cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">tree.<span class="built_in">reverse</span>(l+<span class="number">1</span>,r+<span class="number">1</span>);</span><br><span class="line">&#125; </span><br><span class="line">tree.<span class="built_in">dfs</span>(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://oi-wiki.org/ds/splay/">splay-oi-wiki</a></p><p><a href="https://oi.men.ci/splay-notes-1/">Splay 学习笔记（一）-Menci</a></p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>p4135 作诗</title>
      <link href="/2020/09/20/p4135/"/>
      <url>/2020/09/20/p4135/</url>
      
        <content type="html"><![CDATA[<h1 id="P4135-作诗"><a href="#P4135-作诗" class="headerlink" title="P4135 作诗"></a>P4135 作诗</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给定 $n$ 个不大于 $c$ 的正整数$a_1…a_n$ 和 $m$ 组询问，每次问区间$[l,r]$中有多少个数出现正偶数次。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>分块入门题</p><p>设$sum[i][j]$为前$i$个块中第$j$个元素出现的个数</p><p>$ans[i][j]$为第$i$个块到第$j$个块中出现正偶数次的数的个数</p><p>先来考虑如何预处理出$ans[i][j]$</p><p>考虑每个新进来的数对$a[i][j]$的贡献<br>若新进来的数使该数在这几个区间中的出现次数变成了奇数,则答案减一,反之加一</p><p>对于查询</p><p>若$l,r$在同一个块内,直接暴力查询即可</p><p>若$l,r$不在同一个块内:</p><p>对于完整块,其对答案的贡献即为$ans[l+1][r-1]$</p><p>对于不完整块,暴力统计其块内每个数出现的个数,再加上$sum[r-1][a[i]]-sum[l][a[i]]$</p><p>若总出现次数为奇数,则答案加一,反之减一</p><p>复杂度$O(n \sqrt n)$</p><details><summary><font size=4 font face="comic sans MS">code</font></summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;Ofast&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;inline&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fgcse&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fgcse-lm&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fipa-sra&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-ftree-pre&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-ftree-vrp&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fpeephole2&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-ffast-math&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fsched-spec&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;unroll-loops&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-falign-jumps&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-falign-loops&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-falign-labels&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fdevirtualize&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fcaller-saves&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fcrossjumping&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fthread-jumps&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-funroll-loops&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fwhole-program&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-freorder-blocks&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fschedule-insns&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;inline-functions&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-ftree-tail-merge&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fschedule-insns2&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fstrict-aliasing&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fstrict-overflow&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-falign-functions&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fcse-skip-blocks&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fcse-follow-jumps&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fsched-interblock&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fpartial-inlining&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;no-stack-protector&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-freorder-functions&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-findirect-inlining&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fhoist-adjacent-loads&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-frerun-cse-after-loop&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;inline-small-functions&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-finline-small-functions&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-ftree-switch-conversion&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-foptimize-sibling-calls&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fexpensive-optimizations&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-funsafe-loop-optimizations&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;inline-functions-called-once&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fdelete-null-pointer-checks&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> X=<span class="number">0</span>; <span class="type">bool</span> flag=<span class="number">1</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) flag=<span class="number">0</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">if</span>(flag) <span class="keyword">return</span> X;</span><br><span class="line"><span class="keyword">return</span> ~(X<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100010</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> now (sum[y-1][a[i]]-sum[x][a[i]]+b[a[i]])</span></span><br><span class="line"><span class="type">int</span> a[MAXN],belong[MAXN],t[MAXN],n,m,st[MAXN],ed[MAXN],tag[MAXN],num,sum[<span class="number">400</span>][MAXN],ans[<span class="number">400</span>][<span class="number">400</span>],b[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> x = belong[l];</span><br><span class="line"><span class="type">int</span> y = belong[r];</span><br><span class="line"><span class="keyword">if</span>(x==y)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;i++)&#123;</span><br><span class="line">b[a[i]]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!b[a[i]]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(b[a[i]]%<span class="number">2</span>==<span class="number">0</span>) res++;</span><br><span class="line">b[a[i]] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">res = ans[x+<span class="number">1</span>][y<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=ed[x];i++)&#123;</span><br><span class="line">b[a[i]]++;</span><br><span class="line"><span class="keyword">if</span>(now&gt;<span class="number">1</span>&amp;&amp;(now&amp;<span class="number">1</span>)) res--;</span><br><span class="line"><span class="keyword">if</span>(now%<span class="number">2</span>==<span class="number">0</span>) res++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=st[y];i&lt;=r;i++)&#123;</span><br><span class="line">b[a[i]]++;</span><br><span class="line"><span class="keyword">if</span>(now&gt;<span class="number">1</span>&amp;&amp;(now&amp;<span class="number">1</span>)) res--;</span><br><span class="line"><span class="keyword">if</span>(now%<span class="number">2</span>==<span class="number">0</span>) res++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(b,<span class="number">0</span>,<span class="built_in">sizeof</span>(b));</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n = <span class="built_in">read</span>(),num = <span class="built_in">read</span>(),m = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i] = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> size = <span class="built_in">sqrt</span>(n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=size;i++) st[i] = (i<span class="number">-1</span>)*size+<span class="number">1</span>,ed[i] = i*size;</span><br><span class="line">ed[size] = n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=size;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=st[i];j&lt;=ed[i];j++)&#123;</span><br><span class="line">belong[j] = i;</span><br><span class="line">sum[i][a[j]]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=size;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=num;j++)&#123;</span><br><span class="line">sum[i][j] += sum[i<span class="number">-1</span>][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=size;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=st[i];j&lt;=ed[i];j++)&#123;</span><br><span class="line">b[a[j]]++;</span><br><span class="line"><span class="keyword">if</span>(b[a[j]]==<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(b[a[j]]%<span class="number">2</span>==<span class="number">0</span>) ans[i][i]++;</span><br><span class="line"><span class="keyword">else</span> ans[i][i]--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=size;j++)&#123;</span><br><span class="line">ans[i][j] = ans[i][j<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=st[j];k&lt;=ed[j];k++)&#123;</span><br><span class="line">b[a[k]]++;</span><br><span class="line"><span class="keyword">if</span>(b[a[k]]==<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(b[a[k]]%<span class="number">2</span>==<span class="number">0</span>) ans[i][j]++;</span><br><span class="line">    <span class="keyword">else</span> ans[i][j]--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(b,<span class="number">0</span>,<span class="built_in">sizeof</span>(b));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> A = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="type">int</span> l,r;</span><br><span class="line">l = <span class="built_in">read</span>(),r=<span class="built_in">read</span>();</span><br><span class="line">l = (l+A)%n+<span class="number">1</span>,r = (r+A)%n+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l&gt;r) <span class="built_in">swap</span>(l,r);</span><br><span class="line">A = <span class="built_in">query</span>(l,r);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,A);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷⑨月月赛</title>
      <link href="/2020/09/19/%E6%9C%88%E6%9C%88%E8%B5%9B/"/>
      <url>/2020/09/19/%E6%9C%88%E6%9C%88%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<details><summary><font size=4 font face="comic sans MS">T1</font></summary>良心满满的送分水题直接贪心即可</details><hr><details><summary><font size=4 font face="comic sans MS">T2</font></summary>## 大致题意有一个带权方格图,给一个起点$A$,两个终点$B$和$C$,求从$A$到$B$和$C$的两条路径的并集的电阻计量值的和最小。## 分析考虑到不可能有两个分岔口,直接跑三遍最短路,枚举分岔口即可</details><hr><details><summary><font size=4 font face="comic sans MS">T3</font></summary>## T3## 大致题意有 $n$ 节点，每个点都向$[n-1,n-k]$ 中的任意一个点连边。每次可以选择一个连通块权值都减 $1$，求使得所有节点权值都变成 $0$ 的最小次数的数学期望。## 分析把树换成链,就成了一道经典题了 [**P5019 铺设道路**](https://www.luogu.com.cn/problem/P5019)拓展到树上,也就是把前后关系换成了父子关系若一个点的权值比它父亲权值的大,那么在其父亲减完后两点会断开,会增加$a_v - a_u$个操作次数,反之不会增加操作次数对答案的贡献即为:$\dfrac{\sum_{j=i-k}^{i-1} (a_i-a_j)}{k}(a_i>a_j)$对于每个节点,相当于是要求$[max(1,i-k),i-1]$中小于$a_i$的个数,且每个节点能连的点是序列上连续的一段,考虑使用树状数组来维护使用树状数组来维护点数和和权值和即可### 关于T3题目背景#### [【东方MMD】琪露诺想要理解成熟](https://www.bilibili.com/video/BV1iQ4y1M7k2)10.9补[补档](https://www.bilibili.com/video/BV1Bz4y1d7Zy?from=search&seid=4951912842973668234)原作者不知道为啥把视频删了...### 参考资料:[**洛谷9月月赛 题解（模拟+最短路+期望DP+期望DP**）_OceanLiu](https://www.cnblogs.com/Invictus-Ocean/p/13697299.html)[**某古 9 月月赛 I 游记-xiaolilsq**](https://www.cnblogs.com/lsq147/p/13697104.html#%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90)</details><p><details></p><summary><font size=4 font face="comic sans MS">T4</font></summary><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p><strong><a href="https://www.luogu.com.cn/problem/solution/P6835">原题面</a></strong></p><p>有$n$个点，形成一条单链图，并在其中加入$m$条返祖边</p><p>现在从1号节点出发，每次等概率的前往到一个相邻的节点，求走到第$n+1$个点的期望步数</p><p>$n,m≤10^6$</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>设$E_{x→y}$表示从$x$点走到$y$点的期望步数，$k_i$表示第$i$个点的返祖边条数</p><p>有转移：</p><center>$E_{x→x+1} = \dfrac{1}{k+1}×1+\dfrac{1}{k+1}×\sum\limits_{(x,y)∈E}E_{y→x+1}+1$</center><center>$= 1+\dfrac{1}{k+1}×\sum\limits_{(x,y)∈E}E_{y→x+1}$</center><p>根据期望的线性性质,有$E<em>{x→y} =\sum\limits</em>{i=x}^{y-1}E_{i→i+1}$,代回原式：</p><center>$E_{x→x+1} = 1+\dfrac{1}{k+1}×\sum\limits_{(x,y)∈E}\sum\limits_{i=y}^{x-1}E_{i→i+1}+\dfrac{k×E_{x→x+1}}{k+1}$</center><center>$E_{x→x+1} = 1+k+\sum\limits_{(x,y)∈E}\sum\limits_{i=y}^{x-1}E_{i→i+1}$</center><p>维护一下前缀和即可,$\sum\limits<em>{i=x}^{y-1}E</em>{i→i+1}$既为所求答案</p><p>时间复杂度$O(n+m)$</p><h2 id="lt-details-gt"><a href="#lt-details-gt" class="headerlink" title="&lt;/details&gt;"></a>&lt;/details&gt;</h2>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P2801 教主的魔法</title>
      <link href="/2020/09/19/p2801/"/>
      <url>/2020/09/19/p2801/</url>
      
        <content type="html"><![CDATA[<h1 id="P2801-教主的魔法"><a href="#P2801-教主的魔法" class="headerlink" title="P2801 教主的魔法"></a>P2801 教主的魔法</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给一个长度为$n$的序列$a_i$,有$m$次操作,操作分为两种$:$</p><ul><li><p>将区间$[l,r]$上的所有数加上$c$</p></li><li><p>查询区间$[l,r]$中小于$c$的数的个数</p></li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>数列分块入门题</p><p>对于查询操作,若$l,r$在同一个块内,直接暴力查询</p><p>反之,若不在同一个块内,则答案由三部分组成:以$l$开头的不完整块,以$r$结尾的不完整块,中间一连串连续的完整快</p><p>由于要查询大于等于$c$的值,考虑开一个数组$t$存块中元素排序后的值</p><p>对于不完整块,直接暴力查询</p><p>对于完整块,在$t$数组中二分查找$c$的值即可</p><p>修改操作也同理</p><p>若$l,r$在同一个块内,直接暴力查询</p><p>若不在一个块内,对于不完整块直接暴力修改,并更新该块在$t$数组中的值</p><p>对于完整块,使用类似于$lazttag$的方式保存即可</p><hr><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>预处理时,需对每个块内元素进行一次排序,复杂度为$O(nlogn)$</p><p>查询时,每次至多暴力修改$2\sqrt n$个元素,对$\sqrt n$个块内二分或排序,复杂度为$O(\sqrt n +\sqrt n log\sqrt n  )$</p><p>总复杂度为$O(\sqrt n +\sqrt n log\sqrt n + nlogn)$</p><details><summary><font size=5 font face="comic sans MS">code</font></summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> X=<span class="number">0</span>; <span class="type">bool</span> flag=<span class="number">1</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) flag=<span class="number">0</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">if</span>(flag) <span class="keyword">return</span> X;</span><br><span class="line"><span class="keyword">return</span> ~(X<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1000010</span>;</span><br><span class="line"><span class="type">int</span> a[MAXN],belong[MAXN],t[MAXN],n,m,st[MAXN],ed[MAXN],tag[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=st[x];i&lt;=ed[x];i++) t[i] = a[i];</span><br><span class="line"><span class="built_in">sort</span>(t+st[x],t+ed[x]+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> x = belong[l],y = belong[r];</span><br><span class="line"><span class="keyword">if</span>(x==y)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;i++) a[i]+=val;</span><br><span class="line">  <span class="built_in">sort</span>(x);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=ed[x];i++) a[i]+=val;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=st[y];i&lt;=r;i++) a[i]+=val;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=x+<span class="number">1</span>;i&lt;y;i++) tag[i]+=val;</span><br><span class="line"><span class="built_in">sort</span>(x);</span><br><span class="line"><span class="built_in">sort</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> x = belong[l],y = belong[r];</span><br><span class="line"><span class="keyword">if</span>(x==y)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;i++) <span class="keyword">if</span>(a[i]+tag[x]&gt;=val) res++;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=ed[x];i++) <span class="keyword">if</span>(a[i]+tag[x]&gt;=val) res++;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=st[y];i&lt;=r;i++) <span class="keyword">if</span>(a[i]+tag[y]&gt;=val) res++;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=x+<span class="number">1</span>;i&lt;y;i++)  res += ed[i]-(<span class="built_in">lower_bound</span>(t+st[i],t+ed[i]+<span class="number">1</span>,val-tag[i])-t)+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n = <span class="built_in">read</span>(),m = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]=<span class="built_in">read</span>();</span><br><span class="line"><span class="type">int</span> size  = <span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=size;i++)&#123;</span><br><span class="line">st[i] = (i<span class="number">-1</span>)*size+<span class="number">1</span>,ed[i] = i*size;</span><br><span class="line">&#125;</span><br><span class="line">ed[size] = n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=size;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=st[i];j&lt;=ed[i];j++)&#123;</span><br><span class="line">belong[j] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(a+st[i],a+ed[i]+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">sort</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="type">char</span> op;</span><br><span class="line"><span class="type">int</span> a,b,c;</span><br><span class="line">cin&gt;&gt;op;</span><br><span class="line">a = <span class="built_in">read</span>(),b=<span class="built_in">read</span>(),c=<span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">if</span>(op==<span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="built_in">query</span>(a,b,c)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">add</span>(a,b,c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><strong><a href="https://oi-wiki.org/ds/block-array/">块状数组 - OI Wiki</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF148D Bag of mice</title>
      <link href="/2020/09/13/cf148d/"/>
      <url>/2020/09/13/cf148d/</url>
      
        <content type="html"><![CDATA[<h1 id="CF148D-Bag-of-mice"><a href="#CF148D-Bag-of-mice" class="headerlink" title="CF148D Bag of mice"></a>CF148D Bag of mice</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有$w$只白鼠和$b$只黑鼠 ，$A$和$B$轮流从袋子里抓，谁先抓到白色谁就赢。抓完后会有另一只随机老鼠跑出来。如果两个人都没有抓到白色则$B$赢。$A$先抓，问$A$赢的概率。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>概率$dp$板子题</p><p>设$f[i][j]$表示为袋子里共有$i$只白鼠$j$只黑鼠,$A$获胜的概率</p><p>考虑$f[i][j]$的转移:</p><p>先确定边界,当没有一只白鼠时,$f[0][i] = 0$,全是白鼠时$f[i][0] = 1$</p><ul><li><p>$A$抓了一只白鼠,$A$赢了,概率为$\dfrac{i}{i+j}$</p></li><li><p>$A$抓了一只黑鼠,$B$抓了一只白鼠,$B$硬了,概率为$\dfrac{j}{i+j}×\dfrac{i}{i+j-1}$</p></li><li><p>$A$抓了一只黑鼠,$B$抓了一只黑鼠,跑出来一只白鼠,概率为$\dfrac{j}{i+j}×\dfrac{j-1}{i+j-1}×\dfrac{i}{i+j-2}$,转移到$f[i][j-3]$</p></li><li><p>$A$抓了一只黑鼠,$B$抓了一只黑鼠,跑出来一只黑鼠,概率为$\dfrac{j}{i+j}×\dfrac{j-1}{i+j-1}×\dfrac{j-2}{i+j-2}$,转移到$f[i-1][j-2]$</p></li></ul><p>其中第二种情况不参与计算,只需转移其他三种情况即可</p><h2 id="code"><a href="#code" class="headerlink" title="$code:$"></a>$code:$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">3010</span>;</span><br><span class="line"><span class="type">double</span> f[MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) f[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) f[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">f[i][j] += (<span class="type">double</span>)i/(j+i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(j&gt;=<span class="number">2</span>&amp;&amp;i&gt;=<span class="number">1</span>)&#123;</span><br><span class="line"> f[i][j]+=(<span class="type">double</span>)j/(j+i)*(j<span class="number">-1</span>)/(j+i<span class="number">-1</span>)*i/(j+i<span class="number">-2</span>)*f[i<span class="number">-1</span>][j<span class="number">-2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(j&gt;=<span class="number">3</span>)&#123;</span><br><span class="line">f[i][j]+= (<span class="type">double</span>)j/(j+i)*(j<span class="number">-1</span>)/(j+i<span class="number">-1</span>)*(j<span class="number">-2</span>)/(j+i<span class="number">-2</span>)*f[i][j<span class="number">-3</span>]; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.9lf\n&quot;</span>, f[n][m]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><strong><a href="https://oi-wiki.org/dp/probability/">概率 $dp$_OI Wiki</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P1850 换教室</title>
      <link href="/2020/09/13/p1850/"/>
      <url>/2020/09/13/p1850/</url>
      
        <content type="html"><![CDATA[<h1 id="P1850-换教室"><a href="#P1850-换教室" class="headerlink" title="P1850 换教室"></a>P1850 换教室</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给一张$v$个教室$e$条带权边的图,有$n$个时间段,第$i$个时间段在$c_i$号教室上课,可以申请换到$d_i$号教室,成功的概率为$p_i$,上完后要去第$i+1$个时间段的教室上课,有$m$次申请机会,求最小期望路程</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>设$f[i][j][0/1]$表示第$i$个时间段前用了$j$次申请机会,第$i$个时间段申请$/$不申请的最小期望路程</p><p>$w[i][j]$表示第$i$个教室到第$j$个教室的最短路长度</p><hr><ul><li>当前阶段不申请更换:</li></ul><p>前一个状态换:</p><p>$<del>~</del><del>~</del>~~$$f[i][j][0] = f[i-1][j][1]+w[c<em>{i-1}][c</em>{i}]×(1-p<em>{i-1}) + w[d{_i-1}][c</em>{i}]×p_{i-1}$</p><p>前一个状态不换:</p><p>$<del>~</del><del>~</del>~~$$f[i][j][0] = f[i-1][j][0]+w[c_{i-1}][c_i]$</p><p>取两者的$min$即可</p><hr><ul><li>当前状态申请更换:</li></ul><p>前一个状态不换:</p><p>$<del>~</del><del>~</del>~~$$f[i][j][1] = f[i-1][j-1][0]+w[c<em>{i-1}][d</em>{i}]×p<em>{i}+w[c</em>{i-1}][c<em>{i}]×(1-p</em>{i})$</p><p>前一个状态换:</p><p>比较麻烦,有四种可能</p><ul><li><p>$d<em>{i-1}-&gt;c_i$: $k_1 = w[d</em>{i-1}][c<em>{i}]×p</em>{i-1}*(1-p<em>{i})$ $<del>~</del><del>~</del>~,~$ $d</em>{i-1}-&gt;d<em>i$: $k_2 = w[d</em>{i-1}][d<em>{i}]×p</em>{i}×p_{i-1}$</p></li><li><p>$c<em>{i-1}-&gt;c_i$: $k_3 = w[c</em>{i-1}][c<em>{i}]×(1-p</em>{i-1})<em>(1-p<em>{i})$ $~~,~$ $c</em>{i-1}-&gt;d<em>i$: $k_4 = w[c</em>{i-1}][d<em>{i}]×(1-p</em>{i-1})</em>p_{i}$</p></li></ul><p>$<del>~</del><del>~</del>~~$$f[i][j][1] = f[i-1][j-1][1]+k_1+k_2+k_3+k_4$</p><hr><p>答案即为$min(f[n][i][0])$</p><h2 id="code"><a href="#code" class="headerlink" title="$code:$"></a>$code:$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">2010</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 1145141919</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> X=<span class="number">0</span>; <span class="type">bool</span> flag=<span class="number">1</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) flag=<span class="number">0</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">if</span>(flag) <span class="keyword">return</span> X;</span><br><span class="line"><span class="keyword">return</span> ~(X<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> c[MAXN],d[MAXN];</span><br><span class="line"><span class="type">int</span> w[MAXN][MAXN];</span><br><span class="line"><span class="type">double</span> f[MAXN][MAXN][<span class="number">2</span>];</span><br><span class="line"><span class="type">double</span> p[MAXN]; </span><br><span class="line"><span class="type">int</span> n,m,v,e;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyed</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=v;k++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=v;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=v;j++)</span><br><span class="line">w[i][j] = <span class="built_in">min</span>(w[i][j] , w[i][k]+w[k][j]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">n = <span class="built_in">read</span>(),m=<span class="built_in">read</span>(),v=<span class="built_in">read</span>(),e=<span class="built_in">read</span>();</span><br><span class="line"><span class="built_in">memset</span>(w,<span class="number">63</span>,<span class="built_in">sizeof</span>(w));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) c[i]=<span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) d[i]=<span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;p[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=e;i++)&#123;</span><br><span class="line"><span class="type">int</span> u,v,val;</span><br><span class="line">u = <span class="built_in">read</span>(),v=<span class="built_in">read</span>(),val=<span class="built_in">read</span>();</span><br><span class="line">w[u][v] = w[v][u] = <span class="built_in">min</span>(w[u][v] , val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">floyed</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=v;i++) w[i][i] = w[i][<span class="number">0</span>] = w[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++) f[i][j][<span class="number">0</span>] = f[i][j][<span class="number">1</span>] = <span class="number">1e9</span>;</span><br><span class="line">    </span><br><span class="line">f[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">f[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="built_in">min</span>(m,i);j++)&#123;</span><br><span class="line">f[i][j][<span class="number">0</span>] = <span class="built_in">min</span>(f[i<span class="number">-1</span>][j][<span class="number">0</span>]+w[c[i<span class="number">-1</span>]][c[i]],f[i<span class="number">-1</span>][j][<span class="number">1</span>]+ w[c[i<span class="number">-1</span>]][c[i]]*(<span class="number">1</span>-p[i<span class="number">-1</span>]) + w[d[i<span class="number">-1</span>]][c[i]]*p[i<span class="number">-1</span>]);</span><br><span class="line"><span class="keyword">if</span>(j!=<span class="number">0</span>)&#123;</span><br><span class="line">f[i][j][<span class="number">1</span>] = <span class="built_in">min</span>(f[i<span class="number">-1</span>][j<span class="number">-1</span>][<span class="number">0</span>]+w[c[i<span class="number">-1</span>]][d[i]]*p[i]+w[c[i<span class="number">-1</span>]][c[i]]*(<span class="number">1</span>-p[i]),</span><br><span class="line">f[i<span class="number">-1</span>][j<span class="number">-1</span>][<span class="number">1</span>]+w[c[i<span class="number">-1</span>]][d[i]]*(<span class="number">1</span>-p[i<span class="number">-1</span>])*p[i]+</span><br><span class="line">w[c[i<span class="number">-1</span>]][c[i]]*(<span class="number">1</span>-p[i<span class="number">-1</span>])*(<span class="number">1</span>-p[i])+</span><br><span class="line">w[d[i<span class="number">-1</span>]][c[i]]*p[i<span class="number">-1</span>]*(<span class="number">1</span>-p[i])+</span><br><span class="line">w[d[i<span class="number">-1</span>]][d[i]]*p[i]*p[i<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> ans = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++) ans = <span class="built_in">min</span>(ans,<span class="built_in">min</span>(f[n][i][<span class="number">0</span>],f[n][i][<span class="number">1</span>])); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2lf&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P1860 新魔法药水</title>
      <link href="/2020/09/12/p1860/"/>
      <url>/2020/09/12/p1860/</url>
      
        <content type="html"><![CDATA[<h1 id="P1860-新魔法药水"><a href="#P1860-新魔法药水" class="headerlink" title="P1860 新魔法药水"></a>P1860 新魔法药水</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给$n$个物品,每个物品都有一个售价和回收价,现在有$v$块钱和$m$个操作,每次操作都可以把若干个物品合成为另一个物品,最多可以使用$k$次操作,求能获得的最大收益</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>比较难想的一道$dp$</p><p>设$f[i][j]$表示共有$i$块钱,$j$次操作时能获得的最大收益</p><p>$m[i][j]$表示第$i$个数用了$j$次操作后$i$的最小进价</p><p>$a[i][0/1]$表示第$i$个物品的进价和回收价</p><p>$m$的值直接求不太好求,考虑对$m$进行$dp$</p><p>对于每一个$m[i][j]$,其值必定由其条件物品的值决定,考虑去求每个物品的条件物品购入值的最小值</p><p>设$k[i][j]$表示第$now$个物品前$i$个条件用品用了$j$次魔法的最小购入值</p><p>$p_i$表示$i$物品中每个条件物品用的操作次数,$sum_i$表示第$i$个物品的条件物品总数,则$\sum_i^{sum_i}p_i = j-1$</p><p>可以看出是个分组背包</p><p>则有较为显然的转移:</p><p>$<del>~</del><del>~</del><del>~</del><del>~</del>~~$$k[i][j] = min(k[i-1][j-t]+f[i][t])$</p><p>$m[now][j]$的转移即为</p><p>$<del>~</del><del>~</del><del>~</del><del>~</del>~~$$m[now][j] = min(k[sum_i][j-1])$</p><p>$m$数组求出来了,$f$的转移也就呼之欲出了</p><p>$<del>~</del><del>~</del><del>~</del><del>~</del>~~$$f[v][t] = max(f[v - m[i][j]][t - j]+a[i][1])$</p><p>答案即为$max(f[i][j] - i)$</p><h2 id="code"><a href="#code" class="headerlink" title="$code:$"></a>$code:$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">250</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f</span></span><br><span class="line"><span class="type">int</span> f[MAXN][MAXN*<span class="number">10</span>],a[MAXN][<span class="number">2</span>],mgc[MAXN][MAXN],fia[MAXN],num[MAXN][MAXN],koishi[MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> n,m,v,k;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> X=<span class="number">0</span>; <span class="type">bool</span> flag=<span class="number">1</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) flag=<span class="number">0</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">if</span>(flag) <span class="keyword">return</span> X;</span><br><span class="line"><span class="keyword">return</span> ~(X<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(mgc,inf,<span class="built_in">sizeof</span>(mgc));</span><br><span class="line">n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>(),v=<span class="built_in">read</span>(),k=<span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">a[i][<span class="number">0</span>] = <span class="built_in">read</span>(),mgc[i][<span class="number">0</span>] = a[i][<span class="number">0</span>] , a[i][<span class="number">1</span>] = <span class="built_in">read</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">fia[i] = <span class="built_in">read</span>(),num[i][<span class="number">0</span>] = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=num[i][<span class="number">0</span>];j++)</span><br><span class="line">num[i][j] = <span class="built_in">read</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=k;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="built_in">memset</span>(koishi,inf,<span class="built_in">sizeof</span>(koishi));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> p=<span class="number">0</span>;p&lt;j;p++) koishi[<span class="number">0</span>][p]  =<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">1</span>;now&lt;=num[i][<span class="number">0</span>];now++)</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> p=<span class="number">0</span>;p&lt;j;p++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> q=<span class="number">0</span>;q&lt;=p;q++)</span><br><span class="line">      koishi[now][p] = <span class="built_in">min</span>(koishi[now<span class="number">-1</span>][p-q]+mgc[num[i][now]][q],koishi[now][p]);</span><br><span class="line">      mgc[fia[i]][j] = <span class="built_in">min</span>(mgc[fia[i]][j] , koishi[num[i][<span class="number">0</span>]][j<span class="number">-1</span>]);</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">0</span>;t&lt;=k;t++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=t;j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> mo=mgc[i][j];mo&lt;=v;mo++)&#123;</span><br><span class="line">f[t][mo] = <span class="built_in">max</span>(f[t][mo],f[t-j][mo-mgc[i][j]]+a[i][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=v;j++)&#123;</span><br><span class="line">ans = <span class="built_in">max</span>(ans , f[i][j]-j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="坑点-amp-amp-感想"><a href="#坑点-amp-amp-感想" class="headerlink" title="坑点&amp;&amp;感想"></a>坑点&amp;&amp;感想</h2><ul><li>注意枚举时的边界</li></ul>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P3174 [HAOI2009]毛毛虫</title>
      <link href="/2020/09/08/p3174/"/>
      <url>/2020/09/08/p3174/</url>
      
        <content type="html"><![CDATA[<h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给一n个点的树,定义一条路径的权值为该路径上所有的点数和与该路径上的点相连的点数之和,求最大权值</p><p>$1\leq n \le 300000$</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="做法一"><a href="#做法一" class="headerlink" title="做法一:"></a>做法一:</h3><p>设$deg(i)$为第$i$个节点的度数,$f(i)$为以$i$为根的最大权值和,$g(i)$为以$i$为根的次大权值和</p><p>不难推出转移方程:</p><center>$f(u) = max(f(v))+deg(u)-1$</center><p>枚举每一个点,然后取最大值就可以了</p><p>注意这里最后的答案要加2,因为中间连接的的两个点没酸上</p><p>时间复杂度$O(n^2)$,能取得10pts的<del>好成绩</del></p><h3 id="做法二"><a href="#做法二" class="headerlink" title="做法二:"></a>做法二:</h3><p>观察可以发现,这里的方法和求树的直径相同,只是把长度换成了权值,因此可以直接套用求树的直径的两次$dfs$方法</p><p>时间复杂度$O(n)$<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P4180 严格次小生成树</title>
      <link href="/2020/09/06/p4180/"/>
      <url>/2020/09/06/p4180/</url>
      
        <content type="html"><![CDATA[<h1 id="P4180-BJWC2010-严格次小生成树"><a href="#P4180-BJWC2010-严格次小生成树" class="headerlink" title="P4180 [BJWC2010]严格次小生成树"></a>P4180 [BJWC2010]严格次小生成树</h1><h1 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h1><p>给一张带权无向图,求其严格次小生成树大小</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li><h3 id="次小生成树"><a href="#次小生成树" class="headerlink" title="次小生成树"></a>次小生成树</h3></li></ul><p>无向图中,边权和最小的满足边权和 <strong>大于等于</strong> 最小生成树边权和的生成树</p><p>严格次小生成树即为边权和最小的满足边权和 <strong>严格大于</strong> 最小生成树边权和的生成树</p><h2 id="求法"><a href="#求法" class="headerlink" title="求法"></a>求法</h2><ul><li><p>先求出无向图的最小生成树,设其权值和为$S$</p></li><li><p>枚举每条不在最小生成树中的边$e = (u,v,w)$,将其加入生成树,同时去掉从$u$到$v$的路径上权值最大的一条边$e_{max}$,以确保不存在环且其权值和次小</p></li></ul><p>得到的新生成树权值和即为$S+e.w - e_{max}.w$</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>使用树链剖分来维护两个值$:$区间最大值和区间严格次大值</p><p>设$max1<em>{l,r}$表示区间$[l,r]$中的最大值,$max2</em>{l,r}$表示区间$[l,r]$中的严格次大值</p><p>当$max1<em>{l,mid}==max1</em>{mid+1,r}$时:</p><p>$max2_{l,r}$取左右区间中的较大的严格次大值</p><ul><li>$max2<em>{l,r} = max(max2</em>{l,mid},max2_{mid+1,r})$</li></ul><p>反之,当$max1<em>{l,mid} != max1</em>{mid+1,r}$时:</p><p>$max2_{l,r}$取左右区间中的较小的最大值</p><ul><li>$max2<em>{l,r} = min(max1</em>{l,mid},max1_{mid+1,r})$</li></ul><p>若最大值不等于当前所换的边的大小,直接用最大值来替换</p><p>反之,说明不满足严格小于,用次大值来替换</p><h2 id="code"><a href="#code" class="headerlink" title="$code:$"></a>$code:$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//--------------------------------------------------------------------------------other </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson (node&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson (node&lt;&lt;1|1)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">2e5</span>+<span class="number">5</span>,MAXM = <span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">int</span> head[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">e</span>&#123;</span><br><span class="line"><span class="type">int</span> next,v,w;</span><br><span class="line">&#125;edge[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> n,m,fa[MAXN];</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> vis[MAXM];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">edge[++cnt].v = v;</span><br><span class="line">edge[cnt].w = w;</span><br><span class="line">edge[cnt].next = head[u];</span><br><span class="line">head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(fa[x]==x) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">id</span>&#123;</span><br><span class="line"><span class="type">int</span> u,v,w;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> id &amp;k)<span class="type">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> w&lt;k.w;</span><br><span class="line">&#125;</span><br><span class="line">&#125;a[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> Tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="type">int</span> f1 = <span class="built_in">find</span>(a[i].u);</span><br><span class="line"><span class="type">int</span> f2 = <span class="built_in">find</span>(a[i].v);</span><br><span class="line"><span class="keyword">if</span>(f1!=f2)&#123;</span><br><span class="line">vis[i] = <span class="number">1</span>;</span><br><span class="line">fa[f1] = f2;</span><br><span class="line"><span class="built_in">add</span>(a[i].u,a[i].v,a[i].w),<span class="built_in">add</span>(a[i].v,a[i].u,a[i].w);</span><br><span class="line">sum+=a[i].w;</span><br><span class="line">Tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(Tot == n<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//--------------------------------------------------------------------------------other </span></span><br><span class="line"><span class="type">int</span> dep[MAXN],son[MAXN],faa[MAXN],size[MAXN],w[MAXN];</span><br><span class="line"><span class="type">int</span> id[MAXN],val[MAXN],tot = <span class="number">0</span>,top[MAXN];<span class="comment">//预处理数组 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------------------------------------------------------------------线段树 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st</span>&#123;</span><br><span class="line"><span class="type">int</span> max1,max2,l,r;</span><br><span class="line">&#125;tree[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;</span><br><span class="line">tree[node].max1 = <span class="built_in">max</span>(tree[lson].max1,tree[rson].max1);</span><br><span class="line"><span class="keyword">if</span>(tree[lson].max1==tree[rson].max1)&#123;</span><br><span class="line">tree[node].max2 = <span class="built_in">max</span>(tree[lson].max2,tree[rson].max2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> tree[node].max2 = <span class="built_in">min</span>(tree[lson].max1,tree[rson].max1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">tree[node].l = l,tree[node].r = r;</span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">tree[node].max1 = val[l];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">build</span>(lson,l,mid);</span><br><span class="line"><span class="built_in">build</span>(rson,mid+<span class="number">1</span>,r);</span><br><span class="line"><span class="built_in">pushup</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; <span class="title">unit</span><span class="params">(pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; l,pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; r)</span></span>&#123;</span><br><span class="line">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; f;</span><br><span class="line">f.first = <span class="built_in">max</span>(l.first,r.first);</span><br><span class="line"><span class="keyword">if</span>(l.first==r.first) f.second = <span class="built_in">max</span>(l.second,r.second);</span><br><span class="line"><span class="keyword">else</span> f.second = <span class="built_in">min</span>(l.first,r.first);</span><br><span class="line"><span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; <span class="title">query</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=tree[node].l&amp;&amp;r&gt;=tree[node].r)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">make_pair</span>(tree[node].max1,tree[node].max2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid = (tree[node].l+tree[node].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(r&lt;=mid) <span class="keyword">return</span> <span class="built_in">query</span>(lson,l,r);</span><br><span class="line"><span class="keyword">if</span>(l&gt;mid) <span class="keyword">return</span> <span class="built_in">query</span>(rson,l,r);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">unit</span>(<span class="built_in">query</span>(lson,l,r),<span class="built_in">query</span>(rson,l,r));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------------------------------------------------------------------线段树 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------------------------------------------------------------------dfs</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> f,<span class="type">int</span> deep)</span></span>&#123;</span><br><span class="line">dep[u] = deep;</span><br><span class="line">faa[u] = f;</span><br><span class="line">size[u] = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> maxson = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = edge[i].v;</span><br><span class="line"><span class="keyword">if</span>(v==f) <span class="keyword">continue</span>;</span><br><span class="line">w[v] = edge[i].w;</span><br><span class="line"><span class="built_in">dfs1</span>(v,u,deep+<span class="number">1</span>);</span><br><span class="line">size[u]+=size[v];</span><br><span class="line"><span class="keyword">if</span>(size[v]&gt;maxson)&#123;</span><br><span class="line">son[u] = v;</span><br><span class="line">maxson = size[v];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> topf)</span></span>&#123;</span><br><span class="line">id[u] = ++tot;</span><br><span class="line">val[tot] = w[u];</span><br><span class="line">top[u] = topf;</span><br><span class="line"><span class="keyword">if</span>(!son[u]) <span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">dfs2</span>(son[u],topf);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = edge[i].v;</span><br><span class="line"><span class="keyword">if</span>(v==son[u]||v==faa[u]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs2</span>(v,v);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//--------------------------------------------------------------------------------dfs</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------------------------------------------------------------------查询 </span></span><br><span class="line"><span class="function">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; <span class="title">qb</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; res;</span><br><span class="line"><span class="keyword">while</span>(top[u]!=top[v])&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]]) <span class="built_in">swap</span>(u,v);</span><br><span class="line">res = <span class="built_in">unit</span>(res , <span class="built_in">query</span>(<span class="number">1</span>,id[top[u]],id[u]));</span><br><span class="line">u = faa[top[u]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(u!=v)&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[u]&gt;dep[v]) <span class="built_in">swap</span>(u,v);</span><br><span class="line">res = <span class="built_in">unit</span>(res , <span class="built_in">query</span>(<span class="number">1</span>,id[u]+<span class="number">1</span>,id[v]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//--------------------------------------------------------------------------------查询 </span></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">cin&gt;&gt;a[i].u&gt;&gt;a[i].v&gt;&gt;a[i].w;</span><br><span class="line"><span class="keyword">if</span>(a[i].u==a[i].v) vis[i] = <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) fa[i] = i;</span><br><span class="line"><span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+m);</span><br><span class="line"><span class="built_in">kruskal</span>();</span><br><span class="line"><span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="type">int</span> ans = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[i]) <span class="keyword">continue</span>;<span class="comment">//在树中或为自环 </span></span><br><span class="line">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; maxn = <span class="built_in">qb</span>(a[i].u,a[i].v);<span class="comment">//最大值,次大值 </span></span><br><span class="line"><span class="keyword">if</span>(maxn.first&lt;a[i].w) ans = <span class="built_in">min</span>(ans , sum+a[i].w-maxn.first);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(maxn.second&lt;a[i].w&amp;&amp;maxn.second) ans = <span class="built_in">min</span>(ans , sum+a[i].w-maxn.second); <span class="comment">//存在严格次大值</span></span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h2><h5 id="次小生成树-OI-Wiki"><a href="#次小生成树-OI-Wiki" class="headerlink" title="次小生成树_OI Wiki"></a><a href="https://oi-wiki.org/graph/mst/#_9">次小生成树_OI Wiki</a></h5>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P4231 三步必杀</title>
      <link href="/2020/09/05/p4231/"/>
      <url>/2020/09/05/p4231/</url>
      
        <content type="html"><![CDATA[<h1 id="P4231-三步必杀"><a href="#P4231-三步必杀" class="headerlink" title="P4231 三步必杀"></a>P4231 三步必杀</h1><h1 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h1><p><img src="https://img2020.cnblogs.com/blog/2092833/202009/2092833-20200905221207707-1412115323.jpg" alt=""></p><p>给一个初值全为$0$的数列,有$m$次修改操作都将一个给定区间$[l,r]$加上首相为$s$末项为$e$的等差数列</p><p>求:所有修改完成后所有数的异或和跟最大值</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><h2 id="算法一"><a href="#算法一" class="headerlink" title="算法一"></a>算法一</h2><p>通过观察可以发现,对于差分数组$b$,除了$l$和$r+1$位置,其他位置的值都相等</p><p>考虑用线段树记录差分数组,每次修改时,将:</p><ul><li><p>区间$[l+1,r]$加上一个公差$d$</p></li><li><p>$l$位置加上一个首相$s$</p></li><li><p>$r+1$位置减去一个$d×(r-l)+s$</p></li></ul><p>单点修改$+$区间修改$+$区间查询</p><p>可以获得38$pts$</p><h2 id="算法二"><a href="#算法二" class="headerlink" title="算法二"></a>算法二</h2><p>区间$[l+1,r]$的值均为$d$,考虑对数组$b$再进行一次差分</p><p>令$c$为$b$的差分数组</p><p>每次修改时将$:$</p><ul><li><p>$c_l$的值加上首相$s$</p></li><li><p>$c_{l+1}$的值加上$d -s$</p></li><li><p>$c_{r+1}$的值减去$d - e$</p></li><li><p>$c_{r+2}$的值加上$e$</p></li></ul><p>即可</p><p>只需要修改四个元素</p><p>对于每个$a<em>x$,其值即为$\sum</em>{i=1}^x\sum_{j=1}^{i}c_j$</p><h2 id="code"><a href="#code" class="headerlink" title="$code:$"></a>$code:$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1000010</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">int</span> a[MAXN] , n ,m,ans[MAXN];</span><br><span class="line"><span class="type">int</span> ans1,ansmaxn;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="type">int</span> l,r,s,e;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;s,&amp;e);</span><br><span class="line">a[l] += s;</span><br><span class="line">a[l+<span class="number">1</span>]+=(((e-s)/(r-l)) -s);</span><br><span class="line">a[r+<span class="number">1</span>]+=-(((e-s)/(r-l))+e);</span><br><span class="line">a[r+<span class="number">2</span>]+=e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]+=a[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">ans[i] = ans[i<span class="number">-1</span>]+a[i];</span><br><span class="line">ans1^=ans[i];</span><br><span class="line">ansmaxn = <span class="built_in">max</span>(ansmaxn , ans[i]);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans1&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;ansmaxn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="坑点-amp-amp-感想"><a href="#坑点-amp-amp-感想" class="headerlink" title="坑点&amp;&amp;感想"></a>坑点&amp;&amp;感想</h2><ul><li><p>当原差分数组有特殊性质时,考虑二次差分</p></li><li><p>不开$long long$见祖宗</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF149D Coloring Brackets</title>
      <link href="/2020/09/04/cf149d/"/>
      <url>/2020/09/04/cf149d/</url>
      
        <content type="html"><![CDATA[<h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给一个合法括号序列,一个括号可以染红色、蓝色或不染色,一对匹配的括号需要且只能将其中一个染色,且相邻两个括号颜色不能相同</p><p>求符合条件的染色方案数</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>代码实现上比较恶心的区间$dp$</p><p>设$f[i][j][0/1/2][0/1/2]$为区间$[i,j]$中,第$i$个字符不染色$/$染红色$/$染蓝色的方案数,$pos[i]$为$i$的对应右括号</p><p>分两种情况讨论:</p><ul><li>$i$和$j$是一对配对的括号</li></ul><p>$dfs$子区间$[i+1,j-1]$</p><p>更新每个$f[i][j][0/1/2][0/1/2]$的值</p><p>$\begin{cases}f[l][r][1][0] += f[l+1][r-1][i][j] (i!=1)\f[l][r][2][0] += f[l+1][r-1][i][j] (i!=2)\f[l][r][0][1] += f[l+1][r-1][i][j] (j!=1)\f[l][r][0][2] += f[l+1][r-1][i][j] (j!=2)\end{cases}$</p><ul><li>$i$和$j$不是一对配对的括号</li></ul><p>将$[i,j]$拆分为两个区间$[l,pos[l]]$和$[pos[l]+1,r]$进行$dfs$,暴力统计贡献</p><h2 id="code"><a href="#code" class="headerlink" title="$code:$"></a>$code:$</h2><p>细节较多</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">710</span>;</span><br><span class="line"><span class="type">int</span> mo = <span class="number">1000000007</span>;</span><br><span class="line"><span class="type">int</span> dp[MAXN][MAXN][<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line"><span class="type">char</span> kh[MAXN];</span><br><span class="line"><span class="type">int</span> pos[MAXN],ans;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">c</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;<span class="comment">//暴力统计贡献</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">2</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">2</span>;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=<span class="number">2</span>;k++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> g=<span class="number">0</span>;g&lt;=<span class="number">2</span>;g++)&#123;</span><br><span class="line"><span class="keyword">if</span>((j!=k)||(j==<span class="number">0</span>&amp;&amp;k==<span class="number">0</span>)) dp[l][r][i][g]+=dp[l][pos[l]][i][j]*dp[pos[l]+<span class="number">1</span>][r][k][g],dp[l][r][i][g]%=mo;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> l , <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l+<span class="number">1</span> == r)&#123;</span><br><span class="line">dp[l][r][<span class="number">0</span>][<span class="number">1</span>] = dp[l][r][<span class="number">0</span>][<span class="number">2</span>] = dp[l][r][<span class="number">1</span>][<span class="number">0</span>] = dp[l][r][<span class="number">2</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pos[l]==r)&#123;<span class="comment">//是配对括号</span></span><br><span class="line"><span class="built_in">dfs</span>(l+<span class="number">1</span>,r<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">2</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">2</span>;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i!=<span class="number">1</span>) dp[l][r][<span class="number">1</span>][<span class="number">0</span>] = (dp[l+<span class="number">1</span>][r<span class="number">-1</span>][i][j]+dp[l][r][<span class="number">1</span>][<span class="number">0</span>])%mo;</span><br><span class="line"><span class="keyword">if</span>(i!=<span class="number">2</span>) dp[l][r][<span class="number">2</span>][<span class="number">0</span>] = (dp[l+<span class="number">1</span>][r<span class="number">-1</span>][i][j]+dp[l][r][<span class="number">2</span>][<span class="number">0</span>])%mo;</span><br><span class="line"><span class="keyword">if</span>(j!=<span class="number">1</span>) dp[l][r][<span class="number">0</span>][<span class="number">1</span>] = (dp[l+<span class="number">1</span>][r<span class="number">-1</span>][i][j]+dp[l][r][<span class="number">0</span>][<span class="number">1</span>])%mo;</span><br><span class="line"><span class="keyword">if</span>(j!=<span class="number">2</span>) dp[l][r][<span class="number">0</span>][<span class="number">2</span>] = (dp[l+<span class="number">1</span>][r<span class="number">-1</span>][i][j]+dp[l][r][<span class="number">0</span>][<span class="number">2</span>])%mo;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;<span class="comment">//拆分</span></span><br><span class="line"><span class="built_in">dfs</span>(l,pos[l]);</span><br><span class="line"><span class="built_in">dfs</span>(pos[l]+<span class="number">1</span>,r);</span><br><span class="line"><span class="built_in">c</span>(l,r);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,kh+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="built_in">strlen</span>(kh+<span class="number">1</span>);i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(kh[i]==<span class="string">&#x27;(&#x27;</span>) s.<span class="built_in">push</span>(i);</span><br><span class="line"><span class="keyword">else</span> pos[s.<span class="built_in">top</span>()] = i , s.<span class="built_in">pop</span>();<span class="comment">//记录匹配右括号</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>,<span class="built_in">strlen</span>(kh+<span class="number">1</span>));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">2</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">2</span>;j++)&#123;</span><br><span class="line">ans = (ans + dp[<span class="number">1</span>][<span class="built_in">strlen</span>(kh+<span class="number">1</span>)][i][j])%mo;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开学考柠檬水了</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020 9月做题笔记</title>
      <link href="/2020/09/02/9%E6%9C%88%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/09/02/9%E6%9C%88%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="end"><a href="#end" class="headerlink" title="end"></a>end</h2><details><summary><font size=4 font face="comic sans MS">9.30</font></summary>## 9.30#### [P1450 [HAOI2008]硬币购物](https://www.luogu.com.cn/problem/P1450)容斥+dp感觉做法还是挺神的(~~也可能是因为我太菜了~~)#### [详细](https://www.cnblogs.com/xcxc82/p/13756835.html)</details><hr><details><summary><font size=4 font face="comic sans MS">9.29</font></summary>## 9.29#### [[GDOI2014]采集资源](https://www.luogu.com.cn/problem/P3891)$dp$练习题#### [详细](https://www.cnblogs.com/xcxc82/p/13752296.html)</details><hr><details><summary><font size=4 font face="comic sans MS">9.27</font></summary>## 9.27文艺平衡树[Splay学习笔记](https://www.cnblogs.com/xcxc82/p/13736231.html)</details><hr><details><summary><font size=4 font face="comic sans MS">9.26</font></summary>## 9.26[Splay学习笔记](https://www.cnblogs.com/xcxc82/p/13736231.html)下个星期开运动会了/se## 总结学习了Splay</details><hr><details><summary><font size=4 font face="comic sans MS">9.23~9.25</font></summary>## 9.23~9.25学了下splay笔记明天来补</details><hr><details><summary><font size=4 font face="comic sans MS">9.22</font></summary>## 9.22whking这西西弗什么思博审核啊,十多天了还没好</details><hr><details><summary><font size=4 font face="comic sans MS">9.21</font></summary>## 9.21复习初赛ing草为啥10年初赛会有空间向量的题啊</details><hr><details><summary><font size=4 font face="comic sans MS">9.20</font></summary>## 9.20题无## 总结学习了数列分块入门~~以后打月赛再也不瞎复制之前写的代码了==,被坑死了~~</details><hr><details><summary><font size=4 font face="comic sans MS">9.19</font></summary>## 9.19题### [洛谷 ⑨ 月月赛](https://www.cnblogs.com/xcxc82/p/13697113.html)⑨都不如的菜鸡</details><hr><details><summary><font size=4 font face="comic sans MS">9.18</font></summary>## 9.18题### [P4135 作诗](https://www.luogu.com.cn/problem/P4135)数列分块练手题### [详细](https://www.cnblogs.com/xcxc82/p/13701266.html)## other草上政治课的时候班上有个同学公然看本子,tql</details><hr><details><summary><font size=4 font face="comic sans MS">9.17</font></summary>## 9.17题### [P2801 教主的魔法](https://www.luogu.com.cn/problem/P2801)数列分块入门题### [详细](https://www.cnblogs.com/xcxc82/p/13695957.html)</details><hr><details><summary><font size=4 font face="comic sans MS">9.13~9.16</font></summary>## 9.13~9.16whking€€￡的破审核还没过==</details><hr><details><summary><font size=4 font face="comic sans MS">9.12</font></summary>## 9.12题### [P1860 新魔法药水](https://www.luogu.com.cn/problem/P1860)$dp$好题### [详细](https://www.cnblogs.com/xcxc82/p/13659339.html)### [P1850 换教室](https://www.luogu.com.cn/problem/P1850)最短路+期望$dp$### [详细](https://www.cnblogs.com/xcxc82/p/13661002.html)##总结补了之前没学的期望+概率复习了一些数论知识</details><hr><details><summary><font size=4 font face="comic sans MS">9.11</font></summary>## 9.11题### [P3802 小魔女帕琪](https://www.luogu.com.cn/problem/P3802)折寿中...### [CF148D Bag of mice](https://www.luogu.com.cn/problem/CF148D)概率$dp$模板题,分类讨论即可### [详细](https://www.cnblogs.com/xcxc82/p/13663798.html)</details><hr><details><summary><font size=4 font face="comic sans MS">9.7~9.10</font></summary>## 9.7~9.10题复习初赛+whk</details><hr><details><summary><font size=4 font face="comic sans MS">9.6</font></summary>## 9.6题### [P4180 [BJWC2010]严格次小生成树](https://www.luogu.com.cn/problem/P4180)次小生成树板子题### [详细](https://www.cnblogs.com/xcxc82/p/13623917.html)## 总结~~?似乎没啥可总结的~~学了一些杂七杂八的东西</details><hr><details><summary><font size=4 font face="comic sans MS">9.5</font></summary>## 9.5题### [P4231 三步必杀](https://www.luogu.com.cn/problem/P4231)二次差分车万题面好评### [详细](https://www.cnblogs.com/xcxc82/p/13620012.html)### [SP277 CTGAME - City Game](https://www.luogu.com.cn/problem/SP277)&&[P2280 [HNOI2003]激光炸弹](https://www.luogu.com.cn/problem/P2280)两道$dp$水题</details><hr><details><summary><font size=4 font face="comic sans MS">9.1~9.4</font></summary>## 9.1~9.4题whking打了几个模板题,复习了一些初赛知识~~开学考你们输了~~</details><hr><details><summary><font size=4 font face="comic sans MS">8月补充</font></summary>## 8月补充### [P3225 [HNOI2012]矿场搭建](https://www.luogu.com.cn/problem/P3225)待补充### [P3225 CF149D Coloring Brackets](https://www.luogu.com.cn/problem/P3225)细节较多的一道区间$dp$### [详细](https://www.cnblogs.com/xcxc82/p/13616581.html)### [P3174 [HAOI2009]毛毛虫](https://www.luogu.com.cn/problem/P3174)树形$dp$### [详细](https://www.cnblogs.com/xcxc82/p/13636125.html)</details>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P1169 [ZJOI2007]棋盘制作</title>
      <link href="/2020/08/30/p1169/"/>
      <url>/2020/08/30/p1169/</url>
      
        <content type="html"><![CDATA[<h1 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h1><p>给一个$8×8$的黑白棋盘,求最大的黑白相间的矩形和正方形的面积</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>悬线法$dp$板子题</p><h1 id="悬线法"><a href="#悬线法" class="headerlink" title="悬线法"></a>悬线法</h1><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>用途:解决给定矩阵中满足某条件的最大子矩阵等一类问题</p><h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><p>定义三个数组:</p><p>$up[i][j]$:表示第$i$行第$j$个点能向上扩展到的最长长度</p><p>$l[i][j]$:表示第$i$行第$j$个点能向左扩展到的最左位置</p><p>$r[i][j]$:表示第$i$行第$j$个点能向右扩展到的最右位置</p><p>先预处理出$l$数组和$r$数组:</p><p>$l[i][j] = l[i]<a href="a[i][j]!=a[i][j-1]">j-1</a>$</p><p>$r[i][j] = r[i]<a href="a[i][j]!=a[i][j+1]">j+1</a>$</p><p>当且仅当$a[i][j]!=a[i-1][j]$时,两行才有可能接上</p><p>其对应的$l[i][j]$和$r[i][j]$则分别取靠右的和靠左的那一个,同时更新高度</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a[i][j]!=<span class="number">1</span>)&#123;</span><br><span class="line">up[i][j] = up[i<span class="number">-1</span>][j]+<span class="number">1</span>;</span><br><span class="line">l[i][j] = <span class="built_in">max</span>(l[i][j],l[i<span class="number">-1</span>][j]);</span><br><span class="line">r[i][j] = <span class="built_in">min</span>(r[i][j],r[i<span class="number">-1</span>][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="code"><a href="#code" class="headerlink" title="$code:$"></a>$code:$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">3010</span>;</span><br><span class="line"><span class="type">int</span> a[MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> l[MAXN][MAXN],r[MAXN][MAXN],up[MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> c;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;c);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=c;i++)&#123;</span><br><span class="line"><span class="type">int</span> p,k;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;p,&amp;k);</span><br><span class="line">a[p][k] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=m;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i][j]!=<span class="number">1</span>) l[i][j] = l[i][j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=m<span class="number">-1</span>;j&gt;=<span class="number">1</span>;j--)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i][j]!=<span class="number">1</span>) r[i][j] = r[i][j+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans  = <span class="number">-11451419</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i][j]!=<span class="number">1</span>)&#123;</span><br><span class="line">up[i][j] = up[i<span class="number">-1</span>][j]+<span class="number">1</span>;</span><br><span class="line">l[i][j] = <span class="built_in">max</span>(l[i][j],l[i<span class="number">-1</span>][j]);</span><br><span class="line">r[i][j] = <span class="built_in">min</span>(r[i][j],r[i<span class="number">-1</span>][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> len = r[i][j] - l[i][j]+<span class="number">1</span>;</span><br><span class="line">ans = <span class="built_in">max</span>(ans , up[i][j]*len);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>好水啊</del></p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P3622 [APIO2007]动物园</title>
      <link href="/2020/08/30/p3622/"/>
      <url>/2020/08/30/p3622/</url>
      
        <content type="html"><![CDATA[<h1 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h1><p>给一个$n$个数的环,$c$个人,每个人都可以看到环上的五个位置,且都有子集喜欢和不喜欢的数,当这五个位置至少有一个他喜欢的数字或至少有一个他不喜欢的数字被移走时,该人会开心,求让最多能让多少个人开心</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>比较难想的状压$dp$</p><p>每一个数有没有被撤走可以用$0$和$1$来表示,考虑状态压缩</p><p>考虑到每个人可以看到五个格子,不妨设:</p><p>$num[i][j]$为当区间$[i,i+4]$的状态为$j$时的开心人数</p><p>首先将每个人害怕和不害怕的动物压缩一个状态</p><p>枚举状态$j$,当且仅当五个位置至少有一个他喜欢的数字或至少有一个他不喜欢的数字时,该人会开心</p><p>即$((j$ &amp; $dislike)||($~$j$&amp; $like))$时,$num[i][j]++$</p><p>设$f[i][s]$为区间$[i,i+4]$的状态为$s$时的最多开心人数</p><p>考虑到当区间$[i,i+4]$移动到区间$[i+1,i+5]$时,前四位数字是不变的,因此关心的只有最后一位数的情况</p><p>得到转移$:$</p><p>$f[i][s] = max(f[i-1][(s$&amp;$15)&gt;&gt;1]$,$f[i-1][(s$&amp;$15)&gt;&gt;1|1])+num[i][s]$</p><p>解释:</p><p>$15$的二进制为$01111$,&amp;$15$即为取后四位,$&gt;&gt;1$和$&gt;&gt;1|1$分别代表$i-1$位置的不选与选</p><p>需要注意的是这里的数是一个环,因此只有当开头和结尾的状态一致时才是有效状态</p><h2 id="code"><a href="#code" class="headerlink" title="$code:$"></a>$code:$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">50010</span>;</span><br><span class="line"><span class="type">int</span> n,c;</span><br><span class="line"><span class="type">int</span> num[MAXN][<span class="number">50</span>],f[MAXN][<span class="number">50</span>],ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;c;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=c;i++)&#123;</span><br><span class="line"><span class="type">int</span> e,f,l;</span><br><span class="line"><span class="type">int</span> like=<span class="number">0</span>,dislike=<span class="number">0</span>;</span><br><span class="line">cin&gt;&gt;e&gt;&gt;f&gt;&gt;l;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=f;j++)&#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line">cin&gt;&gt;a;</span><br><span class="line">a = (a-e+n)%n;</span><br><span class="line">like|=<span class="number">1</span>&lt;&lt;a;<span class="comment">//状态压缩</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=l;j++)&#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line">cin&gt;&gt;a;</span><br><span class="line">a = (a-e+n)%n;</span><br><span class="line">dislike|=<span class="number">1</span>&lt;&lt;a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">32</span>;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>((j&amp;dislike)||(~j&amp;like)) num[e][j]++;<span class="comment">//判断是否合法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;<span class="comment">//枚举前5个数的状态</span></span><br><span class="line"><span class="built_in">memset</span>(f[<span class="number">0</span>],<span class="number">-20</span>,<span class="built_in">sizeof</span>(f[<span class="number">0</span>]));</span><br><span class="line"> f[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">32</span>;k++)&#123;</span><br><span class="line">f[j][k] = <span class="built_in">max</span>(f[j<span class="number">-1</span>][(k&amp;<span class="number">15</span>)&lt;&lt;<span class="number">1</span>],f[j<span class="number">-1</span>][(k&amp;<span class="number">15</span>)&lt;&lt;<span class="number">1</span>|<span class="number">1</span>])+num[j][k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans = <span class="built_in">max</span>(ans , f[n][i]);<span class="comment">//由于是一个环,当且仅当末尾和开头状态重合时才是有效答案</span></span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P2051 [AHOI2009]中国象棋</title>
      <link href="/2020/08/30/p2051/"/>
      <url>/2020/08/30/p2051/</url>
      
        <content type="html"><![CDATA[<h1 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h1><p>给一个$n×m$的棋盘,在上面放若干个炮,求有多少种放置方法可以使没有一个炮可以攻击到另一个炮</p><p>$1≤n,m≤100$</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>观察可以发现,每行每列最多只能放两个炮,一列能放炮的位置和之前该列放过的炮的个数有关,且<strong>两列棋子数相等的列是等价的</strong>,考虑设$f(i,j,k)$表示前$i$行中,有$j$列放了1个棋子,$k$列放了两个棋子</p><p>分类讨论每种情况,有转移:</p><p>$\begin{cases}f(i+1,j,k) += f(i,j,k)&amp;(一个都不放)\f(i+1,j-1,k+1) +=f(i,j,k)×j&amp;(放一个,放在之前已经放了一个的列上)\f(i+1,j+1,k) +=f(i,j,k)×(m-j-k)&amp;(放一个,放在之前一个都没有的列上)\f(i+1,j+1,k) +=f(i,j,k)×C_{m-j-k}^2&amp;(放两个,都放在之前一个都没有的列上)\f(i+1,j-2,k+2) +=f(i,j,k)×C_j^2&amp;(放两个,都放在之前已经放了一个的列上)\f(i+1,j,k+1) +=f(i,j,k)×(m-j-k)×j&amp;(放两个,一个放在之前已经放了一个的列上,一个放在之前一个都没有的列上)\end{cases}$</p><h2 id="code"><a href="#code" class="headerlink" title="$code:$"></a>$code:$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">110</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mo 9999973</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> C(x) (((x)*(x-1)/2)%mo)</span></span><br><span class="line"><span class="type">int</span> f[MAXN][MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k+j&lt;=m;k++)&#123;</span><br><span class="line"><span class="keyword">if</span>(f[i][j][k])&#123;</span><br><span class="line">f[i+<span class="number">1</span>][j][k] = (f[i][j][k]+f[i+<span class="number">1</span>][j][k])%mo;</span><br><span class="line"><span class="keyword">if</span>(j&gt;=<span class="number">1</span>) f[i+<span class="number">1</span>][j<span class="number">-1</span>][k+<span class="number">1</span>] = (f[i+<span class="number">1</span>][j<span class="number">-1</span>][k+<span class="number">1</span>]+f[i][j][k]*j)%mo;</span><br><span class="line"><span class="keyword">if</span>(j&gt;=<span class="number">1</span>&amp;&amp;(m-j-k)&gt;<span class="number">0</span>) f[i+<span class="number">1</span>][j][k+<span class="number">1</span>] =(f[i+<span class="number">1</span>][j][k+<span class="number">1</span>]+f[i][j][k]*(m-j-k)*j)%mo;</span><br><span class="line"><span class="keyword">if</span>((m-j-k)&gt;<span class="number">0</span>) f[i+<span class="number">1</span>][j+<span class="number">1</span>][k] = (f[i+<span class="number">1</span>][j+<span class="number">1</span>][k]+f[i][j][k]*(m-j-k))%mo;</span><br><span class="line"><span class="keyword">if</span>(j&gt;=<span class="number">2</span>) f[i+<span class="number">1</span>][j<span class="number">-2</span>][k+<span class="number">2</span>] = (f[i+<span class="number">1</span>][j<span class="number">-2</span>][k+<span class="number">2</span>]+f[i][j][k]*<span class="built_in">C</span>(j))%mo;</span><br><span class="line"><span class="keyword">if</span>((m-j-k)&gt;<span class="number">1</span>) f[i+<span class="number">1</span>][j+<span class="number">2</span>][k] = (f[i+<span class="number">1</span>][j+<span class="number">2</span>][k]+f[i][j][k]*<span class="built_in">C</span>(m-j-k))%mo;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j+i&lt;=m;j++)&#123;</span><br><span class="line">ans = (ans+f[n][i][j])%mo;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans%mo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重构于2021/6/29</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P2501 [HAOI2006]数字序列</title>
      <link href="/2020/08/28/p2501/"/>
      <url>/2020/08/28/p2501/</url>
      
        <content type="html"><![CDATA[<h1 id="P2501-HAOI2006-数字序列"><a href="#P2501-HAOI2006-数字序列" class="headerlink" title="P2501 [HAOI2006]数字序列"></a>P2501 [HAOI2006]数字序列</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给一个长为$n$的序列,求把它改成一个单调递增的序列最少需要改变的数和每个数改变的绝对值之和的最小值</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>神仙$dp$题</p><h2 id="第一问"><a href="#第一问" class="headerlink" title="第一问"></a>第一问</h2><p>直接做不太好做,考虑转化</p><p>最少需要改变的数 $=$ 总数 $-$ 最多不需要改变的数</p><p>若两个数$a_i$,$a_j$$(i&gt;j)$可以保留,则必须满足:</p><p>$a_i - a_j ≥i-j$</p><p>移项,得</p><p>$a_i-i≥a_j-j$</p><p>令$b_i = a_i - i$</p><p>于是原问题就转化为了求$b_i$的最长不下降子序列和在改变最少的数的条件下让$b_i$成为最长不下降序列的最小代价</p><p>最后输出$n -b$的最长不下降子序列长度 即可</p><h2 id="第二问"><a href="#第二问" class="headerlink" title="第二问"></a>第二问</h2><p>首先有个结论$:$</p><p>对于任意区间$[l,r]$,一定存在一个分界点$i$,使得当区间$[l,i]$的值全部修改为$b<em>{l-1}$,区间$[i+1,r]$的值全部修改为$b</em>{r+1}$时总花费最小</p><p>证明$:$</p><p>首先任意的$k∈[l,r]$,其对应的$b<em>k$值一定大于$b</em>{r+1}$或小于$b_{l-1}$</p><p>假设一段中一共有$x$个大于$b<em>{r+1}$的数,$y$个小于$b</em>{l-1}$的数</p><p>如果$x&lt;y$,那么把这一段整体改成$b_{r+1}$时总花费显然会最小</p><p>反之,若$x&gt;y$,那么把这一段整体改为$b_{l-1}$时总花费显然会最小</p><p>因此,最优解一定为将左边一段改为$b<em>{l-1}$,右边一段改为$b</em>{r+1}$</p><p>设$F_i$为以$i$为结尾时的最小代价,$last$为$i$的前驱</p><p>则有转移方程：</p><p>$F<em>i = F_k+\sum</em>{j=last+1}^k|b<em>j-b</em>{last}|+\sum<em>{j=k+1}^{i-1}|b_j-b</em>{i}|$</p><h2 id="code"><a href="#code" class="headerlink" title="$code:$"></a>$code:$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">35010</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 1e12</span></span><br><span class="line"><span class="type">int</span> a[MAXN],b[MAXN],T[MAXN],f[MAXN],n;</span><br><span class="line"><span class="type">int</span> l,r,len;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[MAXN];</span><br><span class="line"><span class="type">int</span> sum1[MAXN],sum2[MAXN];<span class="comment">//前后缀和 </span></span><br><span class="line"><span class="type">int</span> F[MAXN];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n);</span><br><span class="line"><span class="built_in">memset</span>(F,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(F));</span><br><span class="line">g[<span class="number">0</span>].<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">b[<span class="number">0</span>] = -inf,b[n+<span class="number">1</span>] = inf;<span class="comment">//边界 </span></span><br><span class="line">F[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">b[i] = a[i] - i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)&#123;<span class="comment">//求最长不下降子序列 </span></span><br><span class="line">l=<span class="number">0</span>,r=len;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line"><span class="type">int</span> mid = (l+r+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(T[mid]&lt;=b[i]) l = mid;</span><br><span class="line"><span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(l==len) len++;</span><br><span class="line">f[i] = l+<span class="number">1</span>;</span><br><span class="line">T[l+<span class="number">1</span>] = b[i];</span><br><span class="line">g[f[i]].<span class="built_in">push_back</span>(i);<span class="comment">//记录长度为f[i]的最长不下降子序列的结尾i </span></span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;n-len+<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;g[f[i]<span class="number">-1</span>].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line"><span class="type">int</span> start = g[f[i]<span class="number">-1</span>][j];</span><br><span class="line"><span class="keyword">if</span>(b[start]&gt;b[i]) <span class="keyword">continue</span>; </span><br><span class="line">sum1[start] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=start+<span class="number">1</span>;k&lt;=i<span class="number">-1</span>;k++)&#123;</span><br><span class="line">sum1[k] = sum1[k<span class="number">-1</span>]+<span class="built_in">abs</span>(b[start]-b[k]);<span class="comment">//前缀和 </span></span><br><span class="line">&#125;</span><br><span class="line">sum2[i<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=i<span class="number">-2</span>;k&gt;=start;k--)&#123;</span><br><span class="line">sum2[k] = sum2[k+<span class="number">1</span>]+<span class="built_in">abs</span>(b[k+<span class="number">1</span>]-b[i]);<span class="comment">//后缀和 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=start;k&lt;=i<span class="number">-1</span>;k++)&#123;<span class="comment">//枚举分界点 </span></span><br><span class="line">F[i] = <span class="built_in">min</span>(F[i] , F[start]+sum1[k]+sum2[k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;F[n+<span class="number">1</span>];</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="坑点-amp-amp-感想"><a href="#坑点-amp-amp-感想" class="headerlink" title="坑点&amp;&amp;感想"></a>坑点&amp;&amp;感想</h2><ul><li>注意补集转化</li></ul>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P5664 Emiya家今天的饭</title>
      <link href="/2020/08/27/p5664/"/>
      <url>/2020/08/27/p5664/</url>
      
        <content type="html"><![CDATA[<h1 id="P5664-Emiya-家今天的饭"><a href="#P5664-Emiya-家今天的饭" class="headerlink" title="P5664 Emiya 家今天的饭"></a>P5664 Emiya 家今天的饭</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给一个$n×m$的矩阵,从矩阵中选出$k$个元素</p><p>要求满足:</p><ul><li><p>每行只能选一个元素</p></li><li><p>每列的元素个数$≤\dfrac{k}{2}$</p></li></ul><p>求满足条件的集合的方案数之和</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><h2 id="算法一"><a href="#算法一" class="headerlink" title="算法一"></a>算法一</h2><p>先来观察一下限制</p><p>由于不可能有两列都超过总数的一半,不合法的列只可能有一列</p><p>直接做可能不太好做,考虑容斥</p><ul><li>合法方案数 $=$ 总方案数 $-$ 不合法方案数 </li></ul><p>对于不合法的方案数:</p><p>若一个集合不合法,说明某一列的选择个数一定大于其他列中选择个数之和,因此考虑去枚举哪一列不合法</p><p>设$sum[i]$为第$i$行的和</p><p>设$f[i][j][k]$为第$p$列,前$i$行,$p$列中选取了$j$个数,其他列中选取了$k$个数</p><p>则有转移:</p><ul><li>$f[i][j][k] = f[i-1][j][k]+(sum[i]-a[i][now])×f[i-1][j][k-1]+a[i][now]×f[i-1][j-1][k]$</li></ul><p>对于总方案数:</p><p>每一行都可以选择一个元素或不选,根据乘法原理,得到:</p><p>$ans = ∏<em>{i=1}^n∑</em>{j=1}^ma[i][j]-1$(-1是减去空集)</p><p>复杂度$O(mn^3)$,可以获得$84pts$</p><h2 id="code"><a href="#code" class="headerlink" title="$code:$"></a>$code:$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mo 998244353</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">110</span>,MAXM =<span class="number">2010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[MAXN][MAXM];</span><br><span class="line"><span class="type">int</span> sum[MAXN];</span><br><span class="line"><span class="type">int</span> f[MAXN][MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> CUT = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i][j]);</span><br><span class="line">sum[i]+=a[i][j]; </span><br><span class="line">sum[i]%=mo;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">ans *=(<span class="number">1</span>+sum[i])%mo;</span><br><span class="line">ans%=mo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ans = (ans<span class="number">-1</span>+mo)%mo;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">1</span>;now&lt;=m;now++)&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=i;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=i-j;k++)&#123;</span><br><span class="line">f[i][j][k] = f[i - <span class="number">1</span>][j][k];</span><br><span class="line">                    f[i][j][k] += (j&gt;<span class="number">0</span>?f[i - <span class="number">1</span>][j - <span class="number">1</span>][k]:<span class="number">0</span>)* a[i][now] % mo;</span><br><span class="line">                    f[i][j][k] %= mo;</span><br><span class="line">                    f[i][j][k] += (sum[i] - a[i][now] + mo) % mo * (k&gt;<span class="number">0</span>?f[i - <span class="number">1</span>][j][k<span class="number">-1</span>]:<span class="number">0</span>) % mo;</span><br><span class="line">                    f[i][j][k] %= mo;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n-i;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i&gt;j) CUT=(CUT+f[n][i][j])%mo;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;(ans-CUT+mo)%mo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法二"><a href="#算法二" class="headerlink" title="算法二"></a>算法二</h2><p>考虑进一步优化,减去无用状态</p><p>注意到在转移过程中,我们并不关心$k$和$j$的具体数值,而只关心其相对大小关系,考虑直接记录差值</p><p>蛇$f[i][j]$为第$p$列,前$i$行,第$p$列和其他列的差值</p><p>则有转移:</p><p>$f[i][j] = f[i-1][j]+f[i-1][j-1]×a[i][p]+f[i-1][j+1]*(sum[i]-a[i][p])$</p><p>复杂度$O(mn^2)$</p><h2 id="code-1"><a href="#code-1" class="headerlink" title="$code:$"></a>$code:$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">210</span>,MAXM = <span class="number">2010</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mo 998244353</span></span><br><span class="line"><span class="type">int</span> a[MAXN][MAXM];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> f[MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> sum[MAXN];</span><br><span class="line"><span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> udk = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i][j]);</span><br><span class="line">sum[i]+=a[i][j];</span><br><span class="line">sum[i]%=mo;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">ans*=(sum[i]+<span class="number">1</span>)%mo;</span><br><span class="line">ans%=mo;</span><br><span class="line">&#125;</span><br><span class="line">ans = (ans<span class="number">-1</span>+mo)%mo;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> p = <span class="number">1</span>;p&lt;=m;p++)&#123;</span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">f[<span class="number">0</span>][n] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=n-i;j&lt;=n+i;j++)&#123;</span><br><span class="line">f[i][j] = ((f[i<span class="number">-1</span>][j]%mo+f[i<span class="number">-1</span>][j+<span class="number">1</span>]*(sum[i]-a[i][p]+mo)%mo)%mo+f[i<span class="number">-1</span>][j<span class="number">-1</span>]*a[i][p]%mo)%mo;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">udk=(udk+f[n][i+n])%mo;</span><br><span class="line">udk%=mo;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;(ans-udk+mo)%mo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="坑点-amp-amp-感想"><a href="#坑点-amp-amp-感想" class="headerlink" title="坑点&amp;&amp;感想"></a>坑点&amp;&amp;感想</h2><ul><li><p>原问题不太可做时,可以考虑容斥</p></li><li><p>转移时若只关心相对大小关系,可以直接记录差值</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P5658 括号树</title>
      <link href="/2020/08/26/p5658/"/>
      <url>/2020/08/26/p5658/</url>
      
        <content type="html"><![CDATA[<p>重构于$2021/1/30$</p><h1 id="P5658-括号树"><a href="#P5658-括号树" class="headerlink" title="P5658 括号树"></a>P5658 括号树</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给一颗$n$个节点的树,每个结点上都有一个左括号或右括号</p><p>定义 $s_i$为将根结点到 $i$ 号结点的简单路径上的括号，按结点经过顺序依次排列组成的字符串。$k_i$表示$s_i$中不同的合法括号子串的个数，</p><p>求$i \times k_i$的异或和</p><p>$n≤5×10^5$</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>显然只有在当前节点括号为”$)$”且前面有未匹配上的”$($”的时候才会产生新的合法括号</p><p>设$f_i$为从根节点到$i$节点的合法字符字串,$last_i$为$i$节点前上一个没有匹配的”$($”,$g_i$为以$i$为结尾的合法串数量</p><p>$f<em>i = \sum g</em>{last_{i-1}}+1$</p><h2 id="code"><a href="#code" class="headerlink" title="$code:$"></a>$code:$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">500010</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">e</span>&#123;</span><br><span class="line"><span class="type">int</span> to,next;</span><br><span class="line">&#125;edge[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> head[MAXN&lt;&lt;<span class="number">1</span>],cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">edge[++cnt].to = v;</span><br><span class="line">edge[cnt].next = head[u];</span><br><span class="line">head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> a[MAXN];</span><br><span class="line"><span class="type">int</span> n,sum,F[MAXN],fa[MAXN];</span><br><span class="line"><span class="type">int</span> last[MAXN];</span><br><span class="line"><span class="type">int</span> num[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">last[u] = last[fa[u]];</span><br><span class="line">F[u] = F[fa[u]];</span><br><span class="line"><span class="keyword">if</span>(a[u]==<span class="string">&#x27;(&#x27;</span>) last[u] = u;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a[u]==<span class="string">&#x27;)&#x27;</span>&amp;&amp;last[u]!=<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(last[u]==fa[u]) num[u] = num[fa[u]]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> num[u] = num[fa[last[u]]]+<span class="number">1</span>;</span><br><span class="line">last[u] = last[fa[last[u]]];</span><br><span class="line">F[u]+=num[u];</span><br><span class="line">&#125;</span><br><span class="line">ans^=u*F[u];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(f==v) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs</span>(v,u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">cin&gt;&gt;fa[i];</span><br><span class="line"><span class="built_in">add</span>(i,fa[i]);</span><br><span class="line"><span class="built_in">add</span>(fa[i],i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>); </span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P1295 [TJOI2011]书架</title>
      <link href="/2020/08/26/p1295/"/>
      <url>/2020/08/26/p1295/</url>
      
        <content type="html"><![CDATA[<h1 id="P1295-TJOI2011-书架"><a href="#P1295-TJOI2011-书架" class="headerlink" title="P1295 [TJOI2011]书架"></a>P1295 [TJOI2011]书架</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给出一个长度为 $n$ 的序列 $h$，请将 $h$ 分成若干段，满足每段数字之和都不超过 $m$，最小化每段的最大值之和。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h2 id="算法一"><a href="#算法一" class="headerlink" title="算法一"></a>算法一</h2><p>有个非常直观的想法</p><p>设$f[i]$为前$i$个数的最小值</p><p><del>根据套路</del>易得到转移方程:</p><ul><li>$f[i] = min(f[j]+max(h[j+1]$~$h[i]))(\sum_{j+1}^ih[i]&lt;=m)$</li></ul><p>复杂度$O(n^2)$</p><p>吸氧后可以取得80pts的<del>好成绩</del></p><h2 id="code"><a href="#code" class="headerlink" title="$code:$"></a>$code:$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100010</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">int</span> f[MAXN] , h[MAXN];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sum[MAXN];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;h[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">sum[i] = sum[i<span class="number">-1</span>]+h[i];</span><br><span class="line">&#125;</span><br><span class="line">f[<span class="number">1</span>] = h[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">f[i] = <span class="number">191981019</span>;</span><br><span class="line"><span class="type">int</span> maxn = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line"><span class="keyword">if</span>(sum[i] - sum[j]&gt;m) <span class="keyword">break</span>;</span><br><span class="line">maxn =<span class="built_in">max</span>(h[j+<span class="number">1</span>],maxn);</span><br><span class="line">f[i] = <span class="built_in">min</span>(f[i],f[j]+maxn);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;f[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法二"><a href="#算法二" class="headerlink" title="算法二"></a>算法二</h2><p>线段树优化$dp$</p><p>回到上面那个方程</p><p> $f[i] = min(f[j]+max(h[j+1]$~$h[i]))(\sum_{j+1}^ih[i]&lt;=m)$</p><p> $\sum_{j+1}^ih[i]&lt;=m$这个限制我们可以通过二分得到</p><p> 设$pos_i$为最左端点</p><p> 问题就转化成了:</p><p>  $f[i] = min(f[j]+max(h[j+1]$~$h[i]))(pos_i&lt;=m)$</p><p>首先对于每个$i$,如果有一个位置$pos$满足$[pos,i)$中的$h$均小于$h[i]$,显然其后面的所有$maxh[i]$都为$h[i]$</p><p>开一个单调栈,找出这个位置$l$，并将区间$[l+1,i)$的位置全部改为$h[i]$</p><p>区间修改,考虑使用线段树来维护</p><p>用线段树来维护两个值,$f[i-1]$和$f[j]+max(h[j+1]$~$h[i])$</p><p>每当枚举到一个$i$时</p><ul><li><p>更新$i$节点的$f[i-1]$ $<del>~</del>$(单点修改)</p></li><li><p>将区间$[l+1,i)$的位置全部改为$h[i]$ $<del>~</del>$(区间修改)</p></li><li><p>二分查找$i$最左端点,并查询区间$[l+1,i]$的最小$f[j]+max(h[j+1]$~$h[i])$ $<del>~</del>$(区间查询)</p></li></ul><h2 id="算法三-补充"><a href="#算法三-补充" class="headerlink" title="算法三(补充)"></a>算法三(补充)</h2><p><del>过了半年后重做这道题时yy出来的想法</del></p><p>考虑对算法一的方程进行优化,使用线段树来维护$max(h_i)$和$min(f_j+max(h_i))$,并在每次更新时插入新值</p><p>同时,对于$\sum_{j+1}^ih&lt;=m$的限制条件,因为左端点的更新都是只增不减的,只需要在处理新数据之前先进行一次二分，找到左端点即可</p><p>总复杂度$O(nlogn)$</p><h2 id="code-1"><a href="#code-1" class="headerlink" title="$code:$"></a>$code:$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson (node&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson (node&lt;&lt;1|1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 1e12+1145</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mid ((l+r)&gt;&gt;1)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100010</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st</span>&#123;</span><br><span class="line"><span class="type">int</span> ans,tag,val;</span><br><span class="line"><span class="type">int</span> l,r;</span><br><span class="line">&#125;tree[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[MAXN],n,m;</span><br><span class="line"><span class="type">int</span> sta[MAXN],sum[MAXN],top = <span class="number">0</span>,last[MAXN],f[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;<span class="comment">//上传</span></span><br><span class="line">tree[node].ans = <span class="built_in">min</span>(tree[rson].ans,tree[lson].ans);</span><br><span class="line">tree[node].val = <span class="built_in">min</span>(tree[rson].val,tree[lson].val);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">tree[node].l = l,tree[node].r = r;</span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">tree[node].tag = tree[node].val = tree[node].ans = inf;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">build</span>(lson,l,mid);</span><br><span class="line"><span class="built_in">build</span>(rson,mid+<span class="number">1</span>,r);</span><br><span class="line"><span class="built_in">pushup</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tree[node].tag==inf) <span class="keyword">return</span>;</span><br><span class="line">tree[lson].ans = tree[lson].val+tree[node].tag;<span class="comment">//更新最小值</span></span><br><span class="line">tree[rson].ans = tree[rson].val+tree[node].tag;</span><br><span class="line">tree[lson].tag = tree[rson].tag = tree[node].tag;</span><br><span class="line">tree[node].tag = inf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tree[node].l&gt;=l&amp;&amp;tree[node].r&lt;=r)&#123;</span><br><span class="line"><span class="keyword">return</span> tree[node].ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pushdown</span>(node);</span><br><span class="line"><span class="type">int</span> miD = (tree[node].l+tree[node].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> Ans = inf;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=miD) Ans = <span class="built_in">min</span>(Ans , <span class="built_in">query</span>(lson,l,r));</span><br><span class="line"><span class="keyword">if</span>(r&gt;miD) Ans = <span class="built_in">min</span>(Ans , <span class="built_in">query</span>(rson,l,r));</span><br><span class="line"><span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update1</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> c)</span></span>&#123;<span class="comment">//区间修改</span></span><br><span class="line"><span class="keyword">if</span>(tree[node].l&gt;=l&amp;&amp;tree[node].r&lt;=r)&#123;</span><br><span class="line">tree[node].tag = c;</span><br><span class="line">tree[node].ans = tree[node].val+c;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pushdown</span>(node);</span><br><span class="line"><span class="type">int</span> miD = (tree[node].l+tree[node].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=miD) <span class="built_in">update1</span>(lson,l,r,c);</span><br><span class="line"><span class="keyword">if</span>(r&gt;miD) <span class="built_in">update1</span>(rson,l,r,c);</span><br><span class="line"><span class="built_in">pushup</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update2</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> x)</span></span>&#123;<span class="comment">//单点修改</span></span><br><span class="line"><span class="keyword">if</span>(tree[node].l==tree[node].r)&#123;</span><br><span class="line">tree[node].val = f[x<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pushdown</span>(node);</span><br><span class="line"><span class="type">int</span> miD = (tree[node].l+tree[node].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=miD) <span class="built_in">update2</span>(lson,x);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">update2</span>(rson,x);</span><br><span class="line"><span class="built_in">pushup</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;h[i]);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">sum[i] = sum[i<span class="number">-1</span>]+h[i];</span><br><span class="line">&#125;</span><br><span class="line">sta[++top] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(h[i]&gt;h[sta[top]]&amp;&amp;top) top--;</span><br><span class="line"><span class="keyword">if</span>(top) last[i] = sta[top];</span><br><span class="line">sta[++top] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">update2</span>(<span class="number">1</span>,i);</span><br><span class="line"><span class="keyword">if</span>(last[i]&lt;i) <span class="built_in">update1</span>(<span class="number">1</span>,last[i]+<span class="number">1</span>,i,h[i]);</span><br><span class="line"><span class="type">int</span> begin = <span class="built_in">lower_bound</span>(sum,sum+i+<span class="number">1</span>,sum[i]-m)-sum;</span><br><span class="line"><span class="keyword">if</span>(begin&lt;i) f[i] = <span class="built_in">query</span>(<span class="number">1</span>,begin+<span class="number">1</span>,i);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;f[n];</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="坑点-amp-amp-感想"><a href="#坑点-amp-amp-感想" class="headerlink" title="坑点&amp;&amp;感想"></a>坑点&amp;&amp;感想</h2><ul><li><p>$inf$的值一定要设大</p></li><li><p>条件允许时,可以考虑使用线段树来优化$dp$</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P1944 最长括号匹配</title>
      <link href="/2020/08/25/p1944/"/>
      <url>/2020/08/25/p1944/</url>
      
        <content type="html"><![CDATA[<h1 id="P1944-最长括号匹配"><a href="#P1944-最长括号匹配" class="headerlink" title="P1944 最长括号匹配"></a>P1944 最长括号匹配</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给一个由(,),[,]括号组成的字符串，求出其中最长的括号匹配子串。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>水题</p><h2 id="算法一"><a href="#算法一" class="headerlink" title="算法一"></a>算法一</h2><p>比较容易想到的一种算法</p><p>直接用栈来维护,用$vis[i]$来记录第$i$位是否匹配成功</p><p>找出最长的一段输出即可</p><h2 id="code"><a href="#code" class="headerlink" title="$code:$"></a>$code:$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1000010</span>;</span><br><span class="line">string s;</span><br><span class="line">stack&lt;<span class="type">char</span>&gt; S;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; pos;</span><br><span class="line"><span class="type">bool</span> tr[MAXN];</span><br><span class="line"><span class="type">int</span> ans[<span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> L =<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;s;</span><br><span class="line">s = <span class="string">&#x27; &#x27;</span>+s;</span><br><span class="line">S.<span class="built_in">push</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">pos.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line"><span class="keyword">if</span>((s[i]==<span class="string">&#x27;)&#x27;</span>&amp;&amp;S.<span class="built_in">top</span>()==<span class="string">&#x27;(&#x27;</span>)||(s[i]==<span class="string">&#x27;]&#x27;</span>&amp;&amp;S.<span class="built_in">top</span>()==<span class="string">&#x27;[&#x27;</span>)) tr[i] = tr[pos.<span class="built_in">top</span>()] = <span class="number">1</span>,S.<span class="built_in">pop</span>(),pos.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">else</span> pos.<span class="built_in">push</span>(i) , S.<span class="built_in">push</span>(s[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> now = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(tr[i])&#123;</span><br><span class="line">now++;</span><br><span class="line"><span class="keyword">if</span>(now&gt;ans[<span class="number">3</span>])&#123;</span><br><span class="line">ans[<span class="number">3</span>] = now,ans[<span class="number">1</span>] = L,ans[<span class="number">2</span>] = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">now = <span class="number">0</span>;</span><br><span class="line">L = i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=ans[<span class="number">1</span>];i&lt;=ans[<span class="number">2</span>];i++)&#123;</span><br><span class="line">cout&lt;&lt;s[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法二"><a href="#算法二" class="headerlink" title="算法二"></a>算法二</h2><p>设$f[i]$为以第$i$位为末尾的匹配括号字串的最长长度</p><p>若$s[i]$为$($或$[$,不可能匹配,直接跳过即可</p><p>如果$s[i]$为$)$或$]$</p><p>设与$s[i]$相匹配的字符为$s[k]$</p><p>$1.$首先$k$肯定不能在区间$[i-f[i-1],i)$,该区间内的每个字符都已经”被匹配了”</p><p>$2.$假设$k$在区间$[1,i-f[i-1]-1)$中,说明区间$[k+1,i-1]$的字符都是匹配的,与$f[i-1]$矛盾</p><p>综上,$k$能在的位置只有$i-f[i-1]-1$</p><p>得到转移方程:</p><ul><li>$f[i] = f[i-1]+f[i-f[i-1]-2]+2$ </li></ul><h2 id="code-1"><a href="#code-1" class="headerlink" title="$code:$"></a>$code:$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1000010</span>;</span><br><span class="line"><span class="type">int</span> f[MAXN];</span><br><span class="line"><span class="type">int</span> ans = <span class="number">-114514</span>;</span><br><span class="line">string s;</span><br><span class="line"><span class="type">int</span> start,end;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;s;</span><br><span class="line">s = <span class="string">&#x27; &#x27;</span>+s;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(s[i]==<span class="string">&#x27;)&#x27;</span>||s[i]==<span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>((s[i]==<span class="string">&#x27;]&#x27;</span>&amp;&amp;s[i-f[i<span class="number">-1</span>]<span class="number">-1</span>]==<span class="string">&#x27;[&#x27;</span>)||(s[i]==<span class="string">&#x27;)&#x27;</span>&amp;&amp;s[i-f[i<span class="number">-1</span>]<span class="number">-1</span>]==<span class="string">&#x27;(&#x27;</span>))&#123;</span><br><span class="line">f[i] = f[i<span class="number">-1</span>]+f[i-f[i<span class="number">-1</span>]<span class="number">-2</span>]+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(f[i]&gt;ans)&#123;</span><br><span class="line">ans = f[i],end = i;</span><br><span class="line">start = i-f[i]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;=end;i++)&#123;</span><br><span class="line">cout&lt;&lt;s[i];</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P5851 [USACO]Greedy Pie Eaters P</title>
      <link href="/2020/08/24/p5851/"/>
      <url>/2020/08/24/p5851/</url>
      
        <content type="html"><![CDATA[<h1 id="P5851-USACO-Greedy-Pie-Eaters-P"><a href="#P5851-USACO-Greedy-Pie-Eaters-P" class="headerlink" title="P5851 [USACO]Greedy Pie Eaters P"></a>P5851 [USACO]Greedy Pie Eaters P</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有$M$头奶牛,$N$个派,每头奶牛都有一个吃派的范围和体重,分别用$l$,$r$,$w$表示</p><p>求出每头奶牛按顺序吃完后,满足每个奶牛都吃到至少一个派的情况下的最大体重值之和</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>设$f[i][j]$为区间$[i,j]$可获得的最大权值</p><p>$w[i][j][k]$为能吃掉$k$的最大的一个$w$$(i\le l\le k\le r\le j)$</p><p>先来考虑如何去搞出$w[i][j][k]$</p><p>可以去用已知的$w[i][j][k]$去一个个向外更新,扩展到整个序列</p><p>得到方程:</p><p>$w[i-1][j][k] = max(w[i][j][k] , w[i-1][j][k])$</p><p>$w[i][j+1][k] = max(w[i][j][k] , w[i][j+1][k])$</p><p>要注意的是这里的枚举顺序</p><p>因为是不断向外扩展更新的,在枚举$i$时要倒序枚举,枚举$j$时要正序枚举</p><p>转移方程的话首先可以联想到</p><p>$f[i][j] = max(f[i][k]+f[k+1][j])(i\le k &lt;j)$</p><p>但由于这样转移不能让新进干员吃到派</p><p>因此转移方程要改为</p><ul><li>$f[i][j] = max(f[i][k-1]+w[i][j][k]+f[k+1][j])$(第$k$个派还未被吃)</li></ul><h2 id="坑点-amp-amp-感想"><a href="#坑点-amp-amp-感想" class="headerlink" title="坑点&amp;&amp;感想"></a>坑点&amp;&amp;感想</h2><ul><li><p>注意元素之前的关系</p></li><li><p>注意更新顺序和枚举顺序</p></li></ul><h2 id="code"><a href="#code" class="headerlink" title="$code:$"></a>$code:$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">310</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> dp[MAXN][MAXN] , w[MAXN][MAXN][MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="type">int</span> l,r,val;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;val,&amp;l,&amp;r);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = l;j&lt;=r;j++)&#123;</span><br><span class="line"></span><br><span class="line">w[l][r][j] = <span class="built_in">max</span>(w[l][r][j] , val);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=k;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=k;j&lt;=n;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i!=<span class="number">1</span>) w[i<span class="number">-1</span>][j][k] = <span class="built_in">max</span>(w[i][j][k] , w[i<span class="number">-1</span>][j][k]);</span><br><span class="line"><span class="keyword">if</span>(j!=n) w[i][j+<span class="number">1</span>][k] = <span class="built_in">max</span>(w[i][j][k] , w[i][j+<span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">dp[i][i] = w[i][i][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">1</span>;len&lt;n;len++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i+len&lt;=n;i++)&#123;</span><br><span class="line"><span class="type">int</span> j = i+len;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;=j;k++)&#123;</span><br><span class="line">dp[i][j] = <span class="built_in">max</span>(dp[i][j] , dp[i][k<span class="number">-1</span>]+dp[k+<span class="number">1</span>][j]+w[i][j][k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;dp[<span class="number">1</span>][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>几篇题解似乎都有些奇奇怪怪的错误?</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P4158 [SCOI2009]粉刷匠</title>
      <link href="/2020/08/23/p4158/"/>
      <url>/2020/08/23/p4158/</url>
      
        <content type="html"><![CDATA[<h1 id="P4158-SCOI2009-粉刷匠"><a href="#P4158-SCOI2009-粉刷匠" class="headerlink" title="P4158 [SCOI2009]粉刷匠"></a>P4158 [SCOI2009]粉刷匠</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给$n$行长度为$m$的字符串,每个字符都要被粉刷成黑色或白色,一共有$t$次粉刷机会,每次粉刷,只能选择一行字符串中一段连续的子串,然后涂上一种颜色,每个格子最多只能被粉刷一次。</p><p>求最多刷对格子总数</p><p>$n,m≤50,t≤2500$</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>简单的线性$dp$</p><p><strong>算法1</strong></p><p>设$f(i,j,k,0/1)$表示粉刷前$i$行第$i$行粉刷前$j$行共用了$k$次操作,前一个刷对$/$错时能刷对的最多格子数</p><p>分类讨论每一种情况,转移方程:</p><p>$f(i,j,k,1) = \begin{cases}max(f(i,j-1,k-1,0)+1,f(i,j-1,k,1)+1)&amp;a<em>j=a</em>{j-1}\max(f(i,j-1,k,0)+1,f(i,j-1,k-1,1)+1)&amp;a<em>j≠a</em>{j-1}\end{cases}$</p><p>$f(i,j,k,0) = \begin{cases}max(f(i,j-1,k,0)+1,f(i,j-1,k-1,1)+1)&amp;a<em>j=a</em>{j-1}\f(i,j-1,k,1)&amp;a<em>j≠a</em>{j-1}\end{cases}$</p><p><strong>算法2</strong></p><p>观察发现,不可能在一段连续相同的字符中出现”转折点”,因此我们可以把相同的一段字符合并起来</p><p>设$val(i,j)$表示第$i$行第$j$段连续字符的长度,转移方程:</p><p>$f(i,j,k,0) = max(f(i,j-1,k,1) , f(i,j-1,k-1,0))$<br>$f(i,j,k,1) = max(f(i,j-1,k,0) , f(i,j-1,k-1,1)) + val(i,j)$</p><h2 id="code"><a href="#code" class="headerlink" title="$code:$"></a>$code:$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*if(j==1)&#123;</span></span><br><span class="line"><span class="comment">f[i][j][k][1] = max(f[i-1][m][k-1][0]+1,f[i-1][m][k-1][1]+1);</span></span><br><span class="line"><span class="comment">f[i][j][k][0] = max(f[i-1][m][k-1][0],f[i-1][m][k-1][1]);</span></span><br><span class="line"><span class="comment">continue;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">if(s[j]==s[j-1])&#123;</span></span><br><span class="line"><span class="comment">f[i][j][k][1] = max(f[i][j-1][k-1][0]+1,f[i][j-1][k][1]+1);</span></span><br><span class="line"><span class="comment">f[i][j][k][0] = max(f[i][j-1][k][0],f[i][j-1][k-1][1]);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">else&#123;</span></span><br><span class="line"><span class="comment">f[i][j][k][1] = max(f[i][j-1][k][0]+1,f[i][j-1][k-1][1]+1);</span></span><br><span class="line"><span class="comment">f[i][j][k][0] = f[i][j-1][k][1];</span></span><br><span class="line"><span class="comment">&#125;算法1*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">2510</span>,MAXM = <span class="number">60</span>;</span><br><span class="line"><span class="type">int</span> f[MAXM][MAXM][MAXN][<span class="number">2</span>];</span><br><span class="line"><span class="type">char</span> s[MAXN];</span><br><span class="line"><span class="type">int</span> n,m,t;</span><br><span class="line"><span class="type">int</span> tot[MAXM];</span><br><span class="line"><span class="type">int</span> val[MAXM][MAXN]; </span><br><span class="line"><span class="type">int</span> a[MAXM][MAXN];</span><br><span class="line"><span class="type">int</span> dp[MAXM][MAXN];</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;t);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(s[j]!=s[j<span class="number">-1</span>]) ++tot[i];</span><br><span class="line">val[i][tot[i]]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=tot[i];j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=t;k++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(j==<span class="number">1</span>)&#123;<span class="comment">//从上一行转移</span></span><br><span class="line">    f[i][j][k][<span class="number">0</span>] = <span class="built_in">max</span>(f[i<span class="number">-1</span>][tot[i<span class="number">-1</span>]][k<span class="number">-1</span>][<span class="number">0</span>],f[i<span class="number">-1</span>][tot[i<span class="number">-1</span>]][k<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">    f[i][j][k][<span class="number">1</span>] = <span class="built_in">max</span>(f[i<span class="number">-1</span>][tot[i<span class="number">-1</span>]][k<span class="number">-1</span>][<span class="number">0</span>],f[i<span class="number">-1</span>][tot[i<span class="number">-1</span>]][k<span class="number">-1</span>][<span class="number">1</span>])+val[i][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">f[i][j][k][<span class="number">0</span>] = <span class="built_in">max</span>(f[i][j<span class="number">-1</span>][k][<span class="number">1</span>] , f[i][j<span class="number">-1</span>][k<span class="number">-1</span>][<span class="number">0</span>]);</span><br><span class="line">f[i][j][k][<span class="number">1</span>] = <span class="built_in">max</span>(f[i][j<span class="number">-1</span>][k][<span class="number">0</span>] , f[i][j<span class="number">-1</span>][k<span class="number">-1</span>][<span class="number">1</span>]) + val[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">   ans = <span class="built_in">max</span>(f[n][tot[n]][t][<span class="number">1</span>],f[n][tot[n]][t][<span class="number">0</span>]);</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P4302 [SCOI2003]字符串折叠</title>
      <link href="/2020/08/23/p4302/"/>
      <url>/2020/08/23/p4302/</url>
      
        <content type="html"><![CDATA[<h1 id="P4302-SCOI2003-字符串折叠"><a href="#P4302-SCOI2003-字符串折叠" class="headerlink" title="P4302 [SCOI2003]字符串折叠"></a>P4302 [SCOI2003]字符串折叠</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>比较简单的区间$DP$</p><p>和<a href="https://www.luogu.com.cn/problem/CF607B"><strong>CF607B Zuma</strong></a>类似的思路</p><p>设$f[i][j]$为$s[i]$~$s[j]$的最短折叠长度</p><p>如果该子串本身可以折叠$,$就先把它预处理成它不进行划分可以产生的最小值</p><p>再去和划分成两个区间所产生的最小值进行比较即可</p><h2 id="坑点-amp-amp-感想"><a href="#坑点-amp-amp-感想" class="headerlink" title="坑点&amp;&amp;感想"></a>坑点&amp;&amp;感想</h2><ul><li><del>水题,没啥感想</del></li></ul><h2 id="code"><a href="#code" class="headerlink" title="$code:$"></a>$code:$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> dp[MAXN][MAXN] , num[MAXN];</span><br><span class="line">string s;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> L,<span class="type">int</span> R)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> now = L<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">114514</span>)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;i++)&#123;</span><br><span class="line">now++;</span><br><span class="line"><span class="keyword">if</span>(now&gt;R||s[now]!=s[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(now==R) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dp,inf,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">cin&gt;&gt;s;</span><br><span class="line"><span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">s = <span class="string">&#x27; &#x27;</span>+s; </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dp[i][i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) num[i] = num[i/<span class="number">10</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> len = <span class="number">1</span>;len&lt;n;len++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> l =<span class="number">1</span>;l+len&lt;=n;l++)&#123;</span><br><span class="line"><span class="type">int</span> r = l+len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=l;k&lt;r;k++)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">pd</span>(l,k,k+<span class="number">1</span>,r)) dp[l][r] = <span class="built_in">min</span>(dp[l][r] , dp[l][k]+<span class="number">2</span>+num[(len+<span class="number">1</span>)/(k-l+<span class="number">1</span>)]);</span><br><span class="line">dp[l][r] = <span class="built_in">min</span>(dp[l][r] , dp[l][k]+dp[k+<span class="number">1</span>][r]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;dp[<span class="number">1</span>][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.20~8.30做题笔记</title>
      <link href="/2020/08/22/8-20-8-30%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/08/22/8-20-8-30%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>dp题目合集</p><h1 id="end"><a href="#end" class="headerlink" title="end"></a>end</h1><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://oi-wiki.org/dp/"><strong>动态规划部分简介_oi Wiki</strong></a></p><p><a href="https://www.cnblogs.com/luckyblock/p/13121167.html"><strong>DP从入土到入门_Luckyblock</strong></a> </p><hr><h1 id="8-30题"><a href="#8-30题" class="headerlink" title="8.30题"></a>8.30题</h1><h3 id="P1436-棋盘分割"><a href="#P1436-棋盘分割" class="headerlink" title="P1436 棋盘分割"></a><a href="https://www.luogu.com.cn/problem/P1436">P1436 棋盘分割</a></h3><p>暴力$dp$水题</p><h3 id="P1169-ZJOI2007-棋盘制作-amp-amp-P4147-玉蟾宫"><a href="#P1169-ZJOI2007-棋盘制作-amp-amp-P4147-玉蟾宫" class="headerlink" title="P1169 [ZJOI2007]棋盘制作&amp;&amp;P4147 玉蟾宫"></a><a href="https://www.luogu.com.cn/problem/P1169">P1169 [ZJOI2007]棋盘制作</a>&amp;&amp;<a href="https://www.luogu.com.cn/problem/P4147">P4147 玉蟾宫</a></h3><p>悬线法$dp$板子题</p><h3 id="详细"><a href="#详细" class="headerlink" title="详细"></a><a href="https://www.cnblogs.com/xcxc82/p/13586720.html">详细</a></h3><p><del>明天就开学了,英语作业一个字都还没动过</del></p><p><img src="https://img2020.cnblogs.com/blog/2092833/202008/2092833-20200830221945481-1226699273.png" alt=""></p><hr><h1 id="8-29题"><a href="#8-29题" class="headerlink" title="8.29题"></a>8.29题</h1><h3 id="P3622-APIO2007-动物园"><a href="#P3622-APIO2007-动物园" class="headerlink" title="P3622 [APIO2007]动物园"></a><a href="https://www.luogu.com.cn/problem/P3622">P3622 [APIO2007]动物园</a></h3><p>较难的状压$dp$</p><h3 id="详细-1"><a href="#详细-1" class="headerlink" title="详细"></a><a href="https://www.cnblogs.com/xcxc82/p/13586702.html">详细</a></h3><h3 id="P2051-AHOI2009-中国象棋"><a href="#P2051-AHOI2009-中国象棋" class="headerlink" title="P2051 [AHOI2009]中国象棋"></a><a href="https://www.luogu.com.cn/problem/P2051">P2051 [AHOI2009]中国象棋</a></h3><p>状压$dp$练习题</p><h3 id="详细-2"><a href="#详细-2" class="headerlink" title="详细"></a><a href="https://www.cnblogs.com/xcxc82/p/13586341.html">详细</a></h3><hr><h1 id="8-28题"><a href="#8-28题" class="headerlink" title="8.28题"></a>8.28题</h1><h3 id="P2501-HAOI2006-数字序列"><a href="#P2501-HAOI2006-数字序列" class="headerlink" title="P2501 [HAOI2006]数字序列"></a><a href="https://www.luogu.com.cn/problem/P2501">P2501 [HAOI2006]数字序列</a></h3><p>神仙$dp$题</p><h3 id="详细-3"><a href="#详细-3" class="headerlink" title="详细"></a><a href="https://www.cnblogs.com/xcxc82/p/13579988.html">详细</a></h3><h3 id="P1156-垃圾陷阱"><a href="#P1156-垃圾陷阱" class="headerlink" title="P1156 垃圾陷阱"></a><a href="https://www.luogu.com.cn/problem/P1156">P1156 垃圾陷阱</a></h3><p>背包$dp$水题</p><p>需要注意的是这里的$f$数组可能为0,要先全部赋成负数</p><hr><h1 id="8-27题"><a href="#8-27题" class="headerlink" title="8.27题"></a>8.27题</h1><p>无</p><p><del>看jojo8看上瘾了</del></p><hr><h1 id="8-26题"><a href="#8-26题" class="headerlink" title="8.26题"></a>8.26题</h1><h3 id="P1295-TJOI2011-书架"><a href="#P1295-TJOI2011-书架" class="headerlink" title="P1295 [TJOI2011]书架"></a><a href="https://www.luogu.com.cn/problem/P1295">P1295 [TJOI2011]书架</a></h3><p>线段树优化$dp$</p><h3 id="详细-4"><a href="#详细-4" class="headerlink" title="详细"></a><a href="https://www.cnblogs.com/xcxc82/p/13568186.html">详细</a></h3><hr><h1 id="8-25题"><a href="#8-25题" class="headerlink" title="8.25题"></a>8.25题</h1><h3 id="P1944-最长括号匹配"><a href="#P1944-最长括号匹配" class="headerlink" title="P1944 最长括号匹配"></a><a href="https://www.luogu.com.cn/problem/P1944">P1944 最长括号匹配</a></h3><p>水题</p><h3 id="详细-5"><a href="#详细-5" class="headerlink" title="详细"></a><a href="https://www.cnblogs.com/xcxc82/p/13558928.html">详细</a></h3><h3 id="P5658-括号树"><a href="#P5658-括号树" class="headerlink" title="P5658 括号树"></a><a href="https://www.luogu.com.cn/problem/P5658">P5658 括号树</a></h3><p>去年的$d1t2$</p><p>感觉比$18$年的$t2$稍微简单一点?</p><h3 id="详细-6"><a href="#详细-6" class="headerlink" title="详细"></a><a href="https://www.cnblogs.com/xcxc82/p/13568454.html">详细</a></h3><h3 id="P5664-Emiya-家今天的饭"><a href="#P5664-Emiya-家今天的饭" class="headerlink" title="P5664 Emiya 家今天的饭"></a><a href="https://www.luogu.com.cn/problem/P5664">P5664 Emiya 家今天的饭</a></h3><p>很不错的一道$dp$题,穴道虚脱</p><p>被自己的一个傻逼错误卡2个多小时==</p><h3 id="详细-7"><a href="#详细-7" class="headerlink" title="详细"></a><a href="https://www.cnblogs.com/xcxc82/p/13570717.html">详细</a></h3><hr><h1 id="8-24题"><a href="#8-24题" class="headerlink" title="8.24题"></a>8.24题</h1><p>无</p><p><del>打了一天的r6</del></p><hr><h1 id="8-23题"><a href="#8-23题" class="headerlink" title="8.23题"></a>8.23题</h1><h3 id="P2577-ZJOI2004-午餐"><a href="#P2577-ZJOI2004-午餐" class="headerlink" title="P2577 [ZJOI2004]午餐"></a><a href="https://www.luogu.com.cn/problem/P2577">P2577 [ZJOI2004]午餐</a></h3><p>$dp$练手好题</p><p><del>一开始题意读错了卡了半天</del></p><h3 id="详细-8"><a href="#详细-8" class="headerlink" title="详细"></a><a href="https://www.cnblogs.com/xcxc82/p/13550425.html">详细</a></h3><h3 id="P4158-SCOI2009-粉刷匠"><a href="#P4158-SCOI2009-粉刷匠" class="headerlink" title="P4158 [SCOI2009]粉刷匠"></a><a href="https://www.luogu.com.cn/problem/P4158">P4158 [SCOI2009]粉刷匠</a></h3><p>通过合并同类元素来提高效率</p><p>不过据说直接做也可以过</p><h3 id="详细-9"><a href="#详细-9" class="headerlink" title="详细"></a><a href="https://www.cnblogs.com/xcxc82/p/13551096.html">详细</a></h3><hr><h1 id="8-22题"><a href="#8-22题" class="headerlink" title="8.22题"></a>8.22题</h1><h3 id="P5017-摆渡车"><a href="#P5017-摆渡车" class="headerlink" title="P5017 摆渡车"></a><a href="https://www.luogu.com.cn/problem/P5017">P5017 摆渡车</a></h3><p>斜率优化模板题</p><p>当然也有不需要用斜率优化的做法</p><h3 id="详细-10"><a href="#详细-10" class="headerlink" title="详细"></a><a href="https://www.cnblogs.com/xcxc82/p/13547078.html">详细</a></h3><h3 id="P2900-USACO-土地征用"><a href="#P2900-USACO-土地征用" class="headerlink" title=" P2900 [USACO]土地征用"></a><a href="https://www.luogu.com.cn/problem/P2900"> P2900 [USACO]土地征用</a></h3><p>斜率优化好题</p><p>将$x$作为第一关键字,$y$作为第二关键字进行降序排序</p><p>这样下来就保证了$x$全体有序,只需去记录那些比当前的$y<em>{max}$大的土块,把比$y</em>{max}$小的土块都去掉</p><p>从而简化了转移方程</p><h3 id="详细-11"><a href="#详细-11" class="headerlink" title="详细"></a><a href="https://www.cnblogs.com/xcxc82/p/13547083.html">详细</a></h3><hr><h1 id="8-21题"><a href="#8-21题" class="headerlink" title="8.21题"></a>8.21题</h1><p>斜率优化</p><h3 id="详细-12"><a href="#详细-12" class="headerlink" title="详细"></a><a href="https://www.luogu.com.cn/blog/xcxc82/xie-shuai-you-hua">详细</a></h3><h1 id="8-20题"><a href="#8-20题" class="headerlink" title="8.20题"></a>8.20题</h1><h3 id="P3554-POI2013-LUK-Triumphal-arch"><a href="#P3554-POI2013-LUK-Triumphal-arch" class="headerlink" title="P3554 [POI2013]LUK-Triumphal arch"></a><a href="https://www.luogu.com.cn/problem/P3554">P3554 [POI2013]LUK-Triumphal arch</a></h3><p>二分答案$+$树形$DP$</p><p>通过树形$DP$来判断当前的$k$是否可行</p><h3 id="详细-13"><a href="#详细-13" class="headerlink" title="详细"></a><a href="https://www.cnblogs.com/xcxc82/p/13536223.html">详细</a></h3><h3 id="P4302-SCOI2003-字符串折叠"><a href="#P4302-SCOI2003-字符串折叠" class="headerlink" title="P4302 [SCOI2003]字符串折叠"></a><a href="https://www.luogu.com.cn/problem/P4302">P4302 [SCOI2003]字符串折叠</a></h3><p>区间$dp$水题</p><h3 id="详细-14"><a href="#详细-14" class="headerlink" title="详细"></a><a href="https://www.cnblogs.com/xcxc82/p/13550735.html">详细</a></h3><h3 id="P5851-USACO19DEC-Greedy-Pie-Eaters-P"><a href="#P5851-USACO19DEC-Greedy-Pie-Eaters-P" class="headerlink" title="P5851 [USACO19DEC]Greedy Pie Eaters P"></a><a href="https://www.luogu.com.cn/problem/P5851">P5851 [USACO19DEC]Greedy Pie Eaters P</a></h3><p>区间$DP$,转移方程比较独特</p><p>在枚举顺序上也有些要注意的细节</p><h3 id="详细-15"><a href="#详细-15" class="headerlink" title="详细"></a><a href="https://www.cnblogs.com/xcxc82/p/13552907.html">详细</a></h3><hr>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P2900 [USACO]土地征用</title>
      <link href="/2020/08/22/p2900/"/>
      <url>/2020/08/22/p2900/</url>
      
        <content type="html"><![CDATA[<h1 id="P2900-USACO-土地征用"><a href="#P2900-USACO-土地征用" class="headerlink" title=" P2900 [USACO]土地征用"></a><a href="https://www.luogu.com.cn/problem/P2900"> P2900 [USACO]土地征用</a></h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给$n$块 宽$x_i$ 长$y_i$ 的土地,可以将这$n$块土地分成几个组来购买,每组所需要的购买价值为该组中的最大长度$×$最大宽度</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>斜率优化$dp$好题。</p><p>首先通过观察可以看出,当一块土地的长度和宽度都大于另一块土地且两个土地在同一组时</p><p>小的那块土地相当于”毫无用处”</p><p>不妨设法消去这些无用的土块</p><p>具体做法:</p><p>将$x$作为第一关键字,$y$作为第二关键字进行降序排序</p><p>这样下来就已经保证了$x$全体有序,只需去记录那些比当前的$y$大的土块即可</p><p>两轮下来相当于满足了$x[i]$单调递减，$y[i]$单调递增</p><p>设$f[i]为购买前$i$个”有用的”土块所需的最小花费$</p><p>易得状态转移方程:</p><ul><li>$f[i] = min(f[j]+x[j+1]*y[i])$</li></ul><p>再根据斜优套路,得到不等式:</p><ul><li>$\dfrac{f[j]-f[k]}{x[k+1]-x[j+1]}&gt;y[i]$</li></ul><p>利用单调队列去维护即可,时间复杂度$O(tot)$</p><h2 id="坑点-amp-amp-感想"><a href="#坑点-amp-amp-感想" class="headerlink" title="坑点&amp;&amp;感想"></a>坑点&amp;&amp;感想</h2><ul><li><del>十年OI一场空,不开long long见祖宗</del></li></ul><h2 id="code"><a href="#code" class="headerlink" title="$code:$"></a>$code:$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">50010</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">record</span>&#123;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> record k)<span class="type">const</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x==k.x)&#123;</span><br><span class="line"><span class="keyword">return</span> y&gt;k.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x&gt;k.x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;d[MAXN];</span><br><span class="line"><span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> maxn = <span class="number">-114514</span>;</span><br><span class="line"><span class="type">int</span> n,f[MAXN];</span><br><span class="line"><span class="type">int</span> q[MAXN];</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">slope</span><span class="params">(<span class="type">int</span> j,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1.0</span>*((f[j] - f[k]) / (d[k+<span class="number">1</span>].x - d[j+<span class="number">1</span>].x));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;d[i].x,&amp;d[i].y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(d+<span class="number">1</span>,d+n+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(maxn&gt;=d[i].y) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">else</span> maxn = d[i].y,d[++tot] = d[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> l = <span class="number">0</span> ,r = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r&amp;&amp;<span class="built_in">slope</span>(q[l],q[l+<span class="number">1</span>])&lt;=d[i].y) l++;</span><br><span class="line">f[i] = f[q[l]]+d[q[l]+<span class="number">1</span>].x*d[i].y;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r&amp;&amp;<span class="built_in">slope</span>(q[r<span class="number">-1</span>],q[r])&gt;=<span class="built_in">slope</span>(q[r],i)) r--;</span><br><span class="line">q[++r] = i;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;f[tot];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P5071 摆渡车</title>
      <link href="/2020/08/22/p5071/"/>
      <url>/2020/08/22/p5071/</url>
      
        <content type="html"><![CDATA[<p><strong><a href="https://www.luogu.com.cn/problem/P5017">题目链接</a></strong></p><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有$n$个人,每个人都在一个时间点去等车,求当车何时出发时才能让所有人的等待时间之和最小</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>斜率优化<del>模板题</del></p><p>(似乎大佬们都是用更简单的方法来做的?)</p><p>设$person[i]$为前$i$分钟到达的人数之和</p><p>$sum[i]$为前$i$分钟为前$i$分钟内到达时间之和,$f[i]$为从$i$时刻发车所需要的最小等待时间</p><p><del>根据套路</del>易得状态转移方程$:$</p><p>$f[i] = min(f[j]+(person[i] - person[j])*i  -  (sum[i] - sum[j]))$</p><p>根据斜率优化套路:</p><p>$f[i] = min(f[j]-person[j]<em>i+sum[j])-sum[i]+person[i]</em>i$</p><p>当从$k$转移比从$j$转移更优且$k&gt;j$时,有:</p><p>$f[j]-person[j]<em>i+sum[j]&lt;f[k]-person[k]</em>i+sum[k]$ </p><p>移项得:</p><p>$\dfrac{f[j]-f[k]+sum[j]-sum[k]}{f[k]-f[j]}&gt;i$</p><p>用单调队列来维护即可,总复杂度$O(t)$</p><p>设$tmax$为最后一个人的到来时间,为了让所有人都上车,最后一次发车一定要在区间$[tmax,tmax+m)$中</p><p>最终答案即为在区间$[tmax,tmax+m)$中最小的$f[x]$</p><h2 id="坑点-amp-amp-感想"><a href="#坑点-amp-amp-感想" class="headerlink" title="坑点&amp;&amp;感想"></a>坑点&amp;&amp;感想</h2><ul><li><p>$f[k] - f[j]$可能为$0$,需要特判</p></li><li><p>转移时,$i$要从时间$0$开始</p></li><li><p>在$i&lt;m$时,其本身一定是第一个发车点,无需转移</p></li></ul><h2 id="code"><a href="#code" class="headerlink" title="$code:$"></a>$code:$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">4000010</span>;</span><br><span class="line"><span class="type">int</span> f[MAXN],sum[MAXN];</span><br><span class="line"><span class="type">int</span> m,n;</span><br><span class="line"><span class="type">int</span> maxn;</span><br><span class="line"><span class="type">int</span> person[MAXN];</span><br><span class="line"><span class="type">int</span> q[MAXN];</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">slope</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(person[j] - person[k]==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span>*((f[j]+sum[j]-f[k]-sum[k])*MAXN);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1.0</span>*((f[j]-f[k]+sum[j]-sum[k])/(person[j] - person[k]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k);</span><br><span class="line">person[k]++;</span><br><span class="line">maxn = <span class="built_in">max</span>(k,maxn);</span><br><span class="line">sum[k]+=k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m+maxn;i++)&#123;</span><br><span class="line">sum[i]+=sum[i<span class="number">-1</span>];</span><br><span class="line">person[i]+=person[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> l = <span class="number">1</span>,r = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;maxn+m;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i&gt;=m)&#123;</span><br><span class="line"><span class="type">int</span> now = i-m;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r&amp;&amp;<span class="built_in">slope</span>(q[r<span class="number">-1</span>],q[r])&gt;=<span class="built_in">slope</span>(q[r],now)) r--;</span><br><span class="line">q[++r] = now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r&amp;&amp;<span class="built_in">slope</span>(q[l],q[l+<span class="number">1</span>])&lt;=i) l++;</span><br><span class="line">f[i] = person[i]*i - sum[i];</span><br><span class="line"><span class="keyword">if</span>(l&lt;=r) f[i] = <span class="built_in">min</span>(f[i],(f[q[l]] + (person[i] - person[q[l]])*i-(sum[i]-sum[q[l]])));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans = inf;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=maxn;i&lt;maxn+m;i++)&#123;</span><br><span class="line">ans = <span class="built_in">min</span>(f[i] , ans);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P3554 [POI2013]LUK-Triumphal arch</title>
      <link href="/2020/08/20/p3554/"/>
      <url>/2020/08/20/p3554/</url>
      
        <content type="html"><![CDATA[<h1 id="P3554-POI2013-LUK-Triumphal-arch-题解"><a href="#P3554-POI2013-LUK-Triumphal-arch-题解" class="headerlink" title="P3554 [POI2013]LUK-Triumphal arch 题解"></a>P3554 [POI2013]LUK-Triumphal arch 题解</h1><h2 id="间隙"><a href="#间隙" class="headerlink" title="间隙"></a><a href="https://www.luogu.com.cn/problem/P3554">间隙</a></h2><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul><li><h2 id="树形-DP-二分答案"><a href="#树形-DP-二分答案" class="headerlink" title="树形$DP$ , 二分答案"></a>树形$DP$ , 二分答案</h2></li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>题意翻译里已经写的很清楚了,这里就不重复一遍了</p><p>首先这里的答案$k$具有可二分性,考虑二分答案</p><p>当$B$走到一个节点$u$时,第一步要做的肯定是把$u$的儿子全部都涂色</p><p>如果一个节点的儿子数大于当前的$k$,则无论怎么涂都会输</p><p>反之,说明除了涂自己的儿子外还可以”<strong>提前</strong>“涂其他的节点</p><p>设$f[i]$为以$i$根节点的子树需要<strong>其祖先”提前”染色多少个点才能覆盖整个子树</strong></p><p>易得状态转移方程:$f[u] = max(0  , \sum f[v]+1-k)$</p><p>具体解释$:$</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/i6tgjcmc.png" alt=""></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>直接二分答案$k$,对于每一个$k$进行$dp$</p><p>如果$f[1]$为$0$,则说明可行</p><p>反之说明不可行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">e</span>&#123;</span><br><span class="line"><span class="type">int</span> to,next;</span><br><span class="line">&#125;edge[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> head[MAXN&lt;&lt;<span class="number">1</span>],cnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> f[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;<span class="comment">//前向星</span></span><br><span class="line">edge[++cnt].to = v;</span><br><span class="line">edge[cnt].next = head[u];</span><br><span class="line">head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs</span>(v,u,k);</span><br><span class="line">sum=sum+f[v]+<span class="number">1</span>;<span class="comment">//记录</span></span><br><span class="line">&#125;</span><br><span class="line">f[u] = <span class="built_in">max</span>(<span class="number">0</span>,sum-k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line"><span class="type">int</span> u,v;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line"><span class="built_in">add</span>(u,v);</span><br><span class="line"><span class="built_in">add</span>(v,u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> l = <span class="number">0</span>,r = <span class="number">10e10</span>;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=r)&#123;<span class="comment">//二分答案</span></span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line"><span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>,mid);<span class="comment">//dp</span></span><br><span class="line"><span class="keyword">if</span>(f[<span class="number">1</span>]==<span class="number">0</span>)&#123;<span class="comment">//如果f[1]为0 说明可行</span></span><br><span class="line">ans = mid;</span><br><span class="line">r = mid<span class="number">-1</span>;</span><br><span class="line">&#125;反之,不可行</span><br><span class="line"><span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树上启发式合并</title>
      <link href="/2020/08/16/%E6%A0%91%E4%B8%8A%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/"/>
      <url>/2020/08/16/%E6%A0%91%E4%B8%8A%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="模板题-CF600E-Lomsat-gelral"><a href="#模板题-CF600E-Lomsat-gelral" class="headerlink" title="模板题: CF600E Lomsat gelral"></a>模板题: <a href="https://www.luogu.com.cn/problem/CF600E">CF600E Lomsat gelral</a></h1><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>一棵树有n个结点，每个结点都是一种颜色，每个颜色有一个编号，求树中每个子树的最多的颜色编号的和。</p><h1 id="一些定义"><a href="#一些定义" class="headerlink" title="一些定义"></a>一些定义</h1><ul><li>启发式算法:启发式算法是指基于经验和直观感觉，从而对一些算法的优化。</li></ul><p>举例:并查集的按秩合并</p><p>在并查集的按秩合并中,我们将小的集合往大的集合上合并,这样明显有利于加快并查集的祖先查找</p><h1 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h1><ul><li>首先是一次$bfs$,求出每个节点的重儿子</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">size[u] = <span class="number">1</span> ;<span class="comment">//子树大小</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = head[u];i;i = edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs1</span>(v,u);</span><br><span class="line">size[u]+=size[v];</span><br><span class="line"><span class="keyword">if</span>(size[v]&gt;size[son[u]]) son[u] = v;<span class="comment">//找重儿子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来定义两个数组$cnt[]$和$c[]$,分别代表存放的某颜色在“<strong>当前</strong>”子树中的数量和存放某节点的颜色</p><p>这里的”当前”指的就是目前正在处理的节点(如果给每个节点都开一个$cnt$的话则会$MLE$)</p><ul><li><p>如果目前正在处理的节点是轻儿子,就把它的答案计入并删除其贡献</p></li><li><p>反之,如果是重儿子,也把它的答案计入,但不删除其贡献</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cunt</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">c[color[u]]+=val;<span class="comment">//val为1代表计入贡献,为-1代表删除贡献</span></span><br><span class="line"><span class="keyword">if</span>(c[color[u]] &gt; maxn)&#123;<span class="comment">//最多的颜色</span></span><br><span class="line">maxn = c[color[u]];</span><br><span class="line">sum = color[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(c[color[u]] == maxn)&#123;</span><br><span class="line">sum+=color[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(v==maxson||v==fa) <span class="keyword">continue</span>;<span class="comment">//如果是u的重儿子,直接跳过</span></span><br><span class="line"><span class="built_in">cunt</span>(v,u,val);<span class="comment">//dfs暴力计贡献</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa,<span class="type">int</span> keep)</span></span>&#123;<span class="comment">//keep代表是否保留该贡献</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(v==son[u]||v==fa) <span class="keyword">continue</span>;<span class="comment">//是重儿子直接跳过</span></span><br><span class="line"><span class="built_in">dfs2</span>(v,u,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span>(son[u])&#123;<span class="comment">//如果有重儿子</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">dfs2</span>(son[u],u,<span class="number">1</span>);<span class="comment">//keep为1,保留其贡献</span></span><br><span class="line">maxson = son[u];<span class="comment">//记u节点的重儿子</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cunt</span>(u,fa,<span class="number">1</span>);<span class="comment">//暴力统计其非子树贡献</span></span><br><span class="line">maxson = <span class="number">0</span>;</span><br><span class="line">ans[u] = sum;<span class="comment">//记录答案</span></span><br><span class="line"><span class="keyword">if</span>(!keep)&#123;<span class="comment">//如果不是重儿子,则将其贡献删除</span></span><br><span class="line"><span class="built_in">cunt</span>(u,fa,<span class="number">-1</span>); </span><br><span class="line">sum = maxn = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个$dfs$大致可以分为下面四个流程:</p><ul><li><p>记录轻儿子及其子树的答案且删除其贡献</p></li><li><p>记录重儿子及其子树的答案且不删除其贡献</p></li><li><p>暴力统计$u$及其所有轻儿子的贡献合并到刚算出的重儿子信息里</p></li><li><p>删除该删除的贡献</p></li></ul><p><img src="https://img2020.cnblogs.com/blog/2092833/202008/2092833-20200816183326748-1026754225.png" alt=""></p><p>这样一轮下来相当于是遍历了两遍轻儿子,一遍重儿子,显然效率是较高的</p><p>时间复杂度为$O(nlogn)$,<del>具体怎么证还不太清楚</del></p><p>$code:$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">e</span>&#123;</span><br><span class="line"><span class="type">int</span> next,to;</span><br><span class="line">&#125;edge[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> size[MAXN],son[MAXN];</span><br><span class="line"><span class="type">int</span> color[MAXN],c[MAXN];</span><br><span class="line"><span class="type">int</span> maxn , sum;</span><br><span class="line"><span class="type">int</span> head[MAXN&lt;&lt;<span class="number">1</span>],n,cnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> ans[MAXN] , maxson;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">      cnt++;</span><br><span class="line">      edge[cnt].to = v;</span><br><span class="line">      edge[cnt].next=head[u];</span><br><span class="line">      head[u]=cnt;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">size[u] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = head[u];i;i = edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs1</span>(v,u);</span><br><span class="line">size[u]+=size[v];</span><br><span class="line"><span class="keyword">if</span>(size[v]&gt;size[son[u]]) son[u] = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cunt</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">c[color[u]]+=val;</span><br><span class="line"><span class="keyword">if</span>(c[color[u]] &gt; maxn)&#123;</span><br><span class="line">maxn = c[color[u]];</span><br><span class="line">sum = color[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(c[color[u]] == maxn)&#123;</span><br><span class="line">sum+=color[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(v==maxson||v==fa) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">cunt</span>(v,u,val);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa,<span class="type">int</span> keep)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(v==son[u]||v==fa) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs2</span>(v,u,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(son[u])&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">dfs2</span>(son[u],u,<span class="number">1</span>);</span><br><span class="line">maxson = son[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cunt</span>(u,fa,<span class="number">1</span>);</span><br><span class="line">maxson = <span class="number">0</span>;</span><br><span class="line">ans[u] = sum;</span><br><span class="line"><span class="keyword">if</span>(!keep)&#123;</span><br><span class="line"><span class="built_in">cunt</span>(u,fa,<span class="number">-1</span>); </span><br><span class="line">sum = maxn = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;color[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="type">int</span> u,v;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;u,&amp;v);</span><br><span class="line"><span class="built_in">add</span>(u,v);</span><br><span class="line"><span class="built_in">add</span>(v,u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><del>最近沉迷stg无法自拔了</del></p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tarjan算法学习笔记</title>
      <link href="/2020/08/12/tarjan%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/08/12/tarjan%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><h1 id="缩点"><a href="#缩点" class="headerlink" title="缩点"></a><a href="https://www.luogu.com.cn/problem/P3387">缩点</a></h1><h2 id="一些定义"><a href="#一些定义" class="headerlink" title="一些定义"></a>一些定义</h2><ul><li><p>强连通：如果两个顶点可以相互通达，则称两个顶点强连通。</p></li><li><p>如果有向图$G$的每两个顶点都 强连通，称$G$是一个强连通图。</p></li><li><p>非强连通图有向图的极大强连通子图，称为强连通分量。</p></li></ul><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>定义两个数组,$dfn[ ]$和$low[]$</p><p>$dfn[u]$表示$u$节点第一次被$bfs$到的时间戳</p><p>$low[u]$表示$u$节点能”回溯”到的最早时间 </p><p>如果一个节点$u$的儿子$v$的$low[]$小于自己的$low[]$,说明该节点可以”回溯”到$u$之前,会产生一个强连通分量,记录这些点,将其合并成一个新点即可</p><h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><ul><li><p>每$dfs$一个点$u$时,先把该点的$low[u]$和$dfn[u]$初始化成该点的时间戳,同时把这个点压入一个栈中</p></li><li><p>遍历其所有儿子,如果一个儿子没有被访问过,继续向下$dfs$,同时更新节点$u$的$low[u]$</p></li><li><p>反之,说明该儿子出现在$u$之前,无需再次$dfs$,直接更新节点$u$的$low[u]$即可</p></li></ul><ul><li>最后,如果一个节点的$dfn[]$跟$low$相等,说明该点是一个强连通分量中的起点,将栈中的所有该节点前的值全部取出,合并成一个新的节点</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">dfn[u] = low[u] = ++Time;<span class="comment">//初始化</span></span><br><span class="line">s[++top] = u;<span class="comment">//压入栈</span></span><br><span class="line">vis[u] = <span class="number">1</span>;<span class="comment">//被访问过</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].next)&#123;<span class="comment">//遍历所有儿子</span></span><br><span class="line"><span class="type">int</span> v = edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line"><span class="built_in">tarjan</span>(v);<span class="comment">//向下遍历</span></span><br><span class="line">low[u] = <span class="built_in">min</span>(low[v] , low[u]);<span class="comment">//更新low</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(vis[v])&#123;<span class="comment">//节点被访问过,直接更新</span></span><br><span class="line">low[u] = <span class="built_in">min</span>(low[v] , low[u]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(low[u]==dfn[u])&#123;<span class="comment">//如果是一个强连通分量的起点</span></span><br><span class="line"><span class="type">int</span> v;</span><br><span class="line"><span class="keyword">while</span>(v = s[top--])&#123;</span><br><span class="line">vis[v] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(v==u) <span class="keyword">break</span>;<span class="comment">//将u前面的值全部取出</span></span><br><span class="line">w[u]+=w[v];<span class="comment">//合并点权</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="割点"><a href="#割点" class="headerlink" title="割点"></a><a href="https://www.luogu.com.cn/problem/P3388">割点</a></h1><h2 id="一些定义-1"><a href="#一些定义-1" class="headerlink" title="一些定义"></a>一些定义</h2><ul><li>割点:将一个无向图中的一个节点及与其相连的所有的边都删去后,整个图不再联通,则成该点为该图的一个割点</li></ul><h2 id="算法思路-1"><a href="#算法思路-1" class="headerlink" title="算法思路"></a>算法思路</h2><p>跟缩点大同小异的思路。</p><p>既然去除该点可以让整个图不再联通,说明其儿子与其上面的节点都无连接,也就是无法”回溯”到该点之前的点</p><p>直接用跟缩点一样的思路去写即可。</p><p>要注意的是 $:$ 这里的$low[u]$不再是直接更新成$low[v]$,而是更新为$dfn[v]$,在无向图中,每个点都有一条”返祖”边,这时把子节点的$low[]$值赋为父节点的$low[]$，就可能导致其$low[]==$其父节点$low[]&lt;$其父节点$dfn[]$</p><h2 id="算法流程-1"><a href="#算法流程-1" class="headerlink" title="算法流程"></a>算法流程</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">dfn[u] = low[u] = ++Time;<span class="comment">//初始化</span></span><br><span class="line"><span class="type">int</span> child = <span class="number">0</span>;<span class="comment">//根节点的儿子数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = e[i].to;</span><br><span class="line"><span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line"><span class="built_in">tarjan</span>(v,fa);</span><br><span class="line">low[u] = <span class="built_in">min</span>(low[u] , low[v]);<span class="comment">//更新</span></span><br><span class="line"><span class="keyword">if</span>(low[v]&gt;=dfn[u]&amp;&amp;u!=fa)&#123;<span class="comment">//有一个子节点满足条件即可</span></span><br><span class="line">cut[u]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(u==fa) child++;<span class="comment">//如果是根节点,增加儿子数</span></span><br><span class="line">&#125;</span><br><span class="line">low[u] = <span class="built_in">min</span>(low[u],dfn[v]);<span class="comment">//更新</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(u==fa&amp;&amp;child&gt;=<span class="number">2</span>) cut[u]=<span class="number">1</span>;<span class="comment">//如果根节点数量大于2,说明根节点可以成为割点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="缩点练习"><a href="#缩点练习" class="headerlink" title="缩点练习"></a>缩点练习</h1><p><a href="https://www.luogu.com.cn/problem/P2341">P2341 [USACO03FALL][HAOI2006]受欢迎的牛 G</a></p><p><a href="https://www.luogu.com.cn/problem/P2863">P2863 [USACO06JAN]The Cow Prom S</a></p><p><a href="https://www.luogu.com.cn/problem/P2746">P2746 [USACO5.3]校园网Network of Schools</a></p><p><a href="https://www.luogu.com.cn/problem/P1726">P1726 上白泽慧音</a></p><p><a href="https://www.luogu.com.cn/problem/P1262">P1262 间谍网络</a></p><p><a href="https://www.luogu.com.cn/problem/P5676">P5676 [GZOI2017]小z玩游戏</a></p><h2 id="P2341-USACO03FALL-受欢迎的牛-G"><a href="#P2341-USACO03FALL-受欢迎的牛-G" class="headerlink" title="P2341 [USACO03FALL]受欢迎的牛 G"></a>P2341 [USACO03FALL]受欢迎的牛 G</h2><p>$tarjan$经典题。</p><p>首先是缩点,将每个强联通分量都分成一个组,并记录这个组的出度和大小,如果只有一个组的出度为$0$,则说明该组中的所有奶牛都可以成为神犇(如果有两个组的出度均为零的话则说明%无法完全传递)</p><p>$code:$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">dfn[u] = low[u] = ++Time;</span><br><span class="line">vis[u] = <span class="number">1</span>,s[++top] = u;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = e[i].to;</span><br><span class="line"><span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line"><span class="built_in">tarjan</span>(v);</span><br><span class="line">low[u] = <span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(vis[v])&#123;</span><br><span class="line">low[u] = <span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dfn[u]==low[u])&#123;</span><br><span class="line"><span class="type">int</span> v;</span><br><span class="line">scc[u] = ++k;<span class="comment">//记录分组</span></span><br><span class="line"><span class="keyword">while</span>(v=s[top--])&#123;</span><br><span class="line">vis[v] = <span class="number">0</span>;</span><br><span class="line">scc[v] = k;<span class="comment">//记录分组</span></span><br><span class="line">size[k]++;<span class="comment">//记录大小</span></span><br><span class="line"><span class="keyword">if</span>(v==u) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P2863-USACO06JAN-The-Cow-Prom-S"><a href="#P2863-USACO06JAN-The-Cow-Prom-S" class="headerlink" title="[P2863 [USACO06JAN]The Cow Prom S]"></a>[P2863 [USACO06JAN]The Cow Prom S]</h2><p>简单的$tarjan$模板题。</p><p><del>实际上比模板题还要简单</del></p><p>判断栈头是否为$u$,若不为$u$,则说明有两个及以上的节点,若是,说明只有$u$一个节点</p><p>$code:$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">dfn[u] = low[u] = ++Time;</span><br><span class="line">vis[u] = <span class="number">1</span>,s[++top] = u;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = e[i].to;</span><br><span class="line"><span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line"><span class="built_in">tarjan</span>(v);</span><br><span class="line">low[u] = <span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(vis[v])&#123;</span><br><span class="line">low[u] = <span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dfn[u]==low[u])&#123;</span><br><span class="line"><span class="keyword">if</span>(s[top]!=u) ans++;<span class="comment">//特判</span></span><br><span class="line"><span class="type">int</span> v;</span><br><span class="line"><span class="keyword">while</span>(v=s[top--])&#123;</span><br><span class="line">vis[v] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(v==u) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="P2746-USACO5-3-校园网Network-of-Schools"><a href="#P2746-USACO5-3-校园网Network-of-Schools" class="headerlink" title="[P2746 [USACO5.3]校园网Network of Schools]"></a>[P2746 [USACO5.3]校园网Network of Schools]</h2><p> 给一张图,求:</p><ul><li><p>图中入度为零的点的个数</p></li><li><p>把整张图变成强连通图的最少添边值</p><p>第一问很简单,直接统计一下即可,对于第二问,由于强连通图中每个点的入度和出度都不为零,感性理解一下,可以先将那些出度为0的点和入度为0的点互补,由于出度为0的点的数量和入度为0的点数量可能不一致,因此最后还要将那些剩余的点和其他任意一个点相连</p><p>最后的答案即为出度为零的点的数量和入读为零的点的数量中的最大值。</p><p>$code:$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=head[i];j;j=e[j].next)&#123;</span><br><span class="line"><span class="type">int</span> v = e[j].to;</span><br><span class="line"><span class="keyword">if</span>(scc[i]!=scc[v])&#123;</span><br><span class="line">in[scc[v]]++;<span class="comment">//记录入度</span></span><br><span class="line">out[scc[i]]++;<span class="comment">//记录出度</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ansin = <span class="number">0</span>,ansout = <span class="number">0</span>;<span class="comment">//出度数和入度数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(in[i]==<span class="number">0</span>)&#123;<span class="comment">//记录入度</span></span><br><span class="line">ansin++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(out[i]==<span class="number">0</span>)&#123;<span class="comment">//记录出度</span></span><br><span class="line">ansout++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">1</span>)&#123;<span class="comment">//特判,如果该图已经是一个强连通图了,直接输出1和0即可</span></span><br><span class="line">    cout&lt;&lt;<span class="number">1</span>&lt;&lt;endl&lt;&lt;<span class="number">0</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;ansin&lt;&lt;endl&lt;&lt;<span class="built_in">max</span>(ansin,ansout);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="P1726-上白泽慧音"><a href="#P1726-上白泽慧音" class="headerlink" title="P1726 上白泽慧音"></a>P1726 上白泽慧音</h2><p>车万题面好评</p><p>也是一道挺模板的题。</p><p>大致题意就是说求最大且字典序最小的那个强联通分量。</p><p>直接跑一遍$tarjan$记录每个点所在的强连通分量和该强联通分量的大小,然后一遍$for$循环求出最大的那个组,再将在那个组中的节点输出即可</p><p>$code:$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">dfn[u] = low[u] = ++Time;</span><br><span class="line">vis[u] = <span class="number">1</span>,s[++top] = u;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = e[i].to;</span><br><span class="line"><span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line"><span class="built_in">tarjan</span>(v);</span><br><span class="line">low[u] = <span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(vis[v])&#123;</span><br><span class="line">low[u] = <span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dfn[u]==low[u])&#123;</span><br><span class="line"><span class="type">int</span> v;</span><br><span class="line"><span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line">scc[u] = ++k;<span class="comment">//新分组</span></span><br><span class="line"><span class="keyword">while</span>(v=s[top--])&#123;</span><br><span class="line">vis[v] = <span class="number">0</span>;</span><br><span class="line">scc[v] = k;<span class="comment">//记录每个点所在的组</span></span><br><span class="line">size[k]++;<span class="comment">//记录该组的大小</span></span><br><span class="line"><span class="keyword">if</span>(v==u) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P1262-间谍网络"><a href="#P1262-间谍网络" class="headerlink" title="P1262 间谍网络"></a>P1262 间谍网络</h2><p>直接跑一遍缩点，由于强连通分量中的每个点都是互相联通的,一个强联通分量中的最少花费资金也就是那个环里罪犯所需资金最小的</p><p>最后检查一下有无未访问的点,若有,直接输出$NO$,$return$,若无,那就接着记录每个点的入度,将入度为0的组的权值全部加起来即可</p><p>$code:$<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">dfn[u] = low[u] = ++Time;</span><br><span class="line">s[++top] = u;</span><br><span class="line">vis[u] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line"><span class="built_in">tarjan</span>(v);</span><br><span class="line">low[u] = <span class="built_in">min</span>(low[v] , low[u]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(vis[v])&#123;</span><br><span class="line">low[u] = <span class="built_in">min</span>(low[v] , low[u]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(low[u]==dfn[u])&#123;</span><br><span class="line"><span class="type">int</span> v;</span><br><span class="line">tot++;</span><br><span class="line"><span class="keyword">while</span>(v = s[top--])&#123;</span><br><span class="line">vis[v] = <span class="number">0</span>;</span><br><span class="line">c[v] = tot;</span><br><span class="line">sum[tot] = <span class="built_in">min</span>(sum[tot],w[v]);<span class="comment">//取min</span></span><br><span class="line"><span class="keyword">if</span>(v==u) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="P5676-GZOI2017-小z玩游戏"><a href="#P5676-GZOI2017-小z玩游戏" class="headerlink" title="P5676 [GZOI2017]小z玩游戏"></a>P5676 [GZOI2017]小z玩游戏</h2><p>对于这道题,首先想到的肯定是直接$n^2$建边</p><p>但会发现数据太大,复杂度接受不了</p><p>所以要考虑更优秀的建边方法</p><ul><li><p>建一个由有趣程度到游戏的边</p></li><li><p>建一个由游戏到兴趣程度的边</p></li><li><p>建立一个兴趣程度整数倍的边</p></li></ul><p>$code:$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="comment">//从有趣程度到该游戏</span></span><br><span class="line"><span class="type">int</span> u;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;u);</span><br><span class="line"><span class="built_in">add</span>(n+u,i);</span><br><span class="line">maxn = <span class="built_in">max</span>(maxn , u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="comment">//从该游戏到兴趣程度</span></span><br><span class="line"><span class="type">int</span> u;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;u);</span><br><span class="line"><span class="built_in">add</span>(i,n+u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=maxn;i++)&#123;<span class="comment">//兴趣程度的整数倍</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j*i&lt;=maxn;j++)&#123;</span><br><span class="line"><span class="built_in">add</span>(n+i,n+j*i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于那些存在兴趣程度整数倍的游戏,相当于是连上了两个游戏</p><p>而对于那些不存在的游戏,相当于是连了一个虚点,$rt$</p><p><img src="https://img2020.cnblogs.com/blog/2092833/202008/2092833-20200812155727508-655328923.png" alt=""></p><h1 id="割点练习"><a href="#割点练习" class="headerlink" title="割点练习"></a>割点练习</h1><p><a href="https://www.luogu.com.cn/problem/P5058">P5058 [ZJOI2004]嗅探器</a></p><p><a href="https://www.luogu.com.cn/problem/P3225">P3225 [HNOI2012]矿场搭建</a></p><h2 id="P5058-ZJOI2004-嗅探器"><a href="#P5058-ZJOI2004-嗅探器" class="headerlink" title="P5058 [ZJOI2004]嗅探器"></a><a href="https://www.luogu.com.cn/problem/P5058">P5058 [ZJOI2004]嗅探器</a></h2><p>要满足同时能收到$A$和$B$的信息的话要满足两个条件:</p><ul><li><p>$u$是割点</p></li><li><p>$A$或$B$在$v$子树内（包括$v$)且$B$或$A$不在$v$子树内(这样才能把$A$,$B$两个点的信号都收集到)</p></li></ul><p>因此,如果要成为满足条件的点,必须要满足:</p><ul><li>$dfn[v]&lt;=dfn[a]$&amp;&amp;$dfn[v]&gt;dfn[b]$ ($A$在子树内,$B$不在)</li></ul><p>或</p><ul><li>$dfn[v]&lt;=dfn[b]$&amp;&amp;dfn$[v]&gt;dfn[a]$($B$在子树内,$A$不在)</li></ul><p>$code:$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">dfn[u] = low[u] = ++Time;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line"><span class="built_in">tarjan</span>(v,u);</span><br><span class="line">low[u] = <span class="built_in">min</span>(low[v] , low[u]);</span><br><span class="line"><span class="keyword">if</span>(low[v]&gt;=dfn[u]&amp;&amp;u!=a&amp;&amp;u!=b&amp;&amp;dfn[v]&lt;=dfn[a]&amp;&amp;dfn[v]&gt;dfn[b])&#123;<span class="comment">//第一种情况</span></span><br><span class="line">ans = <span class="built_in">min</span>(ans , u);<span class="comment">//取最小的点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(low[v]&gt;=dfn[u]&amp;&amp;u!=a&amp;&amp;u!=b&amp;&amp;dfn[v]&lt;=dfn[b]&amp;&amp;dfn[v]&gt;dfn[a])&#123;<span class="comment">//第二种情况</span></span><br><span class="line">ans = <span class="built_in">min</span>(ans , u);<span class="comment">//取最小的点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(v!=fa) low[u] = <span class="built_in">min</span>(low[u] , dfn[v]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树链剖分学习笔记</title>
      <link href="/2020/08/07/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/08/07/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p> 树链剖分，就是将一颗树分成若干个编号连续的链,将树上问题转换为线性问题,降低问题的处理难度。</p><h2 id="模板题-P3384-【模板】轻重链剖分"><a href="#模板题-P3384-【模板】轻重链剖分" class="headerlink" title="模板题:P3384 【模板】轻重链剖分"></a>模板题:<a href="https://www.luogu.com.cn/problem/P3384">P3384 【模板】轻重链剖分</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给一颗节点数为$n$的带点权树,有以下几种操作:</p><ul><li><p>将树从 $x$ 到 $y$ 结点最短路径上所有节点的值都加上 $z$</p></li><li><p>求从 $x$ 到 $y$ 节点最短路径上的所有 节点值之和</p></li><li><p>以 $x$ 为根节点的子树内所有节点值都加上 $z$。</p></li><li><p>求以 $x$ 为根节点的子树内所有节点值之和</p></li></ul><p>数据范围:$1\le N\le10^5$</p><h2 id="一些定义"><a href="#一些定义" class="headerlink" title="一些定义"></a>一些定义</h2><ul><li><p>重儿子：以一个非叶子节点中的一个儿子为根的子树最大的那一个儿子称为重儿子</p></li><li><p>轻儿子：一个非叶子节点中除了重儿子以外的儿子</p></li><li><p>重边：结点与其重儿子的边称为重边</p></li><li><p>轻边：结点与其轻儿子的边称为轻边</p></li><li><p>重链：由重边组成的路径</p></li><li><p>轻链：由轻边组成的路径</p></li></ul><h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p>首先是两次$DFS$</p><p>第一次求出子树大小,父节点,深度,重儿子这些之后要用的东西</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> f,<span class="type">int</span> deep)</span></span>&#123;</span><br><span class="line">dep[u] = deep;<span class="comment">//深度</span></span><br><span class="line">fa[u] = f;<span class="comment">//父亲节点</span></span><br><span class="line">size[u] = <span class="number">1</span>;<span class="comment">//初始化子树大小</span></span><br><span class="line"><span class="type">int</span> maxson = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i = e[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = e[i].v;</span><br><span class="line"><span class="keyword">if</span>(v==f) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs1</span>(v,u,deep+<span class="number">1</span>);</span><br><span class="line">size[u]+=size[v];</span><br><span class="line">    <span class="keyword">if</span>(size[v]&gt;maxson) son[u] = v,maxson = size[v];<span class="comment">//重儿子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二次$dfs$则是将树上的节点重新编号,划分成若干条链</p><p><strong>每次都去选取自己的重儿子进行连接</strong>,这样可以尽可能的让一条链够长</p><p>其余的轻儿子则作为另一条链的开头</p><p>画成图的话大概是这样:</p><p>(ps:图中的红色节点均为重儿子)</p><p><img src="https://img2020.cnblogs.com/blog/2092833/202008/2092833-20200807180043859-1789457354.png" alt=""></p><p>代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> topf)</span></span>&#123;<span class="comment">//topf为一条链的头</span></span><br><span class="line">id[u] = ++tot;<span class="comment">//重新编号,赋值</span></span><br><span class="line">val[tot] = w[u];</span><br><span class="line">top[u] = topf;<span class="comment">//记录链头,之后有用</span></span><br><span class="line"><span class="keyword">if</span>(!son[u]) <span class="keyword">return</span>;<span class="comment">//为叶子节点</span></span><br><span class="line"><span class="built_in">dfs2</span>(son[u],topf);<span class="comment">//以重儿子向下继续连接</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;<span class="comment">//</span></span><br><span class="line"><span class="type">int</span> v = e[i].v;</span><br><span class="line"><span class="keyword">if</span>(v==fa[u]||v==son[u]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs2</span>(v,v);其余的边则作为新一条链的开头</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用线段树维护这些链</p><p>对于操作1跟操作2</p><p>每次查询和修改从u到v的路径时</p><p>只需将低的那个点跳到上条链的结尾,也就是自己所在的链的头的父节点,同时查询/修改跳过的这段链的值即可</p><p><img src="https://img-blog.csdnimg.cn/20200807175445981.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTc0NTMw,size_16,color_FFFFFF,t_70" alt=""><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">qb</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;<span class="comment">//操作1~5</span></span><br><span class="line"><span class="keyword">while</span>(top[u]!=top[v])&#123;<span class="comment">//如果不在同一条链上</span></span><br><span class="line"><span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]]) <span class="built_in">swap</span>(u,v);<span class="comment">//跳高度低的那个</span></span><br><span class="line">ans+=<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[top[u]],id[u]);<span class="comment">//查询该端的值,修改也同理</span></span><br><span class="line">ans%=mo;</span><br><span class="line">u = fa[top[u]];<span class="comment">//跳到链头的父节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dep[u]&gt;dep[v]) <span class="built_in">swap</span>(u,v);</span><br><span class="line">ans+=<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[u],id[v]);<span class="comment">//操作6</span></span><br><span class="line">ans%=mo;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>对于操作$3,4$,由于是$dfs$,其子树的编号也一定是连续的</p><p>直接查询/修改区间$[id[u],id[u]+size[u]-1]$即可</p><p>($id[u]$为该节点重组后的编号,$size[u]$为子树大小)</p><p>代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson (node&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson (node&lt;&lt;1|1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mid ((l+r)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> len (r-l+1)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">200000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">e</span>&#123;</span><br><span class="line"><span class="type">int</span> u,v,next;</span><br><span class="line">&#125;edge[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> w[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> n,m,mo;</span><br><span class="line"><span class="type">int</span> head[MAXN&lt;&lt;<span class="number">2</span>],cnt = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> dep[MAXN],fa[MAXN],son[MAXN],size[MAXN];</span><br><span class="line"><span class="type">int</span> id[MAXN],val[MAXN],top[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">edge[cnt].u=u;</span><br><span class="line">    edge[cnt].v=v;</span><br><span class="line">    edge[cnt].next=head[u];</span><br><span class="line">    head[u]=cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> f,<span class="type">int</span> deep)</span></span>&#123;</span><br><span class="line">dep[x] = deep;</span><br><span class="line">fa[x] = f;</span><br><span class="line">size[x] = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> maxson = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v= edge[i].v;</span><br><span class="line"><span class="keyword">if</span>(v==f) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs1</span>(v,x,deep+<span class="number">1</span>);</span><br><span class="line">size[x]+=size[v];</span><br><span class="line"><span class="keyword">if</span>(size[v]&gt;maxson) son[x] = v,maxson = size[v];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> topf)</span></span>&#123;</span><br><span class="line">id[x] = ++tot;</span><br><span class="line">val[tot] = w[x];</span><br><span class="line">top[x] = topf;</span><br><span class="line"><span class="keyword">if</span>(!son[x]) <span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">dfs2</span>(son[x],topf);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = edge[i].v;</span><br><span class="line"><span class="keyword">if</span>(v==fa[x]||v==son[x]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs2</span>(v,v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st</span>&#123;</span><br><span class="line"><span class="type">int</span> sum;</span><br><span class="line"><span class="type">int</span> tag;</span><br><span class="line">&#125;tree[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;</span><br><span class="line">tree[node].sum = (tree[lson].sum + tree[rson].sum)%mo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">tree[node].sum = val[l];</span><br><span class="line"><span class="keyword">if</span>(tree[node].sum&gt;mo) tree[node].sum%=mo;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">build</span>(lson,l,mid);</span><br><span class="line"><span class="built_in">build</span>(rson,mid+<span class="number">1</span>,r);</span><br><span class="line"><span class="built_in">pushup</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tree[node].tag==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    tree[lson].tag+=tree[node].tag;</span><br><span class="line">    tree[rson].tag+=tree[node].tag;</span><br><span class="line">    tree[lson].sum+=tree[node].tag*(len-(len&gt;&gt;<span class="number">1</span>));</span><br><span class="line">    tree[rson].sum+=tree[node].tag*(len&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    tree[lson].tag%=mo;</span><br><span class="line">    tree[rson].tag%=mo;</span><br><span class="line">tree[lson].sum%=mo;</span><br><span class="line">tree[rson].sum%=mo;</span><br><span class="line">tree[node].tag = <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=l&amp;&amp;r&lt;=y)&#123;</span><br><span class="line">tree[node].tag+=k;</span><br><span class="line">tree[node].sum+=k*(r-l+<span class="number">1</span>);</span><br><span class="line">tree[node].tag%=mo;</span><br><span class="line">tree[node].sum%=mo;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pushdown</span>(node,l,r);</span><br><span class="line"><span class="keyword">if</span>(x&lt;=mid) <span class="built_in">change</span>(lson,l,mid,x,y,k);</span><br><span class="line"><span class="keyword">if</span>(y&gt;mid) <span class="built_in">change</span>(rson,mid+<span class="number">1</span>,r,x,y,k);</span><br><span class="line"><span class="built_in">pushup</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(x&lt;=l&amp;&amp;r&lt;=y)&#123;</span><br><span class="line"><span class="keyword">return</span> tree[node].sum%mo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pushdown</span>(node,l,r);</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=mid) res+=<span class="built_in">query</span>(lson,l,mid,x,y);</span><br><span class="line"><span class="keyword">if</span>(y&gt;mid) res+=<span class="built_in">query</span>(rson,mid+<span class="number">1</span>,r,x,y);</span><br><span class="line">res%=mo;</span><br><span class="line"><span class="keyword">return</span> res%mo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">cout&lt;&lt;tree[node].sum&lt;&lt;<span class="string">&quot;  &quot;</span>&lt;&lt;tree[node].tag&lt;&lt;endl;</span><br><span class="line"><span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">test</span>(lson,l,mid);</span><br><span class="line">    <span class="built_in">test</span>(rson,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qb</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(top[u]!=top[v])&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]]) <span class="built_in">swap</span>(u,v);</span><br><span class="line">ans+=<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[top[u]],id[u]);</span><br><span class="line">ans%=mo;</span><br><span class="line">u = fa[top[u]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dep[u]&gt;dep[v]) <span class="built_in">swap</span>(u,v);</span><br><span class="line">ans+=<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[u],id[v]);</span><br><span class="line">ans%=mo;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ub</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(top[u]!=top[v])&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]]) <span class="built_in">swap</span>(u,v);</span><br><span class="line"><span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[top[u]],id[u],k);</span><br><span class="line">u = fa[top[u]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dep[u]&gt;dep[v]) <span class="built_in">swap</span>(u,v);</span><br><span class="line"><span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[u],id[v],k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> root;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;root,&amp;mo);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="type">int</span> u,v;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">    <span class="built_in">add</span>(u,v);</span><br><span class="line">    <span class="built_in">add</span>(v,u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs1</span>(root,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">dfs2</span>(root,root);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">cout&lt;&lt;dep[i]&lt;&lt;<span class="string">&quot;  &quot;</span>&lt;&lt;val[i]&lt;&lt;<span class="string">&quot;  &quot;</span>&lt;&lt;size[i]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line"><span class="type">int</span> k,x,y,z;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k);</span><br><span class="line"><span class="keyword">if</span>(k==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line"><span class="built_in">ub</span>(x,y,z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(k==<span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">qb</span>(x,y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(k==<span class="number">3</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line"><span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[x],id[x]+size[x]<span class="number">-1</span>,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[x],id[x]+size[x]<span class="number">-1</span>)%mo);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><del>话说树剖的好多题都好裸啊</del></p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础线段树</title>
      <link href="/2020/08/06/%E5%9F%BA%E7%A1%80%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
      <url>/2020/08/06/%E5%9F%BA%E7%A1%80%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><h2 id="P3373-【模板】线段树-2"><a href="#P3373-【模板】线段树-2" class="headerlink" title="P3373 【模板】线段树 2"></a><a href="https://www.luogu.com.cn/problem/P3373">P3373 【模板】线段树 2</a></h2><p>设$mtag$为乘法标记,$atag$为加法标记</p><p>对于下放后的每一个区间来说,$x=x<em>mtag+atag</em>len$(式$1$)</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/tbtb4rli.png" alt=""></p><p>$x=x\cdot mtag_2+len\cdot atag_2=(x\cdot mtag_2+len\cdot atag_2)\cdot mtag_1+atag_1\cdot len$</p><p>$=x\cdot mtag_2\cdot mtag_1+len*atag_2\cdot mtag_1+atag_1\cdot len$</p><p>$=x\cdot (mtag_2\cdot mtag_1)+len\cdot (atag_2\cdot mtag_1+atag_1)$</p><p>再根据前面的式$1$,易得</p><p>$mtag_2 = mtag_1\cdot mtag_2$</p><p>$atag_2=atag_2\cdot mtag_1+atag_2$</p><p>核心(下放)代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(tree2 *tree,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tree-&gt;lazym==<span class="number">1</span>&amp;&amp;tree-&gt;lazyp==<span class="number">0</span>||tree-&gt;lson==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">tree-&gt;lson-&gt;x = (tree-&gt;lson-&gt;x*tree-&gt;lazym+(<span class="type">long</span> <span class="type">long</span>)tree-&gt;lazyp*(mid-l+<span class="number">1</span>))%mo;</span><br><span class="line">tree-&gt;rson-&gt;x = (tree-&gt;rson-&gt;x*tree-&gt;lazym+(<span class="type">long</span> <span class="type">long</span>)tree-&gt;lazyp*(r-mid))%mo;</span><br><span class="line">tree-&gt;lson-&gt;lazym = (tree-&gt;lazym*tree-&gt;lson-&gt;lazym)%mo;</span><br><span class="line">tree-&gt;rson-&gt;lazym = (tree-&gt;lazym*tree-&gt;rson-&gt;lazym)%mo;</span><br><span class="line">tree-&gt;lson-&gt;lazyp = (tree-&gt;lazym*tree-&gt;lson-&gt;lazyp+tree-&gt;lazyp)%mo;</span><br><span class="line">tree-&gt;rson-&gt;lazyp = (tree-&gt;lazym*tree-&gt;rson-&gt;lazyp+tree-&gt;lazyp)%mo;</span><br><span class="line">tree-&gt;lazym  = <span class="number">1</span>;</span><br><span class="line">tree-&gt;lazyp = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="基础练习题"><a href="#基础练习题" class="headerlink" title="基础练习题"></a>基础练习题</h1><p><strong><a href="https://www.luogu.com.cn/problem/P4145">P4145 上帝造题的七分钟2 / 花神游历各国</a></strong></p><p><strong><a href="https://www.luogu.com.cn/problem/P6327">P6327 区间加区间sin和</a></strong></p><p><strong><a href="https://www.luogu.com.cn/problem/P1438">P1438 无聊的数列</a></strong></p><p><strong><a href="https://www.luogu.com.cn/problem/P4513">P4513 小白逛公园</a></strong></p><p><strong><a href="https://www.luogu.com.cn/problem/P4588">P4588 [TJOI2018]数学计算</a></strong></p><p><strong><a href="https://www.luogu.com.cn/problem/P2894">P2894 [USACO08FEB]Hotel G</a></strong></p><h2 id="P4145-上帝造题的七分钟2-花神游历各国"><a href="#P4145-上帝造题的七分钟2-花神游历各国" class="headerlink" title="P4145 上帝造题的七分钟2 / 花神游历各国"></a>P4145 上帝造题的七分钟2 / 花神游历各国</h2><p>照题里的这个数据范围来看,直接暴力开方肯定会T飞</p><p>通过观察,不难发现数据范围内最大的数也只需要$6$次开方就可以变为$1$</p><p>考虑剪枝优化：</p><p>当一个区间的最大值为$1$时,其整个区间的其他值肯定也为$1$</p><p>因此当区间内最大值等于$1$时,直接$return$掉</p><p>核心代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> L = tree[node].l,R = tree[node].r;</span><br><span class="line"><span class="keyword">if</span>(L==R)&#123;</span><br><span class="line">tree[node].sum = <span class="built_in">sqrt</span>(tree[node].sum);</span><br><span class="line">tree[node].maxn = <span class="built_in">sqrt</span>(tree[node].maxn);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid = (L+R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid&amp;&amp;tree[lson].maxn&gt;<span class="number">1</span>)&#123;<span class="comment">//最大值大于1时在进行修改操作</span></span><br><span class="line"><span class="built_in">change</span>(lson,l,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(r&gt;mid&amp;&amp;tree[rson].maxn&gt;<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">change</span>(rson,l,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pushup</span>(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="P6327-区间加区间sin和"><a href="#P6327-区间加区间sin和" class="headerlink" title="P6327 区间加区间sin和"></a>P6327 区间加区间sin和</h2><p>挺好的一道题目,很适合线段树初学者练手</p><p>学过和差角公式的应该都能很快想出解法</p><p>$sin(a+x) = sinacosx+cosasinx$</p><p>$cos(a+x) = cosacosx-sinxsina$</p><p>只需要在线段树里维护一个$sinx$和一个$cosx$即可</p><p>核心代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update2</span><span class="params">(<span class="type">int</span> node,<span class="type">double</span> sinv,<span class="type">double</span> cosv)</span></span>&#123;<span class="comment">//和差角公式</span></span><br><span class="line"><span class="type">double</span> cosa = tree[node].cosx;</span><br><span class="line">        <span class="type">double</span> sina = tree[node].sinx;</span><br><span class="line">tree[node].cosx = cosa*cosv-sina*sinv;</span><br><span class="line">tree[node].sinx = sina*cosv+cosa*sinv;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;<span class="comment">//下放</span></span><br><span class="line"><span class="keyword">if</span>(tree[node].tag)&#123;</span><br><span class="line"><span class="type">double</span> cosa = <span class="built_in">cos</span>(tree[node].tag),sina = <span class="built_in">sin</span>(tree[node].tag);</span><br><span class="line"><span class="built_in">update2</span>(lson,sina,cosa);<span class="comment">//更新儿子的值</span></span><br><span class="line"><span class="built_in">update2</span>(rson,sina,cosa);</span><br><span class="line">tree[lson].tag+=tree[node].tag;<span class="comment">//更新儿子的tag</span></span><br><span class="line">tree[rson].tag+=tree[node].tag;</span><br><span class="line">tree[node].tag = <span class="number">0</span>;b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span>&#123;<span class="comment">//更新操作</span></span><br><span class="line"><span class="type">int</span> L = tree[node].l,R = tree[node].r;</span><br><span class="line"><span class="keyword">if</span>(R&lt;=r&amp;&amp;L&gt;=l)&#123;<span class="comment">//包围在区间内,直接修改</span></span><br><span class="line">tree[node].tag+=x;</span><br><span class="line"><span class="built_in">update2</span>(node,<span class="built_in">sin</span>(x),<span class="built_in">cos</span>(x));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pushdown</span>(node);<span class="comment">//下放</span></span><br><span class="line"><span class="type">int</span> mid = (L + R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid) <span class="built_in">change</span>(lson,l,r,x);</span><br><span class="line"><span class="keyword">if</span>(r&gt;mid) <span class="built_in">change</span>(rson,l,r,x);</span><br><span class="line"><span class="built_in">update</span>(node);<span class="comment">//上传更新</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P1438-无聊的数列"><a href="#P1438-无聊的数列" class="headerlink" title="P1438 无聊的数列"></a>P1438 无聊的数列</h2><p>利用线段树来维护差分数组。</p><p>每当进行一个操作$1$时</p><p>将点$l$加上首相$k$</p><p>如果区间不是一个点的话,则将区间$[l+1,r]$上的点都加上公差$d$</p><p>如果$r&lt;n$,则在$r+1$的位置上加上$-(k+(r-l)\cdot d))$,便于差分</p><p>查询时,将区间$[1,k]$的值都加上即可,相当于查询操作</p><p>区间查询,区间修改,直接上线段树模板即可</p><p>核心代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="type">int</span> mode,l,r,k,d;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;mode);</span><br><span class="line"><span class="keyword">if</span>(mode==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;k,&amp;d);</span><br><span class="line"><span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,l,k);<span class="comment">//修改左端点</span></span><br><span class="line"><span class="keyword">if</span>(l!=r) <span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,n,l+<span class="number">1</span>,r,d);<span class="comment">//修改区间</span></span><br><span class="line"><span class="keyword">if</span>(r+<span class="number">1</span>&lt;=n) <span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,n,r+<span class="number">1</span>,r+<span class="number">1</span>,-(k+(r-l)*d));<span class="comment">//修改右端点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;d);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,<span class="number">1</span>,d)+a[d]);<span class="comment">//差分数组的值+原值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P4513-小白逛公园"><a href="#P4513-小白逛公园" class="headerlink" title="P4513 小白逛公园"></a>P4513 小白逛公园</h2><p>线段树经典题</p><p>维护一个从区间左端点开始的区间最大子段$maxl$,从右端点开始的区间最大子段$maxr$,总区间最大子段$maxx$,和一个区间和$sum$</p><p>对于$maxl$来说,其右端点的位置有两种可能:</p><ul><li><p>在左儿子中</p></li><li><p>在右儿子中</p></li></ul><p>得到方程:$tree.maxl = max(lson.maxl,lson.sum+rson.maxl)$</p><p>$maxr$也同理</p><p>方程:$tree.maxr = max(rson.maxr,rson.sum+lson.maxr)$</p><p>对于$maxx$来说，其区间范围有三种可能</p><ul><li><p>只在左儿子中</p></li><li><p>只在右儿子中</p></li><li><p>既在左儿子中也在右儿子中</p></li></ul><p>得到方程:$tree.maxx = max(lson.maxx,rson.maxx,lson.maxr+rson.maxl))$</p><p>查询时只需输出区间$[l,r]$中的$maxx$即可</p><p>核心代码:</p><p>更新操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(tree2 *tree,tree2 *lson,tree2 *rson)</span></span>&#123;</span><br><span class="line">tree-&gt;sum = lson-&gt;sum+rson-&gt;sum;</span><br><span class="line">tree-&gt;maxl = <span class="built_in">max</span>(lson-&gt;maxl,lson-&gt;sum+rson-&gt;maxl);</span><br><span class="line">tree-&gt;maxr = <span class="built_in">max</span>(rson-&gt;maxr,rson-&gt;sum+lson-&gt;maxr);</span><br><span class="line">tree-&gt;maxX = <span class="built_in">max</span>(lson-&gt;maxX,<span class="built_in">max</span>(rson-&gt;maxX,lson-&gt;maxr+rson-&gt;maxl));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">tree2 *<span class="title">query</span><span class="params">(tree2 *tree,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=l&amp;&amp;y&gt;=r)</span><br><span class="line"><span class="keyword">return</span> tree;</span><br><span class="line"><span class="type">int</span> mid = (l + r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">tree2 *t1 = <span class="literal">NULL</span>,*t2 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=mid) t1 = <span class="built_in">query</span>(tree-&gt;lson,l,mid,x,y);</span><br><span class="line"><span class="keyword">if</span>(y&gt;mid) t2 = <span class="built_in">query</span>(tree-&gt;rson,mid+<span class="number">1</span>,r,x,y);</span><br><span class="line"><span class="keyword">if</span>(t1==<span class="literal">NULL</span>) <span class="keyword">return</span> t2;</span><br><span class="line"><span class="keyword">if</span>(t2==<span class="literal">NULL</span>) <span class="keyword">return</span> t1;</span><br><span class="line">tree2 *ret = &amp;dizhi[++t];</span><br><span class="line"><span class="built_in">update</span>(ret,t1,t2);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P4588-TJOI2018-数学计算"><a href="#P4588-TJOI2018-数学计算" class="headerlink" title="P4588 [TJOI2018]数学计算"></a>P4588 [TJOI2018]数学计算</h2><p>比较简单的一道题目。</p><p>仔细观察不难发现</p><p>所谓的操作$1$跟操作$2$其实就是在进行普通的单点修改操作而已</p><p>用一个线段树在记录一段区间内的总乘积</p><p>操作$1$是把点$i$的值从$1$修改为$i$</p><p>操作$2$则是把点$pos$的值修改为$1$</p><p>核心代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;</span><br><span class="line">tree[node].val = (tree[lson].val*tree[rson].val)%mo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">tree[node].val = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> mid = (l + r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">build</span>(lson,l,mid);</span><br><span class="line"><span class="built_in">build</span>(rson,mid+<span class="number">1</span>,r);</span><br><span class="line"><span class="built_in">pushup</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">tree[node].val = y;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid = (l + r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=mid) <span class="built_in">change</span>(lson,l,mid,x,y);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">change</span>(rson,mid+<span class="number">1</span>,r,x,y);</span><br><span class="line"><span class="built_in">pushup</span>(node);</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><h2 id="P2894-USACO08FEB-Hotel-G"><a href="#P2894-USACO08FEB-Hotel-G" class="headerlink" title="P2894 [USACO08FEB]Hotel G"></a>P2894 [USACO08FEB]Hotel G</h2><p>跟<a href="https://www.luogu.com.cn/problem/P4513"><strong>P4513 小白逛公园</strong></a>大同小异的思路</p><p>只是把单点修改操作换成了区间修改罢了</p><p>要注意的是这里不存在负值的情况</p><p>因此在上传操作时转移没那么复杂,只用判断$maxl$是否等于$sum$</p><p>若等于,说明左儿子中房间全为空,直接全部加上,再加上右儿子的$maxl$</p><p>若不等于,则为左儿子的$maxl$</p><p>$maxr$也同理</p><p>同时也要注意这里的查询查的是满足长度为$x$的最左的端点</p><p>因此在查询时要满足”能左则左”</p><p>核心代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;<span class="comment">//上传</span></span><br><span class="line"><span class="keyword">if</span>(tree[lson].maxx==tree[lson].sum)&#123;<span class="comment">//如果左区间全为空房</span></span><br><span class="line">tree[node].lmax = tree[lson].sum+tree[rson].lmax;<span class="comment">//全部加上</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">tree[node].lmax = tree[lson].lmax;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(tree[rson].maxx==tree[rson].sum)&#123;</span><br><span class="line">tree[node].rmax = tree[rson].sum+tree[lson].rmax;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">tree[node].rmax = tree[rson].rmax;</span><br><span class="line">&#125;</span><br><span class="line">tree[node].maxx = <span class="built_in">max</span>(tree[lson].rmax+tree[rson].lmax,<span class="built_in">max</span>(tree[lson].maxx,tree[rson].maxx));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">tree[node].sum = tree[node].lmax = tree[node].rmax = tree[node].maxx =r-l+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">build</span>(lson,l,mid);</span><br><span class="line"><span class="built_in">build</span>(rson,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;<span class="comment">//下放</span></span><br><span class="line"><span class="keyword">if</span>(tree[node].lazy==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(tree[node].lazy==<span class="number">1</span>)&#123;<span class="comment">//退房</span></span><br><span class="line">tree[lson].maxx = tree[lson].rmax = tree[lson].lmax = <span class="number">0</span>;</span><br><span class="line">tree[rson].maxx = tree[rson].rmax = tree[rson].lmax = <span class="number">0</span>;</span><br><span class="line">tree[lson].lazy = tree[rson].lazy = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(tree[node].lazy==<span class="number">2</span>)&#123;<span class="comment">//开房</span></span><br><span class="line">tree[lson].maxx = tree[lson].rmax = tree[lson].lmax = tree[lson].sum;</span><br><span class="line">tree[rson].maxx = tree[rson].rmax = tree[rson].lmax = tree[rson].sum;</span><br><span class="line">tree[lson].lazy = tree[rson].lazy = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">tree[node].lazy = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> opt)</span></span>&#123;<span class="comment">//opt为1代表退房,为2代表开房</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(x&lt;=l&amp;&amp;y&gt;=r)&#123;</span><br><span class="line"><span class="keyword">if</span>(opt==<span class="number">1</span>) tree[node].maxx = tree[node].lmax = tree[node].rmax = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> tree[node].maxx = tree[node].lmax = tree[node].rmax = tree[node].sum;</span><br><span class="line"></span><br><span class="line">tree[node].lazy = opt;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pushdown</span>(node);</span><br><span class="line"><span class="keyword">if</span>(x&lt;=mid) <span class="built_in">change</span>(lson,l,mid,x,y,opt);</span><br><span class="line"><span class="keyword">if</span>(y&gt;mid) <span class="built_in">change</span>(rson,mid+<span class="number">1</span>,r,x,y,opt);</span><br><span class="line"><span class="built_in">pushup</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span>&#123;<span class="comment">//查询</span></span><br><span class="line"><span class="built_in">pushdown</span>(node);</span><br><span class="line"><span class="keyword">if</span>(l==r) <span class="keyword">return</span> l;</span><br><span class="line"><span class="keyword">if</span>(tree[lson].maxx&gt;=x)&#123;<span class="comment">//如果左区间的最大值大于x,直接查左边</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">query</span>(lson,l,mid,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(tree[lson].rmax+tree[rson].lmax&gt;=x)&#123;<span class="comment">//如果中间大于x</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>+mid-tree[lson].rmax;左儿子的右最大值,也就是最靠近左边的端点</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(rson,mid+<span class="number">1</span>,r,x);<span class="comment">//否则查右边</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态开点"><a href="#动态开点" class="headerlink" title="动态开点"></a>动态开点</h2><p><strong><a href="https://www.luogu.com.cn/problem/P5459">P5459 [BJOI2016]回转寿司</a></strong></p><p><strong><a href="https://www.luogu.com.cn/problem/CF915E">CF915E Physical Education Lessons</a></strong></p><p>$now ~ loading…$</p><h2 id="扫描线"><a href="#扫描线" class="headerlink" title="扫描线"></a>扫描线</h2><p><strong><a href="https://www.luogu.com.cn/problem/P5490">P5490 【模板】扫描线</a></strong></p><p><strong><a href="https://www.luogu.com.cn/problem/P1502">P1502 窗口的星星</a></strong></p><p>$now ~ loading…$</p><p>``</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P5459 [BJOI2016]回转寿司</title>
      <link href="/2020/08/05/p5459/"/>
      <url>/2020/08/05/p5459/</url>
      
        <content type="html"><![CDATA[<h1 id="P5459-BJOI2016-回转寿司-题解"><a href="#P5459-BJOI2016-回转寿司-题解" class="headerlink" title="P5459 [BJOI2016]回转寿司 题解"></a>P5459 [BJOI2016]回转寿司 题解</h1><h2 id="间隙"><a href="#间隙" class="headerlink" title="间隙"></a><a href="https://www.luogu.com.cn/problem/P5459">间隙</a></h2><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><ul><li><h2 id="前缀和-权值线段树-动态开点"><a href="#前缀和-权值线段树-动态开点" class="headerlink" title="前缀和,权值线段树,动态开点"></a>前缀和,权值线段树,动态开点</h2></li></ul><p>如果您还不会权值线段树跟动态开点的话,推荐去看一下<a href="https://www.bilibili.com/video/BV1Zg4y1q7aY?t=1726"><strong>这个教程</strong></a></p><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给一个序列,现从中取出一段连续子序列,使其子序列内数值总和$a$满足$L\le a\le R$</p><p>求总方案数。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>区间求和,很容易先联想到前缀和</p><p>不妨先设$sum[i]$为前$i$个数的前缀和</p><p>易得式子:</p><p>$L \le sum[r] - sum[l-1] \le R$</p><p>移项一下</p><p>$sum[r]-L \le sum[l-1]  \le sum[r]-R $</p><p>这样原问题就转化为了<strong>在区间$[sum[r]-L,sum[r]-R]$中有多少个$sum[l-1]$($l \in[1,r]$ )</strong></p><p><strong>每一个$r$也就相当于是查询区间$[sum[r]-L,sum[r]-R]$中$sum[l-1]$的总和</strong>($l \in[1,r]$ )</p><p>可以使用权值线段树$+$动态开点来维护。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>从$1$~$n$枚举$r$的值,把每一个$r$当作一次”查询”</p><p>同时不要忘记在进行下一次”查询” 前把 $l$ 的值 “更新”(指插入新的值)</p><p>具体的注释里有讲<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> MAXN = <span class="number">1e10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> sum[N];<span class="comment">//前缀和 </span></span><br><span class="line"><span class="type">int</span> n,l,r;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st</span>&#123;</span><br><span class="line"><span class="type">int</span> l,r,sum;<span class="comment">//左儿子,右儿子,总方案数 </span></span><br><span class="line">&#125;tree[N&lt;&lt;<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;<span class="comment">//上传操作 </span></span><br><span class="line">tree[node].sum = tree[tree[node].l].sum+tree[tree[node].r].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> &amp;node,<span class="type">long</span> <span class="type">long</span> x,<span class="type">long</span> <span class="type">long</span> l = -MAXN , <span class="type">long</span> <span class="type">long</span> r = MAXN)</span></span>&#123;<span class="comment">//更新 注意,l的初始值要设成负数,一开始在这里卡了好久\kk </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!node) node = ++tot;<span class="comment">//动态开点 </span></span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;<span class="comment">//如果为根节点 </span></span><br><span class="line">tree[node].sum++;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> mid = (l + r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=mid) <span class="built_in">update</span>(tree[node].l,x,l,mid);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">update</span>(tree[node].r,x,mid+<span class="number">1</span>,r);</span><br><span class="line"><span class="built_in">pushup</span>(node);<span class="comment">//更新父节点的值 </span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">query</span><span class="params">(<span class="type">int</span> &amp;node,<span class="type">long</span> <span class="type">long</span> x,<span class="type">long</span> <span class="type">long</span> y,<span class="type">long</span> <span class="type">long</span> l =-MAXN,<span class="type">long</span> <span class="type">long</span> r = MAXN)</span></span>&#123;<span class="comment">//查询操作 </span></span><br><span class="line"><span class="keyword">if</span>(!node) node = ++tot;<span class="comment">//动态开点 </span></span><br><span class="line"><span class="keyword">if</span>(x&lt;=l&amp;&amp;y&gt;=r)&#123;<span class="comment">//包含在查询范围内 </span></span><br><span class="line"><span class="keyword">return</span> tree[node].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=mid) res+=<span class="built_in">query</span>(tree[node].l,x,y,l,mid); </span><br><span class="line"><span class="keyword">if</span>(y&gt;mid) res+=<span class="built_in">query</span>(tree[node].r,x,y,mid+<span class="number">1</span>,r); </span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> root = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;l,&amp;r);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">sum[i] = sum[i<span class="number">-1</span>] + a;<span class="comment">//前缀和 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">insert</span>(root,<span class="number">0</span>);<span class="comment">//不要忘记插入0,也就是说一个都不吃的情况 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">ans+=<span class="built_in">query</span>(root,sum[i] - r,sum[i] - l);<span class="comment">//加方案数 </span></span><br><span class="line"><span class="built_in">insert</span>(root,sum[i]);<span class="comment">//&quot;更新&quot;l的值 </span></span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P3478 [POI2008]STA-Station</title>
      <link href="/2020/08/03/p3478/"/>
      <url>/2020/08/03/p3478/</url>
      
        <content type="html"><![CDATA[<h1 id="P3478-POI2008-STA-Station题解"><a href="#P3478-POI2008-STA-Station题解" class="headerlink" title="P3478 [POI2008]STA-Station题解"></a>P3478 [POI2008]STA-Station题解</h1><h2 id="原题面"><a href="#原题面" class="headerlink" title="原题面"></a><a href="https://www.luogu.com.cn/problem/P3478">原题面</a></h2><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul><li>换根DP</li></ul><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给出一个 N 个点的树,找出一个点来,以这个点为根的树时,所有点的深度之和最大</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>换根DP的模板题。</p><p>如果您还不会换根DP的话,可以先去看看UltiMadow巨佬的文章:</p><p><a href="https://www.luogu.com.cn/discuss/show/47327">【日报#278】[学习笔记]换根dp</a>,我一开始也是从那里学的qwq</p><p>这里我们设</p><ul><li><p><strong>$size[i]$为以$1$为根节点时节点$i$的子树大小</strong></p></li><li><p><strong>$dep[i]$为以$1$为根节点时节点$i$的深度大小</strong></p></li><li><p><strong>$dp[i]$为以$i$为根节点时深度之和的大小</strong></p></li></ul><p>很明显,我们可以通过一遍DFS求出以$1$为根节点时的深度之和</p><p>如果一个个的去算的话</p><p>照这个数据范围,显然会T飞</p><p>这个时候就要用到换根DP了</p><h2 id="换根-DP-优化"><a href="#换根-DP-优化" class="headerlink" title="换根$DP$优化"></a>换根$DP$优化</h2><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/o5nj1c7o.png" alt=""></p><p>可以看出,当我们把根节点从1换到3时</p><p>对子节点3的贡献由两部分组成</p><p>1.<strong>自己子树的贡献(图中的k)</strong></p><p>2.<strong>父亲节点$1$的贡献</strong></p><hr><h2 id="如何转移"><a href="#如何转移" class="headerlink" title="如何转移"></a>如何转移</h2><ul><li><p>首先是$k$,作为自己子树所产生的贡献肯定要加上</p></li><li><p>$dp[u]$为以$u$为根节点时的深度总值,在计算时,要减去$v$的子树所产生的贡献,不然就重复计算了,同时</p></li></ul><p><strong>在以 $u$为根时,v节点及其子树内的所有节点的深度都增加了$1$</strong>,需要减去</p><p><strong>(图中红色的节点)</strong></p><p>合起来就是$dp[u]-(size[v]+k)$</p><ul><li>除v子树外的其他节点也一样</li></ul><p><strong>在以$v$为根时，除$v$节点及其子树外的其他节点的深度都增加了$1$</strong></p><p><strong>(图中蓝色的节点)</strong></p><p>合起来就是$(size[1]-size[v])$</p><p>得到转移方程</p><ul><li>$dp[v] = k+(dp[u]-(k+size[v]))+(size[1]-size[v])$</li></ul><p>化简一下</p><ul><li>$dp[v] = dp[u]-2size[v]+size[1]$</li></ul><p>转移方程推出来了,代码部分就不难实现了,两遍dfs,一次dfs统计子树内的节点对当前节点的贡献<br>一次dfs换根</p><p>贴个代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN  = <span class="number">100010</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> dp[MAXN],dep[MAXN],size[MAXN];</span><br><span class="line"><span class="type">int</span> vis[MAXN];</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; son[MAXN];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">size[x] = <span class="number">1</span>;</span><br><span class="line">    vis[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;son[x].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line"><span class="type">int</span> v = son[x][i];</span><br><span class="line"><span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">dep[v] = dep[x] +<span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs1</span>(v);</span><br><span class="line">size[x]+=size[v];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    vis[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;son[x].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line"><span class="type">int</span> v = son[x][i];</span><br><span class="line"><span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">dp[v] = dp[x] +size[<span class="number">1</span>] - <span class="number">2</span>*size[v];</span><br><span class="line"><span class="built_in">dfs2</span>(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="type">int</span> u,v;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">son[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">son[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs1</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dp[<span class="number">1</span>]+=dep[i];</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line"><span class="built_in">dfs2</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans = <span class="number">-0x3f</span>;</span><br><span class="line"><span class="type">int</span> jd =<span class="number">999</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(ans &lt; dp[i]) ans = dp[i], jd = i;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;jd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P1453 城市环路</title>
      <link href="/2020/08/03/p1453/"/>
      <url>/2020/08/03/p1453/</url>
      
        <content type="html"><![CDATA[<h1 id="P1453-城市环路-题解"><a href="#P1453-城市环路-题解" class="headerlink" title="P1453 城市环路 题解"></a>P1453 城市环路 题解</h1><h2 id="间隙"><a href="#间隙" class="headerlink" title="间隙"></a><a href="https://www.luogu.com.cn/problem/P1453">间隙</a></h2><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><ul><li><h3 id="树形dp-基环树"><a href="#树形dp-基环树" class="headerlink" title="树形dp,基环树"></a>树形dp,基环树</h3></li></ul><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给一颗含有点权的基环外向树</p><p>假如两个点之间有一条边连接,如果选择了其中一端的节点,那另一段的节点则不可选择</p><p>求:最大贡献</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>先讲一下什么是基环树。</p><p>基环树,简单来说就是多了一条边的树,产生了一个环形结构,环上的每个节点都是一颗树的根</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/g8bnch8r.png" alt=""></p><p>画成图的话大概是这个样子(基环外向树)</p><p>一般来说,这种题目的做法都是先找到环,断开环中的一条边,<br>把它当成一般的树形$DP$来做。</p><h3 id="如何找环"><a href="#如何找环" class="headerlink" title="如何找环?"></a>如何找环?</h3><p>一般有$dfs$跟并查集两种方法 , 这里我采用的是并查集的做法</p><p>一开始每个节点都是一个独立的集合</p><p>每连接一条边,就把这两个点合并到一个集合中</p><p>如果在连接一条边之前,两个节点就已经在一个集合中了,说明这<strong>两个节点已经联通了,再连接这条边必然会产生环的情况</strong></p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/53vb8z0u.png" alt=""></p><h3 id="如何转移"><a href="#如何转移" class="headerlink" title="如何转移?"></a>如何转移?</h3><p>找到了环之后,只需要将环上的这条边断开即可</p><p>这样的话就可以当作普通的树形$DP$来做了</p><p>设$f[i][0]$为选第$i$个节点产生的最大贡献</p><p>$f[i][1]$为不选第$i$个节点产生的最大贡献</p><p>如果选了第$i$个节点,那它的儿子肯定都不能选</p><p>反之,儿子可以选择选,也可以选择不选</p><p>得到转移方程:</p><p>$f[u][0] = \sum f[v][0]$</p><p>$f[u][1] = \sum max(f[v][1],f[v][0])$</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>思路明白了代码实现应该就不难了</p><p>要注意的是环上的两个点都可以作为树的根节点,因此在$DP$的时候要把两个点都跑一遍</p><p>具体的细节注释有写</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="comment">//存图 </span></span><br><span class="line"><span class="type">int</span> v,next;</span><br><span class="line">&#125;e[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> f[MAXN][<span class="number">2</span>],w[MAXN];<span class="comment">//dp数组,点权 </span></span><br><span class="line"><span class="type">double</span> k; </span><br><span class="line"><span class="type">int</span> fa[MAXN];</span><br><span class="line"><span class="type">int</span> head[MAXN&lt;&lt;<span class="number">1</span>],cnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> root1,root2;<span class="comment">//环上的两个点 </span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;<span class="comment">//前向星 </span></span><br><span class="line">e[++cnt].v = v;</span><br><span class="line">e[cnt].next = head[u];</span><br><span class="line">head[u] = cnt;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="comment">//查找集合 </span></span><br><span class="line"><span class="keyword">if</span>(fa[x]==x)&#123;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">circle</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;<span class="comment">//树形dp </span></span><br><span class="line">f[u][<span class="number">1</span>] = w[u],f[u][<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//初始化 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = e[i].v;</span><br><span class="line"><span class="keyword">if</span>(v!=fa)&#123; </span><br><span class="line"><span class="built_in">circle</span>(v,u);</span><br><span class="line">f[u][<span class="number">0</span>]+=<span class="built_in">max</span>(f[v][<span class="number">1</span>],f[v][<span class="number">0</span>]);<span class="comment">//转移 </span></span><br><span class="line">f[u][<span class="number">1</span>]+=f[v][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w[i]);</span><br><span class="line">fa[i] = i;<span class="comment">//初始化集合 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="type">int</span> u,v;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">u++,v++;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">find</span>(u)==<span class="built_in">find</span>(v))&#123;<span class="comment">//如果在加边前就在一个集合中了,说明找到了环 </span></span><br><span class="line">        root1 = u,root2 = v;<span class="comment">//记录环上的两个点 </span></span><br><span class="line">        <span class="keyword">continue</span>;<span class="comment">//直接跳过加边操作,相当于断开这条边 </span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="built_in">add</span>(u,v);</span><br><span class="line"><span class="built_in">add</span>(v,u);</span><br><span class="line">fa[<span class="built_in">find</span>(v)] = <span class="built_in">find</span>(u);<span class="comment">//合并集合 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;k);</span><br><span class="line"><span class="built_in">circle</span>(root1,<span class="number">0</span>);</span><br><span class="line"><span class="type">double</span> r1 = f[root1][<span class="number">0</span>];<span class="comment">//选root1 </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">circle</span>(root2,<span class="number">0</span>);</span><br><span class="line"><span class="type">double</span> r2 = f[root2][<span class="number">0</span>];<span class="comment">//选root2 </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.1lf&quot;</span>,<span class="built_in">max</span>(r1,r2)*k);<span class="comment">//取最大 </span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础树形dp</title>
      <link href="/2020/08/02/%E6%A0%91%E5%BD%A2dp/"/>
      <url>/2020/08/02/%E6%A0%91%E5%BD%A2dp/</url>
      
        <content type="html"><![CDATA[<p>曾经的黑历史(</p><p>有空了重构一下</p><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><h2 id="P1352-没有上司的舞会"><a href="#P1352-没有上司的舞会" class="headerlink" title="P1352 没有上司的舞会"></a>P1352 没有上司的舞会</h2><p>树状$dp$模板题。</p><p>设$f[i][0]$为第$i$个人来了的方案数</p><p>$f[i][1]$为第$i$和人没来的方案数</p><p>若第$i$个人来了,那么其下属均不回来</p><p>若不来,其下属则有来和不来两种选择</p><p>因此状态转移方程为:</p><ul><li><p>$f[i][0]+=f[son][1]$</p></li><li><p>$f[i][1]+=max(f[son][0],f[son][1])$</p></li></ul><h2 id="P2015-二叉苹果树"><a href="#P2015-二叉苹果树" class="headerlink" title="P2015 二叉苹果树"></a>P2015 二叉苹果树</h2><p>树上背包模板题</p><p>每一个枝条都有”剪”和”不剪”两种可能</p><p>把每一个儿子都看成一个”分组背包”</p><p>设$dp[i][j]$表示第$i$个子树保留$j$条边</p><p>每加入一个”儿子”后,枚举该”儿子”保留的边数,如图<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/bl7hi1vj.png" alt=""></p><h5 id="ps-这里i-k后面还要减1是因为还要多保留从u-gt-v这条边"><a href="#ps-这里i-k后面还要减1是因为还要多保留从u-gt-v这条边" class="headerlink" title="(ps:这里i-k后面还要减1是因为还要多保留从u-&gt;v这条边)"></a>(ps:这里i-k后面还要减1是因为还要多保留从u-&gt;v这条边)</h5><p>故状态转移方程为:</p><ul><li>$f[u][i]=max(f[v][i-k-1]+f[u][k]+w[u][v])(i\in[1,m+1)]$</li></ul><hr><h1 id="树上背包"><a href="#树上背包" class="headerlink" title="树上背包"></a>树上背包</h1><p><strong><a href="https://www.luogu.com.cn/problem/P2014">P2014 [CTSC1997]选课</a></strong></p><p><strong><a href="https://www.luogu.com.cn/problem/P1273">P1273 有线电视网</a></strong></p><p><strong><a href="https://www.luogu.com.cn/problem/P1270">P1270 “访问”美术馆</a></strong></p><p><strong><a href="https://www.luogu.com.cn/problem/P1272">P1272 重建道路</a></strong></p><hr><h2 id="P2014-CTSC1997-选课"><a href="#P2014-CTSC1997-选课" class="headerlink" title="P2014 [CTSC1997]选课"></a>P2014 [CTSC1997]选课</h2><p>和二叉苹果树一样的套路。</p><p>把每一个子课程都看作是一个”分组背包”,倒序枚举即可</p><p>由于题目中可能有多棵树</p><p>因此多开一个节点把所有”树根”连在一起</p><p>同时,在倒序枚举时也要把这个新节点算进去</p><p>转移方程:</p><ul><li>$f[u][i]=max(f[v][i-k-1]+f[u][k]+w[v])(i\in[1,m+1])$</li></ul><p>核心代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">vis[k]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;son[k].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[son[k][i]]!=<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">dp</span>(son[k][i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> v=m+<span class="number">1</span>;v&gt;=<span class="number">1</span>;v--)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> K=<span class="number">0</span>;K&lt;v;K++)&#123;</span><br><span class="line"> f[k][v]=<span class="built_in">max</span>(f[k][v],w[son[k][i]]+f[son[k][i]][K]+f[k][v-K<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="P1273-有线电视网"><a href="#P1273-有线电视网" class="headerlink" title="P1273 有线电视网"></a>P1273 有线电视网</h2><p>也是比较经典的一个树上背包问题</p><p>题目中要求的是在不亏本的情况下最多的观看用户个数</p><p>设$f[i][j]$表示第$i$个站传输给$j$个用户观看最终剩余的钱数</p><p>若最终剩余钱数大于等于0,则说明未亏本</p><p>反之,则说明亏本</p><p>转移方程则为:</p><ul><li>$f[u][i]=max(f[v][k]+f[u][i-k]-w[u][v])$</li></ul><p>$dp$完后从总人数开始倒序判断是否亏本即可</p><p>贴个核心代码:</p><p>$dp部分$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">dp[x][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(val[x])&#123;<span class="comment">//如果是根节点</span></span><br><span class="line">size[x]=<span class="number">1</span>;<span class="comment">//人数加一</span></span><br><span class="line">dp[x][<span class="number">1</span>]=val[x];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;son[x].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line"><span class="built_in">dfs</span>(son[x][i]);</span><br><span class="line">size[x]+=size[son[x][i]];<span class="comment">//计算x节点下的人数总和</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=size[x];j&gt;=<span class="number">0</span>;j--)&#123;<span class="comment">//滚动数组,倒序枚举</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=size[son[x][i]];k++)&#123;<span class="comment">//枚举子树传输的观众数量</span></span><br><span class="line">dp[x][j]=<span class="built_in">max</span>(dp[x][j],dp[x][j-k]+dp[son[x][i]][k]-W[x][son[x][i]]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>$判断部分$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=m;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">if</span>(dp[<span class="number">1</span>][i]&gt;=<span class="number">0</span>)&#123;<span class="comment">//如果不亏本</span></span><br><span class="line">cout&lt;&lt;i;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="P1270-“访问”美术馆"><a href="#P1270-“访问”美术馆" class="headerlink" title="P1270 “访问”美术馆"></a>P1270 “访问”美术馆</h2><p>跟P1273 有线电视网一样的套路</p><p>设$f[i][j]$为在第$i$个节点下偷$j$幅画所需要的最小总时间</p><p>状态转移方程也就呼之欲出了</p><ul><li>$f[u][i]=min(f[v][k]+f[u][i-k]-2w[u][v])$</li></ul><p>这里$w[u][v]$要乘2是因为要进出各一趟</p><p>核心代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(paint[x]!=<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> paint[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;son[x].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> v = son[x][i];</span><br><span class="line"><span class="type">int</span> t=<span class="built_in">dfs</span>(v);</span><br><span class="line">s+=t;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j =s;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=t;k++)&#123;</span><br><span class="line">dp[x][j] = <span class="built_in">min</span>(dp[x][j] , dp[v][k] + dp[x][j-k]+w[x][v]*<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h2 id="P1272-重建道路"><a href="#P1272-重建道路" class="headerlink" title="P1272 重建道路"></a>P1272 重建道路</h2><p>同样也是一道比较经典的树上背包问题</p><p>设$f[i][j]$为第$i$个节点断出一个大小为$j$的子树所需要的断开总数</p><p>状态转移方程:</p><ul><li>$f[u][i]=min(f[v][k]+f[u][i-k]-1)$</li></ul><p>($v$为根的子树提供$k$个节点,$u$和其他儿子提供$j-k$个节点)</p><p>同时,由于一开始时一个子树都没有加进来</p><p>即把$u$的所有”儿子”都切断了<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/rawfxbhz.png" alt=""></p><p>因此当把$v$儿子加进来的时候要把之前那段减去的边加回来</p><p>核心代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">size[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(!is_son[x])&#123;</span><br><span class="line">dp[x][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">size[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;son[x].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line"><span class="type">int</span> v = son[x][i];</span><br><span class="line"><span class="built_in">dfs</span>(v);</span><br><span class="line">size[x]+=size[v];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = size[x];j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>;k&lt;=size[v];k++)&#123;<span class="comment">//这里题解里很多人都写成了&lt;j,问题是子树可能本身就没有这么多子节点,感觉有些问题</span></span><br><span class="line">dp[x][j] = <span class="built_in">min</span>(dp[x][j],dp[x][j-k]+dp[v][k]<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="普通树形-DP"><a href="#普通树形-DP" class="headerlink" title="普通树形$DP$"></a>普通树形$DP$</h1><p><strong><a href="https://www.luogu.com.cn/problem/P2016">P2016 战略游戏</a></strong></p><p><strong><a href="https://www.luogu.com.cn/problem/P2458">P2458 [SDOI2006]保安站岗 题解</a></strong></p><p><strong><a href="https://www.luogu.com.cn/problem/P4084">P4084 [USACO17DEC]Barn Painting G</a></strong></p><p><strong><a href="https://www.luogu.com.cn/problem/P2585">P2585 [ZJOI] 三色二叉树</a></strong></p><p><strong><a href="https://www.luogu.com.cn/problem/P2279">P2279 消防局的设立</a></strong></p><hr><h2 id="P2016-战略游戏"><a href="#P2016-战略游戏" class="headerlink" title="P2016 战略游戏"></a>P2016 战略游戏</h2><p>带了点贪心思想的树形$DP$</p><p>如果父节点放了一个守卫</p><p>那其子节点就都不用放守卫了</p><p>反之,子节点都要放一个守卫</p><p>转移方程:</p><ul><li>$f[u][0]+=f[v][1]$</li><li>$f[u][1]+=min(f[v][1],f[v][0])$</li></ul><p>为什么不用儿子的儿子(“孙子”)节点来看守儿子节点?</p><p><strong>如果一个节点不是叶子节点,那他的子节点数必定大于或等于$1$</strong>,因此如果<strong>用儿子节点来看守其父节点,花费的数量肯定会更多</strong>(或不变)。</p><h6 id="遗憾的是题解里似乎没人说正确性的证明-还是说太简单了都懒得证了"><a href="#遗憾的是题解里似乎没人说正确性的证明-还是说太简单了都懒得证了" class="headerlink" title="遗憾的是题解里似乎没人说正确性的证明?,还是说太简单了都懒得证了"></a>遗憾的是题解里似乎没人说正确性的证明?,<del>还是说太简单了都懒得证了</del></h6><p>核心代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(x!=<span class="number">1509</span>)</span><br><span class="line">dp[x][<span class="number">1</span>]=<span class="number">1</span>,dp[x][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;son[x].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line"><span class="built_in">dfs</span>(son[x][i]);</span><br><span class="line">dp[x][<span class="number">0</span>]+=dp[son[x][i]][<span class="number">1</span>];</span><br><span class="line">dp[x][<span class="number">1</span>]+=<span class="built_in">min</span>(dp[son[x][i]][<span class="number">1</span>],dp[son[x][i]][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于这道题目的带点权版:</p><h2 id="P2458-SDOI2006-保安站岗"><a href="#P2458-SDOI2006-保安站岗" class="headerlink" title="P2458 [SDOI2006]保安站岗"></a>P2458 [SDOI2006]保安站岗</h2><h2 id="题解链接"><a href="#题解链接" class="headerlink" title="题解链接"></a><a href="https://www.luogu.com.cn/blog/xcxc82/p2458-sdoi2006-bao-an-zhan-gang-ti-xie-yes">题解链接</a></h2><h2 id="P4084-USACO17DEC-Barn-Painting-G"><a href="#P4084-USACO17DEC-Barn-Painting-G" class="headerlink" title="P4084 [USACO17DEC]Barn Painting G"></a>P4084 [USACO17DEC]Barn Painting G</h2><p>树上$DP$求方案数。</p><p>还算是比较简单的题目吧…</p><p>设:</p><p>$f[i][0]$为第$i$个节点涂红色的方案数</p><p>$f[i][1]$为第$i$个节点涂绿色的方案数</p><p>$f[i][2]$为第$i$个节点涂蓝色的方案数</p><p>假设第$i$号节点涂了红色,那么它的上一个节点就只能涂绿色和蓝色</p><p>其他情况也同理</p><p>用乘法定理乘一下即可。</p><p>转移方程:</p><ul><li>$\begin{cases}f[u][1]=f[u][1]<em>((f[v][2]+f[v][3]))\f[u][2]=f[u][2]</em>((f[v][1]+f[v][3]))\f[u][3]=f[u][3]*((f[v][1]+f[v][2]))\end{cases}$ </li></ul><hr><h1 id="换根-DP"><a href="#换根-DP" class="headerlink" title="换根$DP$"></a>换根$DP$</h1><p>一种形式十分优美的树形$DP$</p><p><strong><a href="https://www.luogu.com.cn/problem/P3478">P3478 [POI2008]STA-Station</a></strong></p><p><strong><a href="https://www.luogu.com.cn/problem/P2986">P2986 [USACO10MAR]Great Cow Gathering G</a></strong></p><p><strong><a href="https://www.luogu.com.cn/problem/P3047">P3047 [Nearby Cows G]Great Cow Gathering G</a></strong></p><p><strong><a href="https://www.luogu.com.cn/problem/CF708C">CF708C Centroids</a></strong></p><p><strong><a href="https://www.luogu.com.cn/problem/CF1187E">CF1187E Tree Painting</a></strong></p><hr><h2 id="P3478-POI2008-STA-Station"><a href="#P3478-POI2008-STA-Station" class="headerlink" title="P3478 [POI2008]STA-Station"></a>P3478 [POI2008]STA-Station</h2><p>换根DP的模板题。</p><p>这里我们设</p><ul><li><p><strong>$size[i]$为以$1$为根节点时节点$i$的子树大小</strong></p></li><li><p><strong>$dep[i]$为以$1$为根节点时节点$i$的深度大小</strong></p></li><li><p><strong>$dp[i]$为以$i$为根节点时深度之和的大小</strong></p></li></ul><p>很明显,我们可以通过一遍DFS求出以$1$为根节点时的深度之和</p><p>如果一个个的去算的话</p><p>照这个数据范围,显然会T飞</p><p>这个时候就要用到换根DP了</p><h2 id="换根-DP-优化"><a href="#换根-DP-优化" class="headerlink" title="换根$DP$优化"></a>换根$DP$优化</h2><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/o5nj1c7o.png" alt=""></p><p>可以看出,当我们把根节点从1换到3时</p><p>对子节点3的贡献由两部分组成</p><p>1.<strong>自己子树的贡献(图中的k)</strong></p><p>2.<strong>父亲节点$1$的贡献</strong></p><hr><h2 id="如何转移"><a href="#如何转移" class="headerlink" title="如何转移"></a>如何转移</h2><ul><li><p>首先是$k$,作为自己子树所产生的贡献肯定要加上</p></li><li><p>$dp[u]$为以$u$为根节点时的深度总值,在计算时,要减去$v$的子树所产生的贡献,不然就重复计算了,同时</p></li></ul><p><strong>在以 $u$为根时,v节点及其子树内的所有节点的深度都增加了$1$</strong>,需要减去</p><p><strong>(图中红色的节点)</strong></p><p>合起来就是$dp[u]-(size[v]+k)$</p><ul><li>除v子树外的其他节点也一样</li></ul><p><strong>在以$v$为根时，除$v$节点及其子树外的其他节点的深度都增加了$1$</strong></p><p><strong>(图中蓝色的节点)</strong></p><p>合起来就是$(size[1]-size[v])$</p><p>得到转移方程</p><ul><li>$dp[v] = k+(dp[u]-(k+size[v]))+(size[1]-size[v])$</li></ul><p>化简一下</p><ul><li>$dp[v] = dp[u]-2size[v]+size[1]$</li></ul><p>核心代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">size[x] = <span class="number">1</span>;</span><br><span class="line">    vis[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;son[x].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line"><span class="type">int</span> v = son[x][i];</span><br><span class="line"><span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">dep[v] = dep[x] +<span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs1</span>(v);</span><br><span class="line">size[x]+=size[v];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    vis[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;son[x].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line"><span class="type">int</span> v = son[x][i];</span><br><span class="line"><span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">dp[v] = dp[x] +size[<span class="number">1</span>] - <span class="number">2</span>*size[v];</span><br><span class="line"><span class="built_in">dfs2</span>(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="P2986-USACO10MAR-Great-Cow-Gathering-G"><a href="#P2986-USACO10MAR-Great-Cow-Gathering-G" class="headerlink" title="P2986 [USACO10MAR]Great Cow Gathering G"></a>P2986 [USACO10MAR]Great Cow Gathering G</h2><p>前面那道题目的带权值版</p><p>一模一样的思路,只需要把状态转移方程转换一下即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].next)&#123;</span><br><span class="line">    <span class="type">int</span> v =edge[i].v;</span><br><span class="line">    <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(v,u);</span><br><span class="line">    size[u] += size[v];</span><br><span class="line">    sum[u]+=(sum[v]+edge[i].w*size[v]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].next)&#123;</span><br><span class="line">       <span class="type">int</span> v =edge[i].v;</span><br><span class="line">   <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">f[v] = <span class="number">1LL</span>*f[u] + AN*edge[i].w - <span class="number">2</span>*size[v]*edge[i].w;</span><br><span class="line">ans = <span class="built_in">min</span>(ans,f[v]);</span><br><span class="line"><span class="built_in">dp</span>(v,u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="P3047-Nearby-Cows-G"><a href="#P3047-Nearby-Cows-G" class="headerlink" title="P3047 [Nearby Cows G]"></a>P3047 [Nearby Cows G]</h2><h3 id="1-状态表示"><a href="#1-状态表示" class="headerlink" title="1.$状态表示$"></a>1.$状态表示$</h3><p>设$size[i][j]$为第i个节点向下$j$层所包含的点权和</p><p>$f[i][j]$为第$i$个点距离它不超过 $j$的所有节点权值和</p><h3 id="2-状态转移"><a href="#2-状态转移" class="headerlink" title="2.状态转移"></a>2.状态转移</h3><p>对于$size[i][j]:$</p><p>$size[u][j] =\sum\ size[v][j-1]$ 自己向下$j$层即为儿子向下$j-1$</p><p>对于$f[i][j]:$</p><p>儿子对它的贡献:</p><p>$size[v][j]$</p><p>自己向下$j$层,儿子节点肯定也要向下$j$层</p><p>父亲对它的贡献:</p><p>$f[u][j-1]-size[v][j-2]$</p><p>父亲节点扩展$j-1$层的值减去和儿子节点的值所重复包含的$j-2$层值</p><p>转移方程:</p><p>$f[v][j] = f[u][j-1]+size[v][j]-size[v][j-2]$</p><p>核心代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v =edge[i].v;</span><br><span class="line"><span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">dep[v]=dep[u]+<span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs</span>(v,u);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">size[u][i]+=size[v][i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v=edge[i].v;</span><br><span class="line"><span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i<span class="number">-2</span>&gt;=<span class="number">0</span>)</span><br><span class="line">f[v][i] = size[v][i]+f[u][i<span class="number">-1</span>] - size[v][i<span class="number">-2</span>];</span><br><span class="line"><span class="keyword">else</span> f[v][i] = size[v][i]+f[u][i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">dp</span>(v,u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="CF708C-Centroids"><a href="#CF708C-Centroids" class="headerlink" title="CF708C Centroids"></a>CF708C Centroids</h2><p>一道做起来比较麻烦的换根$DP$</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>首先对于一个节点来说,大小大于$n/2$的节点肯定只有一个，这个显而易见</p><p>再来看如何改造</p><p>如果说该节点本身的重儿子就小于$n/2$,那肯定可以成为树的重心</p><p>反之,肯定要在重儿子里找出一个重量最大的且小于等于$n/2$的子树,并将其断开,连接到根节点上(相当于删去这颗子树)</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/c18i92y5.png" alt=""></p><p>如果重儿子的大小减去被删去儿子的大小小于等于$n/2$,则说明可以改造</p><p>反之,无法改造</p><h3 id="如何转移-1"><a href="#如何转移-1" class="headerlink" title="如何转移"></a>如何转移</h3><p>分两种情况来讨论</p><p>$1$.该节点不是其父亲节点重儿子</p><p>其父节点的重儿子不会被改变,只需要判断该节点的重儿子是否改成其父节点即可</p><p>$2$.该节点是其父亲节点的重儿子</p><p>其父亲节点的重儿子会变为其”次大”儿子,其儿子节点的重儿子不会改变</p><p>核心代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">vis[u] = <span class="number">1</span>;</span><br><span class="line">size[u] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;son[u].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line"><span class="type">int</span> v = son[u][i];</span><br><span class="line"><span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line"><span class="built_in">dfs</span>(v);</span><br><span class="line">size[u]+=size[v];</span><br><span class="line"><span class="keyword">if</span>(size[v] &gt; size[maxson[u]])</span><br><span class="line">maxson[u] = v;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">if</span>(maxson[u]!=<span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(size[maxson[u]]&lt;=n/<span class="number">2</span>) dp[u] = size[maxson[u]]; </span><br><span class="line"><span class="keyword">else</span> dp[u] = dp[maxson[u]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exchange</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">        size[u] = size[u] - size[v];</span><br><span class="line">size[v] = size[v] + size[u];</span><br><span class="line"><span class="keyword">if</span>(v==maxson[u])&#123;</span><br><span class="line">maxson[u] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;son[u].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line"><span class="type">int</span> V = son[u][i];</span><br><span class="line"><span class="keyword">if</span>(V!=v&amp;&amp;size[V] &gt; size[maxson[u]])&#123;</span><br><span class="line">maxson[u] = V;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(maxson[u]!=<span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(size[maxson[u]]&lt;=n/<span class="number">2</span>) dp[u] = size[maxson[u]];</span><br><span class="line"><span class="keyword">else</span> dp[u] = dp[maxson[u]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(size[maxson[v]]&lt;size[u])&#123;</span><br><span class="line">maxson[v] = u;</span><br><span class="line"><span class="keyword">if</span>(maxson[v]!=<span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(size[maxson[v]]&lt;=n/<span class="number">2</span>) dp[v] = size[maxson[v]];</span><br><span class="line"><span class="keyword">else</span> dp[v] = dp[maxson[v]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">vis[u]  = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line"> <span class="keyword">if</span>(size[maxson[u]]&lt;=n/<span class="number">2</span>||size[maxson[u]] - dp[maxson[u]]&lt;=n/<span class="number">2</span>) ans[u]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;son[u].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line"><span class="type">int</span> v = son[u][i];</span><br><span class="line"><span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line"><span class="built_in">exchange</span>(u,v);</span><br><span class="line"><span class="built_in">dfs2</span>(v);</span><br><span class="line"><span class="built_in">exchange</span>(v,u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>end.</p><p>基环树部分还是先缓缓吧,暂时还未完全掌握</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SP2713 GSS4</title>
      <link href="/2020/08/01/sp2713/"/>
      <url>/2020/08/01/sp2713/</url>
      
        <content type="html"><![CDATA[<h1 id="SP2713-GSS4-题解"><a href="#SP2713-GSS4-题解" class="headerlink" title="SP2713 GSS4  题解"></a>SP2713 GSS4  题解</h1><h2 id="间隙"><a href="#间隙" class="headerlink" title="间隙"></a><a href="https://www.luogu.com.cn/problem/SP2713">间隙</a></h2><h2 id="双倍经验"><a href="#双倍经验" class="headerlink" title="双倍经验"></a><a href="https://www.luogu.com.cn/problem/P4145">双倍经验</a></h2><h2 id="前置知识-线段树"><a href="#前置知识-线段树" class="headerlink" title="前置知识:线段树"></a>前置知识:线段树</h2><p>如果您还不会线段树的话,推荐去看一下<a href="https://www.cnblogs.com/jason2003/p/9676729.html"><strong>这篇文章</strong></a>,我一开始也是在那里学的</p><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给一堆数,有以下两个操作:</p><ul><li><p>给出一个区间$[L,R]$,把该区间内的每个数都开平方</p></li><li><p>给出一个区间$[L,R]$,查询这个区间的每个数的和</p></li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先看一下这个数据范围,$1e18$,直接暴力的话肯定会T飞</p><p>求和操作很简单,相信学过线段树的人应该都会</p><p>难点在于这个开方操作,我们没法像线段树模板那样打个懒标记来进行下传操作</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/72ur96tc.png" alt=""></p><p>通过观察$\sqrt x$函数图像缓慢的增长率或者其他性质不难发现,很多开方操作是不必要的,考虑减枝优化:</p><ul><li>不难发现,<strong>当一个区间内的所有数都是$1$时,再对该区间进行开方操作对该区间内的总值造成不了任何改变</strong>($\sqrt{1} = 1$)</li></ul><p>因此代码实现方面只要在区间内总值均为1的情况下加一个小剪枝即可</p><hr><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>思路理解了代码实现难度就不高了,但还是有几个坑点…具体的注释里有写</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson (node&lt;&lt;1)<span class="comment">//左儿子</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson (node&lt;&lt;1|1)<span class="comment">//右儿子</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long <span class="comment">//记得开long long</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100005</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st</span>&#123;</span><br><span class="line"><span class="type">int</span> l,r;<span class="comment">//左右端点</span></span><br><span class="line">ll sum;</span><br><span class="line">&#125;tree[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">ll a[MAXN];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;</span><br><span class="line">tree[node].sum = tree[lson].sum + tree[rson].sum;<span class="comment">//合并操作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;<span class="comment">//建树</span></span><br><span class="line">tree[node].l = l;</span><br><span class="line">tree[node].r = r;</span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">tree[node].sum = a[l];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">build</span>(lson,l,mid);</span><br><span class="line"><span class="built_in">build</span>(rson,mid+<span class="number">1</span>,r);</span><br><span class="line"><span class="built_in">pushup</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> L = tree[node].l,R = tree[node].r;</span><br><span class="line"><span class="keyword">if</span>(tree[node].sum==R-L+<span class="number">1</span>) <span class="keyword">return</span>;<span class="comment">//如果总和为区间长度,也就是所有值均为1时,直接剪枝掉</span></span><br><span class="line"><span class="keyword">if</span>(L==R)&#123;</span><br><span class="line">tree[node].sum = <span class="built_in">sqrt</span>(tree[node].sum);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid = (L+R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid)&#123;</span><br><span class="line"><span class="built_in">change</span>(lson,l,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(r&gt;mid)&#123;</span><br><span class="line"><span class="built_in">change</span>(rson,l,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pushup</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;<span class="comment">//查询</span></span><br><span class="line"><span class="type">int</span> L = tree[node].l,R = tree[node].r;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=L&amp;&amp;r&gt;=R)&#123;<span class="comment">//包含在查询区间内,直接返回sum值</span></span><br><span class="line"><span class="keyword">return</span> tree[node].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid = (L+R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid)&#123;</span><br><span class="line">ans+=<span class="built_in">query</span>(lson,l,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(r&gt;mid)&#123;</span><br><span class="line">ans+=<span class="built_in">query</span>(rson,l,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);<span class="comment">//不加貌似会TLE?</span></span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> Case=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Case #%d:\n&quot;</span>,++Case);<span class="comment">//注意,样例里那个case是要输出的,一开始被这里卡了好久...</span></span><br><span class="line"><span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));<span class="comment">//记得要先memset</span></span><br><span class="line"><span class="built_in">memset</span>(tree,<span class="number">0</span>,<span class="built_in">sizeof</span>(tree));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">cin&gt;&gt;m;</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line"><span class="type">int</span> mode,left,right;</span><br><span class="line">cin&gt;&gt;mode&gt;&gt;left&gt;&gt;right;</span><br><span class="line"><span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line"><span class="built_in">swap</span>(left,right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(mode==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">change</span>(<span class="number">1</span>,left,right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">query</span>(<span class="number">1</span>,left,right));</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);<span class="comment">//记得换行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF1187E Tree Painting</title>
      <link href="/2020/07/26/cf1187e/"/>
      <url>/2020/07/26/cf1187e/</url>
      
        <content type="html"><![CDATA[<h1 id="CF1187E-Tree-Painting-题解"><a href="#CF1187E-Tree-Painting-题解" class="headerlink" title="CF1187E Tree Painting 题解"></a>CF1187E Tree Painting 题解</h1><h2 id="原题面"><a href="#原题面" class="headerlink" title="原题面"></a><a href="https://www.luogu.com.cn/problem/CF1187E">原题面</a></h2><h2 id="前置知识-换根-DP"><a href="#前置知识-换根-DP" class="headerlink" title="前置知识: 换根$DP$"></a>前置知识: 换根$DP$</h2><p>换根$DP$模板题</p><p>如果您还不会换根$DP$的话,可以先去看看UM巨佬的日报:</p><p><a href="https://sflsrick.blog.luogu.org/note-how-to-change-root">#278[UltiMadow] [学习笔记]换根dp</a></p><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给定一棵n个点的树 初始全是白点</p><p>要求你做n步操作，每一次选定一个与一个黑点相隔一条边的白点，将它染成黑点，然后获得该白点被染色前所在的白色联通块大小的权值。</p><p>求可获得的最大权值</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>几乎是一道裸的模板题了…</p><p>和P3478几乎一摸一样,只是需要一个微小的结论</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/h4z3mf0i.png" alt=""></p><h5 id="PS-图中节点的编号有一点微小的错误-不过并不影响阅读"><a href="#PS-图中节点的编号有一点微小的错误-不过并不影响阅读" class="headerlink" title="PS:图中节点的编号有一点微小的错误,不过并不影响阅读"></a>PS:图中节点的编号有一点微小的错误,不过并不影响阅读</h5><p>假如说我们选了图中的1号节点作为第一个涂色的点（图中蓝色的点)</p><p>那下一个涂色的节点肯定就能选择它的几个儿子了(图中深红色的点)</p><p>同时,<strong>由于父亲节点已经被涂色了,其子节点不可能再和上面的”祖先”辈节点有联通了</strong><br><strong>能对其产生贡献的只有自己的子树</strong></p><p>因此当一个父亲节点被涂色后,其所有子树都是<strong>相对”独立”的</strong>，涂色顺序的变化对总贡献值无任何影响</p><p>故当<strong>第一个节点被涂色后,剩下节点的涂色顺序均无法对总贡献值产生影响</strong></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>单纯的暴力枚举每个根的位置的话照这个数据范围肯定会T飞</p><p>考虑换根DP</p><p>应该很容易状态转移方程推出:</p><ul><li>$dp[v] = dp[u]-2size[v]+size[1]$</li></ul><p>具体这个方程怎么来的,我之前写的P3478的<a href="https://www.luogu.com.cn/blog/xcxc82/p3478-poi2008sta-station-ti-xie">题解</a>跟前面UM巨佬的日报里也有讲</p><p>套上换根$DP$的板子即可</p><p>贴上丑陋的代码:（其实只要把P3478的代码改一行就可以了）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">200010</span>;</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; son[MAXN];</span><br><span class="line"><span class="type">int</span> vis[MAXN],n;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> size[MAXN];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> f[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">size[u] = <span class="number">1</span>;</span><br><span class="line">vis[u] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;son[u].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line"><span class="type">int</span> v = son[u][i];</span><br><span class="line"><span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line"><span class="built_in">dfs</span>(v);</span><br><span class="line">size[u]+=size[v];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">vis[u] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;son[u].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line"><span class="type">int</span> v = son[u][i];</span><br><span class="line"><span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">f[v] = f[u] + size[<span class="number">1</span>] - <span class="number">2</span>*size[v];</span><br><span class="line"><span class="built_in">dp</span>(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="type">int</span> u,v;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">son[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">son[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">f[<span class="number">1</span>]+=size[i];</span><br><span class="line">&#125;</span><br><span class="line">   <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">   <span class="built_in">dp</span>(<span class="number">1</span>);</span><br><span class="line">   <span class="type">long</span> <span class="type">long</span> ans = <span class="number">-0x3f</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    ans = <span class="built_in">max</span>(ans , f[i]);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P2458 [SDOI2006]保安站岗</title>
      <link href="/2020/07/20/p2458/"/>
      <url>/2020/07/20/p2458/</url>
      
        <content type="html"><![CDATA[<h1 id="P2458-SDOI2006-保安站岗-题解"><a href="#P2458-SDOI2006-保安站岗-题解" class="headerlink" title="P2458 [SDOI2006]保安站岗 题解"></a><strong>P2458 [SDOI2006]保安站岗 题解</strong></h1><h2 id="间隙-原题面"><a href="#间隙-原题面" class="headerlink" title="间隙(原题面)"></a><a href="https://www.luogu.com.cn/problem/P2458">间隙(原题面)</a></h2><ul><li>前排声明:蒟蒻刚学OI没多久,讲的可能比较啰嗦,望见谅</li></ul><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给一颗树,每个点都可以花费一定的价格来放置一名”保安”</p><p>每个保安都可以看管他本身所在的点和所有与他所站的点相邻的点</p><p>求:看管所有点所需要的最小花费</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>树形dp。</p><p>先来说一种错误的做法,也是我一开始想到的做法</p><p>每个点都有”放置”和”不放置”两种选择</p><p><strong>设$dp[i][0]$为第$i$个点”不放置”保安所需要的最小花费</strong></p><p><strong>$dp[i][1]$为第$i$个点“放置”保安所需要的最小花费</strong></p><p>如果第$i$个点”放置”了保安</p><p>那它的下一个节点则可以选择”放或不放”两种决策</p><p>反之,下一个节点必须都”放置”一名保安</p><p><del>很明显是错的</del></p><p>放张图应该就明白了<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/c3ommepj.png" alt=""></p><p>(下一个节点不一定要由父亲或自己来看管,也可以由自己的”儿子”来看管)</p><p>也就是说,每个点的看管对象都有:</p><ul><li><strong>自己</strong></li><li><strong>父亲</strong></li><li><strong>儿子</strong></li></ul><p><strong>三种可能</strong></p><h2 id="如何转移"><a href="#如何转移" class="headerlink" title="如何转移"></a>如何转移</h2><p>设$dp[i][0]$为该点<strong>由自己看管</strong>所产生的最有解</p><p>$dp[i][1]$为该点<strong>由父亲看管</strong>所产生的最优解</p><p>$dp[i][2]$为该点<strong>由儿子看管</strong>所产生的最优解</p><ul><li><strong>1.由“自己”看管</strong></li></ul><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ywr3v3nc.png" alt=""></p><p>自己的位置上已经”放置了”一个点</p><p>那么它的所有儿子就都会被自己所”看管”住</p><p>显然儿子可以选择任意一种决策</p><ul><li>得到转移方程:$dp[i][0]=\sum min(dp[son][0],dp[son][1],dp[son][2])+w[i]$</li></ul><p>($w[i]$为父亲节点”放置”守卫所需要的价值)</p><ul><li><strong>2.由“父亲”看管</strong></li></ul><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/75jddbxl.png" alt=""></p><p>自己由父亲看管,说明自己所在的点上<strong>未”放置”门卫</strong>,那儿子肯定<strong>只能由自己的儿子看管或由自己看管</strong></p><ul><li><p>得到方程:$dp[i][1]=\sum min(dp[son][0],dp[son][2])$</p></li><li><p>3.<strong>由“儿子”看管</strong></p></li></ul><p>（图中红蓝分别为两种可能情况）</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/b7rw1758.png" alt=""></p><p>既然是由自己的儿子看管</p><p>儿子的决策也有两种可能</p><p>1.由儿子的”儿子”看管</p><p>2.由自己看管</p><ul><li>得到方程:$dp[i][2]=\sum min(dp[son][2],dp[son][0])$</li></ul><p>有一种极端情况,如果全部都选了$dp[son][2]$</p><p>“自己”就会产生无人看管的情况</p><p>因此要在这里加一个小特判,具体代码里有解释</p><p>这里做了个简陋的gif,不懂的可以结合代码看一下</p><p><img src="https://img-blog.csdnimg.cn/20200720102214607.gif" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1510</span>;</span><br><span class="line"><span class="type">int</span> n,dp[MAXN][<span class="number">4</span>],w[MAXN];</span><br><span class="line"><span class="type">int</span> is_head[MAXN];</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; son[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="type">bool</span> is_cs = <span class="literal">false</span>;<span class="comment">//用来判断有无极端情况</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> minn = <span class="number">0x3ffffff</span>;<span class="comment">//用来求极端情况的最小值 </span></span><br><span class="line">dp[x][<span class="number">0</span>] = w[x];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;son[x].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line"><span class="type">int</span> v = son[x][i];</span><br><span class="line"><span class="built_in">dfs</span>(v);</span><br><span class="line">dp[x][<span class="number">0</span>]+=<span class="built_in">min</span>(<span class="built_in">min</span>(dp[v][<span class="number">0</span>],dp[v][<span class="number">1</span>]),dp[v][<span class="number">2</span>]);<span class="comment">//由自己看守 </span></span><br><span class="line">dp[x][<span class="number">1</span>]+=<span class="built_in">min</span>(dp[v][<span class="number">2</span>],dp[v][<span class="number">0</span>]);<span class="comment">//由父亲看守 </span></span><br><span class="line"><span class="comment">//由儿子看守 ↓ </span></span><br><span class="line"><span class="keyword">if</span>(dp[v][<span class="number">0</span>]&lt;dp[v][<span class="number">2</span>])&#123; </span><br><span class="line">dp[x][<span class="number">2</span>]+=dp[v][<span class="number">0</span>];<span class="comment">//如果儿子放置守卫花费的钱更少,那就直接在儿子的点上放置一个守卫 </span></span><br><span class="line">is_cs=<span class="literal">true</span>;<span class="comment">//既然儿子的位置上已经放置守卫了,无极端情况存在 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;<span class="comment">//否则在儿子的儿子上放置守卫 </span></span><br><span class="line">minn = <span class="built_in">min</span>( minn , dp[v][<span class="number">0</span>]-dp[v][<span class="number">2</span>]);<span class="comment">//计算最小所需值 </span></span><br><span class="line">dp[x][<span class="number">2</span>]+=dp[v][<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!is_cs) dp[x][<span class="number">2</span>]+=minn;<span class="comment">//如果存在极端情况,则加上差值,相当于是消掉dp[-][2],加上dp[-][0] </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="type">int</span> u,m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;m);</span><br><span class="line">w[u]=m;</span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line"><span class="type">int</span> v;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;v);</span><br><span class="line">is_head[v]++;</span><br><span class="line">son[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!is_head[i])&#123;</span><br><span class="line"><span class="built_in">dfs</span>(i);</span><br><span class="line">cout&lt;&lt;<span class="built_in">min</span>(dp[i][<span class="number">0</span>],dp[i][<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF607B Zuma</title>
      <link href="/2020/07/09/cf607b/"/>
      <url>/2020/07/09/cf607b/</url>
      
        <content type="html"><![CDATA[<h1 id="CF607B-Zuma-题解"><a href="#CF607B-Zuma-题解" class="headerlink" title="CF607B Zuma 题解"></a>CF607B Zuma 题解</h1><h2 id="间隙-原题面"><a href="#间隙-原题面" class="headerlink" title="间隙(原题面)"></a><a href="https://www.luogu.com.cn/problem/CF607B">间隙(原题面)</a></h2><ul><li>前排声明:蒟蒻刚学oi没多久,而且是自学的,写的可能会比较累赘,望见谅。</li></ul><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><ul><li>基础区间dp</li></ul><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给一个长度为n的串,每次都可以挑选一个回文的连续字串进行消除,删除后，剩余的串将连接在一起，形成一个新的串,求把串全部删除完需要的最小次数</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/k3ezz757.png" alt=""></p><p>可以看出每一个区间的的求解都可以分为更小的两个区间的求解</p><p>联想到区间dp</p><p>设$dp[l][r]$为左端点为l,右端点为r时的最优解</p><p>不难推出<del>比较套路的</del>状态转移方程</p><ul><li>$dp[l][r]=min(dp[l][r],dp[l][k]+dp[k+1][r]).(l&lt;=k&lt;r)$</li></ul><p>同时,这里还有一个区间的回文判断</p><p>假设我们把总区间划分为两个区间</p><p>$[1,4,5,3,4,1,3,2]$和$[3,2]$</p><p>其中$[1,4,5,3,4,1,3,2]$包含一个回文部分</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/teqq2yqh.png" alt=""></p><p>此时我们只要直接将回文部分删去即可</p><p>即$dp[l][r]=dp[l+1][r-1]$</p><p>这其实是一个类似于预处理的东西(个人看法,可能有误)</p><p>如果一个区间包含回文部分</p><p>则先把$dp[l][r]$给预处理成它不进行划分可以产生的最小值</p><p>再去和划分成两个区间所产生的最小值进行比较</p><ul><li>即$if(a[l]==a[r])$<br>$dp[l[[r]=dp[l+1][r-1]$</li></ul><p>贴上丑陋的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">510</span>;</span><br><span class="line"><span class="type">int</span> n,a[MAXN],dp[MAXN][MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="comment">//预处理长度为1的区间</span></span><br><span class="line">dp[i][i]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">1</span>;len&lt;n;len++)&#123;<span class="comment">//枚举长度</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>;l&lt;=n&amp;&amp;l+len&lt;=n;l++)&#123;<span class="comment">//枚举左右断点</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> r=l+len;</span><br><span class="line">dp[l][r]=inf;</span><br><span class="line"><span class="keyword">if</span>(a[l]==a[r])&#123;<span class="comment">//如果包含回文部分</span></span><br><span class="line"><span class="keyword">if</span>(r==l+<span class="number">1</span>)&#123;<span class="comment">//注意,这里是区间长度为2的特判</span></span><br><span class="line">dp[l][r]=dp[l+<span class="number">1</span>][r<span class="number">-1</span>]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> dp[l][r]=dp[l+<span class="number">1</span>][r<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=l;k&lt;r;k++)&#123;<span class="comment">//枚举断点</span></span><br><span class="line">dp[l][r]=<span class="built_in">min</span>(dp[l][r],dp[l][k]+dp[k+<span class="number">1</span>][r]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;dp[<span class="number">1</span>][n];</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>如有错误欢迎大佬们指出QwQ</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P3800 power收集</title>
      <link href="/2020/07/07/p3800/"/>
      <url>/2020/07/07/p3800/</url>
      
        <content type="html"><![CDATA[<h1 id="P3800-Power收集-题解"><a href="#P3800-Power收集-题解" class="headerlink" title="P3800 Power收集 题解"></a>P3800 Power收集 题解</h1><h2 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a><a href="https://www.luogu.com.cn/problem/P3800">传送门</a></h2><p>前排声明:蒟蒻刚学oi没多久,写的可能比较粗糙,望谅解</p><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给一个$N×M$大小的矩阵</p><p>其中有k个点包含一个带有价值的P点</p><p>每一行中的一个格子i都可以从上一行中的第$[i-t,i+t]$个格子中转移过来</p><p>求可以获得的最大价值</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>大致思路和<a href="https://www.luogu.com.cn/problem/P1725">P1725 琪露诺</a>很像,只是换了一种形式而已</p><p>既然每一个格子$i$都可以从上一行中的第$ [i-t,i+t] $个格子中转移过来</p><p>我们<strong>设$a[i][j]$为第$i$行第$j$个点的价值大小</strong></p><p>容易得到状态转移方程:</p><ul><li><p>$dp[i][j]=max(dp[i-1][k])+a[i][j] (j-T&lt;=k&lt;=j+T)$</p></li><li><p>因此,对于每一个$dp[i][j]$来说</p></li></ul><p>他的值均是由上一行中$[j-t,j+t]$区间中的最大值转移过来的</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/f400j4mf.png" alt=""></p><h6 id="懒得找城管的图了-只好拿之前cirno的图改了一下"><a href="#懒得找城管的图了-只好拿之前cirno的图改了一下" class="headerlink" title="(懒得找城管的图了,只好拿之前cirno的图改了一下)"></a>(<del>懒得找城管的图了,只好拿之前cirno的图改了一下</del>)</h6><p>可以看出这是一个滑动区间求最值的问题</p><p>可以考虑用单调队列来优化</p><p>在进行第$i$行第$j$列的转移前</p><p>利用滑动窗口将第$i-1$行中$[j-t,j+t]$的最大值来求出来</p><p>这里<del>闲着无聊</del>做了个$gif$</p><p><img src="https://img-blog.csdnimg.cn/20200707134646322.gif" alt=""></p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>开一个数组 $q$ 模拟队列,用来滑动求最值</p><p>首先初始化第一行的$dp[i][j]$</p><p>第2~n行则利用$q$来求上一行的最大值进行转移</p><ul><li><strong>swp函数</strong></li></ul><p>实现队列初始化功能</p><p>将前 $t$ 个数加入队列</p><ul><li><strong>swi函数</strong></li></ul><p>当插入新元素时</p><p>先判断队列是否在$[1,m]$的区间内(不判会RE)</p><p>如果在区间内:</p><p>$1$.调整队列单调性</p><p>$2$.入队</p><p>反之,超出范围,不入队</p><p>$3$.去掉”超时”元素</p><p>贴上丑陋的代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 4010</span></span><br><span class="line"><span class="type">int</span> tail=<span class="number">0</span>,head=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> n,m,k,t,ans; </span><br><span class="line"><span class="type">int</span> q[MAXN],a[MAXN][MAXN],dp[MAXN][MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">queue_empty</span><span class="params">()</span></span>&#123;<span class="comment">//清空窗口 </span></span><br><span class="line">tail=<span class="number">0</span>,head=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swi</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> last)</span></span>&#123;<span class="comment">//插入元素</span></span><br><span class="line">   <span class="keyword">if</span>(x+t&lt;=m)&#123;<span class="comment">//判断是否超过边界,不加会RE </span></span><br><span class="line">   <span class="keyword">while</span>(dp[last][x+t]&gt;dp[last][q[tail]]&amp;&amp;tail&gt;=head)&#123;<span class="comment">//单调队列 </span></span><br><span class="line">tail--;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">q[++tail]=x+t;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(q[head]+t&lt;x) head++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swp</span><span class="params">(<span class="type">int</span> last)</span></span>&#123;<span class="comment">//初始化窗口 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(dp[last][i]&gt;dp[last][q[tail]]&amp;&amp;tail&gt;=head)&#123;</span><br><span class="line">tail--;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">q[++tail] = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k,&amp;t);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line"><span class="type">int</span> x, y, z;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">a[x][y] = z;</span><br><span class="line">&#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="comment">//第一行初始化</span></span><br><span class="line">   dp[<span class="number">1</span>][i]=a[<span class="number">1</span>][i];</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">   <span class="built_in">swp</span>(i<span class="number">-1</span>);</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">swi</span>(j,i<span class="number">-1</span>);</span><br><span class="line">   </span><br><span class="line">  dp[i][j]=dp[i<span class="number">-1</span>][q[head]]+a[i][j]; </span><br><span class="line">  </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">queue_empty</span>();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">ans=<span class="built_in">max</span>(dp[n][i],ans);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如有错误欢迎dalao们指出qwq</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P5239 回忆京都</title>
      <link href="/2020/07/05/p5239/"/>
      <url>/2020/07/05/p5239/</url>
      
        <content type="html"><![CDATA[<h1 id="P5239-回忆京都题解"><a href="#P5239-回忆京都题解" class="headerlink" title="P5239 回忆京都题解"></a>P5239 回忆京都题解</h1><h2 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a><a href="https://www.luogu.com.cn/problem/P5239">传送门</a></h2><p>前排声明:题解写的比较累赘…把一些基本的恒等式都讲了一遍…(部分证明借鉴了《具体数学》一书)</p><p>如果您已经掌握了这些基础的话建议还是去看其他dalao们的题解吧qwq…</p><h2 id="1-基本恒等式"><a href="#1-基本恒等式" class="headerlink" title="1.基本恒等式"></a>1.基本恒等式</h2><p>我们把$\dbinom{n}{k}$符号读作”<strong>n选取k</strong>“</p><p>即<strong>从n个元素的集合中选取k个元素</strong>作为子集的方案总数</p><p>对于该集合的第一个元素的可能,有n种选择</p><p>对第二个元素,有n-1种选择,3,4,5…..也同理</p><p>同时,<strong>对于每k个元素组成的子集都恰好有$k!$种不同的排序</strong></p><p>根据乘法原理</p><p>得到公式</p><p>$\dbinom{n}{k}={\dfrac{n<em>(n-1)…</em>(n-k+1)}{k!}}$ </p><p>(<strong>基本恒等式</strong>)</p><hr><h2 id="2-对称恒等式"><a href="#2-对称恒等式" class="headerlink" title="2.对称恒等式"></a>2.对称恒等式</h2><p>先来看个图</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/a9xmsi5c.png" alt=""></p><p>观察一下不难发现规律</p><p>$\dbinom{n}{k}=\dbinom{n}{n-k}$</p><p>(<strong>对称恒等式</strong>)</p><p>至于正确性也显而易见</p><p><strong>从n个物品中选k个物品就相当于指定的n-k种物品不被选取</strong></p><hr><h2 id="3-吸收恒等式"><a href="#3-吸收恒等式" class="headerlink" title="3.吸收恒等式"></a>3.吸收恒等式</h2><p>我们知道,二项式系数的基本恒等式为</p><p>$\dbinom{n}{k}={\dfrac{n<em>(n-1)…</em>(n-k+1)}{k!}}$ </p><p>可以将式子转化为</p><p>$\dbinom{n}{k}={\dfrac{n}{k}<em>\dfrac{(n-1)…</em>(n-k+1)}{(k-1)!}}$ </p><p>得到式子$\dbinom{n}{k}=\dfrac{n}{k}\dbinom{n-1}{k-1}$</p><p>两边同乘k,得$k\dbinom{n}{k}=n\dbinom{n-1}{k-1}$<strong>恒等式1</strong></p><p>根据这个式子,再利用之前的恒等式1</p><p>还可以得到式子</p><p>$(n-k)\dbinom{n}{k}=(n-k)\dbinom{n}{n-k}$(根据对称性)</p><p>$=n\dbinom{n-1}{n-1-k}$(根据恒等式1)</p><p>$=n\dbinom{n-1}{k}$—-(根据对称性)<strong>恒等式2</strong> </p><hr><h2 id="4-加法公式"><a href="#4-加法公式" class="headerlink" title="4.加法公式"></a>4.加法公式</h2><p>观察一下前面的那张表,不难发现一个规律:</p><p>$\dbinom{n}{k}=\dbinom{n-1}{k-1}+\dbinom{n-1}{k}$</p><p>推导的话也很简单</p><p>根据之前吸收恒等式里的恒等式1和恒等式2</p><p>得出</p><p>$\dbinom{n}{k}=(n-k)\dbinom{n}{k}+k\dbinom{n}{k}=n\dbinom{n-1}{k}+n\dbinom{n-1}{k-1}$</p><hr><h2 id="5-题目"><a href="#5-题目" class="headerlink" title="5.题目"></a>5.题目</h2><h3 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意:"></a>大致题意:</h3><p>q次询问,每次都给一个m跟n,求</p><p>$\sum\limits<em>{i=1}^n\sum\limits</em>{j=1}^mC^i_j$</p><hr><p>根据前面的加法公式,很容易可以解出这题</p><p>一共有n次询问，如果一次一次的去加的话肯定会超时</p><p>可以考虑使用二维前缀和来优化</p><p>至于二维前缀和怎么用,前面的dalao们已经写的很清楚了,为了<del>让题解看起来不是那么的水</del>,彩笔这里就再粗糙的写一遍吧</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ez5vvkji.png" alt=""></p><p>从图中不难看出,对于每一个sum[i][j],都有</p><p>sum[i][j]=sum[i][j-1]+sum[i-1][j]+a[i][j]-sum[i-1][j-1]</p><p>因为这里面有一个对$1926081719260817$取模操作</p><p>相减可能会产生负数</p><p>比如说我们取模后$sum[i][j-1]+sum[i-1][j]+a[i][j]=1$</p><p>而$sum[i-1][j-1]=1926081719260816$</p><p>很明显,相减为负</p><p>至于如何避免其实也很简单,只要再加上一个模数就可以了,相当于是加上之前那个被模掉的部分</p><hr><p>贴上丑陋的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> mo=<span class="number">19260817</span>;</span><br><span class="line"><span class="type">int</span> n,a[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="type">int</span> sum[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">      a[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">1002</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">1002</span>;j++)&#123;</span><br><span class="line">a[i][<span class="number">0</span>]=a[i][i]=<span class="number">1</span>;</span><br><span class="line">a[i][j]=(a[i<span class="number">-1</span>][j]+a[i<span class="number">-1</span>][j<span class="number">-1</span>])%mo;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">1002</span>;i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">1002</span>;j++)&#123;</span><br><span class="line">sum[i][j]=(sum[i<span class="number">-1</span>][j]+sum[i][j<span class="number">-1</span>]+a[i][j]-sum[i<span class="number">-1</span>][j<span class="number">-1</span>]+mo)%mo;</span><br><span class="line">&#125;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="type">int</span> l,r;</span><br><span class="line">cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">cout&lt;&lt;sum[r][l]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如有错误还请大佬们指出</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>p4838 P哥破解密码</title>
      <link href="/2020/06/26/p4838/"/>
      <url>/2020/06/26/p4838/</url>
      
        <content type="html"><![CDATA[<h1 id="P4838-P哥破解密码题解"><a href="#P4838-P哥破解密码题解" class="headerlink" title="P4838 P哥破解密码题解"></a>P4838 P哥破解密码题解</h1><ul><li><h2 id="原题面"><a href="#原题面" class="headerlink" title="原题面"></a><a href="https://www.luogu.com.cn/problem/P4838">原题面</a></h2></li></ul><p><strong>思路貌似跟dalao们的有点不一样</strong></p><ul><li><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2></li></ul><hr><p>给一串长度为n的字符串,<strong>当且仅当串只由A和B构成</strong>，且没有连续的3个A时,该串合法,求方案总数</p><hr><p>感觉跟P4910帕秋莉的手环那道题目差不多吧….都是线性递推,貌似dalao们都是用动态规划来做的,<del>蒟蒻不太会,所以只好用比较sb的递推来做qwq</del></p><ul><li><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2>既然每个字符只有A和B两种可能,,如果字符串没有任何限制的话,很容易看出方 案总数为 : $2^n$</li></ul><p>但这里加了一个<strong>不能有没有连续的3个A</strong>出现的限制条件</p><p>不妨先来画个图来看一下,更加直观一点<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/en3d9md2.png" alt=""><br>图中为n=6的时候的情况</p><p>我们用$f_i$来表示长度为i的字符串的<strong>不合法方案总数</strong>(<strong>注意,是不合法方案总数</strong>)</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/axtxuhus.png" alt=""></p><p>先来看第一个字符选A情况</p><p>这里我们可以把每一个B看作是一个”<strong>断点</strong>“</p><p>不难看出,每出现一个断点后</p><p>该断点下面的情况就可以从之前的$f_i$递推过来</p><p>而当出现连续3个A时,相当于是把下面的所有情况都”<strong>截断</strong>“了</p><p>也就是$2^{n-3}$种情况</p><p>第一个字符选”B”也同理</p><p>相当于是在第一个点的时候就把该串给”<strong>截断</strong>“了</p><p>容易推出当N=6时,合法方案总数为</p><p>$2^6-(f<em>{5}+f</em>{4}+f_{3}+2^3)$</p><p>其他n&gt;3的情况也同理</p><p>得到式子</p><p>方案总数=$2^n-(f<em>{n-1}+f</em>{n-2}+f_{n-3}+2^{n-3})$</p><p>=$7*2^{n-3}-(f<em>{n-1}+f</em>{n-2}+f_{n-3})$</p><p>=$(2^{n-1}+2^{n-2}+2^{n-3})-(f<em>{n-1}+f</em>{n-2}+f_{n-3})$</p><p>设$s_i$为方案总数</p><p>则$s<em>i=s</em>{i-1}+s<em>{i-2}+s</em>{i-3}$</p><p>得到最终式子<br>$\begin{cases}2(n=1)\4 (n=2)\7 (n=3)\s<em>i=s</em>{i-1}+s<em>{i-2}+s</em>{i-3}(n&gt;3)\end{cases}$ </p><p>贴个丑陋的代码<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> mo=<span class="number">19260817</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n,t;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">matrix</span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="type">int</span> a[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line">&#125;ans,a;</span><br><span class="line">matrix <span class="keyword">operator</span> *(<span class="type">const</span> matrix &amp;x,<span class="type">const</span> matrix &amp;y)&#123;</span><br><span class="line">matrix z;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">3</span>;j++)&#123;</span><br><span class="line">z.a[i][j]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">3</span>;k++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">3</span>;j++)&#123;</span><br><span class="line">z.a[i][j]=(z.a[i][j]+(x.a[i][k]*y.a[k][j])%mo)%mo;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="number">2</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">2</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="number">4</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">3</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="number">7</span>&lt;&lt;endl;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">3</span>;j++)&#123;</span><br><span class="line">a.a[i][j]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(i==j) ans.a[i][j]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> ans.a[i][j]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">a.a[<span class="number">1</span>][<span class="number">1</span>]=a.a[<span class="number">1</span>][<span class="number">2</span>]=a.a[<span class="number">1</span>][<span class="number">3</span>]=a.a[<span class="number">2</span>][<span class="number">1</span>]=a.a[<span class="number">3</span>][<span class="number">2</span>]=<span class="number">1</span>; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(n)&#123;</span><br><span class="line"><span class="keyword">if</span>(n&amp;<span class="number">1</span>) ans=ans*a;</span><br><span class="line">n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">a=a*a;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;((ans.a[<span class="number">1</span>][<span class="number">1</span>]+ans.a[<span class="number">2</span>][<span class="number">1</span>])%mo+ans.a[<span class="number">3</span>][<span class="number">1</span>])%mo&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><del>貌似是蒟蒻的第一次不看题解做出(比较水的)紫题?</del></p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>p1725 琪露诺</title>
      <link href="/2020/06/25/p1725/"/>
      <url>/2020/06/25/p1725/</url>
      
        <content type="html"><![CDATA[<h1 id="P1725-琪露诺"><a href="#P1725-琪露诺" class="headerlink" title="P1725 琪露诺"></a><a href="https://www.luogu.com.cn/problem/P1725"></a>P1725 琪露诺</h1><p><a href="https://www.luogu.com.cn/problem/P1725">原题面</a></p><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给编号为0~N的N+1个数,每个格子都有一个冰冻指数ice[i]</p><p>每一个格子都可以转移到区间[i+l,i+r]上,求ice[i]总和的最大值</p><hr><p>很明显可以看出这是一道dp的题</p><p>我们不妨先把转移方程写出来</p><p>题目中说<strong>每一个格子都可以转移到区间[i+l,i+r]上</strong></p><p>不难推出转移方程:</p><ul><li><h3 id="dpi-max-dp-i-r-dp-i-r-1-…dp-i-l-1-dp-i-l-ice-i"><a href="#dpi-max-dp-i-r-dp-i-r-1-…dp-i-l-1-dp-i-l-ice-i" class="headerlink" title="$~~~~dpi=max(dp{i-r},dp{i-r+1},…dp{i-l-1},dp_{i-l})+ice[i]$"></a>$<del>~</del><del>~</del><del>~</del>~dp<em>i=max(dp</em>{i-r},dp<em>{i-r+1},…dp</em>{i-l-1},dp_{i-l})+ice[i]$</h3></li></ul><p>(放张图 样例是自造的,此图为i=4的情况)<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/ai7jcjuq.png" alt=""><br>因此,对于每一个$dp_i$来说</p><p>他的值均是由[$dp<em>{i-l}$~$dp</em>{i-r}$]区间中的最大值转移过来的(前面方程也说了)</p><p>而且这个区间是不断滑动的</p><p>滑动区间求最值,很容易联想到<strong>单调队列</strong></p><p>照题目里的数据范围普通的dp肯定会超时</p><p>因此我们可以用单调队列来优化它</p><p>做了一个比较粗糙的过程动态图qwq<br><img src="https://img-blog.csdnimg.cn/2020062520104327.gif" alt=""><br>补几张gif跳的比较快的图</p><p>$dp_1$</p><ul><li><img src="https://cdn.luogu.com.cn/upload/image_hosting/3h0hzail.png" alt=""><br>$dp_2$</li><li><img src="https://cdn.luogu.com.cn/upload/image_hosting/9osayz2u.png" alt=""><br>以此类推,均由[$dp<em>{i-l}$~$dp</em>{i-r}$]区间中的最大值转移过来</li><li><img src="https://cdn.luogu.com.cn/upload/image_hosting/pq2le485.png" alt=""></li></ul><hr><p>写的貌似有点累赘…</p><p>如有错误还请dalao们指出qwq,<del>话说没人会来看这么辣鸡的题解吧</del></p><p>贴个丑陋的代码:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> ice[<span class="number">300010</span>],dp[<span class="number">300010</span>],q[<span class="number">300010</span>];</span><br><span class="line"><span class="type">int</span> l,n,r,ans=<span class="number">-1</span>&lt;&lt;<span class="number">30</span>;</span><br><span class="line"><span class="type">int</span> head=<span class="number">1</span>,tail=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">findmax</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=n;i++)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(head&lt;=tail&amp;&amp;dp[q[tail]]&lt;dp[i-l]) tail--;<span class="comment">//单调队列 </span></span><br><span class="line"><span class="keyword">while</span>(head&lt;=tail&amp;&amp;q[head]&lt;i-r) head++;<span class="comment">//滑动区间 </span></span><br><span class="line">q[++tail]=i-l;</span><br><span class="line">dp[i]=dp[q[head]]+ice[i];<span class="comment">//转移 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i&gt;=n-r+<span class="number">1</span>) ans=<span class="built_in">max</span>(ans,dp[i]);<span class="comment">//在开始移动的时候求最大值 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;l&gt;&gt;r;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;ice[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0xcf</span>,<span class="built_in">sizeof</span>(dp));dp[<span class="number">0</span>]=<span class="number">0</span>;<span class="comment">//注意,ice的值可能为负,所以要把dp跟ans的值赋为无穷小,一开始在这里卡了好久... </span></span><br><span class="line"><span class="built_in">findmax</span>();</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>​            </p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P6524 「Wdoi-1」托卡马克</title>
      <link href="/2020/06/20/p6524/"/>
      <url>/2020/06/20/p6524/</url>
      
        <content type="html"><![CDATA[<h1 id="P6524-「Wdoi-1」托卡马克-题解"><a href="#P6524-「Wdoi-1」托卡马克-题解" class="headerlink" title="P6524 「Wdoi-1」托卡马克 题解"></a>P6524 「Wdoi-1」托卡马克 题解</h1><p>大致思路和上面那位dalao的差不多,有个错误也是看了上面那位dalao的题解才发现的qwq</p><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a><strong>大致题意</strong></h2><p>在<strong>n</strong>个点中选<strong>m</strong>个点进行<strong>两两相连</strong>,两个点相连所产生的费用为两点距离之差的绝对值<br>求<strong>严格第k大费用值(即不存在并列情况的第 k 大方案）</strong></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先来看一下这个数据范围,<strong>k&lt;=2</strong></p><p>也就是说只有<strong>第一大</strong>和<strong>第二大</strong>两种可能</p><p>先来看一下k=1的时候的情况:</p><h1 id="k-1"><a href="#k-1" class="headerlink" title="k=1"></a>k=1</h1><p>我们假设a1~a8是递增的,且n=8,m=6,k=1</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/8kfaz7oq.png" alt=""></p><p>先假设我们选取了$a<em>1$,$a_2$,$a</em>{3}$,$a<em>{6}$,$a</em>{7}$,$a_{8}$这几个数</p><p>总费用值=$\sum\limits_{i=1,j=i+1}^{n-1,n}a_j-a_i$ </p><p>通过观察可以发现有些值是可以进行拼接的</p><p>如$a_1$~$a_8$=$a_1$~$a_3$+$a_3$~$a_8$=$a_1$~$a_6$+$a_6$~$a_8$=…</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/d2lcgwxn.png" alt=""></p><p>我们可以把这个拼接看成是在这一段的<strong>哪个位置断开</strong></p><p>这样一轮下来就相当于把开头为1和结尾为8的所有段数全部加完了 这样我们就不用再考虑1和8了<br>可以将图简化成下面这个样子</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/7xhv1f3q.png" alt=""></p><p>(如图)</p><p>同样<br>$a_2$~$a_7$这段也一样,以此类推,直到缩小到不能再缩的时候停下就可以了</p><p>(大致过程)<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/chk50fh5.png" alt=""></p><p>根据断点数量的规律</p><p>不难推出费用值=$\sum\limits<em>{i=1}^\frac{m}{2}(m-2(i-1)-1)*(a</em>{n-i+1}*a_i)$</p><p>把$(m-2(i-1)-1)<em>(a_{n-i+1}</em>a_i)$看成一个<strong>组</strong></p><p>根据贪心原则</p><p>当k=1时</p><p>每次只需要分别取原数列排序后<strong>最大和最小的两个值形成的组</strong>,即可</p><p>如图(n=8,m=6)</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ycwc66og.png" alt=""></p><p>这样k=1的情况就做完了</p><p>下面来看k=2的情况</p><h1 id="k-2"><a href="#k-2" class="headerlink" title="k=2"></a>k=2</h1><p>也就是次大的费用值</p><p>根据前面那个式子</p><p>很明显可以看出,如果要得到次小费用值,就要取改变最靠近中间的那个点</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/i0frh7yc.png" alt=""><br>(左右两种方向)</p><p>但从图中的数据明显可以看出,当中间的所有值和最靠近中间的那个值相等时,是无法改变总数值的</p><p>因此在最靠中间的那个值无法对总数值进行改变时</p><p>就只能去考虑改变第二靠近中间的值了,以此类推</p><p>如果不管怎么移动都无法改变总数值</p><p>即各项均相等或n==m时</p><p>输出-1</p><p>贴上丑陋不堪的代码和大致流程图<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/7h357q80.png" alt=""></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n,m,k,a[<span class="number">300010</span>],ans,ansL,ansR;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>); </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m/<span class="number">2</span>;i++)&#123;</span><br><span class="line">ans+=(m<span class="number">-2</span>(i<span class="number">-1</span>)<span class="number">-1</span>)*(a[n-i+<span class="number">1</span>]-a[i]);<span class="comment">//求第1大和</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(k==<span class="number">1</span>) cout&lt;&lt;ans;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n==m||a[<span class="number">1</span>]==a[n])&#123;</span><br><span class="line">cout&lt;&lt;<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=m/<span class="number">2</span>+<span class="number">1</span>;i&lt;=n-m/<span class="number">2</span>;i++)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a[i]!=a[m/<span class="number">2</span>])&#123;</span><br><span class="line">ansL=a[i]-a[m/<span class="number">2</span>];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i==n-m/<span class="number">2</span>)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=m/<span class="number">2</span><span class="number">-1</span>;j&gt;=<span class="number">1</span>;j--) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (a[j]!=a[m/<span class="number">2</span>])&#123;</span><br><span class="line">                    ansL=(m<span class="number">-2</span>*j+<span class="number">1</span>)*(a[m/<span class="number">2</span>]-a[j]);<span class="comment">//算差值</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n-m/<span class="number">2</span>;i&gt;=m/<span class="number">2</span>+<span class="number">1</span>;i--)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a[i]!=a[n-m/<span class="number">2</span>+<span class="number">1</span>])&#123;</span><br><span class="line">ansR=a[n-m/<span class="number">2</span>+<span class="number">1</span>]-a[i];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i==m/<span class="number">2</span>+<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=m/<span class="number">2</span>+<span class="number">2</span>;j&lt;=n;j++)&#123;</span><br><span class="line"><span class="keyword">if</span> (a[j]!=a[n-m/<span class="number">2</span>+<span class="number">1</span>])&#123;</span><br><span class="line"></span><br><span class="line">                    ansR=(<span class="number">2</span>*(j-n)+m<span class="number">-1</span>)*(a[j]-a[n-m/<span class="number">2</span>+<span class="number">1</span>]);<span class="comment">//化简了一下 </span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="built_in">max</span>(ans-ansL,ans-ansR);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P4910 帕秋莉的手环</title>
      <link href="/2020/06/11/p4910/"/>
      <url>/2020/06/11/p4910/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="d3ad362b6bcf1a34a30db5399c1ad1ba69578dc4487ee722f07bd824c574d79c">4630436162ade97ba2718b7d0c4b3b6351ade09e539dfebeb5402828e29e64b0e35b2270b7c9522b7d2ba447f92dd73275edc844eead7eb2fe320821d818921744a104a4173fd9bdb6fd42295b62a016bdc513417d2e3d09c7bd5c8c222b44e2e5db7852fe43c0c61eb0d15f1c51075c16455be7d2dfd06ce6d38b46e7de9e5cb820be760433fdfb681aed60e471cf4e09e40054ceb96ad347e287b444ebe718adf70ea79b0ae4028544947a0133e1213a54cab7c5cb94dd1f79c19de5ebd332c9cb1292b4bf0356cc12e68e24718a47c450ef0561e64433d46ce8561859740fabce3e39ab88efb216b2580a2925b21e163c216c7d5b4b8debed660dcd4bf85f921ff470cef42bf24aa51bfa4dc4845694bd1daad5a97aec0ccf6ad093e0588b5a2699e22ee7cbdf43431c36fe8d8f4e87fb80471a4e412a9e09213edead1efe3aa32d1d3ebba98422fb0bdc36220c08dc21acf2a365e6b37af194c9fdcc9b15559d40a3c0082745858fa92fa2417451516d0f279ef47d86b890af30a072f62d3dcf8bdf2dc3ebca4ffb59abb1eeaf2d02cae775c4e7294b47c7dba5fc84918f8b684f815b5bb8a13dfe8d4945e7212e7d7a510949806734b2bed1338bb2c8bfa38e5b3046ccaae1cc8515b0bddec3dc2c29d08efe06abcb3722fa01713215904954c0848a9203ea1a32698988cabb7544c0c3dabd030d9ca455ea401948c3f94a2492f20ab2dff28c720c80559eb1d1e26ac493d0c14b80fc4b2cba8cc027ef9f678c46d0a93ad5336c28950c61eb204d9dd041cf796a780250c013f7912455379b744a3237531825481b5b9798676bb7af6f4797be100c7d22b651e4d10df24eb5665bfec539b350995e1a9ba6a7cf76a20713d6f1b4dc9331cb000c56e2ee108c38542f42a4370deeef3dff132872eb11860802107531fde3d332f5cc8f395d117504676c5d5d77c6dbc3ff2a8d05afdb9909c85a98efddc40f669c64b6e40804714916fb9ae5cf3216b1ea1b556b8991d42a5fb9ceaca5c35a32b0f1b9cdd32e9330c8a74bcb36779c23506bdfe025e254a94a8e448c5bd8fc47ee0c270f0e3b849a1c5e15e405fb9b4cbd720f439aa09d06f7e8c2b10a27eb69e5ef6093dc0e41422cb053dd0051fc22836b48195db9196bb1153329113b14ecff217813103d42b1811efb85b2207a155f15d5ec5395447247339f655aeff92eb99d68f8b9a5e3cb9ae18c2561bb244453512d2fdc302ca4998a39c7692323e99bd780b22b21e9bb116a6b714c971b5b950519223e69c7e405eb915baa5690ad4968064bb7d968924a680b4e60de627108d6ab5b3198f947c5250e8c805e38aa6d5c153f3bada99b4e555b3de86e8a3c124e399e8dde8dab416bbdcb2bb60c815aff5df8fd86a5a344eb43ed165da7f89091661a9a7769241bc10b2289ef4669bf6908d6398c968b04a684675e665590ca199917f56f27769581b008ce23eef48f36a3f15b684193e96c7f37679bc76c05509046515cabb93c49be55a0a613524d481e3673f9e531f55987b8bb492d2e5bd95bc82de8bea75a20206d69ffd2a13a4ecd596a47204c5fa47526eec5ac7bea393378571b78cbbaa4cb26ef45c0fcaf1aa287a6cdf19c0f66ad4fe97cfd228ebbae01f29e6ecbd2e5384d7a5844e0cd1f046b4d09b930d0af69c61c77004ccab405cd4474de7fcec492c0088016030bed77c2a02c102e0917039bf4c06a6e2594fe2bcc471d5356686dc6f89b73415b9fabfdf94fb9d91b0e3b01af68aa17df66d5d3e68b6444866ac56dc0f6aded25a440301d945086d5cbf489fa50f80bf432c0df165b8ac6a05ae957debf8764a51bc57694f26101f86ef4cac04dcd7e75f7a5532397fa691dfb979f06b5ae06b1331a63863b425105883a429863c59ca1cd73d79d7b5d3bc2f4dfd25bbe5fce67b54e7a41795f7020f32c0facff6ba653065a9765e33d86d7965edfe005d2fc2b1dc34a1dcbcce3067d156f11749351256ada298145f6f92467ab77f2bc5b54f2b5ddcf3edbe21eb9599a9fe405a504fcf9d94ed52e0549588ecd9d63d178524fac4e7d41ae9df6f11c12876f8d6850fe4e28b0e968f72c50189eb3005ee4f808cbcec3faa331866d7f95e652c3296c0919f020bfcabeaacba1c43d262d61f40ceeda519702e73e5cb03c5f51ec15cd4490ba4d7595292f73743fc01addb901fa7e3e1d79b2e12e7e3b02fcfab3e124abf991ff4b06dacfc65a9fa00bf9cf203a1cace347aee2ece7364d7c9c82cd604169693164041f9fc5d024bab06a971d6a57d64ee96c657e61d403a2cf3d73754213c4c41562b1b738533f6639b07e04eaef918a81303e4f97fbc4e2341bd7ad335a88e2c09240b8f1e69c46e15f3bbccf7a0bb6b958fe9b2c7adb9f42ea78826f4a971c8d7db57e3423dd9f74108be967e97f8e2034ae8dec85d09f4ad1fe478327e677ca7db22f35a2222ce123f598d90d4bfb044195a14f13a6ea88699b810708f8c797a3328daa91dbe87b12cdc444b41c8d25c1a4a555eafaa86c36231c9db9819e5b5ed70ad2c0b400b51d6fc00477dee4f2831fedc8f6a1637681767fe8e5508f086a673e8a6ec7534d17e6ec12a652303de1bd7dd139d49e5e0861bad17aa75628729bb7c756e47d602f4120cbfdd66ef5224d5b90409ec2f0c53661e4841bf5337d415447e2b834222c266464028b7bcc4d1d4eb324e6bcdd781e9a0bce71eb51ec3d978c53739752c061b69a524f5d65dde8c2434903865e376d193544932abe628d348d55ec657550045f27acf8b7104a73959380569f8846ed5aab3dec0e1ddcb1f20deb7c9c90f29926ff78fa7cb96eb8745745a7b679f6bfd90f99a6c4de0b456c2e2fe9d43633c0660d2a364c13851de4c56bbe4557b941e992a0b259e0bb9eae9080d2eaa31e1578762391c2ca0a839f919e88084f6359a14dbcf7f35d1182a87fd420d5ec4ceaef97cf5d84abb8f32b8fc2588c9108a76b07b3fce34b1e2c7ec3b35faf433859c7f5a14162a50af79f042b1beb938c8af7807d3c324a3390da04601161f39f9dcbf6927f12dec1b6692f17a5bb212f2e5a6a076f99cead9c7655b510c82ecd6ec20794ddcbf52185f5a3b99f502d5749aa47bf8eaa5ea19262b54c6ccaee01b224c3ce8266f3d2849e57901272c93dce87ed8c4f56ddab9888a74735133b7884604bc5114d2e911a6712df35b33dcd39ff53947a2f61923ec22ce3c124e1b7e0dd04d35e48a837de90e36fb9a236a27c7302ce9f6fd5bebeb01588d29c7810b502404a86625b7b5a4b9aa420a0ac5aec1b7e89934e7c5e1ca31f7c07fdeaa7cef977ea5ab9fd0c243232835a167bdc73763d172193ad9e8231e56272e78aac5c99d39751491f5a475e62a3fd8db185ea1504eebf22583639bf0f6885181e6d84e3cc1fb06d4b0b04082ed64733ec3effe3d1050aa10e2beadecc97e63e3ce0b75998f5994610f311af13dbe4c36312b3377fc17752dd10f7093d37446700a2e5b5f76cdf4e2ef0eabdec303de79fcc1a565375a47ecd2385b631efafcf9db2b183ac5db8612ddcbf3e361bd9210ff6760f3c0604e340e2fe7c11be5e27b31e3fe83ea3a06c22f4e16f40370d752ac944e63e069f02b4668c97c6b19dd4aa276adabeaf33290c76107eb4205cb4494501287e2057c948c2aaecb20d51b7430565db4ea8c3c34acd00e3ef5b92841909a9b1bbd27fb7c61dea7401945db19ea038b7f2b78a9f27be4bfacbd665022bee83e0f659abc2d982213588f4d708248bf09b9b2984c5617a518c6f87de270595e3061769e84d56b786092649d983718c50d3bedeca4511ea88a983715cf49a03bfa7b6de2f1dbbc97e66fabc24ca8944e09164051fe23021a0771b94183784d233cabe6c7b1545221ea180c897f1ee2d53e328e2f8092e2402f1dfb15bdd5c4cebbeb42afdaf1b1cb83b68d751ed34a733f3daa40d88e81e44a73d95dbb2d2b95a462ddfa6c072c6f24191d974fe5cc95c4e2cbed849788178b062605887d0683698e36c1b091322e2fc722b12872c08423f9519443628994ff0c3dfad70b7ab13c6f64ce4b5cdd9ddab777dd432fee93093d4dffd9542b87e27c3d3da5eaa388276a6d7411d82d7c15fa8f0abf7ad6be6b6e052d27dddca884fabb3f5c189bd95c9f23b2186a288445cfe1eda88b79b5c632e3d0dfd6bf448731ba9b56169883c7bee045a360c50ac85df1599bf24f0a6ffda22c8a9aa76043dd54852233190a9770e1d9322c1bfe868305c729979c679c9c3e24ff4dbdd762345ff5c0129de7e46e216659034f01dbc253a3152322e5d4222e975155115dded90e88c4aa8bef84a6e8be4945dc64f062191dcd1c51b4c0ce56d55c75faf4ea7b6274357b8452210c76e24eef1dd02798a34425cfe1f8d7226ab0fe329013234ec7ea0ab0dc631f6b1741dadbbf4fe9a54883ede18b37f8749bb822664dac3785ec9fd439078856d1252a880b7660c3bc5b427fcaa81b897cc186f79421c1d1207ff43843536a2beb110aec5371f5a137af5683a3d7871f4677539e9909759d0898e94f4c70a0ded1f0712293de05530a75ad990a95a22e16a026eb9fb4e6d778f78280bb051ab567659473a415a852ad17f61e1b743d79d0cfc62d916476460c87b6243ac1a93b94e1e288daa7cd98e549804cc21b149b54ba0448592c2c414497baf35a4896843a08e45848a294aa3e893f1236e505a435f5bcbb789af5f3308bd12afbffa1dcf622125013eb9eabe0194c83ed8b06be206b4c9de8468b968be7be5d6e2c35c1092efb4c57253699d852f86011eadb2153c6ba836894c4995c4b73fa9d66fc951f83c6db4d176f3f6e707b57089b999732ba14be4738f8a429fe4f7f60f542c6b26f6897fea80a08a1244081533404a81d0299e5317ec2ab2067d8c53f110b9784c487e22ff6c1d5233b152342f6e679663b7b2c120301432f8c24771e0fdfd6b252d90cde7245fd48f16b954bc967f87da9fbc76c2992ee40dc3aa0d4345c72ac383b14b400d3473a045ebd7081e4b91aa630f0070115e996d295c05382508bbd8a9a0f85f34aab09e7819b82bb510c66a9e6e754d2c962b2c0731d09bfed16590b54bc73ad33233f9ae6881439417cbff6a1afada0992b077ff4e43cea182a91dde38650551a62f26fd156f5069883464e0ccc5e3f4ced94f13e699e89c285a759b1ac874b7a8bbb402068b902b24c39fcac00505701e6a8ee18324d73612aefdf696b254e671a14e480cf7dfb480af7cd8af700b48d79591ce2acb679bd340f5d3a850d185295ae54c787f4394679f9a1c9d6049d32c856300257ea814a7eccfe63fe64644e650c95f16552edf470fc70b574f66c4458c1d6ea016e81b4e4e27a7f82b09836f2996f314871abc35e86f1d1670574151bf5cb61f50e19dc9a6964d5d98567a05e74ddd05b68c280199621ab7aa329aea4f80abaa4f47847b1b71704b59205d2897c5f80d071f001806f6ae43e30cc42f7a73e460a106dd556a4cb2f527080da54e639038f3fa01d161b300d4af375713f7da7cd91f4f8833a937313f1c9b55ed0b352b28dea025c27e9cd33b4ebf165b30776ed4824844a148e039c4dd96b955ae4b6c03b89aeed586ce15044f292514e84539572c0aac6f80f073b07bc021c75026b1fb5cc3511ba0eeb6ac44380e7ec2ba2dcc26c5e02a1060e6b04b8c79a2835374abe29f5c26f9b1888a26cd6a42ae4dfea339c6028f4cfcf4289a11344280c29a394af1f8e7e1129c5d7c3da89c0d137eacb901852885f67cbb625d9f23124799afec1198947773996b128b539f3a8c1a750b62e571a0e91771fcf4e2f0610c50e14b81db0d5f17c7c27e1fdb5774781859e6b69ea2750a82a39fbf4d8d726db2551fa94bd43a562672c4ef3ef2fe7a65403f483a9ee8bf7d0c66f20bcf0134f1a938917383347391798e2b45199904444595e1ae9a6ffc64212041647743dedc6b6da2fe4118c0b62e5d2b300a3dfa5a88cbd99034c7055d0bec170f2662cd14d02d9dd42e47c6cd1fd0a3c8edad4da09943880b560b0d37a47bc0a182f8c6f0180d3b1d82fdf0624cf0e035a4d56c63da42d5dd06546551a50e187ddf5dbae77645c432346d84dc243cc0894ac6c78ee845aa3d60d0fd913f8540afe929cf9b092e1123ba0211ec1f8b5fc2e78f3fbd7fa578906ab6025e2edaacd15436f1be7e287a3f96a4cc3909d273f267c92238a398aede2183351c6bdb0a2d76cd4ad1f51e8c972278b2f775e60fd21028a9a5014af5917029b008662f28ec1bc48e5ab139d12e82e8dd6a847e183cfec6234420eedec7a1f296dfe83bc0de4cda3837513d6c529b6111f658a3e9f09c24804495a3302a9623b41f8811851710f609d0d9987a30ee2be0caac9355db3cea21a4cf235db0d51f07f0ab06a97c43acdd838ce0f0d87e13c3f11523431942026c1a8c708f92427a2fb8e8b126c1d7a14c2510ec8a7a057407d5cfbe9cd6fda5cd0a4e5307eb2a4d7f5ddb959df2ae3a2a21421b0988e17a7385c4ac7109b748e68e80c534dbf97c1db7acfff46b903ba1800b0ba21dc6f61cb16a54b6815cbbfb501b7f955790cbc4fc6e90291c4c5b94df05e187f497d6d4cd5102af18e28b5557e1f726b4d71376050b5737806f85bf360039ef05fd5a86440264ea548b06c809e23d975f166e85a3e829b5e7fa95dcbdac19fddfb68ad25f2d0123572006d4858b371fbf884732065fa031e2647eaee035b65ce81232d31d03765d177d5aad5828fbf9d3ac21d5c1c7c9df9354201290059d30cda34f06eec23cd515fdfbd4903f0780d237454424c26a8f22d52a098f8967fcbd32244839c23f3eb23a1369399b3bd2065667d9e70c0f8cc52425d28e054a9ed50bdcd4dd809e80ab3a62999ee4f9bc15d115536163986d7a2ee2d60425fb44c50f20c05d2113ab3b0c67b185408ee00a362118fe90a7e88363a258fc4adf2908c229f67acc9162cfbba9a0c0b6b916b29d1947bde6cec2f92fdb7d3414e4879f999a6ff13a6fda9ea4f77548098f8e314ef6b6fa067d856dabe78c41d26baab74571afce1b79d016bac9550c294de86466a33a63f05fe5508c7d4cee82670cafe062c2da734461ab64be4667e345c903fd9f83fe1c8fa616093e664846734d44e22e52379be75eb8583a922b461df338b7ef9c2a3b60adbab142c8f0489033a3aa9d8b1c00bf89225a0c3e77c90bfcb0a4cfb6d153ba904efa5670163aee22955e32f64634932c1af0789edcd412611bc20d77e596c6ceb077a54fb449f96feb5f0bae92841ee0c75508d8b717ba191bca3189657adc6930590293dd1a44be32c0cbd80a86791362d6875c78bde92774ea672efa750e139dd7d6ebf657082f4c52a206d17021dc8853e6a7efa4a3446bd02849addd50291ec11da20db84863e19b1baf46e21f3801f0e13d1a316e6a123074864637f90dd026dc49cffca92753edf349a5614c143244b2ccdd1a5e18acb612dfb0440c6f62f8da67c883d29f7ec32e9df7a8bdd150403de01d5388a588ea6699acc7e55a03469113ca3175e6d4c4b1242e47e9a173ee6246f85affccb6f87ccb42a9eba152ae23791521068b58719ceafa55506d73df64dcbc33898bedd5a661d670873a50fc745da339ff0b5c00f226eb5dcaedba4de48de8ca87b6fad4d49e2fdbae533598c99f46792a7837e50b057097f751e676c503ee83cff38dfca38a095a0e58f1cd34369aff2a3f411c47b85bbf6dd4778c95681aeb8861af30a2ca05c93bb6425a74df7146505e92768caee400ba8ef11284fe558c744eaf75a162f5ba7e8381b294254aab86a601dd16a6e1784a675f595749342c3c6a065fed3db07ea2cc90eacd1a7a6d9adf6452a02341aafd55724870eaa1f2fcba9c9421226a29022a757c1c4178ebd5173375e84a08530eeaef6ee65443f909a84d17085471dc503690800da6142175a2d641eeb95f1bd929edf4e71671084ce4e4568ce89373660a9734ffbd4f6e00b74272be6d1297f844b565f60a08b20ca1bdf651521d94b06a4322ddd91bb84d5c5e09a1f04c882cdb8816088dc46e925aae60a56d23b280586167bd6beae5eea3667693381b82571aae64e45dff2f7828a6535129aa67a607231b7c234ee20b9eaa83ce12d48094384bd810fe32eb2da517f33318ae2b879e7080f383fc4383b7f708741ddf1ab0ff1c37a932252b0d61cdfa9a6aaca1c9a5bec6265aa77e14a34673977ecd85ff257f96ed1f0612798cafccf9016f35bfc8d272f722c3435103a5b654584e81a8505cbf464449bc62f23d4be4dd8f50252f0aea1dc1a2d74952258c22491782c2ae853545d9e085fbe977c5b2db79fe54fc53949d36ef194b35785b8727f4fd212e8ba4c6818cb5907291de3943f7c45d515846f692ff11272891415691c0dc1c09bb00daa12ad18ec78dfc8cf26d1ad856cc987211fb0106976b9902eddfc68a114b10416af86697d1c5cfc6e614dbdac79f2291a1690c2f25729b6c1ddf154059e1bdb18912d5f72760d4c67ed8c209aa5e87d77afddd25701a75a0fbe8365202e167fe5d97d75ea1947b294c3431e57319a2fa20bf59435d2f6ea268ca7442c84acff0b98bacbfc91f8a05cb124d5aff5778000d3039112a2eb676d4652d31c12a57a72c293273a4884a39500403cd91ddcf29aab36b3d005ad472a0f2750c67237637a2c1f306972ef10d4aec76382c8b5f1c76c5f226eecac62bb32e02fcab002c7b287c7677e961fe473f4c57c4d1ae727a4e21d69d363f5d921755a3158ed136879f43d2b196d8fd1f37b32e4678fee6ba006246a6bb2a6053c102d555fb15f5d5a0d4c81d7df81600992c4de3c7ecc2d60c8e45d9652143408103ad9b0f24d51af33a8ae3b6ac042159f594ae5c0ef753b893c47c9e437022ce1908e135b6f9672ed54f9d2f89f9ce509d76624aaa5033550f42fa6508e36035e18f2057b5117dd8ed68f09915d1e99834bfa3a0ec942a99d66aa63ed463d5faff56818196f2aa15f5b909433fdd19628d342eb03c9ae6d225d1118947c62f06eff35300ebce85c98fbf13303fc5ebd4f10e6784922fb9a1edfa05ee20c0f3939a10837b38d9fbd9b7ee9afb393c9f41fc907def68ede1524282b8c672f9743d8d6bd547e831cc0c6358735c5f07cba43593df5e478fa29eb0b048ad9342295a1a50d56ccdd50f01c488c3b68ad9f48c3d1618601cd60967b65fa571974439639562124a6318b1e2e77209d09ba053dbd7601894e1c17dfa9ccc4ea4f5e508d9a2775bb742711339b061d9e7e7a1bdfd3a4f3d552151078bb51b3464df45cdb3ba80352be519f6e6b0458634bbab902ce6c04ff91999f73b503f323f941a26bbeff718c659a6c926d8dd2496bd416042e3c849b23da20525350eb62dc92d8ba51682e724bca9df7b87c099c933846c1f409d287d8aa26a5a22d01748284e416d66d24c8fee9cb472c0cb0e1cd006cb0435a23c703d302cca6c1fcc2d8cc406dc2ede435c572fdfba8b9b982a045fb67000d6db609fd5ffbfa590070f3d7d811ec11eeda1524390b072dfcad63cac755e860dd6b16079025330ce0b05c2c30fd03d35247ef9c8dfad4765197be1677e8042b53c282831b096bdb0e9349f6b744bf1b9d23bde8c08600da6148ade7d449c88bd31de9815f7d054bcca7a7985d2b55f8a81b80644ae0d1833575ae7e9db51e34adebaf677e390ae51168a2e9202a2399b6c017498dfff65aaa27f9d47e65cb58637f54d699371e688167b4d33d5355fd4eee5d55d380a88e495182f81b54f4d75379183c35aef60bedca70d1d10fa61bd2cc7f14a47d5ae975670faa6355c879ff4876e6bc31da819bd82997a3f41218ce60b3e4d3357e5f736c783d544bd87c058b456a2d713fa6534b3d75d584d1ec72ca99b07962318e73b36efc18092aa6e2de89b97507ccd1587bceb2fb138a3d62d42ea32baf2aa1acb8681e2d30ee3ab56b61536b689aa294897d6a4743a8201edef66215c03244e3eac9b053f9102d54587d211134b1d332c03b1a107af2ed26257626d9495c1b247cb24353f61ddbe332346890470ac29b8e0f434789db478c4c0f475622566c037a8d4389e943fde0d2d82de8ad64a5ce6f6e0f875ee9423334cad36a471aaa2ab163fa19613b5861992f7a0747364961649ad66c04946f4f77e9799895805053990d8269fc91c8a761cee172c7ad597eb8c8d8457b9c39b0ddcd9bce54c83c5fe41978898877aa0ab4d60ebf4d6660594dfe0d0438eb6bd80261c740c0855f18e9b802384b87fe6096b1561073641af9c824849198705b504dabc7f170fb46d85b546e031873e0de994037e9770f4e5e47c68a6f6bc29f8c44fdc2cbef76cfe502833ac7e0f85f8bd13295eee29d6649bc783f35c18bd71dd3084eaea1d651c214cfb6697c942b4d5f7dc40e2f3d995ebef5a61a1b696d9497424d9a08b01080c33d1ccf482aecd7c9414f1ba8388b8e9224229cb9ab2520348155b12e1afc05e414316e336e9caef285a08f7ac6811c119782124b0846c511bd7ab564ad0944e70d0e86e42e0a7077bf8728b87221a3f7f32c8055e4248f9e2992ef39e6254f4d8f180073132f6bdc5779ef0c8675a638f44e023c5cb40f3bf54470682d6d5557bc947f452c3833648a595fd183ad627e5fbfcdd8e9d4c21985e1d4b8e51845d0ec4fc8a6ead70c5aa85f9c15fa7bf9166c62852c4cef9fa7c948a90b3a3e87bff58bfac26fa86b3378b8fe41c74aff452ce483cdeccf5704e2dbdfdcf0120ce8024fb952a82227bff2f0461f0635371716cf3b6d18f5e275c7f0145c1bc2863e23ffa127a99798468bd7a3b8353ff16903ff96103b462c9a0e9057b7e095294907ba6d1b3de90e218c08fdd68fe600fd67abefe19257a7809c1670aaaa3e23338f375b558af891e5772fe5c4905147c69af042af11de1a5287b5ff92dab8d696367c84b00d4bb81eff3ea3ab607f8ef4693dadc639d658e5f9882101325a20d9bb481d9d476f5fb2e945082d78ccecbf37407bbdc43828cb7cd20c61989c256da118af9f7e0abc16d2b74d1bbfec992c9d058458c922b1395844dfcb2f2b353f60a1de68c392bef106b886c504ee706533cc5dcc154167cee7c3467bb9f1534afad0c870589d445259e5a6acb3abaa146ab2bb275c4a91e7e953ddc6bec9ab33f473196a0627684b6123fa1f19783dc1c5235d65d8f432df008659dd18e4869e12095cdee2c90f5a1ffdf4efd2426b036b7fc3501a9a36a1f5e6fbde25f208feb10e498821cb72d954b9370f861d58714ef40f0361ee0b55bc7f667fd5da1be525ab73f80d8512dcd2889a80ae0840bdc6c77d1d5b0696f4c56a56bca71078aafa6463eb7ad075e4943c75e8756e78e7caf14ddbfe67832fc69505a887bf673a9f9058d87c1db7afd740af2a22f5e9e35796af9a163b9cbd2ca8d68fbc78e31c90f08127eae04a2b75a8f024196f44062684d389ecdf8e4c427f58cd5178fbf394740d4f4718b784e835597b3572b8d38de66d098ea05e6c60c8ce96d95fdd92ab5f953bd43dba239bf62056f724807bcfecb1e8e2801debf94cb76454f7a680f666101d5cd68082427fd264348576f5b50bce71164065361cc31ac73b07643491e2b662521ef14d499bd783772a4b153d5e5d9871e531f238d66b8dfe56d710a372510576a39829fe4c8f3adc4d643b33152416471382fe5c33542da8aba7643a8dbdaf5f765c67cb828907c9ccdb3a1ede200bd4f53070a3fd93c765333dc5a8654bfae80f585a41d58d803755a9a2768db5cfe510663da60150b65b52715613589956d3a6e217036b91ca392aa1c3f32549e76c20204d0e45dfb2a5c9d8d26fbebf46d6c8e71619a22a226339c16392cb483014d96ae795b720187398b3c5c72bc789a9730efe8508b9003de258d46af6b3371b7ee58c0fdb3e6364c805bab98687a90d74c06fee777e515b00905852d25cea593879204b07b91ee0d937c780c7a4bda24d492458e95083501366e2bf8e119cc7b041c27dc7a9c9b7d7e26fa099e1fcd0eaca00a615f52add00cc5fd7b1cfb0d13c2c5eb45cb08303984980b1684591ada43ad883753c0bbed22bddc1dac2cd7aff2cf4535517812b02a0d0b71e92a88a0097af21e0dd53d443d7574ab9a63536aa07638e7e2955a14295d723eddc06d74d72b5622df6fe3d253befb46f1ce315f9f6f3800871a04578af5c9fa414cd61e96be05a5d52d5f130460c3dbe0fe1768e72e825b1462b2b0ddb00f62d0314b9eec002e6c78f34f10ee1bef719c9c2e120ed4d11c481fc070551835481a105d1e52c4ccf819c8dd989d1677e82ae3e692b407ca89ceeba51fe273b74208c399d4ee79f6ddb29a18a4bddb8055b523d4055e51ae6928c9772c30099128c9318ba481c37af46aabad9d7f974000f08d67097625848e18bd707e352a257fe82063068c9b1a25e62f0cc1d820902cfabe57d9f3a1037770b57518a86558d9bde4756448ba0db2576a07046947b2b1a21ca9e5cab4b916348ede80778ff9148b0c460c1d89610ec68e97abbb76ba2bb2ac3a9e5977b10be1b445bee3b9647e737b2e45677f43c79abf8660fd48da1934cd6d72cad69cda412893e730656ebc8826f287ee14bd20ff48a94b8fe52274d0516d5de055ae575a0c89285e8e912bfc00f8c39a086ae6fc6fbd4679ae1c8d0b5504c552e6cb6b198635dcd4e9ed529256012a916b24bfdff5b5e8a033f2f9b7e34198b215574ef73eaefc625e79896d1fd6ae397638e861ec1c0a8d1389f4f5a27be009f9fb587b51af110f387fe4a57dd48eb8e3f827c98af829ea4f190ec0647ce6206278c976a6bef60618ede3f16843c9b4fa2200974ecce349c44ccb8d55e812064b25e0a30a40ae4c663cb0e37f296c70ee7f47ac82795dc93fb660907109948d81c28b9f963045b2b9c6a6ab786a20e5c7bc89a729ee9dcdd46297080e511a760b07d4143993fccea23e624f958eab2cb1b68f2b7da4e75ef285cc7f447de4a7e5356d47c21da8a46256bb97ffd34c2ea272fac7db7ec5eb1df266e739665e119a28b17b14c28413ef8df21be93050ec455c866700526985fb3765cd69fa8d4205ceb7450485e7558adc257f4ed2bb8d035320755914b8d413348077b3b21b15e1657c88a80ea63a2e7f32908ec558bfb4</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 题解 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
