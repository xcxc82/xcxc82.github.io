<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>基础乐理知识笔记</title>
      <link href="/2022/07/31/%E5%9F%BA%E7%A1%80%E4%B9%90%E7%90%86%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/07/31/%E5%9F%BA%E7%A1%80%E4%B9%90%E7%90%86%E7%9F%A5%E8%AF%86%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>对应b站教程:<a href="https://www.bilibili.com/video/BV14p4y1e7TV?p=1&amp;vd_source=51e3f6ab44e8fbb799044e19b28f9f8b">https://www.bilibili.com/video/BV14p4y1e7TV?p=1&amp;vd_source=51e3f6ab44e8fbb799044e19b28f9f8b</a></p><h2 id="唱名”与记住“唱名”的方法"><a href="#唱名”与记住“唱名”的方法" class="headerlink" title="唱名”与记住“唱名”的方法"></a>唱名”与记住“唱名”的方法</h2><ul><li>唱名: 在演唱旋律时为方便唱谱而采用的名称,如用”1234567”代表”do re mi fa sol la si”</li></ul><h2 id="简谱的构造-调号、拍号、情绪与速度的意义"><a href="#简谱的构造-调号、拍号、情绪与速度的意义" class="headerlink" title="简谱的构造(调号、拍号、情绪与速度的意义)"></a>简谱的构造(调号、拍号、情绪与速度的意义)</h2><ul><li>调号: 确定唱名和音名间的关系(音调的高低位置)</li><li>拍号:决定音乐的律动</li><li>情绪与速度:怎么唱,唱的速度(情绪一定程度上也代表速度)</li></ul><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/al5g31so.png"></p><center>简谱中起决定作用的部分</center><h2 id="音名-钢琴键盘-初步理解-1-x3D-C"><a href="#音名-钢琴键盘-初步理解-1-x3D-C" class="headerlink" title="音名,钢琴键盘  初步理解 1&#x3D;C"></a>音名,钢琴键盘  初步理解 1&#x3D;C</h2><ul><li>调号形式:唱名&#x3D;音名(例: 1&#x3D;C,1&#x3D;A,1&#x3D;D等等)</li><li>音名:对固定高度的音所定的名称(CDEFGAB),音名的位置<strong>永远不变</strong>(无论什么情况,无论什么乐器)</li><li>钢琴键盘:由9个基本结构单元组组成,其中一个组里含有5个黑键和7个白键,黑白键地位等同,每组白键自左到右分别为”C D E F G A B”,第1组和第9组不完整,共88个键</li></ul><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/m9r5qpbh.png"></p> <center>钢琴的基本结构单元</center><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ns0rsdxf.png"></p><center>88键钢琴键盘</center><ul><li>“1&#x3D;C”的意义:确定唱名与音名间的对应关系,1&#x3D;C即表示唱名”do”对应音名C,”234567”依次对应”DEFGAB”,<strong>只有在1&#x3D;C时,”234567”全在白键上,其他情况不同</strong></li></ul><h2 id="升降号、黑键的音名-重升重降号、等音扩展篇"><a href="#升降号、黑键的音名-重升重降号、等音扩展篇" class="headerlink" title="升降号、黑键的音名  重升重降号、等音扩展篇"></a>升降号、黑键的音名  重升重降号、等音扩展篇</h2><ul><li>升号:♯  降号:♭</li></ul><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/cidxthit.png"></p><center>升降号的意义</center><ul><li><img src="https://cdn.luogu.com.cn/upload/image_hosting/xofu4mwv.png"></li></ul><center>重升/降号的表示</center><ul><li>黑键的音名: 升降号+白键音名</li></ul><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/3asmnsay.png"></p><center>升/降号的使用</center><ul><li><p>同一音名的不同写法称为等音,在某些特定的环境中使用等音写法可以更具连贯性,易理解</p></li><li><p>钢琴键盘自左到右,音的频率逐渐变大,音逐渐变高</p></li></ul><h2 id="纯八度是什么"><a href="#纯八度是什么" class="headerlink" title="纯八度是什么"></a>纯八度是什么</h2><ul><li><p>两个音的频率越接近简单的整数比,听上去就会越相近,和谐</p></li><li><p>相邻两组中相同音名的两个音的频率比为1:2时,称为纯八度</p></li></ul><h2 id="音的分组、中央C、标准音"><a href="#音的分组、中央C、标准音" class="headerlink" title="音的分组、中央C、标准音"></a>音的分组、中央C、标准音</h2><ul><li>赫尔姆霍茨法: 见下图</li></ul><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/5ldb0dq4.png"></p><center>赫尔姆霍茨法的命名规则</center><ul><li>科学音调记号法:见下图</li></ul><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/nlhg8ibw.png"></p><center>科学音调记号法的命名规则</center><ul><li>中央C: 指C4(c)</li><li>标准音:国际通用的标准高度音,即A4(a)</li></ul><h2 id="高音点、低音点"><a href="#高音点、低音点" class="headerlink" title="高音点、低音点"></a>高音点、低音点</h2><ul><li>区分不同组中的唱名。命名规则见下图</li></ul><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/z33lssyl.png"></p><h2 id="音域、1-x3D-C到底是哪组的C"><a href="#音域、1-x3D-C到底是哪组的C" class="headerlink" title="音域、1&#x3D;C到底是哪组的C"></a>音域、1&#x3D;C到底是哪组的C</h2><ul><li>音域: 乐器所能发出的音高的范围。钢琴的音域为A0~C8</li><li>正常人声的音域大约G3~D5,为简化乐谱,大多数简谱中的1&#x3D;C都为C4</li></ul><h2 id="半音、全音"><a href="#半音、全音" class="headerlink" title="半音、全音"></a>半音、全音</h2><ul><li>半音:指相邻的两个音之间的距离</li><li>全音:半音x2</li></ul><h2 id="乐音、噪音、乐音体系、音列"><a href="#乐音、噪音、乐音体系、音列" class="headerlink" title="乐音、噪音、乐音体系、音列"></a>乐音、噪音、乐音体系、音列</h2><ul><li>乐音:振动规则,频率稳定的音</li><li>噪音:振动不规则,频率不稳定的音(打击乐器多为噪音乐器)</li><li>乐音体系:音乐中使用到的所有乐音的总和。绝大部分情况下为88个音</li><li>音列:乐音体系中,取若干乐音,有序的排列起来,称为音列</li></ul><h2 id="音级、基本音级、变化音级"><a href="#音级、基本音级、变化音级" class="headerlink" title="音级、基本音级、变化音级"></a>音级、基本音级、变化音级</h2><ul><li>音级:乐音体系中的每一个音,都叫做音级</li><li>基本音级: 具有独立名称，不带有升降记号的音级 (CDEFGAB)</li><li>变化音级: 升降号+基本音级</li></ul><h2 id="自然半音、变化半音、自然全音、变化全音"><a href="#自然半音、变化半音、自然全音、变化全音" class="headerlink" title="自然半音、变化半音、自然全音、变化全音"></a>自然半音、变化半音、自然全音、变化全音</h2><ul><li>自然半音,自然全音: 忽略升降符号,两个音的音名字母部分相邻。如#C-D为自然半音,#E-XF为自然全音</li><li>变化半音,变化全音: 反过来,字母部分不同。如♭B-C,♭G-♭♭A</li></ul><h2 id="1234567的内在规则"><a href="#1234567的内在规则" class="headerlink" title="1234567的内在规则"></a>1234567的内在规则</h2><ul><li>见下图</li></ul><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/e16otlmq.png"></p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/l2fcqd2q.png"></p><h2 id="调式、自然大调式"><a href="#调式、自然大调式" class="headerlink" title="调式、自然大调式"></a>调式、自然大调式</h2><ul><li><p>调式:若干高低不同的乐音,围绕某一有稳定感的中心音,按一定的音程关系组织在一起,成为一个有机的体系 (<del>人话:若干个音按某种规则排列</del>)</p></li><li><p>自然大调式: 简称大调。具体规则如下图。</p></li><li><p>自然大调从X音开始,就称为X大调(如C大调,D大调)</p></li></ul><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ns0v8556.png"></p><h2 id="音阶是什么、有什么用-关于调式、音阶的一个萌新常见误区"><a href="#音阶是什么、有什么用-关于调式、音阶的一个萌新常见误区" class="headerlink" title="音阶是什么、有什么用  关于调式、音阶的一个萌新常见误区"></a>音阶是什么、有什么用  关于调式、音阶的一个萌新常见误区</h2><ul><li>音阶:将调式中的音,从以主音开始到以主音结束,由低到高(叫做上行),或者由高到低(叫做下行),以阶梯状排列起来,就叫做音阶。</li><li>特点<ul><li>主音开始,主音结束(有始有终)</li><li>音阶是有序性的(方向性)</li><li>包含该调式中的所有音(完整性)</li></ul></li><li>误区: 调式,音阶不只有一个组</li></ul><h2 id="黑键出发的自然大调、等音调、音阶的选择"><a href="#黑键出发的自然大调、等音调、音阶的选择" class="headerlink" title="黑键出发的自然大调、等音调、音阶的选择"></a>黑键出发的自然大调、等音调、音阶的选择</h2><ul><li>等音调: 发音相同表示不同的调号</li><li>音阶中的相邻的两个音的字母必须连续</li><li>方便起见,含有重升重降号的音阶基本不使用</li></ul><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ayr0qb7p.png"></p><h2 id="等音调扩展篇、何为一共十五个大调"><a href="#等音调扩展篇、何为一共十五个大调" class="headerlink" title="等音调扩展篇、何为一共十五个大调"></a>等音调扩展篇、何为一共十五个大调</h2><ul><li>见下图</li></ul><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/4d2xvy43.png"></p><h2 id="调号总结篇"><a href="#调号总结篇" class="headerlink" title="调号总结篇"></a>调号总结篇</h2><ul><li>前面所有</li></ul><h2 id="模唱、相对音高的练习方式"><a href="#模唱、相对音高的练习方式" class="headerlink" title="模唱、相对音高的练习方式"></a>模唱、相对音高的练习方式</h2><ul><li>多唱</li></ul><h2 id="为什么要有这么多调号？"><a href="#为什么要有这么多调号？" class="headerlink" title="为什么要有这么多调号？"></a>为什么要有这么多调号？</h2><ul><li>适用不同的音域</li></ul><h2 id="如何构建大调音阶"><a href="#如何构建大调音阶" class="headerlink" title="如何构建大调音阶"></a>如何构建大调音阶</h2><ul><li>略 前面写过</li></ul><h2 id="7的发音是Si还是Ti"><a href="#7的发音是Si还是Ti" class="headerlink" title="7的发音是Si还是Ti"></a>7的发音是Si还是Ti</h2><ul><li>自己决定 没必要过于区分</li></ul><h2 id="升降号写音名左边还是右边"><a href="#升降号写音名左边还是右边" class="headerlink" title="升降号写音名左边还是右边"></a>升降号写音名左边还是右边</h2><ul><li>乐谱写左边,书面上无所谓</li></ul><h2 id="调性是什么"><a href="#调性是什么" class="headerlink" title="调性是什么"></a>调性是什么</h2><ul><li>调式: 未指定主音(例自然大调,自然小调)</li><li>调性: 指定了主音的调式(如C自然大调,D自然小调)</li></ul><h2 id="XX大调的音乐中能够出现XX大调音阶中没有的音吗"><a href="#XX大调的音乐中能够出现XX大调音阶中没有的音吗" class="headerlink" title="XX大调的音乐中能够出现XX大调音阶中没有的音吗"></a>XX大调的音乐中能够出现XX大调音阶中没有的音吗</h2><ul><li>可以 偶尔出现不是原本调里的音,是为了凸显新奇感</li><li>艺术行业的理论是一种对成品的归纳和总结,只能尽可能还原真相,目的是为了帮助后来者快速入门,不能做到百分百精确</li></ul>]]></content>
      
      
      <categories>
          
          <category> 音乐 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础乐理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>绘画记录</title>
      <link href="/2022/07/31/%E7%BB%98%E7%94%BB%E8%AE%B0%E5%BD%95/"/>
      <url>/2022/07/31/%E7%BB%98%E7%94%BB%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p><del>预科作业太无聊了 来画点别的东西</del></p><p>7&#x2F;31</p><p>画了莉莉</p><p>虽然说细节还是烂的一批 但和之前的比起来稍微进步了点?</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/7o6swf7y.png"></p><p>8&#x2F;2</p><p>模仿某莉莉头子画风画的(</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/4c8cai7f.png"></p><p>8&#x2F;4</p><p>又是模仿大佬的画风画的 <del>虽然模仿的并不像</del></p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/g7r6e3qm.png"></p>]]></content>
      
      
      <categories>
          
          <category> 绘画 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>v大预科作业第二周</title>
      <link href="/2022/07/08/v%E5%A4%A7%E9%A2%84%E7%A7%91%E4%BD%9C%E4%B8%9A%E7%AC%AC%E4%BA%8C%E5%91%A8/"/>
      <url>/2022/07/08/v%E5%A4%A7%E9%A2%84%E7%A7%91%E4%BD%9C%E4%B8%9A%E7%AC%AC%E4%BA%8C%E5%91%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="DAY1"><a href="#DAY1" class="headerlink" title="DAY1"></a>DAY1</h2><p>感觉这个色彩组合临摹目前来说对我没啥用处…</p><p>考虑明天换个东西做做</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/xj1izccz.png"></p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/o7qjq059.png"></p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/bo4q7m2p.png"></p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/fopzqf9d.png"></p><h2 id="DAY2"><a href="#DAY2" class="headerlink" title="DAY2"></a>DAY2</h2><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/xhxnsbod.png"></p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/mgpa5agy.png"></p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/20j7isx9.png"></p><h2 id="DAY3"><a href="#DAY3" class="headerlink" title="DAY3"></a>DAY3</h2><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/rlmijh66.png"></p>]]></content>
      
      
      <categories>
          
          <category> 绘画 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 预科作业 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>v大预科作业第一周</title>
      <link href="/2022/07/02/v%E5%A4%A7%E9%A2%84%E7%A7%91%E4%BD%9C%E4%B8%9A%E7%AC%AC%E4%B8%80%E5%91%A8/"/>
      <url>/2022/07/02/v%E5%A4%A7%E9%A2%84%E7%A7%91%E4%BD%9C%E4%B8%9A%E7%AC%AC%E4%B8%80%E5%91%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="DAY1"><a href="#DAY1" class="headerlink" title="DAY1"></a>DAY1</h2><p>这量就离谱</p><p>从早上九点一直画到晚上十点多才画完&#x3D; &#x3D;</p><p>终究还是我太菜了&#x2F;kk</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/mtx9gumm.png"></p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/9tw63rc9.png"></p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/4dia4e3o.png"></p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/rlah1j27.png"></p><h2 id="DAY-2"><a href="#DAY-2" class="headerlink" title="DAY 2"></a>DAY 2</h2><p>把最恶心的十个单体练习搞定了</p><p>剩下的明天搞</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/c2rbm3ws.png"></p><h2 id="DAY-3"><a href="#DAY-3" class="headerlink" title="DAY 3"></a>DAY 3</h2><p>把昨天没做的补完了</p><p>感觉手感比第一天好多了</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ra4l48mb.png"></p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/xpon3tyt.png"></p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ecj3opjx.png"></p><h2 id="day4"><a href="#day4" class="headerlink" title="day4"></a>day4</h2><p>单体练习有一些细节还没画完 懒得补了(</p><p>衣玖的衣服是真nm难画…</p><p> <img src="https://cdn.luogu.com.cn/upload/image_hosting/lchyu9kk.png"></p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/milzyu7b.png"></p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/j707cogi.png"></p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/2a8vxfdi.png"></p><h2 id="day5"><a href="#day5" class="headerlink" title="day5"></a>day5</h2><p><del>休息了一整天</del></p><p>随便画了点自己喜欢的东西</p>]]></content>
      
      
      <categories>
          
          <category> 绘画 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 预科作业 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P6835 [Cnoi2020]线形生物</title>
      <link href="/2021/02/12/p6835/"/>
      <url>/2021/02/12/p6835/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p><strong><a href="https://www.luogu.com.cn/problem/solution/P6835">原题面</a></strong></p><p>有$n+1$个点,对于每个点$i(i≤n)$都有一条连向$i+1$的边,形成一条链,并在其中加入$m$条返祖边</p><p>现在从1号节点出发，每次等概率的前往到一个相邻的节点，求走到第$n+1$个点的期望步数</p><p>$n,m≤10^6$</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>设$E_{x→y}$表示从$x$点走到$y$点的期望步数，$k_i$表示第$i$个点的返祖边条数</p><p>有转移：</p><center>$~~~~~E_{x→x+1} = \dfrac{1}{k_x+1}×1+\dfrac{1}{k_x+1}×\sum\limits_{(x,y)∈E}E_{y→x+1}+1$</center><center>$= 1+\dfrac{1}{k_x+1}×\sum\limits_{(x,y)∈E}E_{y→x+1}$</center><p>根据期望的线性性质,有$E_{x→y} &#x3D;\sum\limits_{i&#x3D;x}^{y-1}E_{i→i+1}$,代回原式：</p><center>$E_{x→x+1} = 1+\dfrac{1}{k_x+1}×\sum\limits_{(x,y)∈E}\sum\limits_{i=y}^{x-1}E_{i→i+1}+\dfrac{k_x×E_{x→x+1}}{k_x+1}$</center><center>$E_{x→x+1} = 1+k_x+\sum\limits_{(x,y)∈E}\sum\limits_{i=y}^{x-1}E_{i→i+1}$</center><p>维护一下前缀和即可,$\sum\limits_{i&#x3D;x}^{y-1}E_{i→i+1}$既为所求答案</p><p>时间复杂度$O(n+m)$</p><h2 id="code"><a href="#code" class="headerlink" title="$code$"></a>$code$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//xcxc82 2021/2/9/20:50 </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mo 998244353</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1000010</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> X=<span class="number">0</span>; <span class="type">bool</span> flag=<span class="number">1</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) flag=<span class="number">0</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">if</span>(flag) <span class="keyword">return</span> X;<span class="keyword">return</span> ~(X<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line"><span class="type">int</span> to,from,next;</span><br><span class="line">&#125;e[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> head[MAXN&lt;&lt;<span class="number">2</span>],cnt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">e[++cnt].next = head[u];</span><br><span class="line">e[cnt].from = u;</span><br><span class="line">e[cnt].to = v;</span><br><span class="line">head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> id,n,m,out[MAXN],sum[MAXN],f[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    id = <span class="built_in">read</span>(),n =<span class="built_in">read</span>(),m = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="type">int</span> u = <span class="built_in">read</span>(),v =<span class="built_in">read</span>();</span><br><span class="line"><span class="built_in">add</span>(u,v);</span><br><span class="line">out[u]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">1</span>;u&lt;=n;u++)&#123;</span><br><span class="line">f[u] = <span class="number">1</span>+out[u];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = e[i].to;</span><br><span class="line">f[u] = (f[u]+(sum[u<span class="number">-1</span>]-sum[v<span class="number">-1</span>]+mo)%mo)%mo;</span><br><span class="line">&#125;</span><br><span class="line">sum[u] = (sum[u<span class="number">-1</span>]+f[u])%mo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,sum[n]);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>OI时期的最后一篇博客</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划-期望dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P4046 [JSOI2010]快递服务</title>
      <link href="/2021/01/24/p4046/"/>
      <url>/2021/01/24/p4046/</url>
      
        <content type="html"><![CDATA[<p><strong><a href="https://www.luogu.com.cn/problem/P4046">题目链接</a> <a href="https://www.luogu.com.cn/problem/SP703">双倍经验</a></strong></p><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有$m$个位置,从位置$p$移动到位置$q$需要花费$c(p,q)$的价钱,但并不保证$c(p,q)≠c(q,p)$</p><p>现在有三个员工,初始位置在$1,2,3$和有$n$个请求，任何时刻只有一名员工可以移动，且不允许同一位置上有 $2$ 个以上员工。第 $i$ 个请求发生在位置 $p_i$,公司必须按照顺序,派一名员工到位置 $p_i$去完成请求</p><p>求公司的最小花费。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>设$f(i,x,y,z)$表示解决完前$i$个请求时,三个员工分别在$x,y,z$处时的最小花费,转移:</p><p>$f(i+1,p_{i+1},y,z) &#x3D; min{f(i,x,y,z)+c(x,p_{i+1})}\qquad (p_{i+1}≠y≠z)$</p><p>$f(i+1,x,p_{i+1},z) &#x3D; min{f(i,x,y,z)+c(y,p_{i+1})}\qquad (x≠p_{i+1}≠z)$</p><p>$f(i+1,x,y,p_{i+1}) &#x3D; min{f(i,x,y,z)+c(z,p_{i+1})}\qquad (x≠y≠p_{i+1})$</p><p>时空复杂度$O(nm^3)$,无论是在时间上还是空间上都接受不了</p><p>考虑优化:</p><p>可以发现,在完成第$i$个任务时,一定有一个人站在$p_i$的位置上,也就是说,这个人的信息是”多余”的,只需要记录另外两个人的位置</p><p>设$f(i,x,y)$表示解决前$i$个请求时,三个员工分别在$x,y,p_i$时的最小花费,转移:</p><p>$f(i+1,p_i,y) &#x3D; min{f(i,x,y)+c(x,p_{i+1})}\qquad (p_i≠y≠p_{i+1})$</p><p>$f(i+1,x,y) &#x3D; min{f(i,x,y)+c(p_i,p_{i+1})}\qquad (x≠y≠p_{i+1})$</p><p>$f(i+1,x,p_i) &#x3D; min{f(i,x,y)+c(y,p_{i+1})}\qquad (x≠p_i≠p_{i+1})$</p><p>时间复杂度$O(nm^2)$,再用滚动数组优化一下空间即可</p><h2 id="code"><a href="#code" class="headerlink" title="$code$"></a>$code$</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">xcxc82</span><br><span class="line">*/</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define inf 1e9+10</span><br><span class="line">const int MAXN = 210;</span><br><span class="line">int T,L,n;</span><br><span class="line">inline int read()&#123;</span><br><span class="line">int X=0; bool flag=1; char ch=getchar();</span><br><span class="line">while(ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;) &#123;if(ch==&#x27;-&#x27;) flag=0; ch=getchar();&#125;</span><br><span class="line">while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) &#123;X=(X&lt;&lt;1)+(X&lt;&lt;3)+ch-&#x27;0&#x27;; ch=getchar();&#125;</span><br><span class="line">if(flag) return X;return ~(X-1);</span><br><span class="line">&#125;</span><br><span class="line">int f[2][MAXN][MAXN];</span><br><span class="line">int val[MAXN][MAXN],a[MAXN*5];</span><br><span class="line">int main()&#123;</span><br><span class="line">memset(f,0x3f,sizeof(f));</span><br><span class="line">L = read();</span><br><span class="line">for(int i=1;i&lt;=L;i++)&#123;</span><br><span class="line">for(int j=1;j&lt;=L;j++)&#123;</span><br><span class="line">val[i][j] = read();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    a[0] = 3;</span><br><span class="line">f[0][1][2] = 0;</span><br><span class="line">int now;</span><br><span class="line">while(cin&gt;&gt;now) a[++n] = now;</span><br><span class="line">for(int i=0;i&lt;=n-1;i++)&#123;</span><br><span class="line">memset(f[i+1&amp;1],0x3f,sizeof(f[i+1&amp;1]));</span><br><span class="line">for(int x=1;x&lt;=L;x++)&#123;</span><br><span class="line">for(int y=1;y&lt;=L;y++)&#123;</span><br><span class="line">if(x==y||x==a[i]||y==a[i]) continue;</span><br><span class="line">f[i+1&amp;1][a[i]][y] = min(f[i+1&amp;1][a[i]][y],f[i&amp;1][x][y]+val[x][a[i+1]]);</span><br><span class="line">f[i+1&amp;1][x][y] = min(f[i+1&amp;1][x][y],f[i&amp;1][x][y]+val[a[i]][a[i+1]]);</span><br><span class="line">f[i+1&amp;1][x][a[i]] = min(f[i+1&amp;1][x][a[i]],f[i&amp;1][x][y]+val[y][a[i+1]]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int ans = 0x3f3f3f3f;</span><br><span class="line"></span><br><span class="line">for(int i=1;i&lt;=L;i++) </span><br><span class="line"> for(int j=1;j&lt;=L;j++) </span><br><span class="line">  ans = min(ans,f[n&amp;1][i][j]);</span><br><span class="line">  </span><br><span class="line">printf(&quot;%d&quot;,ans);</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划-线性dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P5774 [JSOI2016]病毒感染</title>
      <link href="/2021/01/19/p5774/"/>
      <url>/2021/01/19/p5774/</url>
      
        <content type="html"><![CDATA[<p><strong><a href="https://www.luogu.com.cn/problem/P5774">题目链接</a></strong></p><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有$N$个小镇爆发了疫情,其中第$i$个小镇每天会死$a_i$个人,现在从第一个小镇出发,每一天可以选择:</p><ul><li><p>走向一个相邻的村庄,若往左走,则必须把之前所有未治愈村庄全部治愈</p></li><li><p>治疗目前所在的村庄,这一天内该村庄内不会有任何人死去</p></li></ul><p>求最少死亡人数</p><p>$n≤3000,a_i≤10^9$</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>可以发现,每个村庄只可能在第一次被经过或第二次被经过时治愈被治愈,换句话说,<strong>在区间$[l,r]$进行一次往返走$(l \Rightarrow r \Rightarrow l \Rightarrow r)$可以治愈该区间内的所有村庄</strong>,并且总过程就是由一连串的”往返走”组成的</p><p>不妨先设$f(i)$表示治疗前$i$个村庄的最少死亡人数,$v(i,j)$表示在区间$[l,r]$进行一次往返走后该区间的最少死亡人数,转移也比较好推,就是细节比较多:</p><center>$f(i) = min \{f(j)+(4×(i-j)+2)×\sum\limits_{x=i+1}^n+v(i+1,j)\}(0≤j＜i)$</center><p>显然这个$v(i,j)$也是可以用$DP$预处理出来的,分类讨论治愈的时间,有转移:</p><center> $v(i,j) = v(i+1,j)+ \begin{cases}2×\sum\limits_{x=i+1}^ja_x\\3×(j-i)×a_i+\sum\limits_{x=i+1}^ja_x\end{cases}$ </center><p>时间复杂度$O(n^2)$</p><h2 id="code"><a href="#code" class="headerlink" title="$code$"></a>$code$</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//xcxc82 2021/1/19/22:03</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define int long long</span><br><span class="line">const int MAXN = 3010;</span><br><span class="line">inline int read()&#123;</span><br><span class="line">int X=0; bool flag=1; char ch=getchar();</span><br><span class="line">while(ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;) &#123;if(ch==&#x27;-&#x27;) flag=0; ch=getchar();&#125;</span><br><span class="line">while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) &#123;X=(X&lt;&lt;1)+(X&lt;&lt;3)+ch-&#x27;0&#x27;; ch=getchar();&#125;</span><br><span class="line">if(flag) return X;return ~(X-1);</span><br><span class="line">&#125;</span><br><span class="line">int n,a[MAXN];</span><br><span class="line">int v[MAXN][MAXN],sum[MAXN]; </span><br><span class="line">int f[MAXN];</span><br><span class="line">signed main()&#123;</span><br><span class="line">   n =read();</span><br><span class="line">   for(int i=1;i&lt;=n;i++) a[i] = read(),sum[i] = sum[i-1]+a[i];</span><br><span class="line">   memset(f,0x3f,sizeof(f));</span><br><span class="line">   memset(v,0x3f,sizeof(v));</span><br><span class="line">   f[0]=0;</span><br><span class="line">   for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">v[i][i] = 0;</span><br><span class="line">&#125;</span><br><span class="line">for(int len=1;len&lt;=n-1;len++)&#123;</span><br><span class="line"> for(int i=1;i+len&lt;=n;i++)&#123;</span><br><span class="line">int j=i+len;</span><br><span class="line">v[i][j] = v[i+1][j]+min(2*(sum[j]-sum[i]),a[i]*3*len+sum[j]-sum[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">for(int j=0;j&lt;i;j++)&#123;</span><br><span class="line">f[i] = min(f[j]+v[j+1][i]+(4*(i-j)-2)*(sum[n]-sum[i]),f[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;%lld&quot;,f[n]);</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划-线性dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P2577 [ZJOI2004]午餐</title>
      <link href="/2021/01/16/p2577/"/>
      <url>/2021/01/16/p2577/</url>
      
        <content type="html"><![CDATA[<p><strong><a href="https://www.luogu.com.cn/problem/P2577">题目链接</a></strong></p><p>重构于$2020&#x2F;1&#x2F;16$</p><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有$n$个人去排队吃饭,每个人都有一个吃饭时间$a_i$和打饭时间$b_i$,一共有两个打饭窗口,要求安排一种分队和排队方案使得所有人都吃完饭的时间尽量早,输出最佳方案下所有人吃完饭的时刻</p><p>$n,a_i,b_i≤200$</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>猜个结论,<strong>吃饭吃的越慢的人排在越前面</strong>,用邻项交换法易证。这样每个人的吃饭顺序就是固定的了</p><p>先来考虑只有一个窗口的情况,不难发现总时间是由<strong>最后一个吃完饭的人的吃饭时间</strong>和<strong>他前面的总排队时间</strong>组成的,设$sum_i$表示前$i$个人打饭的时间,那么全部都吃完饭的时间为$max{sum_i+b_i}$</p><p>再回来看两个窗口时的情况,受只有一个窗口的情况的启发,一个比较好想到的状态是设$f(i,j,k)$表示在前$i$个人中,在$1$窗口排队的总时间为$j$,在$2$窗口排队的总时间为$k$的最早吃完时间,转移显然:</p><p>$f(i,j,k) &#x3D; min\begin{cases}max{f(i-1,j-a_i,k),j+b_i}&amp;j≥a_i\max{f(i-1,j,k-a_i),k+b_i}&amp;k≥a_i\end{cases}(j+k &#x3D; sum_i)$</p><p>时间复杂度$O(n×max{t}^2)$,得分$50pts$</p><p>发现<strong>在窗口$2$排队的时间为在窗口$1$排队的时间的补集</strong>,可以直接用总时间减去在窗口$1$排队的时间得出,因此$k$维度可以去掉</p><p>设$f(i,j)$表示在前$i$个人中,在$1$窗口排队的总时间为$j$时的最早吃完时间,转移:</p><p>$f(i,j) &#x3D; min\begin{cases}max{f(i-1,j-a_i),j+b_i}&amp;j≥a_i\max{f(i-1,j),sum_i-j+b_i}\end{cases}$</p><p>时间复杂度$O(n×max{t})$</p><h2 id="code"><a href="#code" class="headerlink" title="$code$"></a>$code$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">210</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> f[MAXN][MAXN*MAXN];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">person</span>&#123;</span><br><span class="line"><span class="type">int</span> wait,eat;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt;(person k) <span class="type">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> eat&gt;k.eat;</span><br><span class="line">&#125;</span><br><span class="line">&#125;d[MAXN];</span><br><span class="line"><span class="type">int</span> sum[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">cin&gt;&gt;d[i].wait&gt;&gt;d[i].eat;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(d+<span class="number">1</span>,d+<span class="number">1</span>+n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">sum[i] = sum[i<span class="number">-1</span>] + d[i].wait;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=sum[i];j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(j&gt;=d[i].wait) f[i][j] = <span class="built_in">min</span>(f[i][j],<span class="built_in">max</span>(f[i<span class="number">-1</span>][j-d[i].wait],j+d[i].eat));</span><br><span class="line">f[i][j] = <span class="built_in">min</span>(f[i][j],<span class="built_in">max</span>(f[i<span class="number">-1</span>][j],sum[i]-j+d[i].eat));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">1145141919</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=sum[n];i++)&#123;</span><br><span class="line">ans = <span class="built_in">min</span>(ans , f[n][i]);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划-线性dp </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing277. 饼干</title>
      <link href="/2021/01/15/acwing277/"/>
      <url>/2021/01/15/acwing277/</url>
      
        <content type="html"><![CDATA[<p><strong><a href="https://www.acwing.com/problem/content/279/">题目链接</a></strong></p><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有$m$块饼干,$n$个人,每个人都有一个贪婪度,第$i$个人的贪婪度为$g_i$,如果有$a_i$个人拿到的饼干数比第$i$个人多,那么他就会产生$g_i×a_i$的怨气,求一种排列方式,使得每个人至少分到一块饼干且怨气和最小</p><p>$n≤30,n≤m≤5000$</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>发现这个贡献计算是有后效性的,不太好搞</p><p>先来尝试猜个结论:<strong>越贪的人吃越多的饼干</strong>,用邻项交换易证。这样每个人分到的饼干数就是单调不上升的了</p><p>也就是说,<strong>要计算第$i$个人的贡献,我们只需要知道第$i$个人前面有几个人和他分到的饼干数相等</strong>，一个比较NAIVE的想法是设$f(i,j,k)$表示在前$i$个人中,一共分了$j$块饼干,第$i$个人分到$k$块时的最小怨气值和</p><p>转移也比较显然,枚举前面有几个人和他分到的饼干数相等:</p><p>$f(i,j,k) &#x3D; min\begin{cases}min(f(i-1,j-k,p)+g_i×(i-1))&amp;{j-k≥p×(i-1),p&gt;k})\min(f(i-p,j-p×k,k)+\sum_{b&#x3D;i-p+1}^ig_b×(i-p-1))&amp;{j-p×k≥(i-p-1)×k}\end{cases}$</p><p>时间复杂度$O(nm^3)$</p><p><del>数据似乎比较水(,可以拿个80pts左右的样子</del></p><p>现在来考虑优化</p><p>可以发现,我们<strong>只关心每个人分到的饼干数之间的相对大小</strong>,而不关心其具体数值,因此我们可以尝试去把前面那个状态的$k$维度去掉</p><p>设$f(i,j)$表示在前$i$个人中共分了$j$块饼干的最小怨气值和</p><p>如果第$i$个人分到的饼干数不为$1$,<strong>前$i$个人共分到$j$块饼干等价于每人少分一块饼干,既$f(i,j-i)$</strong>,因为每个人拿到的饼干数之间的相对大小没有变,总贡献也不会变</p><p>如果第$i$个人分到的饼干数为$1$,那么就可以枚举他前面有多少个人分到的饼干数也为$1$</p><p>转移方程$:$</p><center>$f(i,j) = min\begin{cases}f(i,j-i)&{j≥i}\\min(f(k,j-(i-k))+\sum_{x=k+1}^ig_i×k)&{j≥i-k}\end{cases}$</center><h2 id="code"><a href="#code" class="headerlink" title="$code$"></a>$code$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//xcxc82</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">80pts</span></span><br><span class="line"><span class="comment">memset(f,0x3f,sizeof(f));</span></span><br><span class="line"><span class="comment">memset(f[1],0,sizeof(f[1]));</span></span><br><span class="line"><span class="comment">  for(int i=2;i&lt;=n;i++)&#123;</span></span><br><span class="line"><span class="comment">    for(int j=1;j&lt;=m;j++)&#123;</span></span><br><span class="line"><span class="comment">      for(int k=1;k&lt;j;k++)&#123;</span></span><br><span class="line"><span class="comment">    for(int p=k+1;p&lt;=j;p++)&#123;</span></span><br><span class="line"><span class="comment">    if(j-k&lt;p*(i-1)||j&lt;k) continue;</span></span><br><span class="line"><span class="comment">    f[i][j][k] = min(f[i][j][k],f[i-1][j-k][p]+g[i]*(i-1));</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">for(int p=1;p&lt;=i-1;p++)&#123;//注意要特判p=i-1,j-p×k!=k的情况</span></span><br><span class="line"><span class="comment">if(j-p*k&lt;(i-p-1)*k||j&lt;p*k||(p==i-1&amp;&amp;j-p*k!=k)) continue;</span></span><br><span class="line"><span class="comment"> f[i][j][k] = min(f[i][j][k],f[i-p][j-p*k][k]+(i-p-1)*(sum[i]-sum[i-p]));</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">5010</span>;</span><br><span class="line"><span class="type">int</span> sum[MAXN],n,m,f[MAXN/<span class="number">100</span>][MAXN];</span><br><span class="line"><span class="type">int</span> l1[MAXN/<span class="number">100</span>][MAXN],l2[MAXN/<span class="number">100</span>][MAXN],ans[MAXN/<span class="number">100</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cookie</span>&#123;</span><br><span class="line"><span class="type">int</span> g,ind;</span><br><span class="line">&#125;a[MAXN];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(cookie x,cookie y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x.g&gt;y.g;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SUM</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sum[j] - sum[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> X=<span class="number">0</span>; <span class="type">bool</span> flag=<span class="number">1</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) flag=<span class="number">0</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">if</span>(flag) <span class="keyword">return</span> X;<span class="keyword">return</span> ~(X<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">print</span>(l1[i][j],l2[i][j]);</span><br><span class="line"><span class="keyword">if</span>(i==l1[i][j])&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> x=<span class="number">1</span>;x&lt;=i;x++) ans[a[x].ind]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">for</span>(<span class="type">int</span> x=l1[i][j]+<span class="number">1</span>;x&lt;=i;x++) ans[a[x].ind] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n = <span class="built_in">read</span>(),m = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i].g = <span class="built_in">read</span>(),a[i].ind = i;</span><br><span class="line"><span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>,cmp); </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) sum[i] = sum[i<span class="number">-1</span>]+a[i].g;</span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=m;j++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;i;k++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(f[k][j-(i-k)]+k*<span class="built_in">SUM</span>(k+<span class="number">1</span>,i)&lt;f[i][j])&#123;</span><br><span class="line">    f[i][j] = f[k][j-(i-k)]+k*<span class="built_in">SUM</span>(k+<span class="number">1</span>,i);</span><br><span class="line">    l1[i][j] = k,l2[i][j] = j-(i-k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(f[i][j-i]&lt;f[i][j])&#123;</span><br><span class="line">f[i][j] = f[i][j-i];</span><br><span class="line">l1[i][j] = i,l2[i][j] = j-i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,f[n][m]);</span><br><span class="line"><span class="built_in">print</span>(n,m);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,ans[i]);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划-线性dp </tag>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NOIP2020 字符串匹配</title>
      <link href="/2021/01/08/noip2020-2/"/>
      <url>/2021/01/08/noip2020-2/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P7114">题目链接</a></p><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给一个字符串$S$,求$S&#x3D;(AB)^iC$的方案数,其中$F(A)≤F(C)$,$F(S)$表示字符串 $S$ 中出现奇数次的字符的数量</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>设$cnt_i$表示奇数字符数小于等于$i$的$A$的个数</p><p>枚举$AB$的长度,然后用$KMP$的$next$数组去枚举循环次数$i$,将小于等于$C$中奇数字符的数量的$A$的方案数,也就是$cnt_{j}$($j$为$C$中出现奇数次字符从数量)加到答案中,并更新一下$cnt$</p><p>最坏时间复杂度$O(n×(logn+26))$,不开$O2$ $92$~$96$pts,开$O2$稳过</p><h2 id="code"><a href="#code" class="headerlink" title="$code$"></a>$code$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">xcxc82</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = (<span class="number">1</span>&lt;&lt;<span class="number">20</span>)+<span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> X=<span class="number">0</span>; <span class="type">bool</span> flag=<span class="number">1</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) flag=<span class="number">0</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">if</span>(flag) <span class="keyword">return</span> X;<span class="keyword">return</span> ~(X<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> pre[MAXN],suf[MAXN],next[MAXN],pre_value[<span class="number">30</span>];</span><br><span class="line"><span class="type">int</span> buc[<span class="number">30</span>];</span><br><span class="line"><span class="type">bool</span> vis[<span class="number">30</span>];</span><br><span class="line"><span class="type">int</span> T,n;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans;</span><br><span class="line">string s;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="literal">false</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line"><span class="built_in">memset</span>(pre,<span class="number">0</span>,<span class="built_in">sizeof</span>(pre));</span><br><span class="line"><span class="built_in">memset</span>(suf,<span class="number">0</span>,<span class="built_in">sizeof</span>(suf));</span><br><span class="line"><span class="built_in">memset</span>(next,<span class="number">0</span>,<span class="built_in">sizeof</span>(next));</span><br><span class="line"><span class="built_in">memset</span>(buc,<span class="number">0</span>,<span class="built_in">sizeof</span>(buc));</span><br><span class="line"><span class="built_in">memset</span>(pre_value,<span class="number">0</span>,<span class="built_in">sizeof</span>(pre_value));</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kmp</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;s[i]!=s[j+<span class="number">1</span>]) j = next[j];</span><br><span class="line"><span class="keyword">if</span>(s[i]==s[j+<span class="number">1</span>]) j++;</span><br><span class="line">next[i] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">T = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">clear</span>();</span><br><span class="line">cin&gt;&gt;s;</span><br><span class="line">s = <span class="string">&#x27; &#x27;</span>+s;</span><br><span class="line">n = s.<span class="built_in">length</span>()<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!vis[s[i]-<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>]) vis[s[i]-<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>] = <span class="number">1</span>,cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">kmp</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="type">int</span> now = s[i]-<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>;</span><br><span class="line">buc[now]++;</span><br><span class="line"><span class="keyword">if</span>(buc[now]&amp;<span class="number">1</span>) pre[i] = pre[i<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> pre[i] = pre[i<span class="number">-1</span>]<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(buc,<span class="number">0</span>,<span class="built_in">sizeof</span>(buc));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line"><span class="type">int</span> now = s[i]-<span class="string">&#x27;a&#x27;</span>+<span class="number">1</span>;</span><br><span class="line">buc[now]++;</span><br><span class="line"><span class="keyword">if</span>(buc[now]&amp;<span class="number">1</span>) suf[i] = suf[i+<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> suf[i] = suf[i+<span class="number">1</span>]<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i&gt;<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;n;j+=i)&#123;</span><br><span class="line"><span class="keyword">if</span>((i%(j-next[j])==<span class="number">0</span>&amp;&amp;j/(j-next[j])&gt;<span class="number">1</span>)||(j==i))</span><br><span class="line">ans+=(<span class="type">long</span> <span class="type">long</span>)(pre_value[suf[j+<span class="number">1</span>]]);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=pre[i];j&lt;=cnt;j++)&#123;</span><br><span class="line">pre_value[j]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>USACO05DEC Cleaning Shifts S</title>
      <link href="/2021/01/01/usaco05dec/"/>
      <url>/2021/01/01/usaco05dec/</url>
      
        <content type="html"><![CDATA[<p> ##P4644 [USACO05DEC]Cleaning Shifts S</p><p>###大致题意</p><p>有$n$条贴纸,第$i$条贴纸可以将第$a_i$到$b_i$段覆盖,售价为$c_i$,现在要用若干条贴纸覆盖纸带上第$L$~$R$个格子,求至少要花费多少钱</p><p>$1≤n≤25000,1≤L≤R≤10^6$</p><p>###分析</p><p>设$f(i)$表示覆盖$L~i$区间所需要的最少花费,将贴纸按右端点升序排序,有显然的转移:<center>$f(b(i)) &#x3D; min(f(j))+c(i))~~~~~~~~~{a(i)-1≤j≤b(i)}$</center></p><p>再用线段树来维护一下$min(f(j))$即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//xcxc82 2021/7/30</span></span><br><span class="line"><span class="comment">//f[b[i]] = min(f[j])+c(a[i]-1&lt;=j&lt;b[i])</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson (node&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson (node&lt;&lt;1|1)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span> + <span class="number">7</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> X=<span class="number">0</span>; <span class="type">bool</span> flag=<span class="number">1</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) flag=<span class="number">0</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">if</span>(flag) <span class="keyword">return</span> X;<span class="keyword">return</span> ~(X<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> f[MAXN];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st</span>&#123;</span><br><span class="line"><span class="type">int</span> min;</span><br><span class="line">&#125;tree[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;</span><br><span class="line">tree[node].min = <span class="built_in">min</span>(tree[lson].min,tree[rson].min);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">tree[node].min = f[l];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">build</span>(lson,l,mid);</span><br><span class="line"><span class="built_in">build</span>(rson,mid+<span class="number">1</span>,r);</span><br><span class="line"><span class="built_in">pushup</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> mid = (l+r)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(x&lt;=l&amp;&amp;y&gt;=r)&#123;</span><br><span class="line"><span class="keyword">return</span> tree[node].min;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans = inf;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=mid) ans = <span class="built_in">min</span>(ans,<span class="built_in">query</span>(lson,l,mid,x,y));</span><br><span class="line"><span class="keyword">if</span>(y&gt;mid) ans = <span class="built_in">min</span>(ans,<span class="built_in">query</span>(rson,mid+<span class="number">1</span>,r,x,y));</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">tree[node].min = v;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=mid) <span class="built_in">modify</span>(lson,l,mid,x,v);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">modify</span>(rson,mid+<span class="number">1</span>,r,x,v);</span><br><span class="line"><span class="built_in">pushup</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> l,r,n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">v</span>&#123;</span><br><span class="line"><span class="type">int</span> l,r,v;</span><br><span class="line">&#125;val[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">S</span><span class="params">(<span class="type">const</span> v &amp;x, <span class="type">const</span> v &amp;y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x.r &lt; y.r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">n = <span class="built_in">read</span>(),l = <span class="built_in">read</span>(),r = <span class="built_in">read</span>();</span><br><span class="line">l++,r++;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">val[i].l = <span class="built_in">read</span>(),val[i].r = <span class="built_in">read</span>(),val[i].v = <span class="built_in">read</span>();</span><br><span class="line">val[i].l++,val[i].r++;</span><br><span class="line"><span class="keyword">if</span>(val[i].l&lt;l) val[i].l = l;</span><br><span class="line"><span class="keyword">if</span>(val[i].r&gt;r) val[i].r = r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(val+<span class="number">1</span>,val+<span class="number">1</span>+n,S);</span><br><span class="line">f[l<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> ans = inf;</span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>,l<span class="number">-1</span>,r);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(val[i].l&gt;val[i].r) <span class="keyword">continue</span>;</span><br><span class="line">f[val[i].r] = <span class="built_in">min</span>(f[val[i].r],<span class="built_in">query</span>(<span class="number">1</span>,l<span class="number">-1</span>,r,val[i].l<span class="number">-1</span>,val[i].r)+val[i].v);</span><br><span class="line"><span class="keyword">if</span>(val[i].r&gt;=r)&#123;</span><br><span class="line">ans = <span class="built_in">min</span>(ans,f[val[i].r]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">modify</span>(<span class="number">1</span>,l<span class="number">-1</span>,r,val[i].r,f[val[i].r]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ans==inf) cout&lt;&lt;<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;ans;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> 动态规划-线段树优化dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P7076 [CSP-S2020] 动物园</title>
      <link href="/2020/12/27/p7076/"/>
      <url>/2020/12/27/p7076/</url>
      
        <content type="html"><![CDATA[<h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a><a href="https://www.luogu.com.cn/problem/P7076">题目链接</a></h3><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>显然,只有在动物不需要购买一种饲料且该种饲料有要求时才不合法</p><p>注意要特判$n &#x3D; 0,x &#x3D; 64$的情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">xcxc82</span><br><span class="line">*/</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define lson node&lt;&lt;1</span><br><span class="line">#define rson node&lt;&lt;1|1</span><br><span class="line">#define int unsigned long long</span><br><span class="line">const int MAXN = 10010;</span><br><span class="line">int k,c,n,m;</span><br><span class="line">inline int read()&#123;</span><br><span class="line">int X=0; bool flag=1; char ch=getchar();</span><br><span class="line">while(ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;) &#123;if(ch==&#x27;-&#x27;) flag=0; ch=getchar();&#125;</span><br><span class="line">while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) &#123;X=(X&lt;&lt;1)+(X&lt;&lt;3)+ch-&#x27;0&#x27;; ch=getchar();&#125;</span><br><span class="line">if(flag) return X;return ~(X-1);</span><br><span class="line">&#125;</span><br><span class="line">int status,buy;</span><br><span class="line">signed main()&#123;</span><br><span class="line">n = read(),m = read(),c = read(),k = read();</span><br><span class="line"></span><br><span class="line">for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">int am = read();</span><br><span class="line">status|=am;</span><br><span class="line">&#125;</span><br><span class="line">for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">int p =  read(),q = read();</span><br><span class="line">buy|=(1ull&lt;&lt;p);</span><br><span class="line">&#125;</span><br><span class="line">int x = 0;</span><br><span class="line">for(int i=0;i&lt;=k-1;i++)&#123;</span><br><span class="line">int s = (status&gt;&gt;i)&amp;1,b = (buy&gt;&gt;i)&amp;1;</span><br><span class="line">if((!s&amp;&amp;!b)||(s|b&amp;&amp;s)) x++; </span><br><span class="line">&#125;</span><br><span class="line">if(x==64&amp;&amp;n==0)&#123;</span><br><span class="line">cout&lt;&lt;&quot;18446744073709551616&quot;;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;(1ull&lt;&lt;x)-n;</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 枚举 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SP1557 GSS2 - Can you answer these queries II</title>
      <link href="/2020/12/11/sp1557/"/>
      <url>/2020/12/11/sp1557/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/SP1557">题目链接</a></p><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给出长度为$n$的序列$a_i$，$q$ 次询问，求最大子段和，相同的数只算一次</p><p>$1 ≤ n,q≤ 100000$</p><p>$-100000≤a_i≤100000$</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>没有修改操作,考虑离线处理</p><p>正序扫描序列加入每个元素,并在线段树中的每个叶子节点$i$维护区间$[i,j]$去掉重复元素后的区间和($j$为目前扫描到的位置)</p><h3 id="如何去重"><a href="#如何去重" class="headerlink" title="如何去重"></a>如何去重</h3><p>定义$pre[i]$表示$i$上一次出现的位置</p><p>如果一个元素$a_i$在$pre[a_i]$的位置出现过了,那就只在区间$[pre[a_i]+1,i]$中加入它(区间加),相当于自动完成了去重</p><h3 id="如何处理询问"><a href="#如何处理询问" class="headerlink" title="如何处理询问"></a>如何处理询问</h3><p>把每个询问离线下来,按右端点排序,对于每个询问$[l,r]$,在加入$a_r$后查询$max(a_i+a_{i+1}…+a_{j-1}+a_j)$  $l≤i≤j≤r$(区间查询),既区间$[l,r]$中的<strong>历史最大值</strong></p><h3 id="如何维护历史最大值"><a href="#如何维护历史最大值" class="headerlink" title="如何维护历史最大值"></a>如何维护历史最大值</h3><p>线段树中的下放操作有较大的”时间差”,直接和当前值取max肯定不行</p><p>于是我们在线段树中维护四个值：最大去重和, 历史最大去重和, 历史最大标记, 目前标记</p><p>下放一个节点时,用该节点的历史最大标记去更新子节点的历史最大去重和和历史最大标记即可</p><h2 id="code"><a href="#code" class="headerlink" title="$code$"></a>$code$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson node&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson node&lt;&lt;1|1</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100010</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> X=<span class="number">0</span>; <span class="type">bool</span> flag=<span class="number">1</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) flag=<span class="number">0</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">if</span>(flag) <span class="keyword">return</span> X;</span><br><span class="line"><span class="keyword">return</span> ~(X<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,a[MAXN],pre[<span class="number">20</span>*MAXN],ans[MAXN];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">query</span>&#123;</span><br><span class="line"><span class="type">int</span> l,r,id;</span><br><span class="line">&#125;q[MAXN];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(query a,query b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.r&lt;b.r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st</span>&#123;</span><br><span class="line"><span class="type">int</span> max,hismax;</span><br><span class="line"><span class="type">int</span> tag,histag;</span><br><span class="line">&#125;tree[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;</span><br><span class="line">tree[node].max = <span class="built_in">max</span>(tree[lson].max,tree[rson].max);</span><br><span class="line">tree[node].hismax = <span class="built_in">max</span>(tree[lson].hismax,tree[rson].hismax);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">tree[node].hismax = <span class="built_in">max</span>(tree[node].hismax,tree[fa].histag+tree[node].max);<span class="comment">//更新历史最大值和历史最大tag</span></span><br><span class="line">tree[node].histag = <span class="built_in">max</span>(tree[node].histag,tree[fa].histag+tree[node].tag);</span><br><span class="line">tree[node].max+=tree[fa].tag;</span><br><span class="line">tree[node].tag+=tree[fa].tag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PUSHDOWN</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!tree[node].tag) <span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">pushdown</span>(lson,node);</span><br><span class="line"><span class="built_in">pushdown</span>(rson,node);</span><br><span class="line">tree[node].histag = tree[node].tag = <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=l&amp;&amp;y&gt;=r)&#123;</span><br><span class="line">tree[node].max+=val,tree[node].tag+=val;</span><br><span class="line">tree[node].hismax = <span class="built_in">max</span>(tree[node].hismax,tree[node].max);</span><br><span class="line">tree[node].histag = <span class="built_in">max</span>(tree[node].histag,tree[node].tag);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">PUSHDOWN</span>(node);</span><br><span class="line"><span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=mid) <span class="built_in">modify</span>(lson,l,mid,x,y,val);</span><br><span class="line"><span class="keyword">if</span>(y&gt;mid) <span class="built_in">modify</span>(rson,mid+<span class="number">1</span>,r,x,y,val);</span><br><span class="line"><span class="built_in">pushup</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=l&amp;&amp;y&gt;=r)&#123;</span><br><span class="line"><span class="keyword">return</span> tree[node].hismax;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">PUSHDOWN</span>(node);</span><br><span class="line"><span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(y&lt;=mid) <span class="keyword">return</span> <span class="built_in">query</span>(lson,l,mid,x,y);</span><br><span class="line"><span class="keyword">if</span>(x&gt;mid) <span class="keyword">return</span> <span class="built_in">query</span>(rson,mid+<span class="number">1</span>,r,x,y);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">query</span>(lson,l,mid,x,y),<span class="built_in">query</span>(rson,mid+<span class="number">1</span>,r,x,y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i] = <span class="built_in">read</span>();</span><br><span class="line">m = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">    q[i].l = <span class="built_in">read</span>(),q[i].r = <span class="built_in">read</span>();</span><br><span class="line">    q[i].id = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(q+<span class="number">1</span>,q+<span class="number">1</span>+m,cmp);</span><br><span class="line"><span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">modify</span>(<span class="number">1</span>,<span class="number">1</span>,n,pre[a[i]+<span class="number">100000</span>]+<span class="number">1</span>,i,a[i]);</span><br><span class="line">pre[a[i]+<span class="number">100000</span>] = i;</span><br><span class="line"><span class="keyword">while</span>(i==q[j].r&amp;&amp;j&lt;=m) ans[q[j].id] = <span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,q[j].l,q[j].r),j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans[i]);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P4556 [Vani有约会]雨天的尾巴 /【模板】线段树合并</title>
      <link href="/2020/11/22/p4556/"/>
      <url>/2020/11/22/p4556/</url>
      
        <content type="html"><![CDATA[<h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给一颗$n$个节点的树,现在有$m$次操作,每次选择两个节点$u$,$v$,对$u$到$v$的路径上的每个节点都发放一袋$z$类型的物品</p><p>求所有操作完成后,每个点存放最多的是哪种物品</p><p>$n,m≤10^5,z≤10^9$</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>线段树合并模板题</p><p>差分+离散化一下</p><p>每次操作时将$u$和$v$的权值线段树中的$z$位置$+1$,$lca(u,v)$和$fa_{lca(u,v)}$中的$z$位置$-1$,所有操作完成后再$dfs$一遍合并子树</p><p>复杂度$(n+m)log(n+m)$</p><h2 id="code"><a href="#code" class="headerlink" title="$code$"></a>$code$</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN = 100010;</span><br><span class="line">int n,m;</span><br><span class="line">int f[MAXN][21],dep[MAXN];</span><br><span class="line"></span><br><span class="line">inline int read()&#123;</span><br><span class="line">int X=0; bool flag=1; char ch=getchar();</span><br><span class="line">while(ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;) &#123;if(ch==&#x27;-&#x27;) flag=0; ch=getchar();&#125;</span><br><span class="line">while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) &#123;X=(X&lt;&lt;1)+(X&lt;&lt;3)+ch-&#x27;0&#x27;; ch=getchar();&#125;</span><br><span class="line">if(flag) return X;</span><br><span class="line">return ~(X-1);</span><br><span class="line">&#125;</span><br><span class="line">struct st&#123;</span><br><span class="line">int lson,rson,val,pos;</span><br><span class="line">&#125;tree[MAXN*100];</span><br><span class="line">int tot,root[MAXN];</span><br><span class="line">struct e&#123;</span><br><span class="line">int v,next;</span><br><span class="line">&#125;edge[MAXN&lt;&lt;1];</span><br><span class="line">int head[MAXN&lt;&lt;1],cnt;</span><br><span class="line">void add(int u,int v)&#123;</span><br><span class="line">edge[++cnt].v = v;</span><br><span class="line">edge[cnt].next = head[u];</span><br><span class="line">head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line">struct Lca&#123;</span><br><span class="line">void dfs(int u,int fa)&#123;</span><br><span class="line">dep[u] = dep[fa]+1;</span><br><span class="line">f[u][0] = fa;</span><br><span class="line">for(int i=1;(1&lt;&lt;i)&lt;=dep[u];i++)&#123;</span><br><span class="line">f[u][i] = f[f[u][i-1]][i-1];</span><br><span class="line">&#125;</span><br><span class="line">for(int i=head[u];i;i=edge[i].next)&#123;</span><br><span class="line">int v = edge[i].v;</span><br><span class="line">if(v==fa) continue;</span><br><span class="line">dfs(v,u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    int lca(int u,int v)&#123;</span><br><span class="line">if(dep[u]&gt;dep[v]) swap(u,v);</span><br><span class="line">for(int i=20;i&gt;=0;i--)&#123;</span><br><span class="line">if(dep[u]&lt;=dep[v]-(1&lt;&lt;i)) v = f[v][i];</span><br><span class="line">&#125;</span><br><span class="line">if(u==v) return u;</span><br><span class="line">for(int i=20;i&gt;=0;i--)&#123;</span><br><span class="line">if(f[u][i]!=f[v][i])&#123;</span><br><span class="line">u = f[u][i];</span><br><span class="line">v = f[v][i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return f[u][0];</span><br><span class="line">&#125;</span><br><span class="line">&#125;LCA;</span><br><span class="line"></span><br><span class="line">void pushup(int node)&#123;</span><br><span class="line">tree[node].val = max(tree[tree[node].lson].val,tree[tree[node].rson].val);</span><br><span class="line">tree[node].pos = tree[tree[node].lson].val&gt;=tree[tree[node].rson].val?tree[tree[node].lson].pos:tree[tree[node].rson].pos;</span><br><span class="line">&#125; </span><br><span class="line">void insert(int &amp;node,int l,int r,int pos,int val)&#123;</span><br><span class="line">if(!node) node = ++tot;</span><br><span class="line">if(l==r)&#123;</span><br><span class="line">tree[node].val += val;</span><br><span class="line">tree[node].pos = l;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">int mid = (l+r)&gt;&gt;1;</span><br><span class="line">if(pos&lt;=mid) insert(tree[node].lson,l,mid,pos,val);</span><br><span class="line">else if(pos&gt;mid)insert(tree[node].rson,mid+1,r,pos,val);</span><br><span class="line">pushup(node);</span><br><span class="line">&#125;</span><br><span class="line">int merge(int a,int b,int l,int r)&#123;</span><br><span class="line">if(!b) return a;</span><br><span class="line">if(!a) return b;</span><br><span class="line">if(l==r)&#123;</span><br><span class="line">tree[a].val+=tree[b].val;</span><br><span class="line">tree[a].pos = tree[a].val?l:0;</span><br><span class="line">return a;</span><br><span class="line">&#125;</span><br><span class="line">int mid = (l+r)&gt;&gt;1;</span><br><span class="line">tree[a].lson = merge(tree[a].lson,tree[b].lson,l,mid);</span><br><span class="line">tree[a].rson = merge(tree[a].rson,tree[b].rson,mid+1,r);</span><br><span class="line">pushup(a);</span><br><span class="line">return a; </span><br><span class="line">&#125;</span><br><span class="line">int len;</span><br><span class="line">int a[MAXN],b[MAXN],c[MAXN];</span><br><span class="line">int value[MAXN];</span><br><span class="line">int ans[MAXN];</span><br><span class="line">int getid(int x)&#123;</span><br><span class="line">return lower_bound(value+1,value+1+len,c[x]) - value;</span><br><span class="line">&#125;</span><br><span class="line">void dfs2(int u,int fa)&#123;</span><br><span class="line">for(int i=head[u];i;i=edge[i].next)&#123;</span><br><span class="line">int v = edge[i].v;</span><br><span class="line">if(v==fa) continue;</span><br><span class="line">dfs2(v,u);</span><br><span class="line">merge(root[u],root[v],1,len);</span><br><span class="line">&#125;</span><br><span class="line">ans[u] = tree[root[u]].pos;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">n = read(),m = read();</span><br><span class="line">for(int i=1;i&lt;n;i++)&#123;</span><br><span class="line">int u = read(),v = read();</span><br><span class="line">add(u,v),add(v,u);</span><br><span class="line">&#125;</span><br><span class="line">LCA.dfs(1,0);</span><br><span class="line">for(int i=1;i&lt;=n;i++) root[i] = ++tot; </span><br><span class="line">for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">a[i] =read(),b[i] = read(),c[i] = read();</span><br><span class="line">value[i] = c[i];</span><br><span class="line">&#125;</span><br><span class="line">sort(value+1,value+1+m);</span><br><span class="line">len = unique(value+1,value+1+m)-(value+1);</span><br><span class="line">for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">int x = a[i],y = b[i],z = getid(i);</span><br><span class="line">int fa = LCA.lca(x,y);</span><br><span class="line">int Fa = f[fa][0];</span><br><span class="line">insert(root[x],1,len,z,1);</span><br><span class="line">insert(root[y],1,len,z,1);</span><br><span class="line">insert(root[fa],1,len,z,-1);</span><br><span class="line">if(Fa) insert(root[Fa],1,len,z,-1);</span><br><span class="line">&#125;</span><br><span class="line">dfs2(1,0);</span><br><span class="line">for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">printf(&quot;%d\n&quot;,value[ans[i]]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P3224 [HNOI2012]永无乡</title>
      <link href="/2020/11/22/p3224/"/>
      <url>/2020/11/22/p3224/</url>
      
        <content type="html"><![CDATA[<h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给一颗$n$个节点带点权图,现在有$m$次操作,操作分为两种:</p><ul><li><p>询问当前与$u$联通的第$k$大权值是哪个</p></li><li><p>连接两个节点$u,v$</p></li></ul><p>$n,m≤10^5$</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>并查集+线段树合并</p><p>维护一个并查集,在合并两个节点$u$和$v$的时候把它们的线段树也合并起来</p><p>复杂度$(n+m)logn$</p><h2 id="code"><a href="#code" class="headerlink" title="$code$"></a>$code$</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int MAXN = 100010;</span><br><span class="line">int fa[MAXN];</span><br><span class="line">inline int read()&#123;</span><br><span class="line">int X=0; bool flag=1; char ch=getchar();</span><br><span class="line">while(ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;) &#123;if(ch==&#x27;-&#x27;) flag=0; ch=getchar();&#125;</span><br><span class="line">while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) &#123;X=(X&lt;&lt;1)+(X&lt;&lt;3)+ch-&#x27;0&#x27;; ch=getchar();&#125;</span><br><span class="line">if(flag) return X;</span><br><span class="line">return ~(X-1);</span><br><span class="line">&#125;</span><br><span class="line">struct st&#123;</span><br><span class="line">int lson,rson,val,pos;</span><br><span class="line">&#125;tree[MAXN*100];</span><br><span class="line">int tot,root[MAXN];</span><br><span class="line">int val[MAXN];</span><br><span class="line">int n,m;</span><br><span class="line">void pushup(int node)&#123;</span><br><span class="line">tree[node].val = tree[tree[node].lson].val+tree[tree[node].rson].val;</span><br><span class="line">&#125;</span><br><span class="line">void insert(int &amp;node,int l,int r,int pos,int val,int ind)&#123;</span><br><span class="line">if(!node) node = ++tot;</span><br><span class="line">if(l==r)&#123;</span><br><span class="line">tree[node].val+=val;</span><br><span class="line">tree[node].pos = ind;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">int mid = (l+r)&gt;&gt;1;</span><br><span class="line">if(pos&lt;=mid) insert(tree[node].lson,l,mid,pos,val,ind);</span><br><span class="line">else if(pos&gt;mid) insert(tree[node].rson,mid+1,r,pos,val,ind);</span><br><span class="line">pushup(node);</span><br><span class="line">&#125;</span><br><span class="line">int query(int node,int l,int r,int k)&#123;</span><br><span class="line">if(!node||tree[node].val&lt;k)&#123;</span><br><span class="line">  return -1;</span><br><span class="line">&#125; </span><br><span class="line">if(l==r)&#123;</span><br><span class="line">return tree[node].pos;</span><br><span class="line">&#125;</span><br><span class="line">int mid =(l+r)&gt;&gt;1;</span><br><span class="line">if(k&lt;=tree[tree[node].lson].val) return query(tree[node].lson,l,mid,k);</span><br><span class="line">else return query(tree[node].rson,mid+1,r,k-tree[tree[node].lson].val);</span><br><span class="line">&#125;</span><br><span class="line">int merge(int node1,int node2,int l,int r)&#123;</span><br><span class="line">if(!node1) return node2;</span><br><span class="line">if(!node2) return node1;</span><br><span class="line">if(l==r)&#123;</span><br><span class="line">if(tree[node2].pos)&#123;</span><br><span class="line">tree[node1].pos = tree[node2].pos;</span><br><span class="line">tree[node1].val += tree[node2].val;</span><br><span class="line">&#125;</span><br><span class="line">return node1;</span><br><span class="line">&#125;</span><br><span class="line">int mid =(l+r)&gt;&gt;1;</span><br><span class="line">tree[node1].lson = merge(tree[node1].lson,tree[node2].lson,l,mid);</span><br><span class="line">tree[node1].rson = merge(tree[node1].rson,tree[node2].rson,mid+1,r);</span><br><span class="line">pushup(node1);</span><br><span class="line">return node1;</span><br><span class="line">&#125;</span><br><span class="line">int find(int x)&#123;</span><br><span class="line">if(fa[x]==x) return x;</span><br><span class="line">return fa[x] = find(fa[x]);</span><br><span class="line">&#125; </span><br><span class="line">int main()&#123;</span><br><span class="line">n = read(),m = read();</span><br><span class="line">for(int i=1;i&lt;=n;i++)&#123;val[i] = read();</span><br><span class="line">fa[i] = i;</span><br><span class="line">insert(root[i],1,n,val[i],1,i);</span><br><span class="line">&#125; </span><br><span class="line">for(int i=1;i&lt;=m;i++) &#123;</span><br><span class="line">int u = read(),v = read();</span><br><span class="line">int x = find(u),y = find(v);</span><br><span class="line">fa[y] = x; </span><br><span class="line">root[x] = merge(root[x],root[y],1,n);</span><br><span class="line">&#125;</span><br><span class="line">int q = read();</span><br><span class="line">for(int i=1;i&lt;=q;i++)&#123;</span><br><span class="line">char c;</span><br><span class="line">cin&gt;&gt;c;</span><br><span class="line">int u = read(),v = read();</span><br><span class="line">int x = find(u),y = find(v);</span><br><span class="line">if(c==&#x27;B&#x27;)&#123;</span><br><span class="line">if(x==y) continue;</span><br><span class="line">fa[y] = x;</span><br><span class="line">root[x] = merge(root[x],root[y],1,n);</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">    cout&lt;&lt;query(root[x],1,n,v)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P4130 [NOI2007]项链工厂</title>
      <link href="/2020/11/21/p4130/"/>
      <url>/2020/11/21/p4130/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P4130">间隙</a></p><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给一个串包含$n$个珠子的项链,其中第$i$个珠子的颜色是$c_i$</p><p>现在要求维护以下几个操作:</p><p><img src="https://img2020.cnblogs.com/blog/2092833/202011/2092833-20201120232612748-2008256197.png"></p><p><img src="https://img2020.cnblogs.com/blog/2092833/202011/2092833-20201120232626190-1424942522.png"></p><p>$n,m≤500000$</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>细节巨多的一道线段树题</p><p>调了将近四个小时&#x2F;kk</p><p>如果没有翻转操作,这就是个线段树裸题</p><p>不难发现,翻转操作只是把顺时针旋转变成了逆时针旋转</p><p>维护两个变量$r$和$k$,分别代表旋转的幅度和是否翻转,然后就可以通过计算轻松搞出查询区间了</p><h3 id="亿点细节"><a href="#亿点细节" class="headerlink" title="亿点细节"></a>亿点细节</h3><ul><li><p>区间颜色全部相同时要特判</p></li><li><p>旋转后区间要翻转</p></li><li><p>注意题目中给的是一个环,因此要特判$l≤r$和$l＞r$的情况</p></li><li><p>区间赋值相加tag,傻逼!</p></li><li><p>交换操作用原数列数据,傻逼!</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line">using namespace std;</span><br><span class="line">const int MAXN = 500010;</span><br><span class="line">#define lson node&lt;&lt;1</span><br><span class="line">#define rson node&lt;&lt;1|1 </span><br><span class="line">inline int read()&#123;</span><br><span class="line">int X=0; bool flag=1; char ch=getchar();</span><br><span class="line">while(ch&lt;&#x27;0&#x27;||ch&gt;&#x27;9&#x27;) &#123;if(ch==&#x27;-&#x27;) flag=0; ch=getchar();&#125;</span><br><span class="line">while(ch&gt;=&#x27;0&#x27;&amp;&amp;ch&lt;=&#x27;9&#x27;) &#123;X=(X&lt;&lt;1)+(X&lt;&lt;3)+ch-&#x27;0&#x27;; ch=getchar();&#125;</span><br><span class="line">if(flag) return X;</span><br><span class="line">return ~(X-1);</span><br><span class="line">&#125;</span><br><span class="line">int n,m,a[MAXN];</span><br><span class="line">int now;</span><br><span class="line">int T[MAXN];</span><br><span class="line">int cnt = 0;</span><br><span class="line">bool is_rotate;</span><br><span class="line">struct st&#123;</span><br><span class="line">int l,r,val,tag;</span><br><span class="line">&#125;tree[MAXN&lt;&lt;2];</span><br><span class="line">stack&lt;st&gt; s;</span><br><span class="line">void pushdown(int node)&#123;</span><br><span class="line">if(!tree[node].tag) return;</span><br><span class="line">tree[lson].l = tree[lson].r = tree[rson].l = tree[rson].r = tree[node].tag;</span><br><span class="line">tree[lson].tag = tree[node].tag;</span><br><span class="line">tree[rson].tag = tree[node].tag;</span><br><span class="line">tree[lson].val = tree[rson].val = 1;</span><br><span class="line">tree[node].tag = 0;</span><br><span class="line">&#125;</span><br><span class="line">void pushup(int node)&#123;</span><br><span class="line">tree[node].l = tree[lson].l;</span><br><span class="line">tree[node].r = tree[rson].r;</span><br><span class="line">if(tree[lson].r == tree[rson].l)&#123;</span><br><span class="line">tree[node].val = tree[lson].val+tree[rson].val -1;</span><br><span class="line">&#125;</span><br><span class="line">else tree[node].val = tree[lson].val+tree[rson].val;</span><br><span class="line">&#125;</span><br><span class="line">void build(int node,int l,int r)&#123;</span><br><span class="line">if(l==r)&#123;</span><br><span class="line">tree[node].l = tree[node].r = a[l];</span><br><span class="line">tree[node].val = 1;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">int mid = (l+r)&gt;&gt;1;</span><br><span class="line">build(lson,l,mid);</span><br><span class="line">build(rson,mid+1,r);</span><br><span class="line">pushup(node);</span><br><span class="line">&#125;</span><br><span class="line">int query(int node,int l,int r,int x,int y)&#123;</span><br><span class="line">if(x&lt;=l&amp;&amp;y&gt;=r)&#123;</span><br><span class="line">return tree[node].val;</span><br><span class="line">&#125;</span><br><span class="line">pushdown(node);</span><br><span class="line">int mid = (l+r)&gt;&gt;1;</span><br><span class="line">if(x&lt;=mid&amp;&amp;y&gt;mid) return query(lson,l,mid,x,y)+query(rson,mid+1,r,x,y)-(tree[lson].r==tree[rson].l);</span><br><span class="line">if(x&lt;=mid) return query(lson,l,mid,x,y);</span><br><span class="line">if(y&gt;mid) return query(rson,mid+1,r,x,y);</span><br><span class="line">pushup(node);</span><br><span class="line">&#125;</span><br><span class="line">st find(int node,int l,int r,int x,int y)&#123;</span><br><span class="line">if(x&lt;=l&amp;&amp;y&gt;=r)&#123;</span><br><span class="line">return tree[node];</span><br><span class="line">&#125;</span><br><span class="line">pushdown(node);</span><br><span class="line">int mid = (l+r)&gt;&gt;1;</span><br><span class="line">if(x&lt;=mid) return find(lson,l,mid,x,y);</span><br><span class="line">if(y&gt;mid) return find(rson,mid+1,r,x,y);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*int merge2()&#123;</span><br><span class="line">int ans = 0;</span><br><span class="line">st last;</span><br><span class="line">while(!s.empty())&#123;</span><br><span class="line">st a = s.top();</span><br><span class="line">s.pop();</span><br><span class="line">ans+=a.val;</span><br><span class="line">if(a.l==last.r) ans--;</span><br><span class="line">last = a;</span><br><span class="line">//cout&lt;&lt;&quot;[&quot;&lt;&lt;a.l&lt;&lt;&quot; &quot;&lt;&lt;a.r&lt;&lt;&quot;]&quot;&lt;&lt;&quot; &quot;&lt;&lt;a.val&lt;&lt;&quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">return ans;</span><br><span class="line">&#125;*/</span><br><span class="line">void modify(int node,int l,int r,int x,int y,int val)&#123;</span><br><span class="line">if(x&lt;=l&amp;&amp;y&gt;=r)&#123;</span><br><span class="line">tree[node].val = 1;</span><br><span class="line">tree[node].tag = val;</span><br><span class="line">tree[node].l = tree[node].r = val;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">pushdown(node);</span><br><span class="line">int mid = (l+r)&gt;&gt;1;</span><br><span class="line">if(x&lt;=mid) modify(lson,l,mid,x,y,val);</span><br><span class="line">if(y&gt;mid) modify(rson,mid+1,r,x,y,val);</span><br><span class="line">pushup(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void calc(int &amp;x,int &amp;y)&#123;</span><br><span class="line">if(!is_rotate)</span><br><span class="line">    &#123;</span><br><span class="line">        if(x&gt;=now+1)x=x-now;</span><br><span class="line">        else x=n-now+x;</span><br><span class="line">        if(y&gt;=now+1) y=y-now;</span><br><span class="line">        else y=n-now+y;</span><br><span class="line">    &#125;else</span><br><span class="line">    &#123;</span><br><span class="line">        if(x&lt;=now+1)x=now-x+2;</span><br><span class="line">        else x=now+n-x+2;</span><br><span class="line">        if(y&lt;=now+1) y=now-y+2;</span><br><span class="line">        else y=now+n-y+2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line">int main()&#123;</span><br><span class="line">n = read(),m = read();</span><br><span class="line">for(int i=1;i&lt;=n;i++) a[i] = read();</span><br><span class="line">    build(1,1,n);</span><br><span class="line">    int t;</span><br><span class="line">    t = read();</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">    char opt[2];</span><br><span class="line">    cin&gt;&gt;opt;</span><br><span class="line">    if(opt[0]==&#x27;R&#x27;)&#123;</span><br><span class="line">    int k = read();</span><br><span class="line">    now = (now+k)%n;</span><br><span class="line">&#125;</span><br><span class="line">else if(opt[0]==&#x27;F&#x27;)&#123;</span><br><span class="line">is_rotate = !is_rotate;</span><br><span class="line">now = (n-now)%n;</span><br><span class="line">&#125;</span><br><span class="line">else if(opt[0]==&#x27;P&#x27;)&#123;</span><br><span class="line">int l = read(),r = read(),val = read();</span><br><span class="line">calc(l,r);</span><br><span class="line">if(is_rotate) swap(l,r);</span><br><span class="line">if(l&lt;=r) modify(1,1,n,l,r,val);</span><br><span class="line">else modify(1,1,n,l,n,val),modify(1,1,n,1,r,val);</span><br><span class="line">&#125;</span><br><span class="line">else if(opt[0]==&#x27;C&#x27;&amp;&amp;opt[1]!=&#x27;S&#x27;)&#123;</span><br><span class="line">if(tree[1].l!=tree[1].r) cout&lt;&lt;tree[1].val&lt;&lt;endl;//T[++cnt] = tree[1].val;</span><br><span class="line">else cout&lt;&lt;max(1,tree[1].val - 1)&lt;&lt;endl;//T[++cnt] = tree[1].val-1;</span><br><span class="line">&#125;</span><br><span class="line">else if(opt[0]==&#x27;S&#x27;)&#123;</span><br><span class="line">int l =read(),r = read();</span><br><span class="line">calc(l,r);</span><br><span class="line">st a = find(1,1,n,l,l);</span><br><span class="line">st b = find(1,1,n,r,r);</span><br><span class="line">modify(1,1,n,l,l,b.l);</span><br><span class="line">modify(1,1,n,r,r,a.l);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">int l = read(),r = read();</span><br><span class="line">calc(l,r);</span><br><span class="line">if(is_rotate) swap(l,r);</span><br><span class="line">//cout&lt;&lt;&quot;[&quot;&lt;&lt;l&lt;&lt;&quot; &quot;&lt;&lt;r&lt;&lt;&quot;]&quot;&lt;&lt;endl;</span><br><span class="line">if(l&lt;=r) cout&lt;&lt;query(1,1,n,l,r)&lt;&lt;endl;</span><br><span class="line">else&#123;</span><br><span class="line">cout&lt;&lt;max(1,query(1,1,n,l,n)+query(1,1,n,1,r)-(tree[1].l==tree[1].r))&lt;&lt;endl; </span><br><span class="line">&#125;</span><br><span class="line"> // T[++cnt] = merge();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P3354 [IOI2005]Riv 河流</title>
      <link href="/2020/11/14/p3354/"/>
      <url>/2020/11/14/p3354/</url>
      
        <content type="html"><![CDATA[<h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给一颗$n$个节点的树,根节点是一个伐木场,每个节点都有一个村庄,每个村庄的每根木头运送到其父亲的代价是$d_i$,现在要建立$k$个伐木场,每个村庄有$w_i$根木头要沿树边运到最近的伐木场,求最小代价</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>树形$dp$</p><p>一开始比较容易想到的是设$f(i,j)$表示在$i$的子树中建立$j$个伐木场所花费的最小代价</p><p>发现无法得知一个节点的上一个伐木场在哪,即无法计算代价,考虑在状态中记录上一个伐木场的位置</p><p>设$f(i,j,k)$表示上一个伐木场的位置是$j$,$i$的子树中建立$j$个伐木场所花费的代价</p><p>有显然的转移:</p><center>$f(u,j,k) = min\{f(u,j,k-l)+min(f(v,v,l),f(v,j,l))\}(1≤l≤k)$</center><p>亿点细节:</p><ul><li><p>记得删除不合法的状态,详细见代码</p></li><li><p>枚举$j$时要先判断$j$是否在$u$的祖先中</p></li></ul><h2 id="code"><a href="#code" class="headerlink" title="$code$"></a>$code$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf (1&lt;&lt;30)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> head[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">e</span>&#123;</span><br><span class="line"><span class="type">int</span> v,w,next;</span><br><span class="line">&#125;edge[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> n,K;</span><br><span class="line"><span class="type">int</span> c[MAXN],f[MAXN][MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> is_fa[MAXN];</span><br><span class="line"><span class="type">int</span> dis[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">edge[++cnt].v = v;</span><br><span class="line">edge[cnt].next = head[u];</span><br><span class="line">edge[cnt].w = w;</span><br><span class="line">head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">is_fa[u] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++) <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=K;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!is_fa[i]) f[u][i][j] = inf;<span class="comment">//除去不合法状态</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">0</span>||u!=i) f[u][i][j] = (dis[u] - dis[i])*c[u];</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(j!=<span class="number">0</span>) f[u][i][j] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> f[u][i][j] = inf;<span class="comment">//显然在u=i且j=0时状态不合法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = edge[i].v;</span><br><span class="line">dis[v] = edge[i].w+dis[u];</span><br><span class="line"><span class="built_in">dfs</span>(v);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!is_fa[j]) <span class="keyword">continue</span>;<span class="comment">//判断是否为祖先</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=K;k&gt;=<span class="number">0</span>;k--)&#123;</span><br><span class="line">f[u][j][k]+=f[v][j][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> s=<span class="number">1</span>;s&lt;=k;s++)&#123;</span><br><span class="line">f[u][j][k] = <span class="built_in">min</span>(f[u][j][k],f[u][j][k-s]+<span class="built_in">min</span>(f[v][v][s],f[v][j][s]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">is_fa[u] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;K;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="type">int</span> u,w;</span><br><span class="line">cin&gt;&gt;c[i]&gt;&gt;u&gt;&gt;w;</span><br><span class="line"><span class="built_in">add</span>(u,i,w);</span><br><span class="line">dis[i] = w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">cout&lt;&lt;f[<span class="number">0</span>][<span class="number">0</span>][K];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划-树形dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF10D LCIS</title>
      <link href="/2020/11/08/cf10d/"/>
      <url>/2020/11/08/cf10d/</url>
      
        <content type="html"><![CDATA[<p><del>考完水篇博客放松一下</del></p><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>求两个串的最长公共上升子序列。</p><p>$1≤n,m≤500$</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>设$f(i,j)$表示$a$串中前$i$个字符,$b$串中前$j$个字符构成以$b_j$结尾的$LCIS$长度</p><p>有显然的转移:</p><ul><li>$a_i &#x3D; b_j$时</li></ul><p>$f(i,j) &#x3D; max\left{f(i-1,k)\right}+1(0≤k&lt;j,b_k&lt;a_i)$</p><ul><li>$a_i≠b_j$时</li></ul><p>$f(i,j) &#x3D; f(i-1,j)$</p><h2 id="code"><a href="#code" class="headerlink" title="$code$"></a>$code$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">510</span>;</span><br><span class="line"><span class="type">int</span> f[MAXN][MAXN],n,m,k,last[MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> a[MAXN],b[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> now)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">print</span>(i<span class="number">-1</span>,last[i][now]);</span><br><span class="line"><span class="keyword">if</span>(last[i][now]!=now)</span><br><span class="line">cout&lt;&lt;b[now]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line">cin&gt;&gt;m;<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) cin&gt;&gt;b[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(b[j]==a[i]) f[i][j] = f[i<span class="number">-1</span>][k]+<span class="number">1</span>,last[i][j] = k;</span><br><span class="line"><span class="keyword">else</span> f[i][j] = f[i<span class="number">-1</span>][j],last[i][j] = j;</span><br><span class="line"><span class="keyword">if</span>(b[j]&lt;a[i]&amp;&amp;f[i<span class="number">-1</span>][j]&gt;f[i<span class="number">-1</span>][k]) k = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(f[n][i]&gt;f[n][ans]) ans = i;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;f[n][ans]&lt;&lt;endl;</span><br><span class="line"><span class="built_in">print</span>(n,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划-线性dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SP263 PERIOD - Period</title>
      <link href="/2020/11/06/sp263/"/>
      <url>/2020/11/06/sp263/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>如果一个字符串$S$是由一个字符串$T$重复$K$次形成的，则称$T$是$S$的循环元。使$K$最大的字符串$T$称为$S$的最小循环元，此时的$K$称为最大循环次数。</p><p>现给一个给定长度为N的字符串$S$，对$S$的每一个前缀$S[1$~$i]$，如果它的最大循环次数大于$1$，则输出该前缀的长度和最大循环次数。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="引理"><a href="#引理" class="headerlink" title="引理"></a>引理</h3><p>$S[1$-$i]$具有长度$len&lt;i$的循环元的充要条件是$len$能整除$i$并且$S[len+1$-$i]&#x3D;S[1$~$i-len]$(即$i-len$是$KMP$算法中$next[i]$的”候选择”)</p><h3 id="证明"><a href="#证明" class="headerlink" title="证明:"></a>证明:</h3><p>首先,$len$能作为$S$的循环元,必须满足$len$能整除$i$,且$S[len+1$-$i]$和$S[1$-$i-len]$都是由$i&#x2F;len-1$个循环元构成的,即$S[len+1$-$i]&#x3D;S[1$-$i-len]$</p><p>其次,分别从$S[len+1$-$i]$和$S[1$-$i-len]$取前$len$个字符,可以发现$S[len+1$-$2*len]$ $&#x3D;$ $S[1$-$len]$,依此类推,可以发现$S[len+1$-$i]$和$S[1$-$i-len]$是以$len$为间隔错位对齐的,故$S[1$-$len]$是$S$的循环元</p><p>证毕</p><h2 id="code"><a href="#code" class="headerlink" title="$code$"></a>$code$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1000010</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> next[MAXN];</span><br><span class="line"><span class="type">char</span> s[MAXN],s2[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;s[i]!=s[j+<span class="number">1</span>]) j = next[j];</span><br><span class="line"><span class="keyword">if</span>(s[i]==s[j+<span class="number">1</span>]) j++;</span><br><span class="line">next[i] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line"><span class="type">int</span> now = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line">now++;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;s[i];</span><br><span class="line"><span class="built_in">pre</span>();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Test case #%d\n&quot;</span>, now);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">if</span>(i%(i-next[i])==<span class="number">0</span>&amp;&amp;i/(i-next[i])&gt;<span class="number">1</span>)&#123;</span><br><span class="line">cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;i/(i-next[i])&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《算法竞赛进阶指南》-李煜东</p><h1 id="CSP2020-RP"><a href="#CSP2020-RP" class="headerlink" title="CSP2020 RP++"></a>CSP2020 RP++</h1>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P4735 最大异或和(可持久化trie树模板)</title>
      <link href="/2020/10/31/p4735/"/>
      <url>/2020/10/31/p4735/</url>
      
        <content type="html"><![CDATA[<p><strong><a href="https://www.luogu.com.cn/problem/P4735">间隙</a></strong></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个非负整数序列 ${a}$，初始长度为$n$。</p><p>有 $m$ 个操作，有以下两种操作类型：</p><p>A x：添加操作，表示在序列末尾添加一个数 $x$，序列的长度 $n+1$。</p><p>Q l r x：询问操作，你需要找到一个位置 $p$，满足$x⊕a[p]⊕a[p+1]⊕…⊕a[N]⊕x$最大，输出最大是多少。</p><p>$N,M≤300000$</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>可持久化trie树模板</p><p>设$s[i]$表示前$i$个数$⊕$起来的结果,根据异或的性质:</p><p>$a_p⊕a_{p+1}⊕…⊕a[n]⊕x &#x3D; s[p-1]⊕s[n]⊕x$</p><p>对于添加操作,直接插入即可</p><p>对于查询操作:</p><p>维护一个数组$b_i$,表示节点$b_i$的子树中的最大版本号(最大下标)</p><p>显然,只有在最大版本号不小于$l-1$时该节点才合法,在合法的前提下尽可能地往与当前位相反的指针走</p><h2 id="code"><a href="#code" class="headerlink" title="$code$"></a>$code$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">600010</span>;</span><br><span class="line"><span class="type">int</span> n,m,child[MAXN*<span class="number">24</span>][<span class="number">2</span>], tot;</span><br><span class="line"><span class="type">int</span> s[MAXN],a[MAXN],root[MAXN],maxindex[MAXN*<span class="number">24</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;</span><br><span class="line">maxindex[node] = <span class="built_in">max</span>(maxindex[child[node][<span class="number">0</span>]],maxindex[child[node][<span class="number">1</span>]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> now,<span class="type">int</span> ind,<span class="type">int</span> last)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(now&lt;<span class="number">0</span>)&#123;</span><br><span class="line">maxindex[node] = ind;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> c = s[ind]&gt;&gt;now&amp;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(last) child[node][c^<span class="number">1</span>] = child[last][c^<span class="number">1</span>];</span><br><span class="line">child[node][c] = ++tot;</span><br><span class="line"><span class="built_in">insert</span>(child[node][c],now<span class="number">-1</span>,ind,child[last][c]);</span><br><span class="line"><span class="built_in">update</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> now,<span class="type">int</span> val,<span class="type">int</span> limit)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(now&lt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> s[maxindex[node]]^val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> c = val&gt;&gt;now&amp;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(maxindex[child[node][c^<span class="number">1</span>]]&gt;=limit)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">query</span>(child[node][c^<span class="number">1</span>],now<span class="number">-1</span>,val,limit);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">query</span>(child[node][c],now<span class="number">-1</span>,val,limit);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">maxindex[<span class="number">0</span>] = <span class="number">-1</span>;<span class="comment">//坑</span></span><br><span class="line">root[<span class="number">0</span>] = ++tot;</span><br><span class="line"><span class="built_in">insert</span>(root[<span class="number">0</span>],<span class="number">23</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">s[i] = s[i<span class="number">-1</span>]^x;</span><br><span class="line">root[i] = ++tot;</span><br><span class="line"><span class="built_in">insert</span>(root[i],<span class="number">23</span>,i,root[i<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="type">char</span> opt[<span class="number">2</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,opt);</span><br><span class="line"><span class="keyword">if</span>(opt[<span class="number">0</span>]==<span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;val);</span><br><span class="line">root[++n] = ++tot;</span><br><span class="line">s[n] = s[n<span class="number">-1</span>]^val;</span><br><span class="line"><span class="built_in">insert</span>(root[n],<span class="number">23</span>,n,root[n<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="type">int</span> l,r,x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;x);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">query</span>(root[r<span class="number">-1</span>],<span class="number">23</span>,x^s[n],l<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tire </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P4551 最长异或路径(01trie模板)</title>
      <link href="/2020/10/31/p4551/"/>
      <url>/2020/10/31/p4551/</url>
      
        <content type="html"><![CDATA[<p><strong><a href="https://www.luogu.com.cn/problem/P4551">间隙</a></strong></p><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给定一棵$n$个点的带权树，求最长的异或路径。</p><p>异或路径指的是指两个结点之间唯一路径上的所有边权的异或</p><p>$1≤n≤100000$</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>01trie模板</p><p>设$f_i$表示从根节点到$i$节点的异或路径,有显然的递推公式:$f_v &#x3D; f_{fa}⊕edge.w$</p><p>根据异或的性质,$x$到$y$之间的异或路径即为$f_v⊕f_u$($a⊕a &#x3D; 0$,即路径上重合的一部分恰好抵消)</p><p>于是可以将每个$f_i$的二进制串从左到右插入到一颗$trie$树中,并在查询时尽可能地往与当前位相反的指针走即可</p><h2 id="code"><a href="#code" class="headerlink" title="$code$"></a>$code$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">e</span>&#123;</span><br><span class="line"><span class="type">int</span> u,v,w,next;</span><br><span class="line">&#125;edge[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> head[MAXN&lt;&lt;<span class="number">1</span>],cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">++cnt;</span><br><span class="line">edge[cnt].w = w;</span><br><span class="line">edge[cnt].u = u;</span><br><span class="line">edge[cnt].v = v;</span><br><span class="line">edge[cnt].next = head[u];</span><br><span class="line">head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> child[MAXN*<span class="number">40</span>][<span class="number">2</span>],tot = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> a[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = edge[i].v;</span><br><span class="line"><span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">a[v] = a[u]^edge[i].w;</span><br><span class="line"><span class="built_in">dfs</span>(v,u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">30</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="type">int</span> now = a&gt;&gt;i&amp;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(!child[p][now]) child[p][now] = ++tot;</span><br><span class="line">p = child[p][now];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">findmax</span><span class="params">(<span class="type">int</span> a)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">30</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="type">int</span> now = a&gt;&gt;i&amp;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(child[p][now^<span class="number">1</span>])&#123;</span><br><span class="line">res|=<span class="number">1</span>&lt;&lt;i;</span><br><span class="line">p = child[p][now^<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">p = child[p][now];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans = <span class="built_in">max</span>(ans,res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line"><span class="type">int</span> u,v,w;</span><br><span class="line">cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line"><span class="built_in">add</span>(u,v,w);</span><br><span class="line"><span class="built_in">add</span>(v,u,w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">insert</span>(a[i]);</span><br><span class="line"><span class="built_in">findmax</span>(a[i]);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tire树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【模板】manacher算法</title>
      <link href="/2020/10/23/manacher%E7%AE%97%E6%B3%95/"/>
      <url>/2020/10/23/manacher%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>看进阶指南的时候看到的算法,正好最近<del>没啥事干</del>来学一下</p><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给一个长度为$n$字符串$S$,求$S$中的最长回文字串</p><p>$n≤1.1×10^7$</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h2 id="算法一"><a href="#算法一" class="headerlink" title="算法一"></a>算法一</h2><p>暴力</p><p>枚举每个点能扩散到的最大长度</p><p>时间复杂度$O(n^2)$</p><hr><h2 id="算法二"><a href="#算法二" class="headerlink" title="算法二"></a>算法二</h2><p>$hash+$二分</p><p>建立出$S$的前后缀$hash$值,然后二分答案,找到最大扩展长度</p><p>时间复杂度$O(nlogn)$</p><hr><h2 id="算法三"><a href="#算法三" class="headerlink" title="算法三"></a>算法三</h2><p>$manacher$<del>麻辣串</del>算法</p><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p>1.在每两个字符间插入一个额外字符,以去掉偶回文串的情况</p><hr><p>2.定义$r_i$表示以$i$为中心时的最大回文半径</p><p>$R$表示当前情况能扩展到的最右字符$(即最右回文右端点)$,$mid$表示最右回文的中心</p><p>考虑每个新进来的字符的情况:</p><p>$1.$ $i∈[mid,R]$</p><p>显然,$i$有一个关于$mid$的对称点$j &#x3D; mid×2-i$,根据对称性,$j$周围的字符和$i$周围的字符一定相同,于是可以先用$r_j$去更新$r_i$,即$r_i &#x3D; min(r_{mid×2-i},r_{mid}-i+mid)$,(右侧不能大于$R$,否则处于未知的位置,无法保证正确性),最后再去试试$i$还能不能扩展,同时更新$R$和$mid$的值</p><p>$2.$ $i∈(R,n]$</p><p>此时$i$处于一个未知的位置,因此只能暴力扩展,同时更新$R$和$mid$的值</p><p>最后的答案即为$(2*max(r_i)-2)&#x2F;2 &#x3D; max(r_i)-1$,由于$R$最多会向右移$n$次,因此总时间复杂度为线性($O(n)$)</p><h2 id="code"><a href="#code" class="headerlink" title="$code$"></a>$code$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">91000000</span>;</span><br><span class="line"><span class="type">char</span> c[MAXN];</span><br><span class="line"><span class="type">char</span> s[MAXN];</span><br><span class="line"><span class="type">int</span> L[MAXN],R[MAXN]; </span><br><span class="line"><span class="type">int</span> MAX_R;</span><br><span class="line"><span class="type">int</span> r[MAXN],len,mid; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">manacher</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(MAX_R&gt;i&amp;&amp;mid&lt;=i) r[i] = <span class="built_in">min</span>(r[mid*<span class="number">2</span>-i],r[mid]-i+mid);</span><br><span class="line"><span class="keyword">else</span> r[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(s[i+r[i]]==s[i-r[i]]) r[i]++;</span><br><span class="line"><span class="keyword">if</span>(i+r[i]&gt;MAX_R)&#123;</span><br><span class="line">mid = i;</span><br><span class="line">MAX_R = r[i]+i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;c;</span><br><span class="line">s[<span class="number">0</span>] =<span class="string">&#x27;#&#x27;</span>,s[<span class="number">1</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">len = <span class="built_in">strlen</span>(c); </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">s[i*<span class="number">2</span>+<span class="number">2</span>] = c[i];</span><br><span class="line">s[i*<span class="number">2</span>+<span class="number">3</span>] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">&#125; </span><br><span class="line">len = len*<span class="number">2</span>+<span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">-114514</span>;</span><br><span class="line"><span class="built_in">manacher</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">ans = <span class="built_in">max</span>(ans,r[i]);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans<span class="number">-1</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> manacher </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing 105. 七夕祭</title>
      <link href="/2020/10/17/ac105/"/>
      <url>/2020/10/17/ac105/</url>
      
        <content type="html"><![CDATA[<h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个$n×m$的矩阵,矩阵上有$t$个点有摊位,两个摊位相邻,当且仅当它们在同一行位置上,且每一行和每一列的第一个位置和最后一个位置也算作相邻</p><p>求至少需要交换多少个相邻摊位,能使得各行各列上的摊位数均相等</p><p>$1≤n,m≤100000$</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>经过观察可以发现交换上下相邻两个的节点只会改变某两行中的摊位数,交换左右两个相邻的节点只会改变某两列中的摊位数,因此可以把原问题拆成两个问题:</p><p>1.至少移动多少个相邻摊位可以使各行中的摊位数相同</p><p>2.至少移动多少个想来摊位可以使各列中的摊位数相同</p><p>先来考虑不是环形的情况</p><p>设$a[i]$表示第$i$行中的摊位数量</p><p>显然,这是个经典的均分纸牌问题,最终答案即为$\sum_{i&#x3D;1}^n|a[i]-\dfrac{t}{m}|$,列也同理</p><p>对于加上环形的情况,一种比较好想的处理方法是断换成链,枚举断开哪个点,但对于$1≤n,m≤100000$的数据范围肯定会T飞,考虑优化;</p><p>设$sum[i]$表示$\sum_{i&#x3D;1}^n|a[i]-\dfrac{t}{m}|$,即$|a[i]-\dfrac{t}{m}|$的前缀和</p><p>假设在第$k$个人后把环断开</p><p>显然,对于区间$[k+1,n]$的行,其前缀和为$sum[i]-sum[k]$</p><p>对于区间$[1,k]$之间的行,其前缀和为$sum[i]+sum[n]-sum[k]$</p><p>又因为$sum[m]$必定是$0$,因此前缀和的变化就是每个位置都减掉$sum[k]$</p><p>答案即为$\sum_{i&#x3D;1}^n|sum[i]-sum[k]|$</p><p>把每个$sum[i]$都看作数轴上的一个点,那么就变成了一个经典的中位数最短距离问题:</p><p>在一个数轴上有$n$个点,从中选出一个点,使得其他的点到该点的距离之和最小</p><p>将$sum$排序后取中位数即可</p><p>总复杂度$O(nlogn+mlogm)$</p><h2 id="code"><a href="#code" class="headerlink" title="$code$"></a>$code$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m,t;</span><br><span class="line"><span class="type">int</span> row[MAXN];</span><br><span class="line"><span class="type">int</span> col[MAXN];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ROW</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> sum[MAXN];</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> unneed = t/n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) row[i]-=t/n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) sum[i] = sum[i<span class="number">-1</span>]+row[i];</span><br><span class="line"><span class="built_in">sort</span>(sum+<span class="number">1</span>,sum+n+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n/<span class="number">2</span>;i++) ans+=sum[n-i+<span class="number">1</span>]-sum[i];</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">COL</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> sum[MAXN];</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> unneed = t/m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) col[i]-=t/m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) sum[i] = sum[i<span class="number">-1</span>]+col[i];</span><br><span class="line"><span class="built_in">sort</span>(sum+<span class="number">1</span>,sum+m+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m/<span class="number">2</span>;i++) ans+=sum[m-i+<span class="number">1</span>]-sum[i];</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m&gt;&gt;t;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;i++)&#123;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">row[x]++;</span><br><span class="line">col[y]++;</span><br><span class="line">cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(cnt%n==<span class="number">0</span>&amp;&amp;cnt%m==<span class="number">0</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;both &quot;</span>;</span><br><span class="line">cout&lt;&lt;<span class="built_in">ROW</span>()+<span class="built_in">COL</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(cnt%n==<span class="number">0</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;row &quot;</span>;</span><br><span class="line">cout&lt;&lt;<span class="built_in">ROW</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(cnt%m==<span class="number">0</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;column &quot;</span>;</span><br><span class="line">cout&lt;&lt;<span class="built_in">COL</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;impossible&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中位数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P4141 消失之物</title>
      <link href="/2020/10/09/p4141/"/>
      <url>/2020/10/09/p4141/</url>
      
        <content type="html"><![CDATA[<h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给$n$个物品和一个容量为$m$的背包,设$cnt(i,x)$表示删去某个物品$i$时填满容量为$x$的背包的方案数</p><p>求所有的$cnt(i,x)$</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>容斥+$dp$</p><p>和<a href="https://www.luogu.com.cn/problem/P1450"><strong>P1450 [HAOI2008]硬币购物</strong></a>大同小异的解法</p><p>总方案数 $&#x3D;$ 不删去物品时的方案数 $-$ 不合法的方案数</p><p>设$f[j]$表示不删去任何物品时背包容量为$j$时的方案数,$g[j]$表示删去物品$i$时填充容量为$j$的背包的方案数</p><p>对于不删去物品时方案数,直接跑一遍01背包即可，对于不合法的方案数:</p><p>当且仅当一个方案使用了第$i$个物品时该改方案不合法,有一个比较容易想到的转移,即:</p><p>$g[j] &#x3D; f[j] - f[j-w[i]]$</p><p><del>显然是错的</del>,因为在$f[j-w[i]]$中可能也有$w[i]$的贡献</p><p>因此因改为:</p><p>$g[j] &#x3D; f[j] - g[j-w[i]]$</p><h2 id="code"><a href="#code" class="headerlink" title="$code$"></a>$code$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">2010</span>;</span><br><span class="line"><span class="type">int</span> f[MAXN],w[MAXN],n,m;</span><br><span class="line"><span class="type">int</span> ie[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">ie[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;w[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=m;j&gt;=w[i];j--)&#123;</span><br><span class="line">f[j]+=f[j-w[i]];</span><br><span class="line">f[j]%=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;w[i];j++)&#123;</span><br><span class="line">ie[j] = f[j];</span><br><span class="line">ie[j]%=<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=w[i];j&lt;=m;j++)&#123;</span><br><span class="line">ie[j] = (f[j] - ie[j-w[i]]+<span class="number">10</span>)%<span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++) cout&lt;&lt;ie[j];</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>听说ZJ今年复赛晋级人数要下降30%…怕不是要初赛AFO了&#x2F;kk</del></p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划-背包dp </tag>
            
            <tag> 容斥 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P2827 蚯蚓</title>
      <link href="/2020/10/05/p2827/"/>
      <url>/2020/10/05/p2827/</url>
      
        <content type="html"><![CDATA[<h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给$n$个数,$m$次操作,每次操作都将最大的一个数$K$分割为$p×K$和$K-p×K$两个数,每次操作后未被切割的数都会长长$q$,现在要求:</p><p>1.第$1t,2t,3t,…$次操作时被切割的数的大小($t$为给定参数)</p><p>2.操作完成后排名为$1t,2t,3t,…$的数的大小</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="算法一"><a href="#算法一" class="headerlink" title="算法一"></a>算法一</h3><p>直接开一个堆来模拟</p><p>可以获得$90pts$的<del>超高</del>分</p><p>复杂度约为$O(mlogn)$</p><h2 id="code"><a href="#code" class="headerlink" title="$code$"></a>$code$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> X=<span class="number">0</span>; <span class="type">bool</span> flag=<span class="number">1</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) flag=<span class="number">0</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">if</span>(flag) <span class="keyword">return</span> X;</span><br><span class="line"><span class="keyword">return</span> ~(X<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt;que;</span><br><span class="line"><span class="type">int</span> n,m,q,u,v,t;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n = <span class="built_in">read</span>(),m =<span class="built_in">read</span>(),q =<span class="built_in">read</span>(),u =<span class="built_in">read</span>(),v =<span class="built_in">read</span>(),t =<span class="built_in">read</span>();</span><br><span class="line"><span class="type">int</span> qy;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">qy = <span class="built_in">read</span>();</span><br><span class="line">que.<span class="built_in">push</span>(qy);</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">double</span> px = (<span class="type">double</span>)u/v;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="type">int</span> now = que.<span class="built_in">top</span>()+val;</span><br><span class="line">val+=q;</span><br><span class="line">que.<span class="built_in">pop</span>();</span><br><span class="line"><span class="type">int</span> xx = (<span class="type">double</span>)(px*now),yy = now - xx;</span><br><span class="line">xx-=val,yy-=val;</span><br><span class="line">que.<span class="built_in">push</span>(xx),que.<span class="built_in">push</span>(yy);</span><br><span class="line"><span class="keyword">if</span>(i%t==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,now);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"><span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line"><span class="type">int</span> now = que.<span class="built_in">top</span>()+val;</span><br><span class="line">que.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span>(T%t==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,now);</span><br><span class="line">T++;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法二"><a href="#算法二" class="headerlink" title="算法二"></a>算法二</h2><p>通过观察可以发现:</p><p>假设有两个数$x$和$y$,且$x≥y$,那么两个数被切割后分别为</p><p>$p×x$和$(1-p)×x$,$p×y$和$(1-p)×y$</p><p>易得</p><p>$p×x≥p×y$,$(1-p)×x≥(1-p)×y$</p><p>说明被切割后的两个数具有单调性</p><p>可以开三个队列,一个存储经排序后的原数,另外两个分别存储被切割后的两个数</p><p>每次操作时取三个队首中最大的一个,并弹出即可</p><p>复杂度为$O(m+nlogn)$</p><h2 id="code-1"><a href="#code-1" class="headerlink" title="$code$"></a>$code$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> X=<span class="number">0</span>; <span class="type">bool</span> flag=<span class="number">1</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) flag=<span class="number">0</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">if</span>(flag) <span class="keyword">return</span> X;</span><br><span class="line"><span class="keyword">return</span> ~(X<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt;q1,q2,q3;</span><br><span class="line"><span class="type">int</span> n,m,q,u,v,t;</span><br><span class="line"><span class="type">int</span> a[<span class="number">100005</span>];</span><br><span class="line"><span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="keyword">return</span> x&gt;y;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">choise</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">1</span>) q1.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(x==<span class="number">2</span>) q2.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">else</span> q3.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> n = <span class="built_in">read</span>(),m =<span class="built_in">read</span>(),q =<span class="built_in">read</span>(),u =<span class="built_in">read</span>(),v =<span class="built_in">read</span>(),t =<span class="built_in">read</span>();</span><br><span class="line"><span class="type">int</span> qy;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">a[i] = <span class="built_in">read</span>();</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">double</span> px = (<span class="type">double</span>)u/v;</span><br><span class="line"><span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>,cmp);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">q1.<span class="built_in">push</span>(a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="type">int</span> que,now = <span class="number">-11451419</span>;</span><br><span class="line"><span class="keyword">if</span>(!q1.<span class="built_in">empty</span>()&amp;&amp;q1.<span class="built_in">front</span>()+val&gt;now) now = q1.<span class="built_in">front</span>()+val,que = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(!q2.<span class="built_in">empty</span>()&amp;&amp;q2.<span class="built_in">front</span>()+val&gt;now) now = q2.<span class="built_in">front</span>()+val,que = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(!q3.<span class="built_in">empty</span>()&amp;&amp;q3.<span class="built_in">front</span>()+val&gt;now) now = q3.<span class="built_in">front</span>()+val,que = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">choise</span>(que);</span><br><span class="line">val+=q;</span><br><span class="line"><span class="type">int</span> xx = (<span class="type">double</span>)(px*now),yy = now - xx;</span><br><span class="line">xx-=val,yy-=val;</span><br><span class="line">q2.<span class="built_in">push</span>(xx),q3.<span class="built_in">push</span>(yy);</span><br><span class="line"><span class="keyword">if</span>(i%t==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,now);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> T = <span class="number">1</span>;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"><span class="keyword">while</span>(!(q1.<span class="built_in">empty</span>()&amp;&amp;q2.<span class="built_in">empty</span>()&amp;&amp;q3.<span class="built_in">empty</span>()))&#123;</span><br><span class="line"><span class="type">int</span> que,now = <span class="number">-11451419</span>;</span><br><span class="line"><span class="keyword">if</span>(!q1.<span class="built_in">empty</span>()&amp;&amp;q1.<span class="built_in">front</span>()+val&gt;now) now = q1.<span class="built_in">front</span>()+val,que = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(!q2.<span class="built_in">empty</span>()&amp;&amp;q2.<span class="built_in">front</span>()+val&gt;now) now = q2.<span class="built_in">front</span>()+val,que = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(!q3.<span class="built_in">empty</span>()&amp;&amp;q3.<span class="built_in">front</span>()+val&gt;now) now = q3.<span class="built_in">front</span>()+val,que = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">choise</span>(que);</span><br><span class="line"><span class="keyword">if</span>(T%t==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,now);</span><br><span class="line">T++; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P2679 子串</title>
      <link href="/2020/10/05/p2679/"/>
      <url>/2020/10/05/p2679/</url>
      
        <content type="html"><![CDATA[<p>update on 2021&#x2F;1&#x2F;24</p><p><strong><a href="https://www.luogu.com.cn/problem/P2679">题目链接</a></strong></p><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给两个字符串$A$和$B$,从字符串 $A$ 中取出 $k$ 个互不重叠的非空子串，把这 $k$ 个子串按照其在字符串 $A$ 中出现的顺序依次连接起来得到一个新的字符串,求有多少种方案可以使这个新串和字符串$B$相等</p><p>$1≤n≤1000,1≤m≤200,1≤k≤m$</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>设$f(i,j,k,0&#x2F;1)$表示在$A$中的前$i$个字符,$B$中前$j$个字符,一共拆了$k$个字串,第$i$个字符选$&#x2F;$不选的方案数,分类讨论拼接的情况,有显然的转移:</p><p>$f(i,j,k,1) &#x3D; f(i-1,j-1,k,0)+f(i-1,j-1,k-1,1)+f_(i-1,j-1,k,1)$</p><p>$f(i,j,k,0) &#x3D; f(i-1,j,k,1)+f(i-1,j,k,0)$</p><p>再用滚动数组优化一下即可</p><p>时间复杂度$O(nmk)$</p><h2 id="code"><a href="#code" class="headerlink" title="$code$"></a>$code$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//90pts</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mo 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN =<span class="number">1005</span>;</span><br><span class="line"><span class="type">int</span> f[<span class="number">1005</span>][<span class="number">110</span>][<span class="number">110</span>][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> n,m,k0;</span><br><span class="line">string a,b;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>; </span><br><span class="line">cin&gt;&gt;n&gt;&gt;m&gt;&gt;k0;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">a = <span class="string">&#x27; &#x27;</span>+a;</span><br><span class="line">b = <span class="string">&#x27; &#x27;</span>+b;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">f[i][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=k0;k++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]==b[j])&#123;</span><br><span class="line">f[i][j][k][<span class="number">0</span>] = (f[i<span class="number">-1</span>][j][k][<span class="number">1</span>]+f[i<span class="number">-1</span>][j][k][<span class="number">0</span>])%mo;</span><br><span class="line">f[i][j][k][<span class="number">1</span>] = ((f[i<span class="number">-1</span>][j<span class="number">-1</span>][k<span class="number">-1</span>][<span class="number">0</span>]+f[i<span class="number">-1</span>][j<span class="number">-1</span>][k<span class="number">-1</span>][<span class="number">1</span>])%mo+f[i<span class="number">-1</span>][j<span class="number">-1</span>][k][<span class="number">1</span>])%mo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">f[i][j][k][<span class="number">0</span>] = (f[i<span class="number">-1</span>][j][k][<span class="number">1</span>]+f[i<span class="number">-1</span>][j][k][<span class="number">0</span>])%mo;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;(f[n][m][k0][<span class="number">0</span>]+f[n][m][k0][<span class="number">1</span>])%mo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mo 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN =<span class="number">1005</span>;</span><br><span class="line"><span class="type">int</span> f[<span class="number">2</span>][<span class="number">205</span>][MAXN][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> n,m,k0;</span><br><span class="line">string a,b;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> now = <span class="number">1</span>;</span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] =  <span class="number">1</span>;</span><br><span class="line">f[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] =  <span class="number">1</span>;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m&gt;&gt;k0;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">a = <span class="string">&#x27; &#x27;</span>+a;</span><br><span class="line">b = <span class="string">&#x27; &#x27;</span>+b;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=k0;k++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]==b[j])&#123;</span><br><span class="line">f[now][j][k][<span class="number">0</span>] = (f[now^<span class="number">1</span>][j][k][<span class="number">1</span>]+f[now^<span class="number">1</span>][j][k][<span class="number">0</span>])%mo;</span><br><span class="line">f[now][j][k][<span class="number">1</span>] = ((f[now^<span class="number">1</span>][j<span class="number">-1</span>][k<span class="number">-1</span>][<span class="number">0</span>]+f[now^<span class="number">1</span>][j<span class="number">-1</span>][k<span class="number">-1</span>][<span class="number">1</span>])%mo+f[now^<span class="number">1</span>][j<span class="number">-1</span>][k][<span class="number">1</span>])%mo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">f[now][j][k][<span class="number">0</span>] = (f[now^<span class="number">1</span>][j][k][<span class="number">1</span>]+f[now^<span class="number">1</span>][j][k][<span class="number">0</span>])%mo;</span><br><span class="line">f[now][j][k][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">now^=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;(f[n&amp;<span class="number">1</span>][m][k0][<span class="number">0</span>]+f[n&amp;<span class="number">1</span>][m][k0][<span class="number">1</span>])%mo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划-区间dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P3959 宝藏</title>
      <link href="/2020/10/04/p3959/"/>
      <url>/2020/10/04/p3959/</url>
      
        <content type="html"><![CDATA[<h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给一张$n$个点$m$条边的图,求出一颗生成树,生成树中的每条边的边权为该边的边权$w$$×$该边的深度$dep$,求生成树的最小权值和</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>枚举每个点暴力$dfs$肯定会$T$飞</p><p>发现$n≤12$且有重复状态,考虑状态压缩；</p><p>设$f[i][j][k]$表示当前点集为$i$,且父亲为$j$,深度为$j$时的最小代价</p><p>枚举集合$i$的子集$s$和$u$的儿子$v$</p><p>当且仅当子集合法时,有转移:</p><p>$f[i][u][k] &#x3D; min(f[s][j][k]+f[s$^$i][v][k+1]+edge(u,v)×k)$</p><p>$(u∈s,v∈s$^$i,edge(u,v)!&#x3D;inf)$</p><p>采用记忆化搜索的形式来实现</p><p>要注意的是当一个状态被访问过且该状态的$f$数组还未被更新时也要特判</p><h2 id="code"><a href="#code" class="headerlink" title="$code$"></a>$code$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">15</span>;</span><br><span class="line"><span class="type">int</span> n,m,ans;</span><br><span class="line"><span class="type">int</span> edge[MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> f[<span class="number">1</span>&lt;&lt;(MAXN)][MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> vis[<span class="number">1</span>&lt;&lt;(MAXN)][MAXN][MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> status,<span class="type">int</span> u,<span class="type">int</span> dep)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(f[status][u][dep]!=<span class="number">-1</span>) <span class="keyword">return</span> f[status][u][dep];</span><br><span class="line"><span class="keyword">if</span>(vis[status][u][dep]) <span class="keyword">return</span> inf;</span><br><span class="line">vis[status][u][dep] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(status==(<span class="number">1</span>&lt;&lt;(u<span class="number">-1</span>))) <span class="keyword">return</span> f[status][u][dep] = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> ans = inf;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> s = status;s;s = (s<span class="number">-1</span>) &amp; status)&#123;</span><br><span class="line"><span class="keyword">if</span>(!(s&amp;(<span class="number">1</span>&lt;&lt;(u<span class="number">-1</span>)))) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> v=<span class="number">1</span>;v&lt;=n;v++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!(status&amp;(<span class="number">1</span>&lt;&lt;(v<span class="number">-1</span>)))||edge[u][v] == edge[<span class="number">0</span>][<span class="number">0</span>]) <span class="keyword">continue</span>;</span><br><span class="line">ans = <span class="built_in">min</span>(ans,<span class="built_in">dfs</span>(s,u,dep)+<span class="built_in">dfs</span>((s^status),v,dep+<span class="number">1</span>)+edge[u][v]*dep);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f[status][u][dep] = ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">ans = inf;</span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">-1</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line"><span class="built_in">memset</span>(edge,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(edge));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="type">int</span> u,v,w;</span><br><span class="line">cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">edge[u][v] = edge[v][u] = <span class="built_in">min</span>(edge[u][v],w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">ans = <span class="built_in">min</span>(ans,<span class="built_in">dfs</span>((<span class="number">1</span>&lt;&lt;n)<span class="number">-1</span>,i,<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划-状压dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P5628 【AFOI-19】面基</title>
      <link href="/2020/10/04/p5628/"/>
      <url>/2020/10/04/p5628/</url>
      
        <content type="html"><![CDATA[<h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给一颗$n$个节点的带边权树,每条边权的值为边两端的端点所形成的子树的乘积,求</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>换根$dp$板子题(或者说是树上容斥?)</p><p>细节有点坑</p><p>设$f[u][j]$表示以$u$为根,距离$u$小于等于$k$的边权和</p><p>先以任意一个节点$u$为根,计算$u$的子树对$u$的贡献,即$f[u][j] &#x3D; \sum f[v][j-1]$</p><p>接下来从$u$去转移到其他节点</p><p>新节点的边权和 $&#x3D;$ 父亲对它的贡献$+$子树对它的贡献 $-$ 重复的部分</p><p>易得转移$:$</p><p>$f[v][j] &#x3D;f[v][j]+ f[u][j-1]-f[v]<a href="j%E2%89%A52">j-2</a>$</p><p><strong>几个坑点</strong></p><ul><li><p>$j&#x3D;1$要特判</p></li><li><p>一个点能截断所有与该点相连的道路,因此道路的距离可能为$k+1$</p></li></ul><h2 id="code"><a href="#code" class="headerlink" title="$code$"></a>$code$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">30010</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">int</span> ans = <span class="number">-114514191919</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">e</span>&#123;</span><br><span class="line"><span class="type">int</span> u,v,w,next;</span><br><span class="line">&#125;edge[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> head[MAXN],val[MAXN];</span><br><span class="line"><span class="type">int</span> n,k,cnt = <span class="number">1</span>,size[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">++cnt;</span><br><span class="line">edge[cnt].u = u;</span><br><span class="line">edge[cnt].v = v;</span><br><span class="line">edge[cnt].next = head[u];</span><br><span class="line">head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> f[MAXN][<span class="number">310</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">size[u] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = edge[i].v;</span><br><span class="line"><span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs1</span>(v,u);</span><br><span class="line">size[u]+=size[v];</span><br><span class="line">edge[i].w = size[v]*(n-size[v]); </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = edge[i].v;</span><br><span class="line"><span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=k+<span class="number">1</span>;j++)&#123;</span><br><span class="line">f[u][j]+=edge[i].w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs2</span>(v,u);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=k+<span class="number">1</span>;j++)</span><br><span class="line">     f[u][j]+=f[v][j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(u!=<span class="number">1</span>)&#123;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=k+<span class="number">1</span>;i&gt;=<span class="number">2</span>;i--)&#123;</span><br><span class="line">f[u][i] += f[fa][i<span class="number">-1</span>] - f[u][i<span class="number">-2</span>];</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">ans = <span class="built_in">max</span>(ans , f[u][k+<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = edge[i].v;</span><br><span class="line"><span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">f[v][<span class="number">1</span>]+=edge[i].w;</span><br><span class="line"><span class="built_in">dp</span>(v,u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="type">int</span> u,v;</span><br><span class="line">cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line"><span class="built_in">add</span>(u,v),<span class="built_in">add</span>(v,u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">dp</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划-树形dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P1967 货车运输</title>
      <link href="/2020/10/03/p1967/"/>
      <url>/2020/10/03/p1967/</url>
      
        <content type="html"><![CDATA[<h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给一张$n$个点,$m$条边的带边权无向图,现在有$q$次询问,每次询问都给一个$x$和$y$,求$x$到$y$的路径上长度最小的边的大小</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>大水题</p><p>先跑一遍最小生成树</p><p>然后把点权转成边权,上树剖即可</p><h2 id="code"><a href="#code" class="headerlink" title="$code$"></a>$code$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson (node&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson (node&lt;&lt;1|1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 1145141919</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">20010</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">e</span>&#123;</span><br><span class="line"><span class="type">int</span> u,v,w,next;</span><br><span class="line">&#125;edge[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">koishi</span>&#123;</span><br><span class="line"><span class="type">int</span> u,v,w;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> koishi &amp;k)<span class="type">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> w&gt;k.w;</span><br><span class="line">&#125;</span><br><span class="line">&#125;a[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> head[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> w[MAXN&lt;&lt;<span class="number">2</span>],n,m;</span><br><span class="line"><span class="type">int</span> dep[MAXN],son[MAXN],fa[MAXN],size[MAXN],faa[MAXN];</span><br><span class="line"><span class="type">int</span> id[MAXN],val[MAXN],tot = <span class="number">0</span>,cnt = <span class="number">1</span>,top[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(faa[x]==x) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> faa[x] = <span class="built_in">find</span>(faa[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">edge[cnt].u = u;</span><br><span class="line">edge[cnt].v = v;</span><br><span class="line">edge[cnt].w = w;</span><br><span class="line">edge[cnt].next = head[u];</span><br><span class="line">head[u] = cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> f,<span class="type">int</span> deep)</span></span>&#123;</span><br><span class="line">dep[u] = deep;</span><br><span class="line">fa[u] = f;</span><br><span class="line">size[u] = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> maxson = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = edge[i].v;</span><br><span class="line"><span class="keyword">if</span>(v==f) <span class="keyword">continue</span>;</span><br><span class="line">w[v] = edge[i].w;</span><br><span class="line"><span class="built_in">dfs1</span>(v,u,deep+<span class="number">1</span>);</span><br><span class="line">size[u]+=size[v];</span><br><span class="line"><span class="keyword">if</span>(size[v]&gt;maxson)&#123;</span><br><span class="line">son[u] = v;</span><br><span class="line">maxson = size[v];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> topf)</span></span>&#123;</span><br><span class="line">id[u] = ++tot;</span><br><span class="line">val[tot] = u;</span><br><span class="line">top[u] = topf;</span><br><span class="line"><span class="keyword">if</span>(!son[u]) <span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">dfs2</span>(son[u],topf);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = edge[i].v;</span><br><span class="line"><span class="keyword">if</span>(v==son[u]||v==fa[u]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs2</span>(v,v);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st</span>&#123;</span><br><span class="line"><span class="type">int</span> minn,l,r,tag;</span><br><span class="line">&#125;tree[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;</span><br><span class="line">tree[node].minn = <span class="built_in">min</span>(tree[lson].minn,tree[rson].minn);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">tree[node].l = l,tree[node].r = r;</span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">tree[node].minn = w[val[l]];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">build</span>(lson,l,mid);</span><br><span class="line"><span class="built_in">build</span>(rson,mid+<span class="number">1</span>,r);</span><br><span class="line"><span class="built_in">update</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(x&lt;=tree[node].l&amp;&amp;tree[node].r&lt;=y)&#123;</span><br><span class="line"><span class="keyword">return</span> tree[node].minn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> mid = (tree[node].l+tree[node].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> now = inf;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=mid) now = <span class="built_in">min</span>(now,<span class="built_in">query</span>(lson,x,y));</span><br><span class="line"><span class="keyword">if</span>(y&gt;mid) now = <span class="built_in">min</span>(now,<span class="built_in">query</span>(rson,x,y));</span><br><span class="line"><span class="keyword">return</span> now;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qb</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> ans = inf;</span><br><span class="line"><span class="keyword">while</span>(top[u]!=top[v])&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]]) <span class="built_in">swap</span>(u,v);</span><br><span class="line">ans=<span class="built_in">min</span>(ans,<span class="built_in">query</span>(<span class="number">1</span>,id[top[u]],id[u]));</span><br><span class="line">u = fa[top[u]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dep[u]&gt;dep[v]) <span class="built_in">swap</span>(u,v);</span><br><span class="line">ans=<span class="built_in">min</span>(ans,<span class="built_in">query</span>(<span class="number">1</span>,id[u]+<span class="number">1</span>,id[v]));</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">faa[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="built_in">find</span>(a[i].u),y = <span class="built_in">find</span>(a[i].v);</span><br><span class="line"><span class="keyword">if</span>(x!=y)&#123;</span><br><span class="line">faa[x] = y;</span><br><span class="line"><span class="built_in">add</span>(a[i].u,a[i].v,a[i].w),<span class="built_in">add</span>(a[i].v,a[i].u,a[i].w);</span><br><span class="line">tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(tot==n<span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(w,<span class="number">-1</span>,<span class="built_in">sizeof</span>(w));</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">cin&gt;&gt;a[i].u&gt;&gt;a[i].v&gt;&gt;a[i].w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+m);</span><br><span class="line"><span class="built_in">kruskal</span>();</span><br><span class="line"><span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="type">int</span> q;</span><br><span class="line">cin&gt;&gt;q;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=q;i++)&#123;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line"><span class="type">int</span> xx = <span class="built_in">find</span>(x),yy = <span class="built_in">find</span>(y);</span><br><span class="line"><span class="keyword">if</span>(xx!=yy) cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="built_in">qb</span>(x,y)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>水博客好爽啊</del></p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论-最小生成树 </tag>
            
            <tag> 树链剖分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P3953 逛公园</title>
      <link href="/2020/10/03/p3953/"/>
      <url>/2020/10/03/p3953/</url>
      
        <content type="html"><![CDATA[<h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一张$n$个点$m$条边的有向图,求出从$1$号点到$n$号点长度$≤d+k$的路径条数($d$表示从$1$到$n$的最短路长度)</p><p>$n≤100000,m≤200000,k≤50$</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>注意到$k≤50$,考虑$dp$</p><h3 id="dp"><a href="#dp" class="headerlink" title="$dp$"></a>$dp$</h3><p>设$f[i][j]$表示走到$i$这个点时有$j$步可多走且到达终点时恰好走完$j$步的方案数</p><p>假设有一条要转移的边$(u,v,w)$</p><p>那么到达$u$时走的总路程即为$d_u+k-j$</p><p>再从$u$走到$v$就走了$d_u+k-j+w$</p><p>剩下的步数即为$k +d_v- (d_u+k-j+w)  &#x3D; d_v - d_u+j-w$</p><p>易得转移:</p><p>$f[u][j] &#x3D; f[v][d_v - d_u+j-w]$</p><p>使用记忆化搜索来实现</p><h3 id="判零环"><a href="#判零环" class="headerlink" title="判零环"></a>判零环</h3><p>此题最坑的地方</p><p>一个比较容易想到的处理方式是在$dfs$的时候记录状态是否出现过,若一个状态出现过两次则说明产生了零环</p><p>但不是所有的零环都会被跑，如果有一个零环被经过时的路径总和大于$k+d_n$,那他就不会被经过</p><p>可以建个反图,然后跑一遍原图的最短路和反图的最短路,然后枚举每个点,判断该点是否满足$d1_i+d2_i≤k+d1_n$,若不满足,则打上一个标记,在$dfs$的时候特判即可</p><p><strong>几个坑点</strong></p><ul><li>$dp$时要判断状态是否合法</li></ul><h2 id="code"><a href="#code" class="headerlink" title="$code$"></a>$code$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100005</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">e</span>&#123;</span><br><span class="line"><span class="type">int</span> to,next,w;</span><br><span class="line">&#125;edge1[MAXN&lt;&lt;<span class="number">1</span>],edge2[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="comment">//----------------------------------edge</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line"><span class="type">int</span> index,dist;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> node &amp;x)<span class="type">const</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> dist&gt;x.dist;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//----------------------------------</span></span><br><span class="line">priority_queue&lt;node&gt; q;</span><br><span class="line"><span class="type">int</span> dis1[MAXN],dis2[MAXN],cnt1,cnt2,head1[MAXN],head2[MAXN],vis[MAXN],n;</span><br><span class="line"><span class="type">int</span> f[MAXN][<span class="number">60</span>];</span><br><span class="line"><span class="type">bool</span> ch[MAXN][<span class="number">60</span>];</span><br><span class="line"><span class="type">bool</span> c[MAXN];</span><br><span class="line"><span class="type">int</span> m,k,p;</span><br><span class="line"><span class="comment">//----------------------------------</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">edge1[++cnt1].next = head1[u];</span><br><span class="line">edge1[cnt1].to = v;</span><br><span class="line">edge1[cnt1].w = w;</span><br><span class="line">head1[u] = cnt1;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">edge2[++cnt2].next = head2[u];</span><br><span class="line">edge2[cnt2].to = v;</span><br><span class="line">edge2[cnt2].w = w;</span><br><span class="line">head2[u] = cnt2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//----------------------------------++edge</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dij1</span><span class="params">(<span class="type">int</span> now)</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">node h = &#123;now,<span class="number">0</span>&#125;;</span><br><span class="line">q.<span class="built_in">push</span>(h);</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">node u = q.<span class="built_in">top</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span>(vis[u.index]) <span class="keyword">continue</span>;</span><br><span class="line">vis[u.index] = <span class="number">1</span>;</span><br><span class="line">dis1[u.index] = u.dist;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head1[u.index];i;i=edge1[i].next)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[edge1[i].to]) <span class="keyword">continue</span>;</span><br><span class="line">h.dist = u.dist+edge1[i].w;</span><br><span class="line">h.index = edge1[i].to;</span><br><span class="line">q.<span class="built_in">push</span>(h);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dij2</span><span class="params">(<span class="type">int</span> now)</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line">node h = &#123;now,<span class="number">0</span>&#125;;</span><br><span class="line">q.<span class="built_in">push</span>(h);</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">node u = q.<span class="built_in">top</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span>(vis[u.index]) <span class="keyword">continue</span>;</span><br><span class="line">vis[u.index] = <span class="number">1</span>;</span><br><span class="line">dis2[u.index] = u.dist;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head2[u.index];i;i=edge2[i].next)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[edge2[i].to]) <span class="keyword">continue</span>;</span><br><span class="line">h.dist = u.dist+edge2[i].w;</span><br><span class="line">h.index = edge2[i].to;</span><br><span class="line">q.<span class="built_in">push</span>(h);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//----------------------------------dij</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">cnt1 = cnt2 = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(c,<span class="number">0</span>,<span class="built_in">sizeof</span>(c));</span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">-1</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line"><span class="built_in">memset</span>(head1,<span class="number">0</span>,<span class="built_in">sizeof</span>(head1));</span><br><span class="line"><span class="built_in">memset</span>(head2,<span class="number">0</span>,<span class="built_in">sizeof</span>(head2));</span><br><span class="line"><span class="built_in">memset</span>(ch,<span class="number">0</span>,<span class="built_in">sizeof</span>(ch));</span><br><span class="line"><span class="built_in">memset</span>(dis1,<span class="number">127</span>,<span class="built_in">sizeof</span>(dis1));</span><br><span class="line"><span class="built_in">memset</span>(dis2,<span class="number">127</span>,<span class="built_in">sizeof</span>(dis2));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//----------------------------------clear</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> now,<span class="type">int</span> lest)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(ch[now][lest]) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(f[now][lest]!=<span class="number">-1</span>) <span class="keyword">return</span> f[now][lest];</span><br><span class="line">ch[now][lest] = <span class="number">1</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> sum  = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(now==n&amp;&amp;lest==<span class="number">0</span>) sum++;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head1[now];i;i=edge1[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = edge1[i].to;</span><br><span class="line"><span class="keyword">if</span>(!c[v]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(dis1[v]+lest-dis1[now]-edge1[i].w&lt;<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="type">int</span> val = <span class="built_in">dfs</span>(v,dis1[v]-dis1[now]+lest-edge1[i].w);</span><br><span class="line"><span class="keyword">if</span>(val==<span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">sum+=val;</span><br><span class="line">sum%=p;</span><br><span class="line">&#125;</span><br><span class="line">f[now][lest] = sum;</span><br><span class="line">ch[now][lest] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> sum;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//----------------------------------dfs</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line"><span class="built_in">clear</span>();</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;p;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="type">int</span> u,v,w;</span><br><span class="line">cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line"><span class="built_in">add1</span>(u,v,w);</span><br><span class="line"><span class="built_in">add2</span>(v,u,w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dij1</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">dij2</span>(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(dis1[i]+dis2[i]&gt;k+dis1[n]) <span class="keyword">continue</span>;</span><br><span class="line">c[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> b = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=k;i++)&#123;</span><br><span class="line"><span class="type">int</span> now = <span class="built_in">dfs</span>(<span class="number">1</span>,i);</span><br><span class="line"><span class="keyword">if</span>(now==<span class="number">-1</span>)&#123;</span><br><span class="line">b = <span class="literal">false</span>;</span><br><span class="line">cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">ans+=now;</span><br><span class="line">ans%=p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(b) cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论-最短路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础数论</title>
      <link href="/2020/10/02/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA/"/>
      <url>/2020/10/02/%E5%9F%BA%E7%A1%80%E6%95%B0%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="1-同余及其基本性质"><a href="#1-同余及其基本性质" class="headerlink" title="1.同余及其基本性质"></a>1.同余及其基本性质</h2><p>1.$a\equiv b\pmod{m}-&gt;ac \equiv bc\pmod{m}$</p><p>2.$a\equiv b\pmod{m},c\equiv d\pmod{m}-&gt;a+b \equiv b+d\pmod{m}$</p><p>3.$a\equiv b\pmod{m},c\equiv d\pmod{m}-&gt;ab \equiv bd\pmod{m}$</p><p>4.$a\equiv b\pmod{m}-&gt;a^n \equiv b^n\pmod{m}$</p><p>小推理:如果有$a\equiv b\pmod{m}$,对任意多项式$f(x) &#x3D; r_kx^k+r_{k-1}x^{k-1}+..+r_1x+r_0$,都有$f(a) &#x3D; f(b)\pmod{m}$</p><h2 id="2-剩余系"><a href="#2-剩余系" class="headerlink" title="2.剩余系"></a>2.剩余系</h2><p>概念:</p><ul><li><p>设$S \subseteq Z$,如果任意整数都与$S$中正好一个元素关于模$m$同余,则称$S$是模$m$的一个<strong>完全剩余系</strong></p></li><li><p>与$m$互素的数构成的集合称为模$m$的一个<strong>既约剩余系</strong></p></li><li><p><strong>欧拉函数</strong>:$φ(m)$表示所有不大于$m$且与$m$互素的正整数的个数</p></li></ul><p>定理1:$a∈Z$,$m$是正整数,若$(a,m) &#x3D; 1$那么有$a^{φ(m)}\equiv 1\pmod{m}$—–(<strong>欧拉定理</strong>)</p><p>定理2:如果$a∈Z$,$p$是素数,则$a^p \equiv a\pmod{p}$,特别的,若$P$不整除$a$,则$a^{p-1}\equiv 1 \pmod{p}$—–(<strong>费马小定理</strong>)</p><h3 id="欧拉函数及其一些性质"><a href="#欧拉函数及其一些性质" class="headerlink" title="欧拉函数及其一些性质:"></a>欧拉函数及其一些性质:</h3><ul><li><p>$φ(m) &#x3D; \prod\limits_{p|m}(1-\dfrac{1}{p})$—–(欧拉函数表达式)</p></li><li><p>当$a$与$b$互质时,$φ(ab) &#x3D; φ(a)φ(b)$—–(数论函数基本定理)</p></li><li><p>若$p$是质数且$a≥1$,有$φ(m) &#x3D; p^a - p^{a-1}$</p></li><li><p>$(a,b) &#x3D; d$,有$φ(ab) &#x3D; φ(a)φ(b)\dfrac{d}{φ(d)}$</p></li></ul><p>证明:</p><center>\begin{split}\dfrac{φ(ab)}{ab}&=\prod\limits_{p|ab}(1-\dfrac{1}{p})\\&=\dfrac{\prod\limits_{p|a}(1-\dfrac{1}{p})\prod\limits_{p|b}(1-\dfrac{1}{p})}{\prod\limits_{p|d}(1-\dfrac{1}{p})}\\&=\dfrac{\dfrac{φ(a)}{a}\dfrac{φ(b)}{b}}{\dfrac{φ(d)}{d}}\\&=\dfrac{φ(a)φ(b)}{ab}·\dfrac{d}{φ(d)}\end{split}</center><p>因此$φ(ab) &#x3D; φ(a)φ(b)\dfrac{d}{φ(d)}$</p><p>证毕。</p><ul><li><p>设$p$为质数,若$p|n$且$p^2|n$,则$φ(n) &#x3D; φ(\dfrac{n}{p})·p$</p></li><li><p>设$p$为质数,若$p|n$且$p^2!|n$,则$φ(n) &#x3D; φ(\dfrac{n}{p})·(p-1)$</p></li></ul><p><del>其实这玩意当时是我写着练习latex格式用的</del></p><p><del>未来有空或许会补完?</del></p><p>2022&#x2F;6&#x2F;30</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P1081 开车旅行</title>
      <link href="/2020/10/02/p1081/"/>
      <url>/2020/10/02/p1081/</url>
      
        <content type="html"><![CDATA[<h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有$n$个城市,每个城市都有一个海拔$h_i$,两个城市$i,j$之间的距离为$|h_i-h_j|$,现在有两个人$A$和$B$轮流向东开车,$A$每次会选择一个距离第二近的城市,$B$每次会选择一个第一进的城市,当开到最后一个城市或距离超过$x$时停止开车,现在要求:</p><p> 对于一个给定的$x &#x3D; x_0$,$A$开车距离与$B$开车的距离比值最小,（如果小 $B$ 的行驶路程为 $0$，此时的比值可视为无穷大，且两个无穷大视为相等）,若有多个城市满足,输出海拔最低的那个</p><p>$m$次询问，每次给一个$x$和出发城市$s$,求小$A$开车行驶的总路程数和小$B$开车行驶的总路程数</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>可以发现很多城市下一次的开车决策是不变的,考虑先去把每个城市下一次开到的点预处理出来</p><p>先把所有的值排一次序,建立双向链表</p><p>从$[1,n]$枚举每个城市</p><p>显然离城市$i$最近和次近的城市即为$i-2,i-1,i+1,i+2$中的两个</p><p>每次选完后把该城市删除即可</p><p>先来看第一问</p><p>直接枚举每个点,暴力模拟开车过程肯定是不行的,复杂度过不了</p><p>发现中间很多开车过程都是无用的,考虑倍增优化</p><p>设$f_{i,j,0&#x2F;1}$表示从$j$城市出发,开车$2^i$天,$A&#x2F;B$先开车开到的城市,$dis_{0&#x2F;1,i,j,0&#x2F;1}$表示$A&#x2F;B$从城市$j$出发,开了$2^i$天,$A&#x2F;B$形式的距离</p><p>根据倍增的性质($2^i &#x3D; 2^{i-1}×2^{i-1}$),有转移:</p><p>$f_{i,j,k} &#x3D; f_{i-1,f(i-1,j,k),k}$ </p><p>$dis_{0&#x2F;1,i,j,k} &#x3D; dis_{0&#x2F;1,i-1,f_{i-1,j,k}}+dis_{0&#x2F;1,i-1,j,k}$  </p><p>注意:$i&#x3D;1$时前后两天不是同一个人开车,需要特判</p><p>枚举每个点,像$LCA$那样从大到小往前跳即可</p><p>操作2也同理</p><p> <strong>几个坑点</strong></p><ul><li><p>链表中要判定当前位置的前驱和后继不存在的情况</p></li><li><p>$i&#x3D;1$时要特判</p></li><li><p>比值的除法要转化为乘法,否则会出现一些奇奇怪怪的精度问题</p></li><li><p>注意特判$B$开车距离为$0$时的情况</p></li></ul><h2 id="code"><a href="#code" class="headerlink" title="$code$"></a>$code$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//细节有亿点多</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> now ((i==1)?k^1:k)<span class="comment">//i=1时的特判</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100005</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">int</span> ansa = <span class="number">1</span>,ansb,best;</span><br><span class="line"><span class="type">int</span> pos[MAXN],n;</span><br><span class="line"><span class="type">int</span> f[<span class="number">30</span>][MAXN][<span class="number">2</span>],dis[<span class="number">2</span>][<span class="number">30</span>][MAXN][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> x0,s,x,m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cc</span>&#123;</span><br><span class="line"><span class="type">int</span> min1,min2;</span><br><span class="line">&#125;drive[MAXN];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">c</span>&#123;</span><br><span class="line"><span class="type">int</span> id,pre,next,val;</span><br><span class="line">&#125;city[MAXN];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(c a,c b)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.val&lt;b.val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">g</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> id)</span></span>&#123;<span class="comment">//选次大的城市</span></span><br><span class="line"><span class="keyword">if</span>(!a) <span class="keyword">return</span> city[b].id;<span class="comment">//特判不存在的情况</span></span><br><span class="line"><span class="keyword">if</span>(!b) <span class="keyword">return</span> city[a].id;</span><br><span class="line"><span class="keyword">if</span>(city[id].val-city[a].val&lt;=city[b].val-city[id].val)</span><br><span class="line"><span class="keyword">return</span> city[a].id;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> city[b].id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="comment">//删除操作</span></span><br><span class="line"><span class="keyword">if</span>(city[x].next) city[city[x].next].pre = city[x].pre;</span><br><span class="line"><span class="keyword">if</span>(city[x].pre) city[city[x].pre].next = city[x].next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prepare</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">sort</span>(city+<span class="number">1</span>,city+<span class="number">1</span>+n,cmp);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) pos[city[i].id] = i,city[i].next = i+<span class="number">1</span>,city[i].pre = i<span class="number">-1</span>;<span class="comment">//建立链表和映射</span></span><br><span class="line">city[<span class="number">1</span>].pre = <span class="number">0</span>,city[n].next = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="type">int</span> pre = city[pos[i]].pre,next = city[pos[i]].next;</span><br><span class="line"><span class="keyword">if</span>(pre&amp;&amp;(city[pos[i]].val - city[pre].val&lt;=city[next].val-city[pos[i]].val||!next))&#123;</span><br><span class="line">drive[i].min2 = city[pre].id;</span><br><span class="line">drive[i].min1 = <span class="built_in">g</span>(city[pre].pre,next,pos[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">drive[i].min2 = city[next].id;</span><br><span class="line">drive[i].min1 = <span class="built_in">g</span>(pre,city[next].next,pos[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">del</span>(pos[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">cin&gt;&gt;city[i].val;</span><br><span class="line">city[i].id = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">prepare</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">if</span>(drive[i].min1)&#123;</span><br><span class="line">f[<span class="number">0</span>][i][<span class="number">0</span>] = drive[i].min1;</span><br><span class="line">dis[<span class="number">0</span>][<span class="number">0</span>][i][<span class="number">0</span>] = <span class="built_in">abs</span>(city[pos[i]].val - city[pos[drive[i].min1]].val);</span><br><span class="line">dis[<span class="number">1</span>][<span class="number">0</span>][i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(drive[i].min2)&#123;</span><br><span class="line">f[<span class="number">0</span>][i][<span class="number">1</span>] = drive[i].min2;</span><br><span class="line">dis[<span class="number">0</span>][<span class="number">0</span>][i][<span class="number">1</span>]= <span class="number">0</span>;</span><br><span class="line">dis[<span class="number">1</span>][<span class="number">0</span>][i][<span class="number">1</span>] = <span class="built_in">abs</span>(city[pos[i]].val - city[pos[drive[i].min2]].val);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> t = ((<span class="built_in">log</span>(n)/<span class="built_in">log</span>(<span class="number">2</span>)+<span class="number">1</span>));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;i++)&#123;<span class="comment">//转移</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=<span class="number">1</span>;k++)&#123;</span><br><span class="line"><span class="keyword">if</span>(f[i<span class="number">-1</span>][j][k]) f[i][j][k] = f[i<span class="number">-1</span>][f[i<span class="number">-1</span>][j][k]][now];</span><br><span class="line"><span class="keyword">if</span>(f[i][j][k])&#123;</span><br><span class="line">dis[<span class="number">0</span>][i][j][k] = dis[<span class="number">0</span>][i<span class="number">-1</span>][j][k]+dis[<span class="number">0</span>][i<span class="number">-1</span>][f[i<span class="number">-1</span>][j][k]][now];</span><br><span class="line">dis[<span class="number">1</span>][i][j][k] = dis[<span class="number">1</span>][i<span class="number">-1</span>][j][k]+dis[<span class="number">1</span>][i<span class="number">-1</span>][f[i<span class="number">-1</span>][j][k]][now];</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cin&gt;&gt;x0;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="type">int</span> disa =<span class="number">0</span>,disb = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> k = <span class="number">0</span>,value = x0;</span><br><span class="line"><span class="type">int</span> s = i;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=t;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line"><span class="keyword">if</span>(f[j][s][k]&amp;&amp;value&gt;=dis[<span class="number">0</span>][j][s][k]+dis[<span class="number">1</span>][j][s][k])&#123;<span class="comment">//倍增跳</span></span><br><span class="line">value-=dis[<span class="number">0</span>][j][s][k]+dis[<span class="number">1</span>][j][s][k];</span><br><span class="line">disa+=dis[<span class="number">0</span>][j][s][k],disb+=dis[<span class="number">1</span>][j][s][k];</span><br><span class="line"><span class="keyword">if</span>(!j) k^=<span class="number">1</span>;</span><br><span class="line">s = f[j][s][k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!disb) disa = <span class="number">1</span>;<span class="comment">//disb为0时,比值为无限大</span></span><br><span class="line"><span class="keyword">if</span>(disa*ansb&lt;disb*ansa)&#123;<span class="comment">//除转乘</span></span><br><span class="line">ansa = disa,ansb = disb,best = i;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(disa*ansb==disb*ansa&amp;&amp;city[pos[i]].val&gt;city[pos[best]].val)&#123;<span class="comment">//选海拔低的那个点</span></span><br><span class="line">ansa = disa,ansb = disb,best = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;best&lt;&lt;endl;</span><br><span class="line">cin&gt;&gt;m;</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line"><span class="type">int</span> x0,s;</span><br><span class="line">cin&gt;&gt;s&gt;&gt;x0;</span><br><span class="line"><span class="type">int</span> disa =<span class="number">0</span>,disb = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> k = <span class="number">0</span>,value = x0;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=t;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line"><span class="keyword">if</span>(f[j][s][k]&amp;&amp;value&gt;=dis[<span class="number">0</span>][j][s][k]+dis[<span class="number">1</span>][j][s][k])&#123;</span><br><span class="line">value-=dis[<span class="number">0</span>][j][s][k]+dis[<span class="number">1</span>][j][s][k];</span><br><span class="line">disa+=dis[<span class="number">0</span>][j][s][k],disb+=dis[<span class="number">1</span>][j][s][k];</span><br><span class="line"><span class="keyword">if</span>(!j) k^=<span class="number">1</span>;</span><br><span class="line">s = f[j][s][k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;disa&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;disb&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划-倍增优化dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P1450 [HAOI2008]硬币购物</title>
      <link href="/2020/09/30/p1450/"/>
      <url>/2020/09/30/p1450/</url>
      
        <content type="html"><![CDATA[<h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有 $4$ 种硬币。面值分别为 $c_1,c_2,c_3,c_4$</p><p>现在有$d_i$枚 $i$ 种硬币,要买一个价值为$s$的商品,求购买方案总数</p><p>$s≤10^5$ </p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>容斥$+dp$</p><p>挺nb的一道$dp$</p><p>如果直接做一次多重背包,显然$T$飞</p><p>通过观察可以发现, 总方案数$&#x3D;$无硬币数量限制的方案总数$-$不合法的方案数</p><h4 id="对于无硬币数量限制的方案"><a href="#对于无硬币数量限制的方案" class="headerlink" title="对于无硬币数量限制的方案:"></a>对于无硬币数量限制的方案:</h4><p>设$f[i]$表示无硬币数量限制时买$i$元钱的物品有多少种购买方法</p><p>直接上完全背包的板子即可</p><h4 id="对于不合法的方案"><a href="#对于不合法的方案" class="headerlink" title="对于不合法的方案:"></a>对于不合法的方案:</h4><p>一个方案不合法,当且仅当他花了$d_i$以上个硬币</p><p>方案数即为$f<a href="s%E2%89%A5(d_i+1)%C3%97c_i">s - (d_i+1)×c_i</a>$,将答案减去$\sum_{i&#x3D;1} ^4f<a href="s%E2%89%A5(d_i+1)%C3%97c_i">s - (d_i+1)×c_i</a>$即可</p><p>但由于两种方案间可能会有交集,会将两个方案的交集多减一次,需要容斥</p><p>对于任意两个方案集合$N$和$M$,有:</p><p>$N∩M &#x3D; N+M-N∪M &#x3D;f[s - (d_N+1)×c_N -(d_M+1)×c_M]$</p><p>将两种方案数的交集重新加进答案即可</p><p><img src="https://img2020.cnblogs.com/blog/2092833/202009/2092833-20200930224735277-917935686.png"></p><p>同时,由于交集之间可能还会有交集,又会加重,需要再次减去交集和交集间的交集,方法和前面的类似,以此类推</p><p>使用二进制枚举子集或直接手动枚举每种情况即可</p><h2 id="code"><a href="#code" class="headerlink" title="$code$"></a>$code$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ie(i) ((d[i]+1)*c[i])</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100000</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long </span></span><br><span class="line"><span class="type">int</span> f[MAXN+<span class="number">10</span>],n,d[<span class="number">10</span>],c[<span class="number">10</span>],m;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++) cin&gt;&gt;c[i];</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=c[i];j&lt;=MAXN;j++)</span><br><span class="line">f[j]+=f[j-c[i]];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"><span class="keyword">while</span>(n--)&#123;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/*if(s&gt;=ie(1)) ans-=f[s-ie(1)];</span></span><br><span class="line"><span class="comment">  if(s&gt;=ie(2)) ans-=f[s-ie(2)];</span></span><br><span class="line"><span class="comment">  if(s&gt;=ie(3)) ans-=f[s-ie(3)];</span></span><br><span class="line"><span class="comment">  if(s&gt;=ie(4)) ans-=f[s-ie(4)];</span></span><br><span class="line"><span class="comment">      if(s&gt;=ie(1)+ie(2)) ans+=f[s-ie(1)-ie(2)];</span></span><br><span class="line"><span class="comment">  if(s&gt;=ie(1)+ie(3)) ans+=f[s-ie(1)-ie(3)];</span></span><br><span class="line"><span class="comment">  if(s&gt;=ie(1)+ie(4)) ans+=f[s-ie(1)-ie(4)];</span></span><br><span class="line"><span class="comment">  if(s&gt;=ie(2)+ie(3)) ans+=f[s-ie(2)-ie(3)];</span></span><br><span class="line"><span class="comment">  if(s&gt;=ie(2)+ie(4)) ans+=f[s-ie(2)-ie(4)];</span></span><br><span class="line"><span class="comment">  if(s&gt;=ie(3)+ie(4)) ans+=f[s-ie(3)-ie(4)];</span></span><br><span class="line"><span class="comment">  if(s&gt;=ie(1)+ie(2)+ie(4)) ans-=f[s-ie(1)-ie(2)-ie(4)];</span></span><br><span class="line"><span class="comment">  if(s&gt;=ie(1)+ie(2)+ie(3)) ans-=f[s-ie(1)-ie(2)-ie(3)];</span></span><br><span class="line"><span class="comment">  if(s&gt;=ie(1)+ie(3)+ie(4)) ans-=f[s-ie(1)-ie(3)-ie(4)];</span></span><br><span class="line"><span class="comment">  if(s&gt;=ie(2)+ie(3)+ie(4)) ans-=f[s-ie(2)-ie(3)-ie(4)];</span></span><br><span class="line"><span class="comment">  if(s&gt;=ie(1)+ie(2)+ie(3)+ie(4)) ans+=f[s-ie(1)-ie(2)-ie(3)-ie(4)];*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">4</span>;j++) cin&gt;&gt;d[j];</span><br><span class="line">cin&gt;&gt;m;</span><br><span class="line">ans = f[m];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> s=<span class="number">1</span>;s&lt;=<span class="number">15</span>;s++)&#123;</span><br><span class="line"><span class="type">int</span> now = m, k=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> sub = s,j=<span class="number">1</span>;sub;sub&gt;&gt;=<span class="number">1</span>,j++)</span><br><span class="line"><span class="keyword">if</span>(sub&amp;<span class="number">1</span>) k^=<span class="number">1</span>,now-=<span class="built_in">ie</span>(j);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(now&gt;=<span class="number">0</span>) k?ans-=f[now]:ans+=f[now];</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划-背包dp </tag>
            
            <tag> 容斥 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P3891 [GDOI2014]采集资源</title>
      <link href="/2020/09/29/p3891/"/>
      <url>/2020/09/29/p3891/</url>
      
        <content type="html"><![CDATA[<h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有$m$块钱,$n$种苦工,每个苦工都有一个购入值$a_i$和每秒收入$b_i$,求让总钱数达到$t$的最少时间</p><p>$n≤100，m,t≤1000, a_i,b_i≤2^{31}$</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>考虑到每秒钟的决策和花费金钱数及当前每秒收入量有关,且这里的<strong>每秒收入量数值较大</strong>,不妨设$f(i,j)$表示在前$i$秒总钱数为$j$时的每秒收入量</p><p>设该秒花费的钱数为$k$,花$k$元钱能买到的最大收入量为$v_k$,有显然的转移: </p><center>$f(i,j) = max(f(i-1,j+k-f(i-1,j+k)-v_k)+v_k)$</center><p>总钱数达到$t$时输出$i$即可</p><p>小坑点:初始钱数大于t时直接输出0</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//xcxc82 2021/7/30</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1010</span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> X=<span class="number">0</span>; <span class="type">bool</span> flag=<span class="number">1</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) flag=<span class="number">0</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">if</span>(flag) <span class="keyword">return</span> X;<span class="keyword">return</span> ~(X<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n,m,t;</span><br><span class="line"><span class="type">int</span> a[MAXN],b[MAXN];</span><br><span class="line"><span class="type">int</span> f[MAXN][MAXN],g[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n = <span class="built_in">read</span>(),m = <span class="built_in">read</span>(),t = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">if</span>(m&gt;=t)&#123;</span><br><span class="line">cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">a[i] =<span class="built_in">read</span>(),b[i] = <span class="built_in">read</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">-1</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line"><span class="built_in">memset</span>(g,<span class="number">-1</span>,<span class="built_in">sizeof</span>(g));</span><br><span class="line">g[<span class="number">0</span>] = <span class="number">0</span>,f[<span class="number">0</span>][m] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=a[i];j&lt;=<span class="number">1000</span>;j++)&#123;</span><br><span class="line">g[j] = <span class="built_in">max</span>(g[j],g[j-a[i]]+b[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">1000</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=t;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(f[i][j]!=<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=j;k++)&#123;</span><br><span class="line">f[i+<span class="number">1</span>][j-k+g[k]+f[i][j]] = <span class="built_in">max</span>(g[k]+f[i][j],f[i+<span class="number">1</span>][j-k+g[k]+f[i][j]]);</span><br><span class="line"><span class="keyword">if</span>(j-k+g[k]+f[i][j]&gt;=t)&#123;</span><br><span class="line">cout&lt;&lt;i+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重构于2021&#x2F;7&#x2F;30</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划-背包dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>splay学习笔记</title>
      <link href="/2020/09/26/splay%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/09/26/splay%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p>一种二叉树的树形数据结构，其定义如下：</p><ul><li><p>左子树上的所有节点的权值均小于其根节点的权值</p></li><li><p>右子树上的所有节点的权值均大于其根节点的权值</p></li><li><p>二叉搜索树的左右子树均为二叉搜索树</p></li></ul><h1 id="Splay"><a href="#Splay" class="headerlink" title="Splay"></a>Splay</h1><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>一种自平衡二叉搜索树，通过不断将某个节点旋转到根节点,使得整棵树仍然满足二叉查找树的性质，且保持平衡而不至于退化为链</p><h3 id="维护的信息"><a href="#维护的信息" class="headerlink" title="维护的信息"></a>维护的信息</h3><table><thead><tr><th align="right">$root$</th><th align="right">$tot$</th><th align="right">$fa[i]$</th><th align="right">$child[i][0&#x2F;1]$</th><th align="right">$val[i]$</th><th align="right">$cnt[i]$</th><th align="right">$size[i]$</th></tr></thead><tbody><tr><td align="right">根节点</td><td align="right">节点总数</td><td align="right">父亲</td><td align="right">左右儿子</td><td align="right">点权</td><td align="right">出现次数</td><td align="right">子树大小</td></tr></tbody></table><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul><li><p>$update(x)$ 更新$x$节点的$size$</p></li><li><p>$clear(x)$ 摧毁节点$x$</p></li><li><p>$get(x)$ 判断$x$是其父亲的左儿子还是右儿子</p></li></ul><h3 id="code"><a href="#code" class="headerlink" title="$code$"></a>$code$</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;child[x][<span class="number">0</span>] = child[x][<span class="number">1</span>] = size[x] = fa[x] = val[x] = <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">if</span>(!x) <span class="keyword">return</span>; size[x] = size[child[x][<span class="number">0</span>]]+size[child[x][<span class="number">1</span>]]+<span class="number">1</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x==child[fa[x]][<span class="number">1</span>];&#125;</span><br></pre></td></tr></table></figure><ul><li><h2 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h2></li></ul><p>为调换$Splay$中父子节点的位置,我们使用旋转操作,将一个节点向上移动一个位置,并保证:</p><ul><li><p>整棵$Splay$的中序遍历不变</p></li><li><p>受影响的节点维护的信息依然正确有效</p></li><li><p>$root$必须指向旋转后的根节点</p></li></ul><h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><p><img src="https://img2020.cnblogs.com/blog/2092833/202009/2092833-20200926185814991-1893107179.gif"></p><p>$Splay$中的旋转分为两种,左旋和右旋,这里以右旋为例:</p><p>旋转分为四个步骤$:$</p><p>(假设需要旋转的节点为$x$,其父亲为$y$)</p><p>$1.$将$y$的左儿子指向$x$的右儿子,且$x$的右儿子的父亲指向$y$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">child[y][<span class="number">0</span>] = child[x][<span class="number">1</span>];</span><br><span class="line">fa[child[x][<span class="number">1</span>]] = y;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>$2.$将$x$的右儿子指向$y$，且$y$的父亲指向$x$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">child[x][<span class="number">1</span>] = y;</span><br><span class="line">fa[y] = x;</span><br></pre></td></tr></table></figure><p>$3.$如果$y$还有父亲$z$,将$y$原来在$z$中所在的位置指向$x$,且$x$的父亲指向$y$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fa[x] = z;</span><br><span class="line">child[z][y==child[z][<span class="number">1</span>]] = x;</span><br></pre></td></tr></table></figure><p>$4.$更新$x$和$y$的$size$</p><h3 id="code-1"><a href="#code-1" class="headerlink" title="$code$"></a>$code$</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> y = fa[x],z=fa[y];</span><br><span class="line"><span class="type">int</span> chy = <span class="built_in">get</span>(x),chx = chy^<span class="number">1</span>;</span><br><span class="line">child[y][chy] = child[x][chx];</span><br><span class="line">fa[child[x][chx]] = y;</span><br><span class="line">child[x][chx] = y;</span><br><span class="line">fa[y] = x;</span><br><span class="line">fa[x] = z;</span><br><span class="line"><span class="keyword">if</span>(z) child[z][y==child[z][<span class="number">1</span>]] = x;</span><br><span class="line"><span class="built_in">update</span>(y),<span class="built_in">update</span>(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h2 id="Splay-操作"><a href="#Splay-操作" class="headerlink" title="$Splay$操作"></a>$Splay$操作</h2></li></ul><p>$Splay$规定,每访问一个节点后,都要强制将该节点旋转到根的位置</p><h3 id="具体步骤-1"><a href="#具体步骤-1" class="headerlink" title="具体步骤"></a>具体步骤</h3><p>为保证不退化成链,$Splay$操作一共分三步</p><p>$1.$如果父节点为目标位置,则向上旋转</p><p>$2.$如果<strong>当前节点与父节点的“关系”和父节点与祖父节点的“关系”相同</strong>，则先旋转父节点，再旋转自身</p><p>$3.$如果不满足以上条件,则将自身连续旋转两次</p><p>重复以上操作,直到旋转到根</p><h3 id="code-2"><a href="#code-2" class="headerlink" title="$code$"></a>$code$</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> goal)</span></span>&#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> f; (f=fa[x])!=goal; <span class="built_in">rotate</span>(x))&#123;</span><br><span class="line">    <span class="keyword">if</span> (fa[f]!=goal) <span class="built_in">rotate</span>(<span class="built_in">get</span>(x)==<span class="built_in">get</span>(f)?f:x);</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">if</span> (!goal) root=x;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2></li></ul><p>设插入的值为$k$</p><ul><li>若树为空树,直接插入根</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!root)&#123;</span><br><span class="line">val[++tot] = k;</span><br><span class="line">cnt[tot]++;</span><br><span class="line">root = tot;</span><br><span class="line"><span class="built_in">update</span>(root);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>否则,根据二叉搜索树的性质向下查找,直到查找到权值等于$k$的节点或空节点</li></ul><p>同时需要将该节点$Splay$到根的位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> now = root,f = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(val[now]==k)&#123;</span><br><span class="line">cnt[now]++;</span><br><span class="line"><span class="built_in">update</span>(now);</span><br><span class="line"><span class="built_in">update</span>(f);</span><br><span class="line"><span class="built_in">Splay</span>(now);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">f = now;</span><br><span class="line">now = child[now][val[now]&lt;k];</span><br><span class="line"><span class="keyword">if</span>(!now)&#123;</span><br><span class="line">val[++tot] = k;</span><br><span class="line">cnt[tot]++;</span><br><span class="line">fa[tot] = f;</span><br><span class="line">child[f][val[f]&lt;k] = tot;</span><br><span class="line"><span class="built_in">update</span>(tot);</span><br><span class="line"><span class="built_in">update</span>(f);</span><br><span class="line"><span class="built_in">Splay</span>(tot);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h2 id="排名"><a href="#排名" class="headerlink" title="排名"></a>排名</h2></li><li><h3 id="查询给定值的排名"><a href="#查询给定值的排名" class="headerlink" title="查询给定值的排名"></a>查询给定值的排名</h3><p>设$x$为需要查询的值</p></li></ul><p>根据二叉搜索树的性质:</p><ul><li><p>若$x$比当前节点的权值小,向左子树查找</p></li><li><p>若$x$比当前节点的权值大，将答案$ans$加上左子树的$size$和当前节点$cnt$的大小,向其右子树查找。</p></li><li><p>若$x$与当前节点的权值相同,返回$ans+1$</p></li></ul><h3 id="code-3"><a href="#code-3" class="headerlink" title="$code$"></a>$code$</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">rank</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>,now = root;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(k&lt;val[now]) now = child[now][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">ans+=size[child[now][<span class="number">0</span>]];</span><br><span class="line"><span class="keyword">if</span>(k==val[now])&#123;</span><br><span class="line"><span class="built_in">Splay</span>(now);</span><br><span class="line"><span class="keyword">return</span> ans+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">ans+=cnt[now];</span><br><span class="line">now = child[now][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h3 id="查询给定排名的值"><a href="#查询给定排名的值" class="headerlink" title="查询给定排名的值"></a>查询给定排名的值</h3></li></ul><p>设$k$为剩余排名,根据二叉搜索树的性质:</p><ul><li><p>若$k$小于左子树的$size$且左子树非空,向左子树查找</p></li><li><p>否则将$k$减去左子树的大小和根的$cnt$</p></li></ul><p> 若此时$k$的值小于等于$0$,返回根节点的权值</p><p>  否则继续向右子树查找</p><h3 id="code-4"><a href="#code-4" class="headerlink" title="$code$"></a>$code$</h3>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">kth</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> now = root;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(child[now][<span class="number">0</span>]&amp;&amp;k&lt;=size[child[now][<span class="number">0</span>]])&#123;</span><br><span class="line">now = child[now][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">k-=cnt[now]+size[child[now][<span class="number">0</span>]];</span><br><span class="line"><span class="keyword">if</span>(k&lt;=<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">Splay</span>(now);</span><br><span class="line"><span class="keyword">return</span> val[now];</span><br><span class="line">&#125;</span><br><span class="line">now = child[now][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h2 id="前驱-amp-amp-后继"><a href="#前驱-amp-amp-后继" class="headerlink" title="前驱&amp;&amp;后继"></a>前驱&amp;&amp;后继</h2></li></ul><p>一个数的前驱定义为小于$x$的最大的数</p><p>后继定义为大于$x$的最小的数</p><p>显然,一个数的前驱是其左子树中最靠右的节点,后继是其右子树的最靠左的节点</p><p>将$x$旋转到根后查询即可</p><h3 id="code-5"><a href="#code-5" class="headerlink" title="$code$"></a>$code$</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">pre</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="type">int</span> now = child[root][<span class="number">0</span>];</span><br><span class="line">     <span class="keyword">while</span>(child[now][<span class="number">1</span>]) now = child[now][<span class="number">1</span>];</span><br><span class="line">     <span class="keyword">return</span> now;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="type">int</span> now = child[root][<span class="number">1</span>];</span><br><span class="line">   <span class="keyword">while</span>(child[now][<span class="number">0</span>]) now = child[now][<span class="number">0</span>];</span><br><span class="line">   <span class="keyword">return</span> now;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li><h2 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h2></li></ul><p>首先将要删除的节点$x$旋转到根的位置</p><ul><li>如果有不止一个$x$,那么直接将$cnt[x]$减$1$即可</li></ul><p>否则</p><ul><li><p>若没有儿子节点,直接将当前节点清空</p></li><li><p>若只有一个儿子,清空当前节点,再把根节点跟新为儿子</p></li><li><p>若有两个儿子,先将$x$的前驱旋转到根,并将$x$的右子树连接到$x$的前驱上</p></li></ul><h3 id="code-6"><a href="#code-6" class="headerlink" title="$code$"></a>$code$</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="built_in">rank</span>(k);</span><br><span class="line"><span class="keyword">if</span>(cnt[root]&gt;<span class="number">1</span>)&#123;</span><br><span class="line">cnt[root]--;</span><br><span class="line"><span class="built_in">update</span>(root);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!child[root][<span class="number">0</span>]&amp;&amp;!child[root][<span class="number">1</span>])&#123;</span><br><span class="line"><span class="built_in">clear</span>(root);</span><br><span class="line">root = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!child[root][<span class="number">0</span>])&#123;</span><br><span class="line"><span class="type">int</span> now = root;</span><br><span class="line">root = child[root][<span class="number">1</span>];</span><br><span class="line">fa[root] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">clear</span>(now);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!child[root][<span class="number">1</span>])&#123;</span><br><span class="line"><span class="type">int</span> now = root;</span><br><span class="line">root = child[root][<span class="number">0</span>];</span><br><span class="line">fa[root] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">clear</span>(now);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> now = root,x = <span class="built_in">pre</span>();</span><br><span class="line">fa[child[now][<span class="number">1</span>]] = x;</span><br><span class="line">child[x][<span class="number">1</span>] = child[now][<span class="number">1</span>];</span><br><span class="line"><span class="built_in">clear</span>(now);</span><br><span class="line"><span class="built_in">update</span>(root);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100005</span>;</span><br><span class="line"><span class="type">int</span> child[MAXN][<span class="number">2</span>],size[MAXN],root,tot,fa[MAXN],val[MAXN],cnt[MAXN];</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ci(Q) scanf(<span class="string">&quot;%d&quot;</span>,&amp;Q)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">splay</span>&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;size[x] = size[child[x][<span class="number">0</span>]]+size[child[x][<span class="number">1</span>]]+cnt[x];&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x==child[fa[x]][<span class="number">1</span>];&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;fa[x] = child[x][<span class="number">0</span>] = child[x][<span class="number">1</span>] = size[x] = val[x] = cnt[x] = <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> y = fa[x] , z = fa[y];</span><br><span class="line"><span class="type">int</span> chy = <span class="built_in">pd</span>(x) ,chx = chy^<span class="number">1</span>;</span><br><span class="line">child[y][chy] = child[x][chx];</span><br><span class="line">fa[child[x][chx]] = y;</span><br><span class="line">child[x][chx] = y,fa[y] = x,fa[x] = z;</span><br><span class="line"><span class="keyword">if</span>(z) child[z][y==child[z][<span class="number">1</span>]] = x;</span><br><span class="line"><span class="built_in">update</span>(x),<span class="built_in">update</span>(y);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Splay</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> f = fa[x];f=fa[x],f;<span class="built_in">rotate</span>(x))&#123;</span><br><span class="line"><span class="keyword">if</span>(fa[f]) <span class="built_in">rotate</span>(<span class="built_in">pd</span>(x)==<span class="built_in">pd</span>(f)?f:x);</span><br><span class="line">&#125;</span><br><span class="line">root = x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!root)&#123;</span><br><span class="line">val[++tot] = k;</span><br><span class="line">cnt[tot]++;</span><br><span class="line">root = tot;</span><br><span class="line"><span class="built_in">update</span>(root);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> now = root,f = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(val[now]==k)&#123;</span><br><span class="line">cnt[now]++;</span><br><span class="line"><span class="built_in">update</span>(now);</span><br><span class="line"><span class="built_in">update</span>(f);</span><br><span class="line"><span class="built_in">Splay</span>(now);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">f = now;</span><br><span class="line">now = child[now][val[now]&lt;k];</span><br><span class="line"><span class="keyword">if</span>(!now)&#123;</span><br><span class="line">val[++tot] = k;</span><br><span class="line">cnt[tot]++;</span><br><span class="line">fa[tot] = f;</span><br><span class="line">child[f][val[f]&lt;k] = tot;</span><br><span class="line"><span class="built_in">update</span>(tot);</span><br><span class="line"><span class="built_in">update</span>(f);</span><br><span class="line"><span class="built_in">Splay</span>(tot);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rank</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>,now = root;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(k&lt;val[now]) now = child[now][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">ans+=size[child[now][<span class="number">0</span>]];</span><br><span class="line"><span class="keyword">if</span>(k==val[now])&#123;</span><br><span class="line"><span class="built_in">Splay</span>(now);</span><br><span class="line"><span class="keyword">return</span> ans+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">ans+=cnt[now];</span><br><span class="line">now = child[now][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">kth</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> now = root;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(child[now][<span class="number">0</span>]&amp;&amp;k&lt;=size[child[now][<span class="number">0</span>]])&#123;</span><br><span class="line">now = child[now][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">k-=cnt[now]+size[child[now][<span class="number">0</span>]];</span><br><span class="line"><span class="keyword">if</span>(k&lt;=<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">Splay</span>(now);</span><br><span class="line"><span class="keyword">return</span> val[now];</span><br><span class="line">&#125;</span><br><span class="line">now = child[now][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pre</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> now = child[root][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">while</span>(child[now][<span class="number">1</span>]) now = child[now][<span class="number">1</span>];</span><br><span class="line"><span class="built_in">Splay</span>(now);</span><br><span class="line"><span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> now = child[root][<span class="number">1</span>];</span><br><span class="line"><span class="keyword">while</span>(child[now][<span class="number">0</span>]) now = child[now][<span class="number">0</span>];</span><br><span class="line"><span class="built_in">Splay</span>(now);</span><br><span class="line"><span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">del</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="built_in">rank</span>(k);</span><br><span class="line"><span class="keyword">if</span>(cnt[root]&gt;<span class="number">1</span>)&#123;</span><br><span class="line">cnt[root]--;</span><br><span class="line"><span class="built_in">update</span>(root);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!child[root][<span class="number">0</span>]&amp;&amp;!child[root][<span class="number">1</span>])&#123;</span><br><span class="line"><span class="built_in">clear</span>(root);</span><br><span class="line">root = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!child[root][<span class="number">0</span>])&#123;</span><br><span class="line"><span class="type">int</span> now = root;</span><br><span class="line">root = child[root][<span class="number">1</span>];</span><br><span class="line">fa[root] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">clear</span>(now);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!child[root][<span class="number">1</span>])&#123;</span><br><span class="line"><span class="type">int</span> now = root;</span><br><span class="line">root = child[root][<span class="number">0</span>];</span><br><span class="line">fa[root] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">clear</span>(now);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> now = root,x = <span class="built_in">pre</span>();</span><br><span class="line">fa[child[now][<span class="number">1</span>]] = x;</span><br><span class="line">child[x][<span class="number">1</span>] = child[now][<span class="number">1</span>];</span><br><span class="line"><span class="built_in">clear</span>(now);</span><br><span class="line"><span class="built_in">update</span>(root);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;tree;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n,op,x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;op,&amp;x);</span><br><span class="line"><span class="keyword">if</span>(op==<span class="number">1</span>) tree.<span class="built_in">insert</span>(x);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">2</span>) tree.<span class="built_in">del</span>(x);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,tree.<span class="built_in">rank</span>(x));</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">4</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,tree.<span class="built_in">kth</span>(x));</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(op==<span class="number">5</span>) tree.<span class="built_in">insert</span>(x),<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,val[tree.<span class="built_in">pre</span>()]),tree.<span class="built_in">del</span>(x);</span><br><span class="line"><span class="keyword">else</span> tree.<span class="built_in">insert</span>(x),<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,val[tree.<span class="built_in">next</span>()]),tree.<span class="built_in">del</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文艺平衡树-Splay维护区间信息"><a href="#文艺平衡树-Splay维护区间信息" class="headerlink" title="文艺平衡树(Splay维护区间信息)"></a>文艺平衡树(Splay维护区间信息)</h2><h3 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h3><p>给一个长度为$n$的序列,序列中第$a_i$项的初始值为$i$</p><p>有$m$次区间翻转操作,输出经过 $m$ 次变换后的结果</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>按点的编号建立一颗$Splay$</p><p>每次翻转时</p><p>先将$val &#x3D; l-1$和$val &#x3D; r+1$的节点分别转到根和根的儿子节点</p><p>根据$Splay$的性质,整颗树的中序遍历不变</p><p>因此只需要将$child[child[root][1]][0]$下的所有子树交换</p><p>通过给打懒标记的方式来实现交换操作即可</p><h3 id="code-7"><a href="#code-7" class="headerlink" title="$code$"></a>$code$</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100005</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">114514191</span>;</span><br><span class="line"><span class="type">int</span> child[MAXN][<span class="number">2</span>],a[MAXN],size[MAXN],root,tot,fa[MAXN],val[MAXN],cnt[MAXN],tag[MAXN];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Splay</span>&#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(!tag[x]) <span class="keyword">return</span>;</span><br><span class="line">tag[child[x][<span class="number">1</span>]]^=<span class="number">1</span>;</span><br><span class="line">tag[child[x][<span class="number">0</span>]]^=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">swap</span>(child[x][<span class="number">1</span>],child[x][<span class="number">0</span>]);</span><br><span class="line">tag[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;size[x] = size[child[x][<span class="number">0</span>]]+size[child[x][<span class="number">1</span>]]+cnt[x];&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="keyword">return</span> x==child[fa[x]][<span class="number">1</span>];&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;fa[x] = child[x][<span class="number">0</span>] = child[x][<span class="number">1</span>] = size[x] = val[x] = cnt[x] = <span class="number">0</span>;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> y = fa[x] , z = fa[y];</span><br><span class="line"><span class="type">int</span> chy = <span class="built_in">pd</span>(x) ,chx = chy^<span class="number">1</span>;</span><br><span class="line">child[y][chy] = child[x][chx];</span><br><span class="line">fa[child[x][chx]] = y;</span><br><span class="line">child[x][chx] = y,fa[y] = x,fa[x] = z;</span><br><span class="line"><span class="keyword">if</span>(z) child[z][y==child[z][<span class="number">1</span>]] = x;</span><br><span class="line"><span class="built_in">update</span>(x),<span class="built_in">update</span>(y);</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">build</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&gt;r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> now = ++tot;</span><br><span class="line">fa[now] = f;</span><br><span class="line">cnt[now]++;</span><br><span class="line">val[now] = a[mid];</span><br><span class="line">    size[now]++;</span><br><span class="line">    child[now][<span class="number">0</span>] = <span class="built_in">build</span>(l,mid<span class="number">-1</span>,now);</span><br><span class="line">    child[now][<span class="number">1</span>] = <span class="built_in">build</span>(mid+<span class="number">1</span>,r,now);</span><br><span class="line">    <span class="built_in">update</span>(now);</span><br><span class="line">    <span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">splay</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> goal)</span></span>&#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> f; (f=fa[x])!=goal; <span class="built_in">rotate</span>(x))&#123;</span><br><span class="line">    <span class="keyword">if</span> (fa[f]!=goal) <span class="built_in">rotate</span>(<span class="built_in">pd</span>(x)==<span class="built_in">pd</span>(f)?f:x);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">if</span> (!goal) root=x;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">kth</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> now = root;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">pushdown</span>(now);</span><br><span class="line"><span class="keyword">if</span>(child[now][<span class="number">0</span>]&amp;&amp;k&lt;=size[child[now][<span class="number">0</span>]])&#123;</span><br><span class="line">now = child[now][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="type">int</span> t = cnt[now]+size[child[now][<span class="number">0</span>]];</span><br><span class="line"><span class="keyword">if</span>(k&lt;=t)&#123;</span><br><span class="line"><span class="keyword">return</span> now;</span><br><span class="line">&#125;</span><br><span class="line">k-=t;</span><br><span class="line">now = child[now][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"> <span class="type">int</span> l = <span class="built_in">kth</span>(x<span class="number">-1</span>),r = <span class="built_in">kth</span>(y+<span class="number">1</span>);</span><br><span class="line"> <span class="built_in">splay</span>(l,<span class="number">0</span>),<span class="built_in">splay</span>(r,l);</span><br><span class="line"> <span class="type">int</span> now = child[root][<span class="number">1</span>];</span><br><span class="line"> now = child[now][<span class="number">0</span>];</span><br><span class="line"> tag[now]^=<span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"> <span class="built_in">pushdown</span>(x);</span><br><span class="line"> <span class="keyword">if</span>(child[x][<span class="number">0</span>]) <span class="built_in">dfs</span>(child[x][<span class="number">0</span>]);</span><br><span class="line"> <span class="keyword">if</span>(val[x]!=inf&amp;&amp;val[x]!=-inf) cout&lt;&lt;val[x]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"> <span class="keyword">if</span>(child[x][<span class="number">1</span>]) <span class="built_in">dfs</span>(child[x][<span class="number">1</span>]); </span><br><span class="line"> &#125;</span><br><span class="line">&#125;tree; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">a[<span class="number">1</span>] = -inf,a[n+<span class="number">2</span>] = inf;<span class="comment">//给区间[1,n]的序列翻转</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i+<span class="number">1</span>] = i;</span><br><span class="line">root = tree.<span class="built_in">build</span>(<span class="number">1</span>,n+<span class="number">2</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="type">int</span> l,r;</span><br><span class="line">cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">tree.<span class="built_in">reverse</span>(l+<span class="number">1</span>,r+<span class="number">1</span>);</span><br><span class="line">&#125; </span><br><span class="line">tree.<span class="built_in">dfs</span>(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://oi-wiki.org/ds/splay/">splay-oi-wiki</a></p><p><a href="https://oi.men.ci/splay-notes-1/">Splay 学习笔记（一）-Menci</a></p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> splay </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>p4135 作诗</title>
      <link href="/2020/09/20/p4135/"/>
      <url>/2020/09/20/p4135/</url>
      
        <content type="html"><![CDATA[<h1 id="P4135-作诗"><a href="#P4135-作诗" class="headerlink" title="P4135 作诗"></a>P4135 作诗</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给定 $n$ 个不大于 $c$ 的正整数$a_1…a_n$ 和 $m$ 组询问，每次问区间$[l,r]$中有多少个数出现正偶数次。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>分块入门题</p><p>设$sum[i][j]$为前$i$个块中第$j$个元素出现的个数</p><p>$ans[i][j]$为第$i$个块到第$j$个块中出现正偶数次的数的个数</p><p>先来考虑如何预处理出$ans[i][j]$</p><p>考虑每个新进来的数对$a[i][j]$的贡献<br>若新进来的数使该数在这几个区间中的出现次数变成了奇数,则答案减一,反之加一</p><p>对于查询</p><p>若$l,r$在同一个块内,直接暴力查询即可</p><p>若$l,r$不在同一个块内:</p><p>对于完整块,其对答案的贡献即为$ans[l+1][r-1]$</p><p>对于不完整块,暴力统计其块内每个数出现的个数,再加上$sum[r-1][a[i]]-sum[l][a[i]]$</p><p>若总出现次数为奇数,则答案加一,反之减一</p><p>复杂度$O(n \sqrt n)$</p><details><summary><font size=4 font face="comic sans MS">code</font></summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;Ofast&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;inline&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fgcse&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fgcse-lm&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fipa-sra&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-ftree-pre&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-ftree-vrp&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fpeephole2&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-ffast-math&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fsched-spec&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;unroll-loops&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-falign-jumps&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-falign-loops&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-falign-labels&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fdevirtualize&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fcaller-saves&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fcrossjumping&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fthread-jumps&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-funroll-loops&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fwhole-program&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-freorder-blocks&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fschedule-insns&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;inline-functions&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-ftree-tail-merge&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fschedule-insns2&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fstrict-aliasing&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fstrict-overflow&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-falign-functions&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fcse-skip-blocks&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fcse-follow-jumps&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fsched-interblock&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fpartial-inlining&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;no-stack-protector&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-freorder-functions&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-findirect-inlining&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fhoist-adjacent-loads&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-frerun-cse-after-loop&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;inline-small-functions&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-finline-small-functions&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-ftree-switch-conversion&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-foptimize-sibling-calls&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fexpensive-optimizations&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-funsafe-loop-optimizations&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;inline-functions-called-once&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> GCC optimize(<span class="string">&quot;-fdelete-null-pointer-checks&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> X=<span class="number">0</span>; <span class="type">bool</span> flag=<span class="number">1</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) flag=<span class="number">0</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">if</span>(flag) <span class="keyword">return</span> X;</span><br><span class="line"><span class="keyword">return</span> ~(X<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100010</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> now (sum[y-1][a[i]]-sum[x][a[i]]+b[a[i]])</span></span><br><span class="line"><span class="type">int</span> a[MAXN],belong[MAXN],t[MAXN],n,m,st[MAXN],ed[MAXN],tag[MAXN],num,sum[<span class="number">400</span>][MAXN],ans[<span class="number">400</span>][<span class="number">400</span>],b[MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> x = belong[l];</span><br><span class="line"><span class="type">int</span> y = belong[r];</span><br><span class="line"><span class="keyword">if</span>(x==y)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;i++)&#123;</span><br><span class="line">b[a[i]]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!b[a[i]]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(b[a[i]]%<span class="number">2</span>==<span class="number">0</span>) res++;</span><br><span class="line">b[a[i]] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">res = ans[x+<span class="number">1</span>][y<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=ed[x];i++)&#123;</span><br><span class="line">b[a[i]]++;</span><br><span class="line"><span class="keyword">if</span>(now&gt;<span class="number">1</span>&amp;&amp;(now&amp;<span class="number">1</span>)) res--;</span><br><span class="line"><span class="keyword">if</span>(now%<span class="number">2</span>==<span class="number">0</span>) res++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=st[y];i&lt;=r;i++)&#123;</span><br><span class="line">b[a[i]]++;</span><br><span class="line"><span class="keyword">if</span>(now&gt;<span class="number">1</span>&amp;&amp;(now&amp;<span class="number">1</span>)) res--;</span><br><span class="line"><span class="keyword">if</span>(now%<span class="number">2</span>==<span class="number">0</span>) res++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(b,<span class="number">0</span>,<span class="built_in">sizeof</span>(b));</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n = <span class="built_in">read</span>(),num = <span class="built_in">read</span>(),m = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i] = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> size = <span class="built_in">sqrt</span>(n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=size;i++) st[i] = (i<span class="number">-1</span>)*size+<span class="number">1</span>,ed[i] = i*size;</span><br><span class="line">ed[size] = n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=size;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=st[i];j&lt;=ed[i];j++)&#123;</span><br><span class="line">belong[j] = i;</span><br><span class="line">sum[i][a[j]]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=size;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=num;j++)&#123;</span><br><span class="line">sum[i][j] += sum[i<span class="number">-1</span>][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=size;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=st[i];j&lt;=ed[i];j++)&#123;</span><br><span class="line">b[a[j]]++;</span><br><span class="line"><span class="keyword">if</span>(b[a[j]]==<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(b[a[j]]%<span class="number">2</span>==<span class="number">0</span>) ans[i][i]++;</span><br><span class="line"><span class="keyword">else</span> ans[i][i]--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=size;j++)&#123;</span><br><span class="line">ans[i][j] = ans[i][j<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=st[j];k&lt;=ed[j];k++)&#123;</span><br><span class="line">b[a[k]]++;</span><br><span class="line"><span class="keyword">if</span>(b[a[k]]==<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(b[a[k]]%<span class="number">2</span>==<span class="number">0</span>) ans[i][j]++;</span><br><span class="line">    <span class="keyword">else</span> ans[i][j]--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(b,<span class="number">0</span>,<span class="built_in">sizeof</span>(b));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> A = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="type">int</span> l,r;</span><br><span class="line">l = <span class="built_in">read</span>(),r=<span class="built_in">read</span>();</span><br><span class="line">l = (l+A)%n+<span class="number">1</span>,r = (r+A)%n+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l&gt;r) <span class="built_in">swap</span>(l,r);</span><br><span class="line">A = <span class="built_in">query</span>(l,r);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,A);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷⑨月月赛</title>
      <link href="/2020/09/19/%E6%9C%88%E6%9C%88%E8%B5%9B/"/>
      <url>/2020/09/19/%E6%9C%88%E6%9C%88%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<details><summary><font size=4 font face="comic sans MS">T1</font></summary><p>良心满满的送分水题</p><p>直接贪心即可</p></details><hr><details><summary><font size=4 font face="comic sans MS">T2</font></summary><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有一个带权方格图,给一个起点$A$,两个终点$B$和$C$,求从$A$到$B$和$C$的两条路径的并集的电阻计量值的和最小。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>考虑到不可能有两个分岔口,直接跑三遍最短路,枚举分岔口即可</p></details><hr><details><summary><font size=4 font face="comic sans MS">T3</font></summary><h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h2><h2 id="大致题意-1"><a href="#大致题意-1" class="headerlink" title="大致题意"></a>大致题意</h2><p>有 $n$ 节点，每个点都向$[n-1,n-k]$ 中的任意一个点连边。每次可以选择一个连通块权值都减 $1$，求使得所有节点权值都变成 $0$ 的最小次数的数学期望。</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>把树换成链,就成了一道经典题了 <a href="https://www.luogu.com.cn/problem/P5019"><strong>P5019 铺设道路</strong></a></p><p>拓展到树上,也就是把前后关系换成了父子关系</p><p>若一个点的权值比它父亲权值的大,那么在其父亲减完后两点会断开,会增加$a_v - a_u$个操作次数,反之不会增加操作次数</p><p>对答案的贡献即为:$\dfrac{\sum_{j&#x3D;i-k}^{i-1} (a_i-a_j)}{k}(a_i&gt;a_j)$</p><p>对于每个节点,相当于是要求$[max(1,i-k),i-1]$中小于$a_i$的个数,且每个节点能连的点是序列上连续的一段,考虑使用树状数组来维护</p><p>使用树状数组来维护点数和和权值和即可</p><h3 id="关于T3题目背景"><a href="#关于T3题目背景" class="headerlink" title="关于T3题目背景"></a>关于T3题目背景</h3><h4 id="【东方MMD】琪露诺想要理解成熟"><a href="#【东方MMD】琪露诺想要理解成熟" class="headerlink" title="【东方MMD】琪露诺想要理解成熟"></a><a href="https://www.bilibili.com/video/BV1iQ4y1M7k2">【东方MMD】琪露诺想要理解成熟</a></h4><p>10.9补<br><a href="https://www.bilibili.com/video/BV1Bz4y1d7Zy?from=search&seid=4951912842973668234">补档</a>原作者不知道为啥把视频删了…</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h3><p><a href="https://www.cnblogs.com/Invictus-Ocean/p/13697299.html"><strong>洛谷9月月赛 题解（模拟+最短路+期望DP+期望DP</strong>）_OceanLiu</a></p><p><a href="https://www.cnblogs.com/lsq147/p/13697104.html#%E9%A2%98%E7%9B%AE%E5%88%86%E6%9E%90"><strong>某古 9 月月赛 I 游记-xiaolilsq</strong></a></p></details><details><summary><font size=4 font face="comic sans MS">T4</font></summary><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p><strong><a href="https://www.luogu.com.cn/problem/solution/P6835">原题面</a></strong></p><p>有$n$个点，形成一条单链图，并在其中加入$m$条返祖边</p><p>现在从1号节点出发，每次等概率的前往到一个相邻的节点，求走到第$n+1$个点的期望步数</p><p>$n,m≤10^6$</p><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>设$E_{x→y}$表示从$x$点走到$y$点的期望步数，$k_i$表示第$i$个点的返祖边条数</p><p>有转移：</p><center>$E_{x→x+1} = \dfrac{1}{k+1}×1+\dfrac{1}{k+1}×\sum\limits_{(x,y)∈E}E_{y→x+1}+1$</center><center>$= 1+\dfrac{1}{k+1}×\sum\limits_{(x,y)∈E}E_{y→x+1}$</center><p>根据期望的线性性质,有$E_{x→y} &#x3D;\sum\limits_{i&#x3D;x}^{y-1}E_{i→i+1}$,代回原式：</p><center>$E_{x→x+1} = 1+\dfrac{1}{k+1}×\sum\limits_{(x,y)∈E}\sum\limits_{i=y}^{x-1}E_{i→i+1}+\dfrac{k×E_{x→x+1}}{k+1}$</center><center>$E_{x→x+1} = 1+k+\sum\limits_{(x,y)∈E}\sum\limits_{i=y}^{x-1}E_{i→i+1}$</center><p>维护一下前缀和即可,$\sum\limits_{i&#x3D;x}^{y-1}E_{i→i+1}$既为所求答案</p><p>时间复杂度$O(n+m)$</p></details>------------]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P2801 教主的魔法</title>
      <link href="/2020/09/19/p2801/"/>
      <url>/2020/09/19/p2801/</url>
      
        <content type="html"><![CDATA[<h1 id="P2801-教主的魔法"><a href="#P2801-教主的魔法" class="headerlink" title="P2801 教主的魔法"></a>P2801 教主的魔法</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给一个长度为$n$的序列$a_i$,有$m$次操作,操作分为两种$:$</p><ul><li><p>将区间$[l,r]$上的所有数加上$c$</p></li><li><p>查询区间$[l,r]$中小于$c$的数的个数</p></li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>数列分块入门题</p><p>对于查询操作,若$l,r$在同一个块内,直接暴力查询</p><p>反之,若不在同一个块内,则答案由三部分组成:以$l$开头的不完整块,以$r$结尾的不完整块,中间一连串连续的完整快</p><p>由于要查询大于等于$c$的值,考虑开一个数组$t$存块中元素排序后的值</p><p>对于不完整块,直接暴力查询</p><p>对于完整块,在$t$数组中二分查找$c$的值即可</p><p>修改操作也同理</p><p>若$l,r$在同一个块内,直接暴力查询</p><p>若不在一个块内,对于不完整块直接暴力修改,并更新该块在$t$数组中的值</p><p>对于完整块,使用类似于$lazttag$的方式保存即可</p><hr><h3 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h3><p>预处理时,需对每个块内元素进行一次排序,复杂度为$O(nlogn)$</p><p>查询时,每次至多暴力修改$2\sqrt n$个元素,对$\sqrt n$个块内二分或排序,复杂度为$O(\sqrt n +\sqrt n log\sqrt n  )$</p><p>总复杂度为$O(\sqrt n +\sqrt n log\sqrt n + nlogn)$</p><details><summary><font size=5 font face="comic sans MS">code</font></summary><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> X=<span class="number">0</span>; <span class="type">bool</span> flag=<span class="number">1</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) flag=<span class="number">0</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">if</span>(flag) <span class="keyword">return</span> X;</span><br><span class="line"><span class="keyword">return</span> ~(X<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1000010</span>;</span><br><span class="line"><span class="type">int</span> a[MAXN],belong[MAXN],t[MAXN],n,m,st[MAXN],ed[MAXN],tag[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=st[x];i&lt;=ed[x];i++) t[i] = a[i];</span><br><span class="line"><span class="built_in">sort</span>(t+st[x],t+ed[x]+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> x = belong[l],y = belong[r];</span><br><span class="line"><span class="keyword">if</span>(x==y)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;i++) a[i]+=val;</span><br><span class="line">  <span class="built_in">sort</span>(x);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=ed[x];i++) a[i]+=val;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=st[y];i&lt;=r;i++) a[i]+=val;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=x+<span class="number">1</span>;i&lt;y;i++) tag[i]+=val;</span><br><span class="line"><span class="built_in">sort</span>(x);</span><br><span class="line"><span class="built_in">sort</span>(y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> x = belong[l],y = belong[r];</span><br><span class="line"><span class="keyword">if</span>(x==y)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;i++) <span class="keyword">if</span>(a[i]+tag[x]&gt;=val) res++;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=ed[x];i++) <span class="keyword">if</span>(a[i]+tag[x]&gt;=val) res++;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=st[y];i&lt;=r;i++) <span class="keyword">if</span>(a[i]+tag[y]&gt;=val) res++;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=x+<span class="number">1</span>;i&lt;y;i++)  res += ed[i]-(<span class="built_in">lower_bound</span>(t+st[i],t+ed[i]+<span class="number">1</span>,val-tag[i])-t)+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">n = <span class="built_in">read</span>(),m = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]=<span class="built_in">read</span>();</span><br><span class="line"><span class="type">int</span> size  = <span class="built_in">sqrt</span>(n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=size;i++)&#123;</span><br><span class="line">st[i] = (i<span class="number">-1</span>)*size+<span class="number">1</span>,ed[i] = i*size;</span><br><span class="line">&#125;</span><br><span class="line">ed[size] = n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=size;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=st[i];j&lt;=ed[i];j++)&#123;</span><br><span class="line">belong[j] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(a+st[i],a+ed[i]+<span class="number">1</span>);</span><br><span class="line"><span class="built_in">sort</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="type">char</span> op;</span><br><span class="line"><span class="type">int</span> a,b,c;</span><br><span class="line">cin&gt;&gt;op;</span><br><span class="line">a = <span class="built_in">read</span>(),b=<span class="built_in">read</span>(),c=<span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">if</span>(op==<span class="string">&#x27;A&#x27;</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="built_in">query</span>(a,b,c)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">add</span>(a,b,c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></details><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><strong><a href="https://oi-wiki.org/ds/block-array/">块状数组 - OI Wiki</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF148D Bag of mice</title>
      <link href="/2020/09/13/cf148d/"/>
      <url>/2020/09/13/cf148d/</url>
      
        <content type="html"><![CDATA[<h1 id="CF148D-Bag-of-mice"><a href="#CF148D-Bag-of-mice" class="headerlink" title="CF148D Bag of mice"></a>CF148D Bag of mice</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有$w$只白鼠和$b$只黑鼠 ，$A$和$B$轮流从袋子里抓，谁先抓到白色谁就赢。抓完后会有另一只随机老鼠跑出来。如果两个人都没有抓到白色则$B$赢。$A$先抓，问$A$赢的概率。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>概率$dp$板子题</p><p>设$f[i][j]$表示为袋子里共有$i$只白鼠$j$只黑鼠,$A$获胜的概率</p><p>考虑$f[i][j]$的转移:</p><p>先确定边界,当没有一只白鼠时,$f[0][i] &#x3D; 0$,全是白鼠时$f[i][0] &#x3D; 1$</p><ul><li><p>$A$抓了一只白鼠,$A$赢了,概率为$\dfrac{i}{i+j}$</p></li><li><p>$A$抓了一只黑鼠,$B$抓了一只白鼠,$B$硬了,概率为$\dfrac{j}{i+j}×\dfrac{i}{i+j-1}$</p></li><li><p>$A$抓了一只黑鼠,$B$抓了一只黑鼠,跑出来一只白鼠,概率为$\dfrac{j}{i+j}×\dfrac{j-1}{i+j-1}×\dfrac{i}{i+j-2}$,转移到$f[i][j-3]$</p></li><li><p>$A$抓了一只黑鼠,$B$抓了一只黑鼠,跑出来一只黑鼠,概率为$\dfrac{j}{i+j}×\dfrac{j-1}{i+j-1}×\dfrac{j-2}{i+j-2}$,转移到$f[i-1][j-2]$</p></li></ul><p>其中第二种情况不参与计算,只需转移其他三种情况即可</p><h2 id="code"><a href="#code" class="headerlink" title="$code:$"></a>$code:$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">3010</span>;</span><br><span class="line"><span class="type">double</span> f[MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) f[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) f[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i&gt;=<span class="number">1</span>)&#123;</span><br><span class="line">f[i][j] += (<span class="type">double</span>)i/(j+i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(j&gt;=<span class="number">2</span>&amp;&amp;i&gt;=<span class="number">1</span>)&#123;</span><br><span class="line"> f[i][j]+=(<span class="type">double</span>)j/(j+i)*(j<span class="number">-1</span>)/(j+i<span class="number">-1</span>)*i/(j+i<span class="number">-2</span>)*f[i<span class="number">-1</span>][j<span class="number">-2</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(j&gt;=<span class="number">3</span>)&#123;</span><br><span class="line">f[i][j]+= (<span class="type">double</span>)j/(j+i)*(j<span class="number">-1</span>)/(j+i<span class="number">-1</span>)*(j<span class="number">-2</span>)/(j+i<span class="number">-2</span>)*f[i][j<span class="number">-3</span>]; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.9lf\n&quot;</span>, f[n][m]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><strong><a href="https://oi-wiki.org/dp/probability/">概率 $dp$_OI Wiki</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划-期望dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P1850 换教室</title>
      <link href="/2020/09/13/p1850/"/>
      <url>/2020/09/13/p1850/</url>
      
        <content type="html"><![CDATA[<h1 id="P1850-换教室"><a href="#P1850-换教室" class="headerlink" title="P1850 换教室"></a>P1850 换教室</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给一张$v$个教室$e$条带权边的图,有$n$个时间段,第$i$个时间段在$c_i$号教室上课,可以申请换到$d_i$号教室,成功的概率为$p_i$,上完后要去第$i+1$个时间段的教室上课,有$m$次申请机会,求最小期望路程</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>设$f[i][j][0&#x2F;1]$表示第$i$个时间段前用了$j$次申请机会,第$i$个时间段申请$&#x2F;$不申请的最小期望路程</p><p>$w[i][j]$表示第$i$个教室到第$j$个教室的最短路长度</p><hr><ul><li>当前阶段不申请更换:</li></ul><p>前一个状态换:</p><p>$~~~~~~~~~~~~$$f[i][j][0] &#x3D; f[i-1][j][1]+w[c_{i-1}][c_{i}]×(1-p_{i-1}) + w[d{<em>i-1}][c</em>{i}]×p_{i-1}$</p><p>前一个状态不换:</p><p>$~~~~~~~~~~~~$$f[i][j][0] &#x3D; f[i-1][j][0]+w[c_{i-1}][c_i]$</p><p>取两者的$min$即可</p><hr><ul><li>当前状态申请更换:</li></ul><p>前一个状态不换:</p><p>$~~~~~~~~~~~~$$f[i][j][1] &#x3D; f[i-1][j-1][0]+w[c_{i-1}][d_{i}]×p_{i}+w[c_{i-1}][c_{i}]×(1-p_{i})$</p><p>前一个状态换:</p><p>比较麻烦,有四种可能</p><ul><li><p>$d_{i-1}-&gt;c_i$: $k_1 &#x3D; w[d_{i-1}][c_{i}]×p_{i-1}*(1-p_{i})$ $~~~~~~~~~~~,~$ $d_{i-1}-&gt;d_i$: $k_2 &#x3D; w[d_{i-1}][d_{i}]×p_{i}×p_{i-1}$</p></li><li><p>$c_{i-1}-&gt;c_i$: $k_3 &#x3D; w[c_{i-1}][c_{i}]×(1-p_{i-1})*(1-p_{i})$ $~~,~$ $c_{i-1}-&gt;d_i$: $k_4 &#x3D; w[c_{i-1}][d_{i}]×(1-p_{i-1})*p_{i}$</p></li></ul><p>$~~~~~~~~~~~~$$f[i][j][1] &#x3D; f[i-1][j-1][1]+k_1+k_2+k_3+k_4$</p><hr><p>答案即为$min(f[n][i][0])$</p><h2 id="code"><a href="#code" class="headerlink" title="$code:$"></a>$code:$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">2010</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 1145141919</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> X=<span class="number">0</span>; <span class="type">bool</span> flag=<span class="number">1</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) flag=<span class="number">0</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">if</span>(flag) <span class="keyword">return</span> X;</span><br><span class="line"><span class="keyword">return</span> ~(X<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> c[MAXN],d[MAXN];</span><br><span class="line"><span class="type">int</span> w[MAXN][MAXN];</span><br><span class="line"><span class="type">double</span> f[MAXN][MAXN][<span class="number">2</span>];</span><br><span class="line"><span class="type">double</span> p[MAXN]; </span><br><span class="line"><span class="type">int</span> n,m,v,e;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyed</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=v;k++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=v;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=v;j++)</span><br><span class="line">w[i][j] = <span class="built_in">min</span>(w[i][j] , w[i][k]+w[k][j]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">n = <span class="built_in">read</span>(),m=<span class="built_in">read</span>(),v=<span class="built_in">read</span>(),e=<span class="built_in">read</span>();</span><br><span class="line"><span class="built_in">memset</span>(w,<span class="number">63</span>,<span class="built_in">sizeof</span>(w));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) c[i]=<span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) d[i]=<span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;p[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=e;i++)&#123;</span><br><span class="line"><span class="type">int</span> u,v,val;</span><br><span class="line">u = <span class="built_in">read</span>(),v=<span class="built_in">read</span>(),val=<span class="built_in">read</span>();</span><br><span class="line">w[u][v] = w[v][u] = <span class="built_in">min</span>(w[u][v] , val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">floyed</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=v;i++) w[i][i] = w[i][<span class="number">0</span>] = w[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= m; j++) f[i][j][<span class="number">0</span>] = f[i][j][<span class="number">1</span>] = <span class="number">1e9</span>;</span><br><span class="line">    </span><br><span class="line">f[<span class="number">1</span>][<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">f[<span class="number">1</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="built_in">min</span>(m,i);j++)&#123;</span><br><span class="line">f[i][j][<span class="number">0</span>] = <span class="built_in">min</span>(f[i<span class="number">-1</span>][j][<span class="number">0</span>]+w[c[i<span class="number">-1</span>]][c[i]],f[i<span class="number">-1</span>][j][<span class="number">1</span>]+ w[c[i<span class="number">-1</span>]][c[i]]*(<span class="number">1</span>-p[i<span class="number">-1</span>]) + w[d[i<span class="number">-1</span>]][c[i]]*p[i<span class="number">-1</span>]);</span><br><span class="line"><span class="keyword">if</span>(j!=<span class="number">0</span>)&#123;</span><br><span class="line">f[i][j][<span class="number">1</span>] = <span class="built_in">min</span>(f[i<span class="number">-1</span>][j<span class="number">-1</span>][<span class="number">0</span>]+w[c[i<span class="number">-1</span>]][d[i]]*p[i]+w[c[i<span class="number">-1</span>]][c[i]]*(<span class="number">1</span>-p[i]),</span><br><span class="line">f[i<span class="number">-1</span>][j<span class="number">-1</span>][<span class="number">1</span>]+w[c[i<span class="number">-1</span>]][d[i]]*(<span class="number">1</span>-p[i<span class="number">-1</span>])*p[i]+</span><br><span class="line">w[c[i<span class="number">-1</span>]][c[i]]*(<span class="number">1</span>-p[i<span class="number">-1</span>])*(<span class="number">1</span>-p[i])+</span><br><span class="line">w[d[i<span class="number">-1</span>]][c[i]]*p[i<span class="number">-1</span>]*(<span class="number">1</span>-p[i])+</span><br><span class="line">w[d[i<span class="number">-1</span>]][d[i]]*p[i]*p[i<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> ans = <span class="number">1e9</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++) ans = <span class="built_in">min</span>(ans,<span class="built_in">min</span>(f[n][i][<span class="number">0</span>],f[n][i][<span class="number">1</span>])); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2lf&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划-期望dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P1860 新魔法药水</title>
      <link href="/2020/09/12/p1860/"/>
      <url>/2020/09/12/p1860/</url>
      
        <content type="html"><![CDATA[<h1 id="P1860-新魔法药水"><a href="#P1860-新魔法药水" class="headerlink" title="P1860 新魔法药水"></a>P1860 新魔法药水</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给$n$个物品,每个物品都有一个售价和回收价,现在有$v$块钱和$m$个操作,每次操作都可以把若干个物品合成为另一个物品,最多可以使用$k$次操作,求能获得的最大收益</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>比较难想的一道$dp$</p><p>设$f[i][j]$表示共有$i$块钱,$j$次操作时能获得的最大收益</p><p>$m[i][j]$表示第$i$个数用了$j$次操作后$i$的最小进价</p><p>$a[i][0&#x2F;1]$表示第$i$个物品的进价和回收价</p><p>$m$的值直接求不太好求,考虑对$m$进行$dp$</p><p>对于每一个$m[i][j]$,其值必定由其条件物品的值决定,考虑去求每个物品的条件物品购入值的最小值</p><p>设$k[i][j]$表示第$now$个物品前$i$个条件用品用了$j$次魔法的最小购入值</p><p>$p_i$表示$i$物品中每个条件物品用的操作次数,$sum_i$表示第$i$个物品的条件物品总数,则$\sum_i^{sum_i}p_i &#x3D; j-1$</p><p>可以看出是个分组背包</p><p>则有较为显然的转移:</p><p>$~~~~~~~~~~~~~~~~~~~~~~$$k[i][j] &#x3D; min(k[i-1][j-t]+f[i][t])$</p><p>$m[now][j]$的转移即为</p><p>$~~~~~~~~~~~~~~~~~~~~~~$$m[now][j] &#x3D; min(k[sum_i][j-1])$</p><p>$m$数组求出来了,$f$的转移也就呼之欲出了</p><p>$~~~~~~~~~~~~~~~~~~~~~~$$f[v][t] &#x3D; max(f[v - m[i][j]][t - j]+a[i][1])$</p><p>答案即为$max(f[i][j] - i)$</p><h2 id="code"><a href="#code" class="headerlink" title="$code:$"></a>$code:$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">250</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f</span></span><br><span class="line"><span class="type">int</span> f[MAXN][MAXN*<span class="number">10</span>],a[MAXN][<span class="number">2</span>],mgc[MAXN][MAXN],fia[MAXN],num[MAXN][MAXN],koishi[MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> n,m,v,k;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> X=<span class="number">0</span>; <span class="type">bool</span> flag=<span class="number">1</span>; <span class="type">char</span> ch=<span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">while</span>(ch&lt;<span class="string">&#x27;0&#x27;</span>||ch&gt;<span class="string">&#x27;9&#x27;</span>) &#123;<span class="keyword">if</span>(ch==<span class="string">&#x27;-&#x27;</span>) flag=<span class="number">0</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">while</span>(ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>) &#123;X=(X&lt;&lt;<span class="number">1</span>)+(X&lt;&lt;<span class="number">3</span>)+ch-<span class="string">&#x27;0&#x27;</span>; ch=<span class="built_in">getchar</span>();&#125;</span><br><span class="line"><span class="keyword">if</span>(flag) <span class="keyword">return</span> X;</span><br><span class="line"><span class="keyword">return</span> ~(X<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(mgc,inf,<span class="built_in">sizeof</span>(mgc));</span><br><span class="line">n=<span class="built_in">read</span>(),m=<span class="built_in">read</span>(),v=<span class="built_in">read</span>(),k=<span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">a[i][<span class="number">0</span>] = <span class="built_in">read</span>(),mgc[i][<span class="number">0</span>] = a[i][<span class="number">0</span>] , a[i][<span class="number">1</span>] = <span class="built_in">read</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">fia[i] = <span class="built_in">read</span>(),num[i][<span class="number">0</span>] = <span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=num[i][<span class="number">0</span>];j++)</span><br><span class="line">num[i][j] = <span class="built_in">read</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=k;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="built_in">memset</span>(koishi,inf,<span class="built_in">sizeof</span>(koishi));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> p=<span class="number">0</span>;p&lt;j;p++) koishi[<span class="number">0</span>][p]  =<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">1</span>;now&lt;=num[i][<span class="number">0</span>];now++)</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> p=<span class="number">0</span>;p&lt;j;p++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> q=<span class="number">0</span>;q&lt;=p;q++)</span><br><span class="line">      koishi[now][p] = <span class="built_in">min</span>(koishi[now<span class="number">-1</span>][p-q]+mgc[num[i][now]][q],koishi[now][p]);</span><br><span class="line">      mgc[fia[i]][j] = <span class="built_in">min</span>(mgc[fia[i]][j] , koishi[num[i][<span class="number">0</span>]][j<span class="number">-1</span>]);</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">0</span>;t&lt;=k;t++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=t;j++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> mo=mgc[i][j];mo&lt;=v;mo++)&#123;</span><br><span class="line">f[t][mo] = <span class="built_in">max</span>(f[t][mo],f[t-j][mo-mgc[i][j]]+a[i][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=v;j++)&#123;</span><br><span class="line">ans = <span class="built_in">max</span>(ans , f[i][j]-j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="坑点-amp-amp-感想"><a href="#坑点-amp-amp-感想" class="headerlink" title="坑点&amp;&amp;感想"></a>坑点&amp;&amp;感想</h2><ul><li>注意枚举时的边界</li></ul>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划-背包dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P3174 [HAOI2009]毛毛虫</title>
      <link href="/2020/09/08/p3174/"/>
      <url>/2020/09/08/p3174/</url>
      
        <content type="html"><![CDATA[<h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给一n个点的树,定义一条路径的权值为该路径上所有的点数和与该路径上的点相连的点数之和,求最大权值</p><p>$1\leq n \le 300000$</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>###做法一:</p><p>设$deg(i)$为第$i$个节点的度数,$f(i)$为以$i$为根的最大权值和,$g(i)$为以$i$为根的次大权值和</p><p>不难推出转移方程:</p><center>$f(u) = max(f(v))+deg(u)-1$</center><p>枚举每一个点,然后取最大值就可以了</p><p>注意这里最后的答案要加2,因为中间连接的的两个点没酸上</p><p>时间复杂度$O(n^2)$,能取得10pts的<del>好成绩</del></p><p>###做法二:</p><p>观察可以发现,这里的方法和求树的直径相同,只是把长度换成了权值,因此可以直接套用求树的直径的两次$dfs$方法</p><p>时间复杂度$O(n)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划-树形dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P4180 严格次小生成树</title>
      <link href="/2020/09/06/p4180/"/>
      <url>/2020/09/06/p4180/</url>
      
        <content type="html"><![CDATA[<h1 id="P4180-BJWC2010-严格次小生成树"><a href="#P4180-BJWC2010-严格次小生成树" class="headerlink" title="P4180 [BJWC2010]严格次小生成树"></a>P4180 [BJWC2010]严格次小生成树</h1><h1 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h1><p>给一张带权无向图,求其严格次小生成树大小</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li><h3 id="次小生成树"><a href="#次小生成树" class="headerlink" title="次小生成树"></a>次小生成树</h3></li></ul><p>无向图中,边权和最小的满足边权和 <strong>大于等于</strong> 最小生成树边权和的生成树</p><p>严格次小生成树即为边权和最小的满足边权和 <strong>严格大于</strong> 最小生成树边权和的生成树</p><h2 id="求法"><a href="#求法" class="headerlink" title="求法"></a>求法</h2><ul><li><p>先求出无向图的最小生成树,设其权值和为$S$</p></li><li><p>枚举每条不在最小生成树中的边$e &#x3D; (u,v,w)$,将其加入生成树,同时去掉从$u$到$v$的路径上权值最大的一条边$e_{max}$,以确保不存在环且其权值和次小</p></li></ul><p>得到的新生成树权值和即为$S+e.w - e_{max}.w$</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>使用树链剖分来维护两个值$:$区间最大值和区间严格次大值</p><p>设$max1_{l,r}$表示区间$[l,r]$中的最大值,$max2_{l,r}$表示区间$[l,r]$中的严格次大值</p><p>当$max1_{l,mid}&#x3D;&#x3D;max1_{mid+1,r}$时:</p><p>$max2_{l,r}$取左右区间中的较大的严格次大值</p><ul><li>$max2_{l,r} &#x3D; max(max2_{l,mid},max2_{mid+1,r})$</li></ul><p>反之,当$max1_{l,mid} !&#x3D; max1_{mid+1,r}$时:</p><p>$max2_{l,r}$取左右区间中的较小的最大值</p><ul><li>$max2_{l,r} &#x3D; min(max1_{l,mid},max1_{mid+1,r})$</li></ul><p>若最大值不等于当前所换的边的大小,直接用最大值来替换</p><p>反之,说明不满足严格小于,用次大值来替换</p><h2 id="code"><a href="#code" class="headerlink" title="$code:$"></a>$code:$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//--------------------------------------------------------------------------------other </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson (node&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson (node&lt;&lt;1|1)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">2e5</span>+<span class="number">5</span>,MAXM = <span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">int</span> head[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">e</span>&#123;</span><br><span class="line"><span class="type">int</span> next,v,w;</span><br><span class="line">&#125;edge[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> n,m,fa[MAXN];</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="type">bool</span> vis[MAXM];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">edge[++cnt].v = v;</span><br><span class="line">edge[cnt].w = w;</span><br><span class="line">edge[cnt].next = head[u];</span><br><span class="line">head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(fa[x]==x) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">id</span>&#123;</span><br><span class="line"><span class="type">int</span> u,v,w;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> id &amp;k)<span class="type">const</span>&#123;</span><br><span class="line"><span class="keyword">return</span> w&lt;k.w;</span><br><span class="line">&#125;</span><br><span class="line">&#125;a[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kruskal</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> Tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="type">int</span> f1 = <span class="built_in">find</span>(a[i].u);</span><br><span class="line"><span class="type">int</span> f2 = <span class="built_in">find</span>(a[i].v);</span><br><span class="line"><span class="keyword">if</span>(f1!=f2)&#123;</span><br><span class="line">vis[i] = <span class="number">1</span>;</span><br><span class="line">fa[f1] = f2;</span><br><span class="line"><span class="built_in">add</span>(a[i].u,a[i].v,a[i].w),<span class="built_in">add</span>(a[i].v,a[i].u,a[i].w);</span><br><span class="line">sum+=a[i].w;</span><br><span class="line">Tot++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(Tot == n<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//--------------------------------------------------------------------------------other </span></span><br><span class="line"><span class="type">int</span> dep[MAXN],son[MAXN],faa[MAXN],size[MAXN],w[MAXN];</span><br><span class="line"><span class="type">int</span> id[MAXN],val[MAXN],tot = <span class="number">0</span>,top[MAXN];<span class="comment">//预处理数组 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------------------------------------------------------------------线段树 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st</span>&#123;</span><br><span class="line"><span class="type">int</span> max1,max2,l,r;</span><br><span class="line">&#125;tree[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;</span><br><span class="line">tree[node].max1 = <span class="built_in">max</span>(tree[lson].max1,tree[rson].max1);</span><br><span class="line"><span class="keyword">if</span>(tree[lson].max1==tree[rson].max1)&#123;</span><br><span class="line">tree[node].max2 = <span class="built_in">max</span>(tree[lson].max2,tree[rson].max2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> tree[node].max2 = <span class="built_in">min</span>(tree[lson].max1,tree[rson].max1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">tree[node].l = l,tree[node].r = r;</span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">tree[node].max1 = val[l];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">build</span>(lson,l,mid);</span><br><span class="line"><span class="built_in">build</span>(rson,mid+<span class="number">1</span>,r);</span><br><span class="line"><span class="built_in">pushup</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; <span class="title">unit</span><span class="params">(pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; l,pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; r)</span></span>&#123;</span><br><span class="line">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; f;</span><br><span class="line">f.first = <span class="built_in">max</span>(l.first,r.first);</span><br><span class="line"><span class="keyword">if</span>(l.first==r.first) f.second = <span class="built_in">max</span>(l.second,r.second);</span><br><span class="line"><span class="keyword">else</span> f.second = <span class="built_in">min</span>(l.first,r.first);</span><br><span class="line"><span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; <span class="title">query</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=tree[node].l&amp;&amp;r&gt;=tree[node].r)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">make_pair</span>(tree[node].max1,tree[node].max2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid = (tree[node].l+tree[node].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(r&lt;=mid) <span class="keyword">return</span> <span class="built_in">query</span>(lson,l,r);</span><br><span class="line"><span class="keyword">if</span>(l&gt;mid) <span class="keyword">return</span> <span class="built_in">query</span>(rson,l,r);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">unit</span>(<span class="built_in">query</span>(lson,l,r),<span class="built_in">query</span>(rson,l,r));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------------------------------------------------------------------线段树 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------------------------------------------------------------------dfs</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> f,<span class="type">int</span> deep)</span></span>&#123;</span><br><span class="line">dep[u] = deep;</span><br><span class="line">faa[u] = f;</span><br><span class="line">size[u] = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> maxson = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = edge[i].v;</span><br><span class="line"><span class="keyword">if</span>(v==f) <span class="keyword">continue</span>;</span><br><span class="line">w[v] = edge[i].w;</span><br><span class="line"><span class="built_in">dfs1</span>(v,u,deep+<span class="number">1</span>);</span><br><span class="line">size[u]+=size[v];</span><br><span class="line"><span class="keyword">if</span>(size[v]&gt;maxson)&#123;</span><br><span class="line">son[u] = v;</span><br><span class="line">maxson = size[v];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> topf)</span></span>&#123;</span><br><span class="line">id[u] = ++tot;</span><br><span class="line">val[tot] = w[u];</span><br><span class="line">top[u] = topf;</span><br><span class="line"><span class="keyword">if</span>(!son[u]) <span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">dfs2</span>(son[u],topf);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = edge[i].v;</span><br><span class="line"><span class="keyword">if</span>(v==son[u]||v==faa[u]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs2</span>(v,v);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//--------------------------------------------------------------------------------dfs</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//--------------------------------------------------------------------------------查询 </span></span><br><span class="line"><span class="function">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; <span class="title">qb</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; res;</span><br><span class="line"><span class="keyword">while</span>(top[u]!=top[v])&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]]) <span class="built_in">swap</span>(u,v);</span><br><span class="line">res = <span class="built_in">unit</span>(res , <span class="built_in">query</span>(<span class="number">1</span>,id[top[u]],id[u]));</span><br><span class="line">u = faa[top[u]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(u!=v)&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[u]&gt;dep[v]) <span class="built_in">swap</span>(u,v);</span><br><span class="line">res = <span class="built_in">unit</span>(res , <span class="built_in">query</span>(<span class="number">1</span>,id[u]+<span class="number">1</span>,id[v]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//--------------------------------------------------------------------------------查询 </span></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">cin&gt;&gt;a[i].u&gt;&gt;a[i].v&gt;&gt;a[i].w;</span><br><span class="line"><span class="keyword">if</span>(a[i].u==a[i].v) vis[i] = <span class="number">1</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) fa[i] = i;</span><br><span class="line"><span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+m);</span><br><span class="line"><span class="built_in">kruskal</span>();</span><br><span class="line"><span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="type">int</span> ans = <span class="number">1e18</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[i]) <span class="keyword">continue</span>;<span class="comment">//在树中或为自环 </span></span><br><span class="line">pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; maxn = <span class="built_in">qb</span>(a[i].u,a[i].v);<span class="comment">//最大值,次大值 </span></span><br><span class="line"><span class="keyword">if</span>(maxn.first&lt;a[i].w) ans = <span class="built_in">min</span>(ans , sum+a[i].w-maxn.first);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(maxn.second&lt;a[i].w&amp;&amp;maxn.second) ans = <span class="built_in">min</span>(ans , sum+a[i].w-maxn.second); <span class="comment">//存在严格次大值</span></span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h2><h5 id="次小生成树-OI-Wiki"><a href="#次小生成树-OI-Wiki" class="headerlink" title="次小生成树_OI Wiki"></a><a href="https://oi-wiki.org/graph/mst/#_9">次小生成树_OI Wiki</a></h5>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论-最小生成树 </tag>
            
            <tag> 树链剖分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P4231 三步必杀</title>
      <link href="/2020/09/05/p4231/"/>
      <url>/2020/09/05/p4231/</url>
      
        <content type="html"><![CDATA[<h1 id="P4231-三步必杀"><a href="#P4231-三步必杀" class="headerlink" title="P4231 三步必杀"></a>P4231 三步必杀</h1><h1 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h1><p><img src="https://img2020.cnblogs.com/blog/2092833/202009/2092833-20200905221207707-1412115323.jpg"></p><p>给一个初值全为$0$的数列,有$m$次修改操作都将一个给定区间$[l,r]$加上首相为$s$末项为$e$的等差数列</p><p>求:所有修改完成后所有数的异或和跟最大值</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><h2 id="算法一"><a href="#算法一" class="headerlink" title="算法一"></a>算法一</h2><p>通过观察可以发现,对于差分数组$b$,除了$l$和$r+1$位置,其他位置的值都相等</p><p>考虑用线段树记录差分数组,每次修改时,将:</p><ul><li><p>区间$[l+1,r]$加上一个公差$d$</p></li><li><p>$l$位置加上一个首相$s$</p></li><li><p>$r+1$位置减去一个$d×(r-l)+s$</p></li></ul><p>单点修改$+$区间修改$+$区间查询</p><p>可以获得38$pts$</p><h2 id="算法二"><a href="#算法二" class="headerlink" title="算法二"></a>算法二</h2><p>区间$[l+1,r]$的值均为$d$,考虑对数组$b$再进行一次差分</p><p>令$c$为$b$的差分数组</p><p>每次修改时将$:$</p><ul><li><p>$c_l$的值加上首相$s$</p></li><li><p>$c_{l+1}$的值加上$d -s$</p></li><li><p>$c_{r+1}$的值减去$d - e$</p></li><li><p>$c_{r+2}$的值加上$e$</p></li></ul><p>即可</p><p>只需要修改四个元素</p><p>对于每个$a_x$,其值即为$\sum_{i&#x3D;1}^x\sum_{j&#x3D;1}^{i}c_j$</p><h2 id="code"><a href="#code" class="headerlink" title="$code:$"></a>$code:$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1000010</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">int</span> a[MAXN] , n ,m,ans[MAXN];</span><br><span class="line"><span class="type">int</span> ans1,ansmaxn;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="type">int</span> l,r,s,e;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;s,&amp;e);</span><br><span class="line">a[l] += s;</span><br><span class="line">a[l+<span class="number">1</span>]+=(((e-s)/(r-l)) -s);</span><br><span class="line">a[r+<span class="number">1</span>]+=-(((e-s)/(r-l))+e);</span><br><span class="line">a[r+<span class="number">2</span>]+=e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]+=a[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">ans[i] = ans[i<span class="number">-1</span>]+a[i];</span><br><span class="line">ans1^=ans[i];</span><br><span class="line">ansmaxn = <span class="built_in">max</span>(ansmaxn , ans[i]);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans1&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;ansmaxn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="坑点-amp-amp-感想"><a href="#坑点-amp-amp-感想" class="headerlink" title="坑点&amp;&amp;感想"></a>坑点&amp;&amp;感想</h2><ul><li><p>当原差分数组有特殊性质时,考虑二次差分</p></li><li><p>不开$long long$见祖宗</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> 差分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF149D Coloring Brackets</title>
      <link href="/2020/09/04/cf149d/"/>
      <url>/2020/09/04/cf149d/</url>
      
        <content type="html"><![CDATA[<h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给一个合法括号序列,一个括号可以染红色、蓝色或不染色,一对匹配的括号需要且只能将其中一个染色,且相邻两个括号颜色不能相同</p><p>求符合条件的染色方案数</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>代码实现上比较恶心的区间$dp$</p><p>设$f[i][j][0&#x2F;1&#x2F;2][0&#x2F;1&#x2F;2]$为区间$[i,j]$中,第$i$个字符不染色$&#x2F;$染红色$&#x2F;$染蓝色的方案数,$pos[i]$为$i$的对应右括号</p><p>分两种情况讨论:</p><ul><li>$i$和$j$是一对配对的括号</li></ul><p>$dfs$子区间$[i+1,j-1]$</p><p>更新每个$f[i][j][0&#x2F;1&#x2F;2][0&#x2F;1&#x2F;2]$的值</p><p>$\begin{cases}f[l][r][1][0] +&#x3D; f[l+1][r-1][i][j] (i!&#x3D;1)\f[l][r][2][0] +&#x3D; f[l+1][r-1][i][j] (i!&#x3D;2)\f[l][r][0][1] +&#x3D; f[l+1][r-1][i][j] (j!&#x3D;1)\f[l][r][0][2] +&#x3D; f[l+1][r-1][i][j] (j!&#x3D;2)\end{cases}$</p><ul><li>$i$和$j$不是一对配对的括号</li></ul><p>将$[i,j]$拆分为两个区间$[l,pos[l]]$和$[pos[l]+1,r]$进行$dfs$,暴力统计贡献</p><h2 id="code"><a href="#code" class="headerlink" title="$code:$"></a>$code:$</h2><p>细节较多</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">710</span>;</span><br><span class="line"><span class="type">int</span> mo = <span class="number">1000000007</span>;</span><br><span class="line"><span class="type">int</span> dp[MAXN][MAXN][<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line"><span class="type">char</span> kh[MAXN];</span><br><span class="line"><span class="type">int</span> pos[MAXN],ans;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">c</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;<span class="comment">//暴力统计贡献</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">2</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">2</span>;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=<span class="number">2</span>;k++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> g=<span class="number">0</span>;g&lt;=<span class="number">2</span>;g++)&#123;</span><br><span class="line"><span class="keyword">if</span>((j!=k)||(j==<span class="number">0</span>&amp;&amp;k==<span class="number">0</span>)) dp[l][r][i][g]+=dp[l][pos[l]][i][j]*dp[pos[l]+<span class="number">1</span>][r][k][g],dp[l][r][i][g]%=mo;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> l , <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l+<span class="number">1</span> == r)&#123;</span><br><span class="line">dp[l][r][<span class="number">0</span>][<span class="number">1</span>] = dp[l][r][<span class="number">0</span>][<span class="number">2</span>] = dp[l][r][<span class="number">1</span>][<span class="number">0</span>] = dp[l][r][<span class="number">2</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pos[l]==r)&#123;<span class="comment">//是配对括号</span></span><br><span class="line"><span class="built_in">dfs</span>(l+<span class="number">1</span>,r<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">2</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">2</span>;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i!=<span class="number">1</span>) dp[l][r][<span class="number">1</span>][<span class="number">0</span>] = (dp[l+<span class="number">1</span>][r<span class="number">-1</span>][i][j]+dp[l][r][<span class="number">1</span>][<span class="number">0</span>])%mo;</span><br><span class="line"><span class="keyword">if</span>(i!=<span class="number">2</span>) dp[l][r][<span class="number">2</span>][<span class="number">0</span>] = (dp[l+<span class="number">1</span>][r<span class="number">-1</span>][i][j]+dp[l][r][<span class="number">2</span>][<span class="number">0</span>])%mo;</span><br><span class="line"><span class="keyword">if</span>(j!=<span class="number">1</span>) dp[l][r][<span class="number">0</span>][<span class="number">1</span>] = (dp[l+<span class="number">1</span>][r<span class="number">-1</span>][i][j]+dp[l][r][<span class="number">0</span>][<span class="number">1</span>])%mo;</span><br><span class="line"><span class="keyword">if</span>(j!=<span class="number">2</span>) dp[l][r][<span class="number">0</span>][<span class="number">2</span>] = (dp[l+<span class="number">1</span>][r<span class="number">-1</span>][i][j]+dp[l][r][<span class="number">0</span>][<span class="number">2</span>])%mo;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;<span class="comment">//拆分</span></span><br><span class="line"><span class="built_in">dfs</span>(l,pos[l]);</span><br><span class="line"><span class="built_in">dfs</span>(pos[l]+<span class="number">1</span>,r);</span><br><span class="line"><span class="built_in">c</span>(l,r);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,kh+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="built_in">strlen</span>(kh+<span class="number">1</span>);i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(kh[i]==<span class="string">&#x27;(&#x27;</span>) s.<span class="built_in">push</span>(i);</span><br><span class="line"><span class="keyword">else</span> pos[s.<span class="built_in">top</span>()] = i , s.<span class="built_in">pop</span>();<span class="comment">//记录匹配右括号</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>,<span class="built_in">strlen</span>(kh+<span class="number">1</span>));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">2</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">2</span>;j++)&#123;</span><br><span class="line">ans = (ans + dp[<span class="number">1</span>][<span class="built_in">strlen</span>(kh+<span class="number">1</span>)][i][j])%mo;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开学考柠檬水了</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划-区间dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020 9月做题笔记</title>
      <link href="/2020/09/02/9%E6%9C%88%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/09/02/9%E6%9C%88%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="end"><a href="#end" class="headerlink" title="end"></a>end</h2><details><summary><font size=4 font face="comic sans MS">9.30</font></summary><h2 id="9-30"><a href="#9-30" class="headerlink" title="9.30"></a>9.30</h2><h4 id="P1450-HAOI2008-硬币购物"><a href="#P1450-HAOI2008-硬币购物" class="headerlink" title="P1450 [HAOI2008]硬币购物"></a><a href="https://www.luogu.com.cn/problem/P1450">P1450 [HAOI2008]硬币购物</a></h4><p>容斥+dp</p><p>感觉做法还是挺神的(<del>也可能是因为我太菜了</del>)</p><h4 id="详细"><a href="#详细" class="headerlink" title="详细"></a><a href="https://www.cnblogs.com/xcxc82/p/13756835.html">详细</a></h4></details><hr><details><summary><font size=4 font face="comic sans MS">9.29</font></summary><h2 id="9-29"><a href="#9-29" class="headerlink" title="9.29"></a>9.29</h2><h4 id="GDOI2014-采集资源"><a href="#GDOI2014-采集资源" class="headerlink" title="[GDOI2014]采集资源"></a><a href="https://www.luogu.com.cn/problem/P3891">[GDOI2014]采集资源</a></h4><p>$dp$练习题</p><h4 id="详细-1"><a href="#详细-1" class="headerlink" title="详细"></a><a href="https://www.cnblogs.com/xcxc82/p/13752296.html">详细</a></h4></details><hr><details><summary><font size=4 font face="comic sans MS">9.27</font></summary><h2 id="9-27"><a href="#9-27" class="headerlink" title="9.27"></a>9.27</h2><p>文艺平衡树</p><p><a href="https://www.cnblogs.com/xcxc82/p/13736231.html">Splay学习笔记</a></p></details><hr><details><summary><font size=4 font face="comic sans MS">9.26</font></summary><h2 id="9-26"><a href="#9-26" class="headerlink" title="9.26"></a>9.26</h2><p><a href="https://www.cnblogs.com/xcxc82/p/13736231.html">Splay学习笔记</a></p><p>下个星期开运动会了&#x2F;se</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>学习了Splay</p></details><hr><details><summary><font size=4 font face="comic sans MS">9.23~9.25</font></summary><h2 id="9-23-9-25"><a href="#9-23-9-25" class="headerlink" title="9.23~9.25"></a>9.23~9.25</h2><p>学了下splay</p><p>笔记明天来补</p></details><hr><details><summary><font size=4 font face="comic sans MS">9.22</font></summary><h2 id="9-22"><a href="#9-22" class="headerlink" title="9.22"></a>9.22</h2><p>whking</p><p>这西西弗什么思博审核啊,十多天了还没好</p></details><hr><details><summary><font size=4 font face="comic sans MS">9.21</font></summary><h2 id="9-21"><a href="#9-21" class="headerlink" title="9.21"></a>9.21</h2><p>复习初赛ing</p><p>草为啥10年初赛会有空间向量的题啊</p></details><hr><details><summary><font size=4 font face="comic sans MS">9.20</font></summary><h2 id="9-20题"><a href="#9-20题" class="headerlink" title="9.20题"></a>9.20题</h2><p>无</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>学习了数列分块入门</p><p><del>以后打月赛再也不瞎复制之前写的代码了&#x3D;&#x3D;,被坑死了</del></p></details><hr><details><summary><font size=4 font face="comic sans MS">9.19</font></summary><h2 id="9-19题"><a href="#9-19题" class="headerlink" title="9.19题"></a>9.19题</h2><h3 id="洛谷-⑨-月月赛"><a href="#洛谷-⑨-月月赛" class="headerlink" title="洛谷 ⑨ 月月赛"></a><a href="https://www.cnblogs.com/xcxc82/p/13697113.html">洛谷 ⑨ 月月赛</a></h3><p>⑨都不如的菜鸡</p></details><hr><details><summary><font size=4 font face="comic sans MS">9.18</font></summary><h2 id="9-18题"><a href="#9-18题" class="headerlink" title="9.18题"></a>9.18题</h2><h3 id="P4135-作诗"><a href="#P4135-作诗" class="headerlink" title="P4135 作诗"></a><a href="https://www.luogu.com.cn/problem/P4135">P4135 作诗</a></h3><p>数列分块练手题</p><h3 id="详细-2"><a href="#详细-2" class="headerlink" title="详细"></a><a href="https://www.cnblogs.com/xcxc82/p/13701266.html">详细</a></h3><h2 id="other"><a href="#other" class="headerlink" title="other"></a>other</h2><p>草上政治课的时候班上有个同学公然看本子,tql</p></details><hr><details><summary><font size=4 font face="comic sans MS">9.17</font></summary><h2 id="9-17题"><a href="#9-17题" class="headerlink" title="9.17题"></a>9.17题</h2><h3 id="P2801-教主的魔法"><a href="#P2801-教主的魔法" class="headerlink" title="P2801 教主的魔法"></a><a href="https://www.luogu.com.cn/problem/P2801">P2801 教主的魔法</a></h3><p>数列分块入门题</p><h3 id="详细-3"><a href="#详细-3" class="headerlink" title="详细"></a><a href="https://www.cnblogs.com/xcxc82/p/13695957.html">详细</a></h3></details><hr><details><summary><font size=4 font face="comic sans MS">9.13~9.16</font></summary><h2 id="9-13-9-16"><a href="#9-13-9-16" class="headerlink" title="9.13~9.16"></a>9.13~9.16</h2><p>whking</p><p>€€￡的破审核还没过&#x3D;&#x3D;</p></details><hr><details><summary><font size=4 font face="comic sans MS">9.12</font></summary><h2 id="9-12题"><a href="#9-12题" class="headerlink" title="9.12题"></a>9.12题</h2><h3 id="P1860-新魔法药水"><a href="#P1860-新魔法药水" class="headerlink" title="P1860 新魔法药水"></a><a href="https://www.luogu.com.cn/problem/P1860">P1860 新魔法药水</a></h3><p>$dp$好题</p><h3 id="详细-4"><a href="#详细-4" class="headerlink" title="详细"></a><a href="https://www.cnblogs.com/xcxc82/p/13659339.html">详细</a></h3><h3 id="P1850-换教室"><a href="#P1850-换教室" class="headerlink" title="P1850 换教室"></a><a href="https://www.luogu.com.cn/problem/P1850">P1850 换教室</a></h3><p>最短路+期望$dp$</p><h3 id="详细-5"><a href="#详细-5" class="headerlink" title="详细"></a><a href="https://www.cnblogs.com/xcxc82/p/13661002.html">详细</a></h3><p>##总结</p><p>补了之前没学的期望+概率</p><p>复习了一些数论知识</p></details><hr><details><summary><font size=4 font face="comic sans MS">9.11</font></summary><h2 id="9-11题"><a href="#9-11题" class="headerlink" title="9.11题"></a>9.11题</h2><h3 id="P3802-小魔女帕琪"><a href="#P3802-小魔女帕琪" class="headerlink" title="P3802 小魔女帕琪"></a><a href="https://www.luogu.com.cn/problem/P3802">P3802 小魔女帕琪</a></h3><p>折寿中…</p><h3 id="CF148D-Bag-of-mice"><a href="#CF148D-Bag-of-mice" class="headerlink" title="CF148D Bag of mice"></a><a href="https://www.luogu.com.cn/problem/CF148D">CF148D Bag of mice</a></h3><p>概率$dp$模板题,分类讨论即可</p><h3 id="详细-6"><a href="#详细-6" class="headerlink" title="详细"></a><a href="https://www.cnblogs.com/xcxc82/p/13663798.html">详细</a></h3></details><hr><details><summary><font size=4 font face="comic sans MS">9.7~9.10</font></summary><h2 id="9-7-9-10题"><a href="#9-7-9-10题" class="headerlink" title="9.7~9.10题"></a>9.7~9.10题</h2><p>复习初赛+whk</p></details><hr><details><summary><font size=4 font face="comic sans MS">9.6</font></summary><h2 id="9-6题"><a href="#9-6题" class="headerlink" title="9.6题"></a>9.6题</h2><h3 id="P4180-BJWC2010-严格次小生成树"><a href="#P4180-BJWC2010-严格次小生成树" class="headerlink" title="P4180 [BJWC2010]严格次小生成树"></a><a href="https://www.luogu.com.cn/problem/P4180">P4180 [BJWC2010]严格次小生成树</a></h3><p>次小生成树板子题</p><h3 id="详细-7"><a href="#详细-7" class="headerlink" title="详细"></a><a href="https://www.cnblogs.com/xcxc82/p/13623917.html">详细</a></h3><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p><del>?似乎没啥可总结的</del></p><p>学了一些杂七杂八的东西</p></details><hr><details><summary><font size=4 font face="comic sans MS">9.5</font></summary><h2 id="9-5题"><a href="#9-5题" class="headerlink" title="9.5题"></a>9.5题</h2><h3 id="P4231-三步必杀"><a href="#P4231-三步必杀" class="headerlink" title="P4231 三步必杀"></a><a href="https://www.luogu.com.cn/problem/P4231">P4231 三步必杀</a></h3><p>二次差分</p><p>车万题面好评</p><h3 id="详细-8"><a href="#详细-8" class="headerlink" title="详细"></a><a href="https://www.cnblogs.com/xcxc82/p/13620012.html">详细</a></h3><h3 id="SP277-CTGAME-City-Game-amp-amp-P2280-HNOI2003-激光炸弹"><a href="#SP277-CTGAME-City-Game-amp-amp-P2280-HNOI2003-激光炸弹" class="headerlink" title="SP277 CTGAME - City Game&amp;&amp;P2280 [HNOI2003]激光炸弹"></a><a href="https://www.luogu.com.cn/problem/SP277">SP277 CTGAME - City Game</a>&amp;&amp;<a href="https://www.luogu.com.cn/problem/P2280">P2280 [HNOI2003]激光炸弹</a></h3><p>两道$dp$水题</p></details><hr><details><summary><font size=4 font face="comic sans MS">9.1~9.4</font></summary><h2 id="9-1-9-4题"><a href="#9-1-9-4题" class="headerlink" title="9.1~9.4题"></a>9.1~9.4题</h2><p>whking</p><p>打了几个模板题,复习了一些初赛知识</p><p><del>开学考你们输了</del></p></details><hr><details><summary><font size=4 font face="comic sans MS">8月补充</font></summary><h2 id="8月补充"><a href="#8月补充" class="headerlink" title="8月补充"></a>8月补充</h2><h3 id="P3225-HNOI2012-矿场搭建"><a href="#P3225-HNOI2012-矿场搭建" class="headerlink" title="P3225 [HNOI2012]矿场搭建"></a><a href="https://www.luogu.com.cn/problem/P3225">P3225 [HNOI2012]矿场搭建</a></h3><p>待补充</p><h3 id="P3225-CF149D-Coloring-Brackets"><a href="#P3225-CF149D-Coloring-Brackets" class="headerlink" title="P3225 CF149D Coloring Brackets"></a><a href="https://www.luogu.com.cn/problem/P3225">P3225 CF149D Coloring Brackets</a></h3><p>细节较多的一道区间$dp$</p><h3 id="详细-9"><a href="#详细-9" class="headerlink" title="详细"></a><a href="https://www.cnblogs.com/xcxc82/p/13616581.html">详细</a></h3><h3 id="P3174-HAOI2009-毛毛虫"><a href="#P3174-HAOI2009-毛毛虫" class="headerlink" title="P3174 [HAOI2009]毛毛虫"></a><a href="https://www.luogu.com.cn/problem/P3174">P3174 [HAOI2009]毛毛虫</a></h3><p>树形$dp$</p><h3 id="详细-10"><a href="#详细-10" class="headerlink" title="详细"></a><a href="https://www.cnblogs.com/xcxc82/p/13636125.html">详细</a></h3></details>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P1169 [ZJOI2007]棋盘制作</title>
      <link href="/2020/08/30/p1169/"/>
      <url>/2020/08/30/p1169/</url>
      
        <content type="html"><![CDATA[<h1 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h1><p>给一个$8×8$的黑白棋盘,求最大的黑白相间的矩形和正方形的面积</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>悬线法$dp$板子题</p><h1 id="悬线法"><a href="#悬线法" class="headerlink" title="悬线法"></a>悬线法</h1><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>用途:解决给定矩阵中满足某条件的最大子矩阵等一类问题</p><h2 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h2><p>定义三个数组:</p><p>$up[i][j]$:表示第$i$行第$j$个点能向上扩展到的最长长度</p><p>$l[i][j]$:表示第$i$行第$j$个点能向左扩展到的最左位置</p><p>$r[i][j]$:表示第$i$行第$j$个点能向右扩展到的最右位置</p><p>先预处理出$l$数组和$r$数组:</p><p>$l[i][j] &#x3D; l[i]<a href="a%5Bi%5D%5Bj%5D!=a%5Bi%5D%5Bj-1%5D">j-1</a>$</p><p>$r[i][j] &#x3D; r[i]<a href="a%5Bi%5D%5Bj%5D!=a%5Bi%5D%5Bj+1%5D">j+1</a>$</p><p>当且仅当$a[i][j]!&#x3D;a[i-1][j]$时,两行才有可能接上</p><p>其对应的$l[i][j]$和$r[i][j]$则分别取靠右的和靠左的那一个,同时更新高度</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a[i][j]!=<span class="number">1</span>)&#123;</span><br><span class="line">up[i][j] = up[i<span class="number">-1</span>][j]+<span class="number">1</span>;</span><br><span class="line">l[i][j] = <span class="built_in">max</span>(l[i][j],l[i<span class="number">-1</span>][j]);</span><br><span class="line">r[i][j] = <span class="built_in">min</span>(r[i][j],r[i<span class="number">-1</span>][j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="code"><a href="#code" class="headerlink" title="$code:$"></a>$code:$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">3010</span>;</span><br><span class="line"><span class="type">int</span> a[MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> l[MAXN][MAXN],r[MAXN][MAXN],up[MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> c;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;c);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=c;i++)&#123;</span><br><span class="line"><span class="type">int</span> p,k;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;p,&amp;k);</span><br><span class="line">a[p][k] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=m;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i][j]!=<span class="number">1</span>) l[i][j] = l[i][j<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=m<span class="number">-1</span>;j&gt;=<span class="number">1</span>;j--)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i][j]!=<span class="number">1</span>) r[i][j] = r[i][j+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans  = <span class="number">-11451419</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i][j]!=<span class="number">1</span>)&#123;</span><br><span class="line">up[i][j] = up[i<span class="number">-1</span>][j]+<span class="number">1</span>;</span><br><span class="line">l[i][j] = <span class="built_in">max</span>(l[i][j],l[i<span class="number">-1</span>][j]);</span><br><span class="line">r[i][j] = <span class="built_in">min</span>(r[i][j],r[i<span class="number">-1</span>][j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> len = r[i][j] - l[i][j]+<span class="number">1</span>;</span><br><span class="line">ans = <span class="built_in">max</span>(ans , up[i][j]*len);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>好水啊</del></p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划-悬线法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P3622 [APIO2007]动物园</title>
      <link href="/2020/08/30/p3622/"/>
      <url>/2020/08/30/p3622/</url>
      
        <content type="html"><![CDATA[<h1 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h1><p>给一个$n$个数的环,$c$个人,每个人都可以看到环上的五个位置,且都有子集喜欢和不喜欢的数,当这五个位置至少有一个他喜欢的数字或至少有一个他不喜欢的数字被移走时,该人会开心,求让最多能让多少个人开心</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>比较难想的状压$dp$</p><p>每一个数有没有被撤走可以用$0$和$1$来表示,考虑状态压缩</p><p>考虑到每个人可以看到五个格子,不妨设:</p><p>$num[i][j]$为当区间$[i,i+4]$的状态为$j$时的开心人数</p><p>首先将每个人害怕和不害怕的动物压缩一个状态</p><p>枚举状态$j$,当且仅当五个位置至少有一个他喜欢的数字或至少有一个他不喜欢的数字时,该人会开心</p><p>即$((j$ &amp; $dislike)||($~$j$&amp; $like))$时,$num[i][j]++$</p><p>设$f[i][s]$为区间$[i,i+4]$的状态为$s$时的最多开心人数</p><p>考虑到当区间$[i,i+4]$移动到区间$[i+1,i+5]$时,前四位数字是不变的,因此关心的只有最后一位数的情况</p><p>得到转移$:$</p><p>$f[i][s] &#x3D; max(f[i-1][(s$&amp;$15)&gt;&gt;1]$,$f[i-1][(s$&amp;$15)&gt;&gt;1|1])+num[i][s]$</p><p>解释:</p><p>$15$的二进制为$01111$,&amp;$15$即为取后四位,$&gt;&gt;1$和$&gt;&gt;1|1$分别代表$i-1$位置的不选与选</p><p>需要注意的是这里的数是一个环,因此只有当开头和结尾的状态一致时才是有效状态</p><h2 id="code"><a href="#code" class="headerlink" title="$code:$"></a>$code:$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">50010</span>;</span><br><span class="line"><span class="type">int</span> n,c;</span><br><span class="line"><span class="type">int</span> num[MAXN][<span class="number">50</span>],f[MAXN][<span class="number">50</span>],ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;c;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=c;i++)&#123;</span><br><span class="line"><span class="type">int</span> e,f,l;</span><br><span class="line"><span class="type">int</span> like=<span class="number">0</span>,dislike=<span class="number">0</span>;</span><br><span class="line">cin&gt;&gt;e&gt;&gt;f&gt;&gt;l;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=f;j++)&#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line">cin&gt;&gt;a;</span><br><span class="line">a = (a-e+n)%n;</span><br><span class="line">like|=<span class="number">1</span>&lt;&lt;a;<span class="comment">//状态压缩</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=l;j++)&#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line">cin&gt;&gt;a;</span><br><span class="line">a = (a-e+n)%n;</span><br><span class="line">dislike|=<span class="number">1</span>&lt;&lt;a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">32</span>;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>((j&amp;dislike)||(~j&amp;like)) num[e][j]++;<span class="comment">//判断是否合法</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;<span class="comment">//枚举前5个数的状态</span></span><br><span class="line"><span class="built_in">memset</span>(f[<span class="number">0</span>],<span class="number">-20</span>,<span class="built_in">sizeof</span>(f[<span class="number">0</span>]));</span><br><span class="line"> f[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;<span class="number">32</span>;k++)&#123;</span><br><span class="line">f[j][k] = <span class="built_in">max</span>(f[j<span class="number">-1</span>][(k&amp;<span class="number">15</span>)&lt;&lt;<span class="number">1</span>],f[j<span class="number">-1</span>][(k&amp;<span class="number">15</span>)&lt;&lt;<span class="number">1</span>|<span class="number">1</span>])+num[j][k];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ans = <span class="built_in">max</span>(ans , f[n][i]);<span class="comment">//由于是一个环,当且仅当末尾和开头状态重合时才是有效答案</span></span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划-状压dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P2051 [AHOI2009]中国象棋</title>
      <link href="/2020/08/30/p2051/"/>
      <url>/2020/08/30/p2051/</url>
      
        <content type="html"><![CDATA[<h1 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h1><p>给一个$n×m$的棋盘,在上面放若干个炮,求有多少种放置方法可以使没有一个炮可以攻击到另一个炮</p><p>$1≤n,m≤100$</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>观察可以发现,每行每列最多只能放两个炮,一列能放炮的位置和之前该列放过的炮的个数有关,且<strong>两列棋子数相等的列是等价的</strong>,考虑设$f(i,j,k)$表示前$i$行中,有$j$列放了1个棋子,$k$列放了两个棋子</p><p>分类讨论每种情况,有转移:</p><p>$\begin{cases}f(i+1,j,k) +&#x3D; f(i,j,k)&amp;(一个都不放)\f(i+1,j-1,k+1) +&#x3D;f(i,j,k)×j&amp;(放一个,放在之前已经放了一个的列上)\f(i+1,j+1,k) +&#x3D;f(i,j,k)×(m-j-k)&amp;(放一个,放在之前一个都没有的列上)\f(i+1,j+1,k) +&#x3D;f(i,j,k)×C_{m-j-k}^2&amp;(放两个,都放在之前一个都没有的列上)\f(i+1,j-2,k+2) +&#x3D;f(i,j,k)×C_j^2&amp;(放两个,都放在之前已经放了一个的列上)\f(i+1,j,k+1) +&#x3D;f(i,j,k)×(m-j-k)×j&amp;(放两个,一个放在之前已经放了一个的列上,一个放在之前一个都没有的列上)\end{cases}$</p><h2 id="code"><a href="#code" class="headerlink" title="$code:$"></a>$code:$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">110</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mo 9999973</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> C(x) (((x)*(x-1)/2)%mo)</span></span><br><span class="line"><span class="type">int</span> f[MAXN][MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=m;j++)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k+j&lt;=m;k++)&#123;</span><br><span class="line"><span class="keyword">if</span>(f[i][j][k])&#123;</span><br><span class="line">f[i+<span class="number">1</span>][j][k] = (f[i][j][k]+f[i+<span class="number">1</span>][j][k])%mo;</span><br><span class="line"><span class="keyword">if</span>(j&gt;=<span class="number">1</span>) f[i+<span class="number">1</span>][j<span class="number">-1</span>][k+<span class="number">1</span>] = (f[i+<span class="number">1</span>][j<span class="number">-1</span>][k+<span class="number">1</span>]+f[i][j][k]*j)%mo;</span><br><span class="line"><span class="keyword">if</span>(j&gt;=<span class="number">1</span>&amp;&amp;(m-j-k)&gt;<span class="number">0</span>) f[i+<span class="number">1</span>][j][k+<span class="number">1</span>] =(f[i+<span class="number">1</span>][j][k+<span class="number">1</span>]+f[i][j][k]*(m-j-k)*j)%mo;</span><br><span class="line"><span class="keyword">if</span>((m-j-k)&gt;<span class="number">0</span>) f[i+<span class="number">1</span>][j+<span class="number">1</span>][k] = (f[i+<span class="number">1</span>][j+<span class="number">1</span>][k]+f[i][j][k]*(m-j-k))%mo;</span><br><span class="line"><span class="keyword">if</span>(j&gt;=<span class="number">2</span>) f[i+<span class="number">1</span>][j<span class="number">-2</span>][k+<span class="number">2</span>] = (f[i+<span class="number">1</span>][j<span class="number">-2</span>][k+<span class="number">2</span>]+f[i][j][k]*<span class="built_in">C</span>(j))%mo;</span><br><span class="line"><span class="keyword">if</span>((m-j-k)&gt;<span class="number">1</span>) f[i+<span class="number">1</span>][j+<span class="number">2</span>][k] = (f[i+<span class="number">1</span>][j+<span class="number">2</span>][k]+f[i][j][k]*<span class="built_in">C</span>(m-j-k))%mo;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j+i&lt;=m;j++)&#123;</span><br><span class="line">ans = (ans+f[n][i][j])%mo;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans%mo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重构于2021&#x2F;6&#x2F;29</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划-线性dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P2501 [HAOI2006]数字序列</title>
      <link href="/2020/08/28/p2501/"/>
      <url>/2020/08/28/p2501/</url>
      
        <content type="html"><![CDATA[<h1 id="P2501-HAOI2006-数字序列"><a href="#P2501-HAOI2006-数字序列" class="headerlink" title="P2501 [HAOI2006]数字序列"></a>P2501 [HAOI2006]数字序列</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给一个长为$n$的序列,求把它改成一个单调递增的序列最少需要改变的数和每个数改变的绝对值之和的最小值</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>神仙$dp$题</p><h2 id="第一问"><a href="#第一问" class="headerlink" title="第一问"></a>第一问</h2><p>直接做不太好做,考虑转化</p><p>最少需要改变的数 $&#x3D;$ 总数 $-$ 最多不需要改变的数</p><p>若两个数$a_i$,$a_j$$(i&gt;j)$可以保留,则必须满足:</p><p>$a_i - a_j ≥i-j$</p><p>移项,得</p><p>$a_i-i≥a_j-j$</p><p>令$b_i &#x3D; a_i - i$</p><p>于是原问题就转化为了求$b_i$的最长不下降子序列和在改变最少的数的条件下让$b_i$成为最长不下降序列的最小代价</p><p>最后输出$n -b$的最长不下降子序列长度 即可</p><h2 id="第二问"><a href="#第二问" class="headerlink" title="第二问"></a>第二问</h2><p>首先有个结论$:$</p><p>对于任意区间$[l,r]$,一定存在一个分界点$i$,使得当区间$[l,i]$的值全部修改为$b_{l-1}$,区间$[i+1,r]$的值全部修改为$b_{r+1}$时总花费最小</p><p>证明$:$</p><p>首先任意的$k∈[l,r]$,其对应的$b_k$值一定大于$b_{r+1}$或小于$b_{l-1}$</p><p>假设一段中一共有$x$个大于$b_{r+1}$的数,$y$个小于$b_{l-1}$的数</p><p>如果$x&lt;y$,那么把这一段整体改成$b_{r+1}$时总花费显然会最小</p><p>反之,若$x&gt;y$,那么把这一段整体改为$b_{l-1}$时总花费显然会最小</p><p>因此,最优解一定为将左边一段改为$b_{l-1}$,右边一段改为$b_{r+1}$</p><p>设$F_i$为以$i$为结尾时的最小代价,$last$为$i$的前驱</p><p>则有转移方程：</p><p>$F_i &#x3D; F_k+\sum_{j&#x3D;last+1}^k|b_j-b_{last}|+\sum_{j&#x3D;k+1}^{i-1}|b_j-b_{i}|$</p><h2 id="code"><a href="#code" class="headerlink" title="$code:$"></a>$code:$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">35010</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 1e12</span></span><br><span class="line"><span class="type">int</span> a[MAXN],b[MAXN],T[MAXN],f[MAXN],n;</span><br><span class="line"><span class="type">int</span> l,r,len;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; g[MAXN];</span><br><span class="line"><span class="type">int</span> sum1[MAXN],sum2[MAXN];<span class="comment">//前后缀和 </span></span><br><span class="line"><span class="type">int</span> F[MAXN];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n);</span><br><span class="line"><span class="built_in">memset</span>(F,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(F));</span><br><span class="line">g[<span class="number">0</span>].<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">b[<span class="number">0</span>] = -inf,b[n+<span class="number">1</span>] = inf;<span class="comment">//边界 </span></span><br><span class="line">F[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i]);</span><br><span class="line">b[i] = a[i] - i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)&#123;<span class="comment">//求最长不下降子序列 </span></span><br><span class="line">l=<span class="number">0</span>,r=len;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line"><span class="type">int</span> mid = (l+r+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(T[mid]&lt;=b[i]) l = mid;</span><br><span class="line"><span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(l==len) len++;</span><br><span class="line">f[i] = l+<span class="number">1</span>;</span><br><span class="line">T[l+<span class="number">1</span>] = b[i];</span><br><span class="line">g[f[i]].<span class="built_in">push_back</span>(i);<span class="comment">//记录长度为f[i]的最长不下降子序列的结尾i </span></span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;n-len+<span class="number">1</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;g[f[i]<span class="number">-1</span>].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line"><span class="type">int</span> start = g[f[i]<span class="number">-1</span>][j];</span><br><span class="line"><span class="keyword">if</span>(b[start]&gt;b[i]) <span class="keyword">continue</span>; </span><br><span class="line">sum1[start] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=start+<span class="number">1</span>;k&lt;=i<span class="number">-1</span>;k++)&#123;</span><br><span class="line">sum1[k] = sum1[k<span class="number">-1</span>]+<span class="built_in">abs</span>(b[start]-b[k]);<span class="comment">//前缀和 </span></span><br><span class="line">&#125;</span><br><span class="line">sum2[i<span class="number">-1</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=i<span class="number">-2</span>;k&gt;=start;k--)&#123;</span><br><span class="line">sum2[k] = sum2[k+<span class="number">1</span>]+<span class="built_in">abs</span>(b[k+<span class="number">1</span>]-b[i]);<span class="comment">//后缀和 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=start;k&lt;=i<span class="number">-1</span>;k++)&#123;<span class="comment">//枚举分界点 </span></span><br><span class="line">F[i] = <span class="built_in">min</span>(F[i] , F[start]+sum1[k]+sum2[k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;F[n+<span class="number">1</span>];</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="坑点-amp-amp-感想"><a href="#坑点-amp-amp-感想" class="headerlink" title="坑点&amp;&amp;感想"></a>坑点&amp;&amp;感想</h2><ul><li>注意补集转化</li></ul>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划-线性dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P5664 Emiya家今天的饭</title>
      <link href="/2020/08/27/p5664/"/>
      <url>/2020/08/27/p5664/</url>
      
        <content type="html"><![CDATA[<h1 id="P5664-Emiya-家今天的饭"><a href="#P5664-Emiya-家今天的饭" class="headerlink" title="P5664 Emiya 家今天的饭"></a>P5664 Emiya 家今天的饭</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给一个$n×m$的矩阵,从矩阵中选出$k$个元素</p><p>要求满足:</p><ul><li><p>每行只能选一个元素</p></li><li><p>每列的元素个数$≤\dfrac{k}{2}$</p></li></ul><p>求满足条件的集合的方案数之和</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><h2 id="算法一"><a href="#算法一" class="headerlink" title="算法一"></a>算法一</h2><p>先来观察一下限制</p><p>由于不可能有两列都超过总数的一半,不合法的列只可能有一列</p><p>直接做可能不太好做,考虑容斥</p><ul><li>合法方案数 $&#x3D;$ 总方案数 $-$ 不合法方案数</li></ul><p>对于不合法的方案数:</p><p>若一个集合不合法,说明某一列的选择个数一定大于其他列中选择个数之和,因此考虑去枚举哪一列不合法</p><p>设$sum[i]$为第$i$行的和</p><p>设$f[i][j][k]$为第$p$列,前$i$行,$p$列中选取了$j$个数,其他列中选取了$k$个数</p><p>则有转移:</p><ul><li>$f[i][j][k] &#x3D; f[i-1][j][k]+(sum[i]-a[i][now])×f[i-1][j][k-1]+a[i][now]×f[i-1][j-1][k]$</li></ul><p>对于总方案数:</p><p>每一行都可以选择一个元素或不选,根据乘法原理,得到:</p><p>$ans &#x3D; ∏_{i&#x3D;1}^n∑_{j&#x3D;1}^ma[i][j]-1$(-1是减去空集)</p><p>复杂度$O(mn^3)$,可以获得$84pts$</p><h2 id="code"><a href="#code" class="headerlink" title="$code:$"></a>$code:$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mo 998244353</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">110</span>,MAXM =<span class="number">2010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> a[MAXN][MAXM];</span><br><span class="line"><span class="type">int</span> sum[MAXN];</span><br><span class="line"><span class="type">int</span> f[MAXN][MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> CUT = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i][j]);</span><br><span class="line">sum[i]+=a[i][j]; </span><br><span class="line">sum[i]%=mo;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">ans *=(<span class="number">1</span>+sum[i])%mo;</span><br><span class="line">ans%=mo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ans = (ans<span class="number">-1</span>+mo)%mo;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> now=<span class="number">1</span>;now&lt;=m;now++)&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=i;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=i-j;k++)&#123;</span><br><span class="line">f[i][j][k] = f[i - <span class="number">1</span>][j][k];</span><br><span class="line">                    f[i][j][k] += (j&gt;<span class="number">0</span>?f[i - <span class="number">1</span>][j - <span class="number">1</span>][k]:<span class="number">0</span>)* a[i][now] % mo;</span><br><span class="line">                    f[i][j][k] %= mo;</span><br><span class="line">                    f[i][j][k] += (sum[i] - a[i][now] + mo) % mo * (k&gt;<span class="number">0</span>?f[i - <span class="number">1</span>][j][k<span class="number">-1</span>]:<span class="number">0</span>) % mo;</span><br><span class="line">                    f[i][j][k] %= mo;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=n-i;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i&gt;j) CUT=(CUT+f[n][i][j])%mo;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;(ans-CUT+mo)%mo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法二"><a href="#算法二" class="headerlink" title="算法二"></a>算法二</h2><p>考虑进一步优化,减去无用状态</p><p>注意到在转移过程中,我们并不关心$k$和$j$的具体数值,而只关心其相对大小关系,考虑直接记录差值</p><p>蛇$f[i][j]$为第$p$列,前$i$行,第$p$列和其他列的差值</p><p>则有转移:</p><p>$f[i][j] &#x3D; f[i-1][j]+f[i-1][j-1]×a[i][p]+f[i-1][j+1]*(sum[i]-a[i][p])$</p><p>复杂度$O(mn^2)$</p><h2 id="code-1"><a href="#code-1" class="headerlink" title="$code:$"></a>$code:$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">210</span>,MAXM = <span class="number">2010</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mo 998244353</span></span><br><span class="line"><span class="type">int</span> a[MAXN][MAXM];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> f[MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> sum[MAXN];</span><br><span class="line"><span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> udk = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;a[i][j]);</span><br><span class="line">sum[i]+=a[i][j];</span><br><span class="line">sum[i]%=mo;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">ans*=(sum[i]+<span class="number">1</span>)%mo;</span><br><span class="line">ans%=mo;</span><br><span class="line">&#125;</span><br><span class="line">ans = (ans<span class="number">-1</span>+mo)%mo;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> p = <span class="number">1</span>;p&lt;=m;p++)&#123;</span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line">f[<span class="number">0</span>][n] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=n-i;j&lt;=n+i;j++)&#123;</span><br><span class="line">f[i][j] = ((f[i<span class="number">-1</span>][j]%mo+f[i<span class="number">-1</span>][j+<span class="number">1</span>]*(sum[i]-a[i][p]+mo)%mo)%mo+f[i<span class="number">-1</span>][j<span class="number">-1</span>]*a[i][p]%mo)%mo;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">udk=(udk+f[n][i+n])%mo;</span><br><span class="line">udk%=mo;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;(ans-udk+mo)%mo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="坑点-amp-amp-感想"><a href="#坑点-amp-amp-感想" class="headerlink" title="坑点&amp;&amp;感想"></a>坑点&amp;&amp;感想</h2><ul><li><p>原问题不太可做时,可以考虑容斥</p></li><li><p>转移时若只关心相对大小关系,可以直接记录差值</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划-背包dp </tag>
            
            <tag> 容斥 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P5658 括号树</title>
      <link href="/2020/08/26/p5658/"/>
      <url>/2020/08/26/p5658/</url>
      
        <content type="html"><![CDATA[<p>重构于$2021&#x2F;1&#x2F;30$</p><h1 id="P5658-括号树"><a href="#P5658-括号树" class="headerlink" title="P5658 括号树"></a>P5658 括号树</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给一颗$n$个节点的树,每个结点上都有一个左括号或右括号</p><p>定义 $s_i$为将根结点到 $i$ 号结点的简单路径上的括号，按结点经过顺序依次排列组成的字符串。$k_i$表示$s_i$中不同的合法括号子串的个数，</p><p>求$i \times k_i$的异或和</p><p>$n≤5×10^5$</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>显然只有在当前节点括号为”$)$”且前面有未匹配上的”$($”的时候才会产生新的合法括号</p><p>设$f_i$为从根节点到$i$节点的合法字符字串,$last_i$为$i$节点前上一个没有匹配的”$($”,$g_i$为以$i$为结尾的合法串数量</p><p>$f_i &#x3D; \sum g_{last_{i-1}}+1$</p><h2 id="code"><a href="#code" class="headerlink" title="$code:$"></a>$code:$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">500010</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">e</span>&#123;</span><br><span class="line"><span class="type">int</span> to,next;</span><br><span class="line">&#125;edge[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> head[MAXN&lt;&lt;<span class="number">1</span>],cnt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">edge[++cnt].to = v;</span><br><span class="line">edge[cnt].next = head[u];</span><br><span class="line">head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> a[MAXN];</span><br><span class="line"><span class="type">int</span> n,sum,F[MAXN],fa[MAXN];</span><br><span class="line"><span class="type">int</span> last[MAXN];</span><br><span class="line"><span class="type">int</span> num[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> f)</span></span>&#123;</span><br><span class="line">last[u] = last[fa[u]];</span><br><span class="line">F[u] = F[fa[u]];</span><br><span class="line"><span class="keyword">if</span>(a[u]==<span class="string">&#x27;(&#x27;</span>) last[u] = u;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(a[u]==<span class="string">&#x27;)&#x27;</span>&amp;&amp;last[u]!=<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(last[u]==fa[u]) num[u] = num[fa[u]]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> num[u] = num[fa[last[u]]]+<span class="number">1</span>;</span><br><span class="line">last[u] = last[fa[last[u]]];</span><br><span class="line">F[u]+=num[u];</span><br><span class="line">&#125;</span><br><span class="line">ans^=u*F[u];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(f==v) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs</span>(v,u);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">cin&gt;&gt;fa[i];</span><br><span class="line"><span class="built_in">add</span>(i,fa[i]);</span><br><span class="line"><span class="built_in">add</span>(fa[i],i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>); </span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P1295 [TJOI2011]书架</title>
      <link href="/2020/08/26/p1295/"/>
      <url>/2020/08/26/p1295/</url>
      
        <content type="html"><![CDATA[<h1 id="P1295-TJOI2011-书架"><a href="#P1295-TJOI2011-书架" class="headerlink" title="P1295 [TJOI2011]书架"></a>P1295 [TJOI2011]书架</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给出一个长度为 $n$ 的序列 $h$，请将 $h$ 分成若干段，满足每段数字之和都不超过 $m$，最小化每段的最大值之和。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h2 id="算法一"><a href="#算法一" class="headerlink" title="算法一"></a>算法一</h2><p>有个非常直观的想法</p><p>设$f[i]$为前$i$个数的最小值</p><p><del>根据套路</del>易得到转移方程:</p><ul><li>$f[i] &#x3D; min(f[j]+max(h[j+1]$~$h[i]))(\sum_{j+1}^ih[i]&lt;&#x3D;m)$</li></ul><p>复杂度$O(n^2)$</p><p>吸氧后可以取得80pts的<del>好成绩</del></p><h2 id="code"><a href="#code" class="headerlink" title="$code:$"></a>$code:$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100010</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">int</span> f[MAXN] , h[MAXN];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> sum[MAXN];</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;h[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">sum[i] = sum[i<span class="number">-1</span>]+h[i];</span><br><span class="line">&#125;</span><br><span class="line">f[<span class="number">1</span>] = h[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">f[i] = <span class="number">191981019</span>;</span><br><span class="line"><span class="type">int</span> maxn = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line"><span class="keyword">if</span>(sum[i] - sum[j]&gt;m) <span class="keyword">break</span>;</span><br><span class="line">maxn =<span class="built_in">max</span>(h[j+<span class="number">1</span>],maxn);</span><br><span class="line">f[i] = <span class="built_in">min</span>(f[i],f[j]+maxn);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;f[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法二"><a href="#算法二" class="headerlink" title="算法二"></a>算法二</h2><p>线段树优化$dp$</p><p>回到上面那个方程</p><p> $f[i] &#x3D; min(f[j]+max(h[j+1]$~$h[i]))(\sum_{j+1}^ih[i]&lt;&#x3D;m)$</p><p> $\sum_{j+1}^ih[i]&lt;&#x3D;m$这个限制我们可以通过二分得到</p><p> 设$pos_i$为最左端点</p><p> 问题就转化成了:</p><p>  $f[i] &#x3D; min(f[j]+max(h[j+1]$~$h[i]))(pos_i&lt;&#x3D;m)$</p><p>首先对于每个$i$,如果有一个位置$pos$满足$[pos,i)$中的$h$均小于$h[i]$,显然其后面的所有$maxh[i]$都为$h[i]$</p><p>开一个单调栈,找出这个位置$l$，并将区间$[l+1,i)$的位置全部改为$h[i]$</p><p>区间修改,考虑使用线段树来维护</p><p>用线段树来维护两个值,$f[i-1]$和$f[j]+max(h[j+1]$~$h[i])$</p><p>每当枚举到一个$i$时</p><ul><li><p>更新$i$节点的$f[i-1]$ $~~~~~$(单点修改)</p></li><li><p>将区间$[l+1,i)$的位置全部改为$h[i]$ $~~~~~$(区间修改)</p></li><li><p>二分查找$i$最左端点,并查询区间$[l+1,i]$的最小$f[j]+max(h[j+1]$~$h[i])$ $~~~~~$(区间查询)</p></li></ul><h2 id="算法三-补充"><a href="#算法三-补充" class="headerlink" title="算法三(补充)"></a>算法三(补充)</h2><p><del>过了半年后重做这道题时yy出来的想法</del></p><p>考虑对算法一的方程进行优化,使用线段树来维护$max(h_i)$和$min(f_j+max(h_i))$,并在每次更新时插入新值</p><p>同时,对于$\sum_{j+1}^ih&lt;&#x3D;m$的限制条件,因为左端点的更新都是只增不减的,只需要在处理新数据之前先进行一次二分，找到左端点即可</p><p>总复杂度$O(nlogn)$</p><h2 id="code-1"><a href="#code-1" class="headerlink" title="$code:$"></a>$code:$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson (node&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson (node&lt;&lt;1|1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 1e12+1145</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mid ((l+r)&gt;&gt;1)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100010</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st</span>&#123;</span><br><span class="line"><span class="type">int</span> ans,tag,val;</span><br><span class="line"><span class="type">int</span> l,r;</span><br><span class="line">&#125;tree[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[MAXN],n,m;</span><br><span class="line"><span class="type">int</span> sta[MAXN],sum[MAXN],top = <span class="number">0</span>,last[MAXN],f[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;<span class="comment">//上传</span></span><br><span class="line">tree[node].ans = <span class="built_in">min</span>(tree[rson].ans,tree[lson].ans);</span><br><span class="line">tree[node].val = <span class="built_in">min</span>(tree[rson].val,tree[lson].val);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">tree[node].l = l,tree[node].r = r;</span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">tree[node].tag = tree[node].val = tree[node].ans = inf;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">build</span>(lson,l,mid);</span><br><span class="line"><span class="built_in">build</span>(rson,mid+<span class="number">1</span>,r);</span><br><span class="line"><span class="built_in">pushup</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tree[node].tag==inf) <span class="keyword">return</span>;</span><br><span class="line">tree[lson].ans = tree[lson].val+tree[node].tag;<span class="comment">//更新最小值</span></span><br><span class="line">tree[rson].ans = tree[rson].val+tree[node].tag;</span><br><span class="line">tree[lson].tag = tree[rson].tag = tree[node].tag;</span><br><span class="line">tree[node].tag = inf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tree[node].l&gt;=l&amp;&amp;tree[node].r&lt;=r)&#123;</span><br><span class="line"><span class="keyword">return</span> tree[node].ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pushdown</span>(node);</span><br><span class="line"><span class="type">int</span> miD = (tree[node].l+tree[node].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> Ans = inf;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=miD) Ans = <span class="built_in">min</span>(Ans , <span class="built_in">query</span>(lson,l,r));</span><br><span class="line"><span class="keyword">if</span>(r&gt;miD) Ans = <span class="built_in">min</span>(Ans , <span class="built_in">query</span>(rson,l,r));</span><br><span class="line"><span class="keyword">return</span> Ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update1</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> c)</span></span>&#123;<span class="comment">//区间修改</span></span><br><span class="line"><span class="keyword">if</span>(tree[node].l&gt;=l&amp;&amp;tree[node].r&lt;=r)&#123;</span><br><span class="line">tree[node].tag = c;</span><br><span class="line">tree[node].ans = tree[node].val+c;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pushdown</span>(node);</span><br><span class="line"><span class="type">int</span> miD = (tree[node].l+tree[node].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=miD) <span class="built_in">update1</span>(lson,l,r,c);</span><br><span class="line"><span class="keyword">if</span>(r&gt;miD) <span class="built_in">update1</span>(rson,l,r,c);</span><br><span class="line"><span class="built_in">pushup</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update2</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> x)</span></span>&#123;<span class="comment">//单点修改</span></span><br><span class="line"><span class="keyword">if</span>(tree[node].l==tree[node].r)&#123;</span><br><span class="line">tree[node].val = f[x<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pushdown</span>(node);</span><br><span class="line"><span class="type">int</span> miD = (tree[node].l+tree[node].r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=miD) <span class="built_in">update2</span>(lson,x);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">update2</span>(rson,x);</span><br><span class="line"><span class="built_in">pushup</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;h[i]);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">sum[i] = sum[i<span class="number">-1</span>]+h[i];</span><br><span class="line">&#125;</span><br><span class="line">sta[++top] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(h[i]&gt;h[sta[top]]&amp;&amp;top) top--;</span><br><span class="line"><span class="keyword">if</span>(top) last[i] = sta[top];</span><br><span class="line">sta[++top] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">update2</span>(<span class="number">1</span>,i);</span><br><span class="line"><span class="keyword">if</span>(last[i]&lt;i) <span class="built_in">update1</span>(<span class="number">1</span>,last[i]+<span class="number">1</span>,i,h[i]);</span><br><span class="line"><span class="type">int</span> begin = <span class="built_in">lower_bound</span>(sum,sum+i+<span class="number">1</span>,sum[i]-m)-sum;</span><br><span class="line"><span class="keyword">if</span>(begin&lt;i) f[i] = <span class="built_in">query</span>(<span class="number">1</span>,begin+<span class="number">1</span>,i);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;f[n];</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="坑点-amp-amp-感想"><a href="#坑点-amp-amp-感想" class="headerlink" title="坑点&amp;&amp;感想"></a>坑点&amp;&amp;感想</h2><ul><li><p>$inf$的值一定要设大</p></li><li><p>条件允许时,可以考虑使用线段树来优化$dp$</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
            <tag> 动态规划-线段树优化dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P1944 最长括号匹配</title>
      <link href="/2020/08/25/p1944/"/>
      <url>/2020/08/25/p1944/</url>
      
        <content type="html"><![CDATA[<h1 id="P1944-最长括号匹配"><a href="#P1944-最长括号匹配" class="headerlink" title="P1944 最长括号匹配"></a>P1944 最长括号匹配</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给一个由(,),[,]括号组成的字符串，求出其中最长的括号匹配子串。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>水题</p><h2 id="算法一"><a href="#算法一" class="headerlink" title="算法一"></a>算法一</h2><p>比较容易想到的一种算法</p><p>直接用栈来维护,用$vis[i]$来记录第$i$位是否匹配成功</p><p>找出最长的一段输出即可</p><h2 id="code"><a href="#code" class="headerlink" title="$code:$"></a>$code:$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1000010</span>;</span><br><span class="line">string s;</span><br><span class="line">stack&lt;<span class="type">char</span>&gt; S;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; pos;</span><br><span class="line"><span class="type">bool</span> tr[MAXN];</span><br><span class="line"><span class="type">int</span> ans[<span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> L =<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;s;</span><br><span class="line">s = <span class="string">&#x27; &#x27;</span>+s;</span><br><span class="line">S.<span class="built_in">push</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">pos.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line"><span class="keyword">if</span>((s[i]==<span class="string">&#x27;)&#x27;</span>&amp;&amp;S.<span class="built_in">top</span>()==<span class="string">&#x27;(&#x27;</span>)||(s[i]==<span class="string">&#x27;]&#x27;</span>&amp;&amp;S.<span class="built_in">top</span>()==<span class="string">&#x27;[&#x27;</span>)) tr[i] = tr[pos.<span class="built_in">top</span>()] = <span class="number">1</span>,S.<span class="built_in">pop</span>(),pos.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">else</span> pos.<span class="built_in">push</span>(i) , S.<span class="built_in">push</span>(s[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> now = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(tr[i])&#123;</span><br><span class="line">now++;</span><br><span class="line"><span class="keyword">if</span>(now&gt;ans[<span class="number">3</span>])&#123;</span><br><span class="line">ans[<span class="number">3</span>] = now,ans[<span class="number">1</span>] = L,ans[<span class="number">2</span>] = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">now = <span class="number">0</span>;</span><br><span class="line">L = i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=ans[<span class="number">1</span>];i&lt;=ans[<span class="number">2</span>];i++)&#123;</span><br><span class="line">cout&lt;&lt;s[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法二"><a href="#算法二" class="headerlink" title="算法二"></a>算法二</h2><p>设$f[i]$为以第$i$位为末尾的匹配括号字串的最长长度</p><p>若$s[i]$为$($或$[$,不可能匹配,直接跳过即可</p><p>如果$s[i]$为$)$或$]$</p><p>设与$s[i]$相匹配的字符为$s[k]$</p><p>$1.$首先$k$肯定不能在区间$[i-f[i-1],i)$,该区间内的每个字符都已经”被匹配了”</p><p>$2.$假设$k$在区间$[1,i-f[i-1]-1)$中,说明区间$[k+1,i-1]$的字符都是匹配的,与$f[i-1]$矛盾</p><p>综上,$k$能在的位置只有$i-f[i-1]-1$</p><p>得到转移方程:</p><ul><li>$f[i] &#x3D; f[i-1]+f[i-f[i-1]-2]+2$</li></ul><h2 id="code-1"><a href="#code-1" class="headerlink" title="$code:$"></a>$code:$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1000010</span>;</span><br><span class="line"><span class="type">int</span> f[MAXN];</span><br><span class="line"><span class="type">int</span> ans = <span class="number">-114514</span>;</span><br><span class="line">string s;</span><br><span class="line"><span class="type">int</span> start,end;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;s;</span><br><span class="line">s = <span class="string">&#x27; &#x27;</span>+s;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(s[i]==<span class="string">&#x27;)&#x27;</span>||s[i]==<span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>((s[i]==<span class="string">&#x27;]&#x27;</span>&amp;&amp;s[i-f[i<span class="number">-1</span>]<span class="number">-1</span>]==<span class="string">&#x27;[&#x27;</span>)||(s[i]==<span class="string">&#x27;)&#x27;</span>&amp;&amp;s[i-f[i<span class="number">-1</span>]<span class="number">-1</span>]==<span class="string">&#x27;(&#x27;</span>))&#123;</span><br><span class="line">f[i] = f[i<span class="number">-1</span>]+f[i-f[i<span class="number">-1</span>]<span class="number">-2</span>]+<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(f[i]&gt;ans)&#123;</span><br><span class="line">ans = f[i],end = i;</span><br><span class="line">start = i-f[i]+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=start;i&lt;=end;i++)&#123;</span><br><span class="line">cout&lt;&lt;s[i];</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划-区间dp </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P5851 [USACO]Greedy Pie Eaters P</title>
      <link href="/2020/08/24/p5851/"/>
      <url>/2020/08/24/p5851/</url>
      
        <content type="html"><![CDATA[<h1 id="P5851-USACO-Greedy-Pie-Eaters-P"><a href="#P5851-USACO-Greedy-Pie-Eaters-P" class="headerlink" title="P5851 [USACO]Greedy Pie Eaters P"></a>P5851 [USACO]Greedy Pie Eaters P</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有$M$头奶牛,$N$个派,每头奶牛都有一个吃派的范围和体重,分别用$l$,$r$,$w$表示</p><p>求出每头奶牛按顺序吃完后,满足每个奶牛都吃到至少一个派的情况下的最大体重值之和</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>设$f[i][j]$为区间$[i,j]$可获得的最大权值</p><p>$w[i][j][k]$为能吃掉$k$的最大的一个$w$$(i\le l\le k\le r\le j)$</p><p>先来考虑如何去搞出$w[i][j][k]$</p><p>可以去用已知的$w[i][j][k]$去一个个向外更新,扩展到整个序列</p><p>得到方程:</p><p>$w[i-1][j][k] &#x3D; max(w[i][j][k] , w[i-1][j][k])$</p><p>$w[i][j+1][k] &#x3D; max(w[i][j][k] , w[i][j+1][k])$</p><p>要注意的是这里的枚举顺序</p><p>因为是不断向外扩展更新的,在枚举$i$时要倒序枚举,枚举$j$时要正序枚举</p><p>转移方程的话首先可以联想到</p><p>$f[i][j] &#x3D; max(f[i][k]+f[k+1][j])(i\le k &lt;j)$</p><p>但由于这样转移不能让新进干员吃到派</p><p>因此转移方程要改为</p><ul><li>$f[i][j] &#x3D; max(f[i][k-1]+w[i][j][k]+f[k+1][j])$(第$k$个派还未被吃)</li></ul><h2 id="坑点-amp-amp-感想"><a href="#坑点-amp-amp-感想" class="headerlink" title="坑点&amp;&amp;感想"></a>坑点&amp;&amp;感想</h2><ul><li><p>注意元素之前的关系</p></li><li><p>注意更新顺序和枚举顺序</p></li></ul><h2 id="code"><a href="#code" class="headerlink" title="$code:$"></a>$code:$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">310</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> dp[MAXN][MAXN] , w[MAXN][MAXN][MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="type">int</span> l,r,val;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;val,&amp;l,&amp;r);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = l;j&lt;=r;j++)&#123;</span><br><span class="line"></span><br><span class="line">w[l][r][j] = <span class="built_in">max</span>(w[l][r][j] , val);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=k;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=k;j&lt;=n;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i!=<span class="number">1</span>) w[i<span class="number">-1</span>][j][k] = <span class="built_in">max</span>(w[i][j][k] , w[i<span class="number">-1</span>][j][k]);</span><br><span class="line"><span class="keyword">if</span>(j!=n) w[i][j+<span class="number">1</span>][k] = <span class="built_in">max</span>(w[i][j][k] , w[i][j+<span class="number">1</span>][k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">dp[i][i] = w[i][i][i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">1</span>;len&lt;n;len++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i+len&lt;=n;i++)&#123;</span><br><span class="line"><span class="type">int</span> j = i+len;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;=j;k++)&#123;</span><br><span class="line">dp[i][j] = <span class="built_in">max</span>(dp[i][j] , dp[i][k<span class="number">-1</span>]+dp[k+<span class="number">1</span>][j]+w[i][j][k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;dp[<span class="number">1</span>][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>几篇题解似乎都有些奇奇怪怪的错误?</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划-区间dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P4158 [SCOI2009]粉刷匠</title>
      <link href="/2020/08/23/p4158/"/>
      <url>/2020/08/23/p4158/</url>
      
        <content type="html"><![CDATA[<h1 id="P4158-SCOI2009-粉刷匠"><a href="#P4158-SCOI2009-粉刷匠" class="headerlink" title="P4158 [SCOI2009]粉刷匠"></a>P4158 [SCOI2009]粉刷匠</h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给$n$行长度为$m$的字符串,每个字符都要被粉刷成黑色或白色,一共有$t$次粉刷机会,每次粉刷,只能选择一行字符串中一段连续的子串,然后涂上一种颜色,每个格子最多只能被粉刷一次。</p><p>求最多刷对格子总数</p><p>$n,m≤50,t≤2500$</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>简单的线性$dp$</p><p><strong>算法1</strong></p><p>设$f(i,j,k,0&#x2F;1)$表示粉刷前$i$行第$i$行粉刷前$j$行共用了$k$次操作,前一个刷对$&#x2F;$错时能刷对的最多格子数</p><p>分类讨论每一种情况,转移方程:</p><p>$f(i,j,k,1) &#x3D; \begin{cases}max(f(i,j-1,k-1,0)+1,f(i,j-1,k,1)+1)&amp;a_j&#x3D;a_{j-1}\max(f(i,j-1,k,0)+1,f(i,j-1,k-1,1)+1)&amp;a_j≠a_{j-1}\end{cases}$</p><p>$f(i,j,k,0) &#x3D; \begin{cases}max(f(i,j-1,k,0)+1,f(i,j-1,k-1,1)+1)&amp;a_j&#x3D;a_{j-1}\f(i,j-1,k,1)&amp;a_j≠a_{j-1}\end{cases}$</p><p><strong>算法2</strong></p><p>观察发现,不可能在一段连续相同的字符中出现”转折点”,因此我们可以把相同的一段字符合并起来</p><p>设$val(i,j)$表示第$i$行第$j$段连续字符的长度,转移方程:</p><p>$f(i,j,k,0) &#x3D; max(f(i,j-1,k,1) , f(i,j-1,k-1,0))$<br>$f(i,j,k,1) &#x3D; max(f(i,j-1,k,0) , f(i,j-1,k-1,1)) + val(i,j)$</p><h2 id="code"><a href="#code" class="headerlink" title="$code:$"></a>$code:$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*if(j==1)&#123;</span></span><br><span class="line"><span class="comment">f[i][j][k][1] = max(f[i-1][m][k-1][0]+1,f[i-1][m][k-1][1]+1);</span></span><br><span class="line"><span class="comment">f[i][j][k][0] = max(f[i-1][m][k-1][0],f[i-1][m][k-1][1]);</span></span><br><span class="line"><span class="comment">continue;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">if(s[j]==s[j-1])&#123;</span></span><br><span class="line"><span class="comment">f[i][j][k][1] = max(f[i][j-1][k-1][0]+1,f[i][j-1][k][1]+1);</span></span><br><span class="line"><span class="comment">f[i][j][k][0] = max(f[i][j-1][k][0],f[i][j-1][k-1][1]);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">else&#123;</span></span><br><span class="line"><span class="comment">f[i][j][k][1] = max(f[i][j-1][k][0]+1,f[i][j-1][k-1][1]+1);</span></span><br><span class="line"><span class="comment">f[i][j][k][0] = f[i][j-1][k][1];</span></span><br><span class="line"><span class="comment">&#125;算法1*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">2510</span>,MAXM = <span class="number">60</span>;</span><br><span class="line"><span class="type">int</span> f[MAXM][MAXM][MAXN][<span class="number">2</span>];</span><br><span class="line"><span class="type">char</span> s[MAXN];</span><br><span class="line"><span class="type">int</span> n,m,t;</span><br><span class="line"><span class="type">int</span> tot[MAXM];</span><br><span class="line"><span class="type">int</span> val[MAXM][MAXN]; </span><br><span class="line"><span class="type">int</span> a[MAXM][MAXN];</span><br><span class="line"><span class="type">int</span> dp[MAXM][MAXN];</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;t);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(s[j]!=s[j<span class="number">-1</span>]) ++tot[i];</span><br><span class="line">val[i][tot[i]]++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=tot[i];j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=t;k++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(j==<span class="number">1</span>)&#123;<span class="comment">//从上一行转移</span></span><br><span class="line">    f[i][j][k][<span class="number">0</span>] = <span class="built_in">max</span>(f[i<span class="number">-1</span>][tot[i<span class="number">-1</span>]][k<span class="number">-1</span>][<span class="number">0</span>],f[i<span class="number">-1</span>][tot[i<span class="number">-1</span>]][k<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">    f[i][j][k][<span class="number">1</span>] = <span class="built_in">max</span>(f[i<span class="number">-1</span>][tot[i<span class="number">-1</span>]][k<span class="number">-1</span>][<span class="number">0</span>],f[i<span class="number">-1</span>][tot[i<span class="number">-1</span>]][k<span class="number">-1</span>][<span class="number">1</span>])+val[i][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">f[i][j][k][<span class="number">0</span>] = <span class="built_in">max</span>(f[i][j<span class="number">-1</span>][k][<span class="number">1</span>] , f[i][j<span class="number">-1</span>][k<span class="number">-1</span>][<span class="number">0</span>]);</span><br><span class="line">f[i][j][k][<span class="number">1</span>] = <span class="built_in">max</span>(f[i][j<span class="number">-1</span>][k][<span class="number">0</span>] , f[i][j<span class="number">-1</span>][k<span class="number">-1</span>][<span class="number">1</span>]) + val[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">   ans = <span class="built_in">max</span>(f[n][tot[n]][t][<span class="number">1</span>],f[n][tot[n]][t][<span class="number">0</span>]);</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划-线性dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P4302 [SCOI2003]字符串折叠</title>
      <link href="/2020/08/23/p4302/"/>
      <url>/2020/08/23/p4302/</url>
      
        <content type="html"><![CDATA[<h1 id="P4302-SCOI2003-字符串折叠"><a href="#P4302-SCOI2003-字符串折叠" class="headerlink" title="P4302 [SCOI2003]字符串折叠"></a>P4302 [SCOI2003]字符串折叠</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>比较简单的区间$DP$</p><p>和<a href="https://www.luogu.com.cn/problem/CF607B"><strong>CF607B Zuma</strong></a>类似的思路</p><p>设$f[i][j]$为$s[i]$~$s[j]$的最短折叠长度</p><p>如果该子串本身可以折叠$,$就先把它预处理成它不进行划分可以产生的最小值</p><p>再去和划分成两个区间所产生的最小值进行比较即可</p><h2 id="坑点-amp-amp-感想"><a href="#坑点-amp-amp-感想" class="headerlink" title="坑点&amp;&amp;感想"></a>坑点&amp;&amp;感想</h2><ul><li><del>水题,没啥感想</del></li></ul><h2 id="code"><a href="#code" class="headerlink" title="$code:$"></a>$code:$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> dp[MAXN][MAXN] , num[MAXN];</span><br><span class="line">string s;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pd</span><span class="params">(<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> L,<span class="type">int</span> R)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> now = L<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">114514</span>)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=r;i++)&#123;</span><br><span class="line">now++;</span><br><span class="line"><span class="keyword">if</span>(now&gt;R||s[now]!=s[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(now==R) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dp,inf,<span class="built_in">sizeof</span>(dp));</span><br><span class="line">cin&gt;&gt;s;</span><br><span class="line"><span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">s = <span class="string">&#x27; &#x27;</span>+s; </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dp[i][i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) num[i] = num[i/<span class="number">10</span>]+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> len = <span class="number">1</span>;len&lt;n;len++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> l =<span class="number">1</span>;l+len&lt;=n;l++)&#123;</span><br><span class="line"><span class="type">int</span> r = l+len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=l;k&lt;r;k++)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">pd</span>(l,k,k+<span class="number">1</span>,r)) dp[l][r] = <span class="built_in">min</span>(dp[l][r] , dp[l][k]+<span class="number">2</span>+num[(len+<span class="number">1</span>)/(k-l+<span class="number">1</span>)]);</span><br><span class="line">dp[l][r] = <span class="built_in">min</span>(dp[l][r] , dp[l][k]+dp[k+<span class="number">1</span>][r]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;dp[<span class="number">1</span>][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划-区间dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.20~8.30做题笔记</title>
      <link href="/2020/08/22/8-20-8-30%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/08/22/8-20-8-30%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>dp题目合集</p><p>#end</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://oi-wiki.org/dp/"><strong>动态规划部分简介_oi Wiki</strong></a></p><p><a href="https://www.cnblogs.com/luckyblock/p/13121167.html"><strong>DP从入土到入门_Luckyblock</strong></a> </p><hr><h1 id="8-30题"><a href="#8-30题" class="headerlink" title="8.30题"></a>8.30题</h1><h3 id="P1436-棋盘分割"><a href="#P1436-棋盘分割" class="headerlink" title="P1436 棋盘分割"></a><a href="https://www.luogu.com.cn/problem/P1436">P1436 棋盘分割</a></h3><p>暴力$dp$水题</p><h3 id="P1169-ZJOI2007-棋盘制作-amp-amp-P4147-玉蟾宫"><a href="#P1169-ZJOI2007-棋盘制作-amp-amp-P4147-玉蟾宫" class="headerlink" title="P1169 [ZJOI2007]棋盘制作&amp;&amp;P4147 玉蟾宫"></a><a href="https://www.luogu.com.cn/problem/P1169">P1169 [ZJOI2007]棋盘制作</a>&amp;&amp;<a href="https://www.luogu.com.cn/problem/P4147">P4147 玉蟾宫</a></h3><p>悬线法$dp$板子题</p><h3 id="详细"><a href="#详细" class="headerlink" title="详细"></a><a href="https://www.cnblogs.com/xcxc82/p/13586720.html">详细</a></h3><p><del>明天就开学了,英语作业一个字都还没动过</del></p><p><img src="https://img2020.cnblogs.com/blog/2092833/202008/2092833-20200830221945481-1226699273.png"></p><hr><h1 id="8-29题"><a href="#8-29题" class="headerlink" title="8.29题"></a>8.29题</h1><h3 id="P3622-APIO2007-动物园"><a href="#P3622-APIO2007-动物园" class="headerlink" title="P3622 [APIO2007]动物园"></a><a href="https://www.luogu.com.cn/problem/P3622">P3622 [APIO2007]动物园</a></h3><p>较难的状压$dp$</p><h3 id="详细-1"><a href="#详细-1" class="headerlink" title="详细"></a><a href="https://www.cnblogs.com/xcxc82/p/13586702.html">详细</a></h3><h3 id="P2051-AHOI2009-中国象棋"><a href="#P2051-AHOI2009-中国象棋" class="headerlink" title="P2051 [AHOI2009]中国象棋"></a><a href="https://www.luogu.com.cn/problem/P2051">P2051 [AHOI2009]中国象棋</a></h3><p>状压$dp$练习题</p><h3 id="详细-2"><a href="#详细-2" class="headerlink" title="详细"></a><a href="https://www.cnblogs.com/xcxc82/p/13586341.html">详细</a></h3><hr><h1 id="8-28题"><a href="#8-28题" class="headerlink" title="8.28题"></a>8.28题</h1><h3 id="P2501-HAOI2006-数字序列"><a href="#P2501-HAOI2006-数字序列" class="headerlink" title="P2501 [HAOI2006]数字序列"></a><a href="https://www.luogu.com.cn/problem/P2501">P2501 [HAOI2006]数字序列</a></h3><p>神仙$dp$题</p><h3 id="详细-3"><a href="#详细-3" class="headerlink" title="详细"></a><a href="https://www.cnblogs.com/xcxc82/p/13579988.html">详细</a></h3><h3 id="P1156-垃圾陷阱"><a href="#P1156-垃圾陷阱" class="headerlink" title="P1156 垃圾陷阱"></a><a href="https://www.luogu.com.cn/problem/P1156">P1156 垃圾陷阱</a></h3><p>背包$dp$水题</p><p>需要注意的是这里的$f$数组可能为0,要先全部赋成负数</p><hr><h1 id="8-27题"><a href="#8-27题" class="headerlink" title="8.27题"></a>8.27题</h1><p>无</p><p><del>看jojo8看上瘾了</del></p><hr><h1 id="8-26题"><a href="#8-26题" class="headerlink" title="8.26题"></a>8.26题</h1><h3 id="P1295-TJOI2011-书架"><a href="#P1295-TJOI2011-书架" class="headerlink" title="P1295 [TJOI2011]书架"></a><a href="https://www.luogu.com.cn/problem/P1295">P1295 [TJOI2011]书架</a></h3><p>线段树优化$dp$</p><h3 id="详细-4"><a href="#详细-4" class="headerlink" title="详细"></a><a href="https://www.cnblogs.com/xcxc82/p/13568186.html">详细</a></h3><hr><h1 id="8-25题"><a href="#8-25题" class="headerlink" title="8.25题"></a>8.25题</h1><h3 id="P1944-最长括号匹配"><a href="#P1944-最长括号匹配" class="headerlink" title="P1944 最长括号匹配"></a><a href="https://www.luogu.com.cn/problem/P1944">P1944 最长括号匹配</a></h3><p>水题</p><h3 id="详细-5"><a href="#详细-5" class="headerlink" title="详细"></a><a href="https://www.cnblogs.com/xcxc82/p/13558928.html">详细</a></h3><h3 id="P5658-括号树"><a href="#P5658-括号树" class="headerlink" title="P5658 括号树"></a><a href="https://www.luogu.com.cn/problem/P5658">P5658 括号树</a></h3><p>去年的$d1t2$</p><p>感觉比$18$年的$t2$稍微简单一点?</p><h3 id="详细-6"><a href="#详细-6" class="headerlink" title="详细"></a><a href="https://www.cnblogs.com/xcxc82/p/13568454.html">详细</a></h3><h3 id="P5664-Emiya-家今天的饭"><a href="#P5664-Emiya-家今天的饭" class="headerlink" title="P5664 Emiya 家今天的饭"></a><a href="https://www.luogu.com.cn/problem/P5664">P5664 Emiya 家今天的饭</a></h3><p>很不错的一道$dp$题,穴道虚脱</p><p>被自己的一个傻逼错误卡2个多小时&#x3D;&#x3D;</p><p>###<a href="https://www.cnblogs.com/xcxc82/p/13570717.html">详细</a></p><hr><h1 id="8-24题"><a href="#8-24题" class="headerlink" title="8.24题"></a>8.24题</h1><p>无</p><p><del>打了一天的r6</del></p><hr><h1 id="8-23题"><a href="#8-23题" class="headerlink" title="8.23题"></a>8.23题</h1><h3 id="P2577-ZJOI2004-午餐"><a href="#P2577-ZJOI2004-午餐" class="headerlink" title="P2577 [ZJOI2004]午餐"></a><a href="https://www.luogu.com.cn/problem/P2577">P2577 [ZJOI2004]午餐</a></h3><p>$dp$练手好题</p><p><del>一开始题意读错了卡了半天</del></p><p>###<a href="https://www.cnblogs.com/xcxc82/p/13550425.html">详细</a></p><h3 id="P4158-SCOI2009-粉刷匠"><a href="#P4158-SCOI2009-粉刷匠" class="headerlink" title="P4158 [SCOI2009]粉刷匠"></a><a href="https://www.luogu.com.cn/problem/P4158">P4158 [SCOI2009]粉刷匠</a></h3><p>通过合并同类元素来提高效率</p><p>不过据说直接做也可以过</p><h3 id="详细-7"><a href="#详细-7" class="headerlink" title="详细"></a><a href="https://www.cnblogs.com/xcxc82/p/13551096.html">详细</a></h3><hr><h1 id="8-22题"><a href="#8-22题" class="headerlink" title="8.22题"></a>8.22题</h1><h3 id="P5017-摆渡车"><a href="#P5017-摆渡车" class="headerlink" title="P5017 摆渡车"></a><a href="https://www.luogu.com.cn/problem/P5017">P5017 摆渡车</a></h3><p>斜率优化模板题</p><p>当然也有不需要用斜率优化的做法</p><p>###<a href="https://www.cnblogs.com/xcxc82/p/13547078.html">详细</a></p><h3 id="P2900-USACO-土地征用"><a href="#P2900-USACO-土地征用" class="headerlink" title=" P2900 [USACO]土地征用"></a><a href="https://www.luogu.com.cn/problem/P2900"> P2900 [USACO]土地征用</a></h3><p>斜率优化好题</p><p>将$x$作为第一关键字,$y$作为第二关键字进行降序排序</p><p>这样下来就保证了$x$全体有序,只需去记录那些比当前的$y_{max}$大的土块,把比$y_{max}$小的土块都去掉</p><p>从而简化了转移方程</p><p>###<a href="https://www.cnblogs.com/xcxc82/p/13547083.html">详细</a></p><hr><h1 id="8-21题"><a href="#8-21题" class="headerlink" title="8.21题"></a>8.21题</h1><p>斜率优化</p><p>###<a href="https://www.luogu.com.cn/blog/xcxc82/xie-shuai-you-hua">详细</a></p><h1 id="8-20题"><a href="#8-20题" class="headerlink" title="8.20题"></a>8.20题</h1><h3 id="P3554-POI2013-LUK-Triumphal-arch"><a href="#P3554-POI2013-LUK-Triumphal-arch" class="headerlink" title="P3554 [POI2013]LUK-Triumphal arch"></a><a href="https://www.luogu.com.cn/problem/P3554">P3554 [POI2013]LUK-Triumphal arch</a></h3><p>二分答案$+$树形$DP$</p><p>通过树形$DP$来判断当前的$k$是否可行</p><p>###<a href="https://www.cnblogs.com/xcxc82/p/13536223.html">详细</a></p><h3 id="P4302-SCOI2003-字符串折叠"><a href="#P4302-SCOI2003-字符串折叠" class="headerlink" title="P4302 [SCOI2003]字符串折叠"></a><a href="https://www.luogu.com.cn/problem/P4302">P4302 [SCOI2003]字符串折叠</a></h3><p>区间$dp$水题</p><p>###<a href="https://www.cnblogs.com/xcxc82/p/13550735.html">详细</a></p><h3 id="P5851-USACO19DEC-Greedy-Pie-Eaters-P"><a href="#P5851-USACO19DEC-Greedy-Pie-Eaters-P" class="headerlink" title="P5851 [USACO19DEC]Greedy Pie Eaters P"></a><a href="https://www.luogu.com.cn/problem/P5851">P5851 [USACO19DEC]Greedy Pie Eaters P</a></h3><p>区间$DP$,转移方程比较独特</p><p>在枚举顺序上也有些要注意的细节</p><h3 id="详细-8"><a href="#详细-8" class="headerlink" title="详细"></a><a href="https://www.cnblogs.com/xcxc82/p/13552907.html">详细</a></h3><hr>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P2900 [USACO]土地征用</title>
      <link href="/2020/08/22/p2900/"/>
      <url>/2020/08/22/p2900/</url>
      
        <content type="html"><![CDATA[<h1 id="P2900-USACO-土地征用"><a href="#P2900-USACO-土地征用" class="headerlink" title=" P2900 [USACO]土地征用"></a><a href="https://www.luogu.com.cn/problem/P2900"> P2900 [USACO]土地征用</a></h1><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给$n$块 宽$x_i$ 长$y_i$ 的土地,可以将这$n$块土地分成几个组来购买,每组所需要的购买价值为该组中的最大长度$×$最大宽度</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>斜率优化$dp$好题。</p><p>首先通过观察可以看出,当一块土地的长度和宽度都大于另一块土地且两个土地在同一组时</p><p>小的那块土地相当于”毫无用处”</p><p>不妨设法消去这些无用的土块</p><p>具体做法:</p><p>将$x$作为第一关键字,$y$作为第二关键字进行降序排序</p><p>这样下来就已经保证了$x$全体有序,只需去记录那些比当前的$y$大的土块即可</p><p>两轮下来相当于满足了$x[i]$单调递减，$y[i]$单调递增</p><p>设$f[i]为购买前$i$个”有用的”土块所需的最小花费$</p><p>易得状态转移方程:</p><ul><li>$f[i] &#x3D; min(f[j]+x[j+1]*y[i])$</li></ul><p>再根据斜优套路,得到不等式:</p><ul><li>$\dfrac{f[j]-f[k]}{x[k+1]-x[j+1]}&gt;y[i]$</li></ul><p>利用单调队列去维护即可,时间复杂度$O(tot)$</p><h2 id="坑点-amp-amp-感想"><a href="#坑点-amp-amp-感想" class="headerlink" title="坑点&amp;&amp;感想"></a>坑点&amp;&amp;感想</h2><ul><li><del>十年OI一场空,不开long long见祖宗</del></li></ul><h2 id="code"><a href="#code" class="headerlink" title="$code:$"></a>$code:$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">50010</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">record</span>&#123;</span><br><span class="line"><span class="type">int</span> x,y;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> record k)<span class="type">const</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x==k.x)&#123;</span><br><span class="line"><span class="keyword">return</span> y&gt;k.y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x&gt;k.x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;d[MAXN];</span><br><span class="line"><span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> maxn = <span class="number">-114514</span>;</span><br><span class="line"><span class="type">int</span> n,f[MAXN];</span><br><span class="line"><span class="type">int</span> q[MAXN];</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">slope</span><span class="params">(<span class="type">int</span> j,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1.0</span>*((f[j] - f[k]) / (d[k+<span class="number">1</span>].x - d[j+<span class="number">1</span>].x));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;d[i].x,&amp;d[i].y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(d+<span class="number">1</span>,d+n+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(maxn&gt;=d[i].y) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">else</span> maxn = d[i].y,d[++tot] = d[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> l = <span class="number">0</span> ,r = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=tot;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r&amp;&amp;<span class="built_in">slope</span>(q[l],q[l+<span class="number">1</span>])&lt;=d[i].y) l++;</span><br><span class="line">f[i] = f[q[l]]+d[q[l]+<span class="number">1</span>].x*d[i].y;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r&amp;&amp;<span class="built_in">slope</span>(q[r<span class="number">-1</span>],q[r])&gt;=<span class="built_in">slope</span>(q[r],i)) r--;</span><br><span class="line">q[++r] = i;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;f[tot];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划-斜率优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P5071 摆渡车</title>
      <link href="/2020/08/22/p5071/"/>
      <url>/2020/08/22/p5071/</url>
      
        <content type="html"><![CDATA[<p><strong><a href="https://www.luogu.com.cn/problem/P5017">题目链接</a></strong></p><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>有$n$个人,每个人都在一个时间点去等车,求当车何时出发时才能让所有人的等待时间之和最小</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>斜率优化<del>模板题</del></p><p>(似乎大佬们都是用更简单的方法来做的?)</p><p>设$person[i]$为前$i$分钟到达的人数之和</p><p>$sum[i]$为前$i$分钟为前$i$分钟内到达时间之和,$f[i]$为从$i$时刻发车所需要的最小等待时间</p><p><del>根据套路</del>易得状态转移方程$:$</p><p>$f[i] &#x3D; min(f[j]+(person[i] - person[j])*i  -  (sum[i] - sum[j]))$</p><p>根据斜率优化套路:</p><p>$f[i] &#x3D; min(f[j]-person[j]*i+sum[j])-sum[i]+person[i]*i$</p><p>当从$k$转移比从$j$转移更优且$k&gt;j$时,有:</p><p>$f[j]-person[j]*i+sum[j]&lt;f[k]-person[k]*i+sum[k]$ </p><p>移项得:</p><p>$\dfrac{f[j]-f[k]+sum[j]-sum[k]}{f[k]-f[j]}&gt;i$</p><p>用单调队列来维护即可,总复杂度$O(t)$</p><p>设$tmax$为最后一个人的到来时间,为了让所有人都上车,最后一次发车一定要在区间$[tmax,tmax+m)$中</p><p>最终答案即为在区间$[tmax,tmax+m)$中最小的$f[x]$</p><h2 id="坑点-amp-amp-感想"><a href="#坑点-amp-amp-感想" class="headerlink" title="坑点&amp;&amp;感想"></a>坑点&amp;&amp;感想</h2><ul><li><p>$f[k] - f[j]$可能为$0$,需要特判</p></li><li><p>转移时,$i$要从时间$0$开始</p></li><li><p>在$i&lt;m$时,其本身一定是第一个发车点,无需转移</p></li></ul><h2 id="code"><a href="#code" class="headerlink" title="$code:$"></a>$code:$</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">4000010</span>;</span><br><span class="line"><span class="type">int</span> f[MAXN],sum[MAXN];</span><br><span class="line"><span class="type">int</span> m,n;</span><br><span class="line"><span class="type">int</span> maxn;</span><br><span class="line"><span class="type">int</span> person[MAXN];</span><br><span class="line"><span class="type">int</span> q[MAXN];</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">slope</span><span class="params">(<span class="type">int</span> k,<span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(person[j] - person[k]==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1.0</span>*((f[j]+sum[j]-f[k]-sum[k])*MAXN);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1.0</span>*((f[j]-f[k]+sum[j]-sum[k])/(person[j] - person[k]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k);</span><br><span class="line">person[k]++;</span><br><span class="line">maxn = <span class="built_in">max</span>(k,maxn);</span><br><span class="line">sum[k]+=k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;m+maxn;i++)&#123;</span><br><span class="line">sum[i]+=sum[i<span class="number">-1</span>];</span><br><span class="line">person[i]+=person[i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> l = <span class="number">1</span>,r = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;maxn+m;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i&gt;=m)&#123;</span><br><span class="line"><span class="type">int</span> now = i-m;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r&amp;&amp;<span class="built_in">slope</span>(q[r<span class="number">-1</span>],q[r])&gt;=<span class="built_in">slope</span>(q[r],now)) r--;</span><br><span class="line">q[++r] = now;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r&amp;&amp;<span class="built_in">slope</span>(q[l],q[l+<span class="number">1</span>])&lt;=i) l++;</span><br><span class="line">f[i] = person[i]*i - sum[i];</span><br><span class="line"><span class="keyword">if</span>(l&lt;=r) f[i] = <span class="built_in">min</span>(f[i],(f[q[l]] + (person[i] - person[q[l]])*i-(sum[i]-sum[q[l]])));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans = inf;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=maxn;i&lt;maxn+m;i++)&#123;</span><br><span class="line">ans = <span class="built_in">min</span>(f[i] , ans);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划-斜率优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P3554 [POI2013]LUK-Triumphal arch</title>
      <link href="/2020/08/20/p3554/"/>
      <url>/2020/08/20/p3554/</url>
      
        <content type="html"><![CDATA[<h1 id="P3554-POI2013-LUK-Triumphal-arch-题解"><a href="#P3554-POI2013-LUK-Triumphal-arch-题解" class="headerlink" title="P3554 [POI2013]LUK-Triumphal arch 题解"></a>P3554 [POI2013]LUK-Triumphal arch 题解</h1><h2 id="间隙"><a href="#间隙" class="headerlink" title="间隙"></a><a href="https://www.luogu.com.cn/problem/P3554">间隙</a></h2><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul><li><h2 id="树形-DP-二分答案"><a href="#树形-DP-二分答案" class="headerlink" title="树形$DP$ , 二分答案"></a>树形$DP$ , 二分答案</h2></li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>题意翻译里已经写的很清楚了,这里就不重复一遍了</p><p>首先这里的答案$k$具有可二分性,考虑二分答案</p><p>当$B$走到一个节点$u$时,第一步要做的肯定是把$u$的儿子全部都涂色</p><p>如果一个节点的儿子数大于当前的$k$,则无论怎么涂都会输</p><p>反之,说明除了涂自己的儿子外还可以”<strong>提前</strong>“涂其他的节点</p><p>设$f[i]$为以$i$根节点的子树需要<strong>其祖先”提前”染色多少个点才能覆盖整个子树</strong></p><p>易得状态转移方程:$f[u] &#x3D; max(0  , \sum f[v]+1-k)$</p><p>具体解释$:$</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/i6tgjcmc.png"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>直接二分答案$k$,对于每一个$k$进行$dp$</p><p>如果$f[1]$为$0$,则说明可行</p><p>反之说明不可行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">3e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">e</span>&#123;</span><br><span class="line"><span class="type">int</span> to,next;</span><br><span class="line">&#125;edge[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> head[MAXN&lt;&lt;<span class="number">1</span>],cnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> f[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;<span class="comment">//前向星</span></span><br><span class="line">edge[++cnt].to = v;</span><br><span class="line">edge[cnt].next = head[u];</span><br><span class="line">head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs</span>(v,u,k);</span><br><span class="line">sum=sum+f[v]+<span class="number">1</span>;<span class="comment">//记录</span></span><br><span class="line">&#125;</span><br><span class="line">f[u] = <span class="built_in">max</span>(<span class="number">0</span>,sum-k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)&#123;</span><br><span class="line"><span class="type">int</span> u,v;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line"><span class="built_in">add</span>(u,v);</span><br><span class="line"><span class="built_in">add</span>(v,u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> l = <span class="number">0</span>,r = <span class="number">10e10</span>;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span>(l&lt;=r)&#123;<span class="comment">//二分答案</span></span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="built_in">sizeof</span>(f));</span><br><span class="line"><span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>,mid);<span class="comment">//dp</span></span><br><span class="line"><span class="keyword">if</span>(f[<span class="number">1</span>]==<span class="number">0</span>)&#123;<span class="comment">//如果f[1]为0 说明可行</span></span><br><span class="line">ans = mid;</span><br><span class="line">r = mid<span class="number">-1</span>;</span><br><span class="line">&#125;反之,不可行</span><br><span class="line"><span class="keyword">else</span> l = mid+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划-树形dp </tag>
            
            <tag> 二分答案 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树上启发式合并</title>
      <link href="/2020/08/16/%E6%A0%91%E4%B8%8A%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/"/>
      <url>/2020/08/16/%E6%A0%91%E4%B8%8A%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="模板题-CF600E-Lomsat-gelral"><a href="#模板题-CF600E-Lomsat-gelral" class="headerlink" title="模板题: CF600E Lomsat gelral"></a>模板题: <a href="https://www.luogu.com.cn/problem/CF600E">CF600E Lomsat gelral</a></h1><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>一棵树有n个结点，每个结点都是一种颜色，每个颜色有一个编号，求树中每个子树的最多的颜色编号的和。</p><h1 id="一些定义"><a href="#一些定义" class="headerlink" title="一些定义"></a>一些定义</h1><ul><li>启发式算法:启发式算法是指基于经验和直观感觉，从而对一些算法的优化。</li></ul><p>举例:并查集的按秩合并</p><p>在并查集的按秩合并中,我们将小的集合往大的集合上合并,这样明显有利于加快并查集的祖先查找</p><h1 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h1><ul><li>首先是一次$bfs$,求出每个节点的重儿子</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">size[u] = <span class="number">1</span> ;<span class="comment">//子树大小</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = head[u];i;i = edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs1</span>(v,u);</span><br><span class="line">size[u]+=size[v];</span><br><span class="line"><span class="keyword">if</span>(size[v]&gt;size[son[u]]) son[u] = v;<span class="comment">//找重儿子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来定义两个数组$cnt[]$和$c[]$,分别代表存放的某颜色在“<strong>当前</strong>”子树中的数量和存放某节点的颜色</p><p>这里的”当前”指的就是目前正在处理的节点(如果给每个节点都开一个$cnt$的话则会$MLE$)</p><ul><li><p>如果目前正在处理的节点是轻儿子,就把它的答案计入并删除其贡献</p></li><li><p>反之,如果是重儿子,也把它的答案计入,但不删除其贡献</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cunt</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">c[color[u]]+=val;<span class="comment">//val为1代表计入贡献,为-1代表删除贡献</span></span><br><span class="line"><span class="keyword">if</span>(c[color[u]] &gt; maxn)&#123;<span class="comment">//最多的颜色</span></span><br><span class="line">maxn = c[color[u]];</span><br><span class="line">sum = color[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(c[color[u]] == maxn)&#123;</span><br><span class="line">sum+=color[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(v==maxson||v==fa) <span class="keyword">continue</span>;<span class="comment">//如果是u的重儿子,直接跳过</span></span><br><span class="line"><span class="built_in">cunt</span>(v,u,val);<span class="comment">//dfs暴力计贡献</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa,<span class="type">int</span> keep)</span></span>&#123;<span class="comment">//keep代表是否保留该贡献</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(v==son[u]||v==fa) <span class="keyword">continue</span>;<span class="comment">//是重儿子直接跳过</span></span><br><span class="line"><span class="built_in">dfs2</span>(v,u,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span>(son[u])&#123;<span class="comment">//如果有重儿子</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">dfs2</span>(son[u],u,<span class="number">1</span>);<span class="comment">//keep为1,保留其贡献</span></span><br><span class="line">maxson = son[u];<span class="comment">//记u节点的重儿子</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cunt</span>(u,fa,<span class="number">1</span>);<span class="comment">//暴力统计其非子树贡献</span></span><br><span class="line">maxson = <span class="number">0</span>;</span><br><span class="line">ans[u] = sum;<span class="comment">//记录答案</span></span><br><span class="line"><span class="keyword">if</span>(!keep)&#123;<span class="comment">//如果不是重儿子,则将其贡献删除</span></span><br><span class="line"><span class="built_in">cunt</span>(u,fa,<span class="number">-1</span>); </span><br><span class="line">sum = maxn = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个$dfs$大致可以分为下面四个流程:</p><ul><li><p>记录轻儿子及其子树的答案且删除其贡献</p></li><li><p>记录重儿子及其子树的答案且不删除其贡献</p></li><li><p>暴力统计$u$及其所有轻儿子的贡献合并到刚算出的重儿子信息里</p></li><li><p>删除该删除的贡献</p></li></ul><p><img src="https://img2020.cnblogs.com/blog/2092833/202008/2092833-20200816183326748-1026754225.png"></p><p>这样一轮下来相当于是遍历了两遍轻儿子,一遍重儿子,显然效率是较高的</p><p>时间复杂度为$O(nlogn)$,<del>具体怎么证还不太清楚</del></p><p>$code:$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">e</span>&#123;</span><br><span class="line"><span class="type">int</span> next,to;</span><br><span class="line">&#125;edge[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> size[MAXN],son[MAXN];</span><br><span class="line"><span class="type">int</span> color[MAXN],c[MAXN];</span><br><span class="line"><span class="type">int</span> maxn , sum;</span><br><span class="line"><span class="type">int</span> head[MAXN&lt;&lt;<span class="number">1</span>],n,cnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> ans[MAXN] , maxson;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">      cnt++;</span><br><span class="line">      edge[cnt].to = v;</span><br><span class="line">      edge[cnt].next=head[u];</span><br><span class="line">      head[u]=cnt;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">size[u] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = head[u];i;i = edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs1</span>(v,u);</span><br><span class="line">size[u]+=size[v];</span><br><span class="line"><span class="keyword">if</span>(size[v]&gt;size[son[u]]) son[u] = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cunt</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">c[color[u]]+=val;</span><br><span class="line"><span class="keyword">if</span>(c[color[u]] &gt; maxn)&#123;</span><br><span class="line">maxn = c[color[u]];</span><br><span class="line">sum = color[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(c[color[u]] == maxn)&#123;</span><br><span class="line">sum+=color[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(v==maxson||v==fa) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">cunt</span>(v,u,val);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa,<span class="type">int</span> keep)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(v==son[u]||v==fa) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs2</span>(v,u,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(son[u])&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">dfs2</span>(son[u],u,<span class="number">1</span>);</span><br><span class="line">maxson = son[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cunt</span>(u,fa,<span class="number">1</span>);</span><br><span class="line">maxson = <span class="number">0</span>;</span><br><span class="line">ans[u] = sum;</span><br><span class="line"><span class="keyword">if</span>(!keep)&#123;</span><br><span class="line"><span class="built_in">cunt</span>(u,fa,<span class="number">-1</span>); </span><br><span class="line">sum = maxn = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;color[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="type">int</span> u,v;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;u,&amp;v);</span><br><span class="line"><span class="built_in">add</span>(u,v);</span><br><span class="line"><span class="built_in">add</span>(v,u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><del>最近沉迷stg无法自拔了</del></p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 树上启发式合并 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tarjan算法学习笔记</title>
      <link href="/2020/08/12/tarjan%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/08/12/tarjan%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><h1 id="缩点"><a href="#缩点" class="headerlink" title="缩点"></a><a href="https://www.luogu.com.cn/problem/P3387">缩点</a></h1><h2 id="一些定义"><a href="#一些定义" class="headerlink" title="一些定义"></a>一些定义</h2><ul><li><p>强连通：如果两个顶点可以相互通达，则称两个顶点强连通。</p></li><li><p>如果有向图$G$的每两个顶点都 强连通，称$G$是一个强连通图。</p></li><li><p>非强连通图有向图的极大强连通子图，称为强连通分量。</p></li></ul><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>定义两个数组,$dfn[ ]$和$low[]$</p><p>$dfn[u]$表示$u$节点第一次被$bfs$到的时间戳</p><p>$low[u]$表示$u$节点能”回溯”到的最早时间 </p><p>如果一个节点$u$的儿子$v$的$low[]$小于自己的$low[]$,说明该节点可以”回溯”到$u$之前,会产生一个强连通分量,记录这些点,将其合并成一个新点即可</p><h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><ul><li><p>每$dfs$一个点$u$时,先把该点的$low[u]$和$dfn[u]$初始化成该点的时间戳,同时把这个点压入一个栈中</p></li><li><p>遍历其所有儿子,如果一个儿子没有被访问过,继续向下$dfs$,同时更新节点$u$的$low[u]$</p></li><li><p>反之,说明该儿子出现在$u$之前,无需再次$dfs$,直接更新节点$u$的$low[u]$即可</p></li><li><p>最后,如果一个节点的$dfn[]$跟$low$相等,说明该点是一个强连通分量中的起点,将栈中的所有该节点前的值全部取出,合并成一个新的节点</p></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">dfn[u] = low[u] = ++Time;<span class="comment">//初始化</span></span><br><span class="line">s[++top] = u;<span class="comment">//压入栈</span></span><br><span class="line">vis[u] = <span class="number">1</span>;<span class="comment">//被访问过</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].next)&#123;<span class="comment">//遍历所有儿子</span></span><br><span class="line"><span class="type">int</span> v = edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line"><span class="built_in">tarjan</span>(v);<span class="comment">//向下遍历</span></span><br><span class="line">low[u] = <span class="built_in">min</span>(low[v] , low[u]);<span class="comment">//更新low</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(vis[v])&#123;<span class="comment">//节点被访问过,直接更新</span></span><br><span class="line">low[u] = <span class="built_in">min</span>(low[v] , low[u]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(low[u]==dfn[u])&#123;<span class="comment">//如果是一个强连通分量的起点</span></span><br><span class="line"><span class="type">int</span> v;</span><br><span class="line"><span class="keyword">while</span>(v = s[top--])&#123;</span><br><span class="line">vis[v] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(v==u) <span class="keyword">break</span>;<span class="comment">//将u前面的值全部取出</span></span><br><span class="line">w[u]+=w[v];<span class="comment">//合并点权</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="割点"><a href="#割点" class="headerlink" title="割点"></a><a href="https://www.luogu.com.cn/problem/P3388">割点</a></h1><h2 id="一些定义-1"><a href="#一些定义-1" class="headerlink" title="一些定义"></a>一些定义</h2><ul><li>割点:将一个无向图中的一个节点及与其相连的所有的边都删去后,整个图不再联通,则成该点为该图的一个割点</li></ul><h2 id="算法思路-1"><a href="#算法思路-1" class="headerlink" title="算法思路"></a>算法思路</h2><p>跟缩点大同小异的思路。</p><p>既然去除该点可以让整个图不再联通,说明其儿子与其上面的节点都无连接,也就是无法”回溯”到该点之前的点</p><p>直接用跟缩点一样的思路去写即可。</p><p>要注意的是 $:$ 这里的$low[u]$不再是直接更新成$low[v]$,而是更新为$dfn[v]$,在无向图中,每个点都有一条”返祖”边,这时把子节点的$low[]$值赋为父节点的$low[]$，就可能导致其$low[]&#x3D;&#x3D;$其父节点$low[]&lt;$其父节点$dfn[]$</p><h2 id="算法流程-1"><a href="#算法流程-1" class="headerlink" title="算法流程"></a>算法流程</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">dfn[u] = low[u] = ++Time;<span class="comment">//初始化</span></span><br><span class="line"><span class="type">int</span> child = <span class="number">0</span>;<span class="comment">//根节点的儿子数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = e[i].to;</span><br><span class="line"><span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line"><span class="built_in">tarjan</span>(v,fa);</span><br><span class="line">low[u] = <span class="built_in">min</span>(low[u] , low[v]);<span class="comment">//更新</span></span><br><span class="line"><span class="keyword">if</span>(low[v]&gt;=dfn[u]&amp;&amp;u!=fa)&#123;<span class="comment">//有一个子节点满足条件即可</span></span><br><span class="line">cut[u]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(u==fa) child++;<span class="comment">//如果是根节点,增加儿子数</span></span><br><span class="line">&#125;</span><br><span class="line">low[u] = <span class="built_in">min</span>(low[u],dfn[v]);<span class="comment">//更新</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(u==fa&amp;&amp;child&gt;=<span class="number">2</span>) cut[u]=<span class="number">1</span>;<span class="comment">//如果根节点数量大于2,说明根节点可以成为割点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="缩点练习"><a href="#缩点练习" class="headerlink" title="缩点练习"></a>缩点练习</h1><p><a href="https://www.luogu.com.cn/problem/P2341">P2341 [USACO03FALL][HAOI2006]受欢迎的牛 G</a></p><p><a href="https://www.luogu.com.cn/problem/P2863">P2863 [USACO06JAN]The Cow Prom S</a></p><p><a href="https://www.luogu.com.cn/problem/P2746">P2746 [USACO5.3]校园网Network of Schools</a></p><p><a href="https://www.luogu.com.cn/problem/P1726">P1726 上白泽慧音</a></p><p><a href="https://www.luogu.com.cn/problem/P1262">P1262 间谍网络</a></p><p><a href="https://www.luogu.com.cn/problem/P5676">P5676 [GZOI2017]小z玩游戏</a></p><h2 id="P2341-USACO03FALL-受欢迎的牛-G"><a href="#P2341-USACO03FALL-受欢迎的牛-G" class="headerlink" title="P2341 [USACO03FALL]受欢迎的牛 G"></a>P2341 [USACO03FALL]受欢迎的牛 G</h2><p>$tarjan$经典题。</p><p>首先是缩点,将每个强联通分量都分成一个组,并记录这个组的出度和大小,如果只有一个组的出度为$0$,则说明该组中的所有奶牛都可以成为神犇(如果有两个组的出度均为零的话则说明%无法完全传递)</p><p>$code:$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">dfn[u] = low[u] = ++Time;</span><br><span class="line">vis[u] = <span class="number">1</span>,s[++top] = u;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = e[i].to;</span><br><span class="line"><span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line"><span class="built_in">tarjan</span>(v);</span><br><span class="line">low[u] = <span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(vis[v])&#123;</span><br><span class="line">low[u] = <span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dfn[u]==low[u])&#123;</span><br><span class="line"><span class="type">int</span> v;</span><br><span class="line">scc[u] = ++k;<span class="comment">//记录分组</span></span><br><span class="line"><span class="keyword">while</span>(v=s[top--])&#123;</span><br><span class="line">vis[v] = <span class="number">0</span>;</span><br><span class="line">scc[v] = k;<span class="comment">//记录分组</span></span><br><span class="line">size[k]++;<span class="comment">//记录大小</span></span><br><span class="line"><span class="keyword">if</span>(v==u) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P2863-USACO06JAN-The-Cow-Prom-S"><a href="#P2863-USACO06JAN-The-Cow-Prom-S" class="headerlink" title="[P2863 [USACO06JAN]The Cow Prom S]"></a>[P2863 [USACO06JAN]The Cow Prom S]</h2><p>简单的$tarjan$模板题。</p><p><del>实际上比模板题还要简单</del></p><p>判断栈头是否为$u$,若不为$u$,则说明有两个及以上的节点,若是,说明只有$u$一个节点</p><p>$code:$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">dfn[u] = low[u] = ++Time;</span><br><span class="line">vis[u] = <span class="number">1</span>,s[++top] = u;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = e[i].to;</span><br><span class="line"><span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line"><span class="built_in">tarjan</span>(v);</span><br><span class="line">low[u] = <span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(vis[v])&#123;</span><br><span class="line">low[u] = <span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dfn[u]==low[u])&#123;</span><br><span class="line"><span class="keyword">if</span>(s[top]!=u) ans++;<span class="comment">//特判</span></span><br><span class="line"><span class="type">int</span> v;</span><br><span class="line"><span class="keyword">while</span>(v=s[top--])&#123;</span><br><span class="line">vis[v] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(v==u) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="P2746-USACO5-3-校园网Network-of-Schools"><a href="#P2746-USACO5-3-校园网Network-of-Schools" class="headerlink" title="[P2746 [USACO5.3]校园网Network of Schools]"></a>[P2746 [USACO5.3]校园网Network of Schools]</h2><p> 给一张图,求:</p><ul><li><p>图中入度为零的点的个数</p></li><li><p>把整张图变成强连通图的最少添边值</p></li></ul><p> 第一问很简单,直接统计一下即可,对于第二问,由于强连通图中每个点的入度和出度都不为零,感性理解一下,可以先将那些出度为0的点和入度为0的点互补,由于出度为0的点的数量和入度为0的点数量可能不一致,因此最后还要将那些剩余的点和其他任意一个点相连</p><p> 最后的答案即为出度为零的点的数量和入读为零的点的数量中的最大值。</p><p> $code:$<br> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=head[i];j;j=e[j].next)&#123;</span><br><span class="line"><span class="type">int</span> v = e[j].to;</span><br><span class="line"><span class="keyword">if</span>(scc[i]!=scc[v])&#123;</span><br><span class="line">in[scc[v]]++;<span class="comment">//记录入度</span></span><br><span class="line">out[scc[i]]++;<span class="comment">//记录出度</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ansin = <span class="number">0</span>,ansout = <span class="number">0</span>;<span class="comment">//出度数和入度数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(in[i]==<span class="number">0</span>)&#123;<span class="comment">//记录入度</span></span><br><span class="line">ansin++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(out[i]==<span class="number">0</span>)&#123;<span class="comment">//记录出度</span></span><br><span class="line">ansout++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">1</span>)&#123;<span class="comment">//特判,如果该图已经是一个强连通图了,直接输出1和0即可</span></span><br><span class="line">    cout&lt;&lt;<span class="number">1</span>&lt;&lt;endl&lt;&lt;<span class="number">0</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;ansin&lt;&lt;endl&lt;&lt;<span class="built_in">max</span>(ansin,ansout);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="P1726-上白泽慧音"><a href="#P1726-上白泽慧音" class="headerlink" title="P1726 上白泽慧音"></a>P1726 上白泽慧音</h2><p>车万题面好评</p><p>也是一道挺模板的题。</p><p>大致题意就是说求最大且字典序最小的那个强联通分量。</p><p>直接跑一遍$tarjan$记录每个点所在的强连通分量和该强联通分量的大小,然后一遍$for$循环求出最大的那个组,再将在那个组中的节点输出即可</p><p>$code:$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">dfn[u] = low[u] = ++Time;</span><br><span class="line">vis[u] = <span class="number">1</span>,s[++top] = u;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = e[i].to;</span><br><span class="line"><span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line"><span class="built_in">tarjan</span>(v);</span><br><span class="line">low[u] = <span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(vis[v])&#123;</span><br><span class="line">low[u] = <span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dfn[u]==low[u])&#123;</span><br><span class="line"><span class="type">int</span> v;</span><br><span class="line"><span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line">scc[u] = ++k;<span class="comment">//新分组</span></span><br><span class="line"><span class="keyword">while</span>(v=s[top--])&#123;</span><br><span class="line">vis[v] = <span class="number">0</span>;</span><br><span class="line">scc[v] = k;<span class="comment">//记录每个点所在的组</span></span><br><span class="line">size[k]++;<span class="comment">//记录该组的大小</span></span><br><span class="line"><span class="keyword">if</span>(v==u) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P1262-间谍网络"><a href="#P1262-间谍网络" class="headerlink" title="P1262 间谍网络"></a>P1262 间谍网络</h2><p>直接跑一遍缩点，由于强连通分量中的每个点都是互相联通的,一个强联通分量中的最少花费资金也就是那个环里罪犯所需资金最小的</p><p>最后检查一下有无未访问的点,若有,直接输出$NO$,$return$,若无,那就接着记录每个点的入度,将入度为0的组的权值全部加起来即可</p><p>$code:$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">dfn[u] = low[u] = ++Time;</span><br><span class="line">s[++top] = u;</span><br><span class="line">vis[u] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line"><span class="built_in">tarjan</span>(v);</span><br><span class="line">low[u] = <span class="built_in">min</span>(low[v] , low[u]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(vis[v])&#123;</span><br><span class="line">low[u] = <span class="built_in">min</span>(low[v] , low[u]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(low[u]==dfn[u])&#123;</span><br><span class="line"><span class="type">int</span> v;</span><br><span class="line">tot++;</span><br><span class="line"><span class="keyword">while</span>(v = s[top--])&#123;</span><br><span class="line">vis[v] = <span class="number">0</span>;</span><br><span class="line">c[v] = tot;</span><br><span class="line">sum[tot] = <span class="built_in">min</span>(sum[tot],w[v]);<span class="comment">//取min</span></span><br><span class="line"><span class="keyword">if</span>(v==u) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P5676-GZOI2017-小z玩游戏"><a href="#P5676-GZOI2017-小z玩游戏" class="headerlink" title="P5676 [GZOI2017]小z玩游戏"></a>P5676 [GZOI2017]小z玩游戏</h2><p>对于这道题,首先想到的肯定是直接$n^2$建边</p><p>但会发现数据太大,复杂度接受不了</p><p>所以要考虑更优秀的建边方法</p><ul><li><p>建一个由有趣程度到游戏的边</p></li><li><p>建一个由游戏到兴趣程度的边</p></li><li><p>建立一个兴趣程度整数倍的边</p></li></ul><p>$code:$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="comment">//从有趣程度到该游戏</span></span><br><span class="line"><span class="type">int</span> u;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;u);</span><br><span class="line"><span class="built_in">add</span>(n+u,i);</span><br><span class="line">maxn = <span class="built_in">max</span>(maxn , u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="comment">//从该游戏到兴趣程度</span></span><br><span class="line"><span class="type">int</span> u;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;u);</span><br><span class="line"><span class="built_in">add</span>(i,n+u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=maxn;i++)&#123;<span class="comment">//兴趣程度的整数倍</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j*i&lt;=maxn;j++)&#123;</span><br><span class="line"><span class="built_in">add</span>(n+i,n+j*i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于那些存在兴趣程度整数倍的游戏,相当于是连上了两个游戏</p><p>而对于那些不存在的游戏,相当于是连了一个虚点,$rt$</p><p><img src="https://img2020.cnblogs.com/blog/2092833/202008/2092833-20200812155727508-655328923.png"></p><h1 id="割点练习"><a href="#割点练习" class="headerlink" title="割点练习"></a>割点练习</h1><p><a href="https://www.luogu.com.cn/problem/P5058">P5058 [ZJOI2004]嗅探器</a></p><p><a href="https://www.luogu.com.cn/problem/P3225">P3225 [HNOI2012]矿场搭建</a></p><h2 id="P5058-ZJOI2004-嗅探器"><a href="#P5058-ZJOI2004-嗅探器" class="headerlink" title="P5058 [ZJOI2004]嗅探器"></a><a href="https://www.luogu.com.cn/problem/P5058">P5058 [ZJOI2004]嗅探器</a></h2><p>要满足同时能收到$A$和$B$的信息的话要满足两个条件:</p><ul><li><p>$u$是割点</p></li><li><p>$A$或$B$在$v$子树内（包括$v$)且$B$或$A$不在$v$子树内(这样才能把$A$,$B$两个点的信号都收集到)</p></li></ul><p>因此,如果要成为满足条件的点,必须要满足:</p><ul><li>$dfn[v]&lt;&#x3D;dfn[a]$&amp;&amp;$dfn[v]&gt;dfn[b]$ ($A$在子树内,$B$不在)</li></ul><p>或</p><ul><li>$dfn[v]&lt;&#x3D;dfn[b]$&amp;&amp;dfn$[v]&gt;dfn[a]$($B$在子树内,$A$不在)</li></ul><p>$code:$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">dfn[u] = low[u] = ++Time;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line"><span class="built_in">tarjan</span>(v,u);</span><br><span class="line">low[u] = <span class="built_in">min</span>(low[v] , low[u]);</span><br><span class="line"><span class="keyword">if</span>(low[v]&gt;=dfn[u]&amp;&amp;u!=a&amp;&amp;u!=b&amp;&amp;dfn[v]&lt;=dfn[a]&amp;&amp;dfn[v]&gt;dfn[b])&#123;<span class="comment">//第一种情况</span></span><br><span class="line">ans = <span class="built_in">min</span>(ans , u);<span class="comment">//取最小的点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(low[v]&gt;=dfn[u]&amp;&amp;u!=a&amp;&amp;u!=b&amp;&amp;dfn[v]&lt;=dfn[b]&amp;&amp;dfn[v]&gt;dfn[a])&#123;<span class="comment">//第二种情况</span></span><br><span class="line">ans = <span class="built_in">min</span>(ans , u);<span class="comment">//取最小的点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(v!=fa) low[u] = <span class="built_in">min</span>(low[u] , dfn[v]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 图论-tarjan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树链剖分学习笔记</title>
      <link href="/2020/08/07/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/08/07/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p> 树链剖分，就是将一颗树分成若干个编号连续的链,将树上问题转换为线性问题,降低问题的处理难度。</p><h2 id="模板题-P3384-【模板】轻重链剖分"><a href="#模板题-P3384-【模板】轻重链剖分" class="headerlink" title="模板题:P3384 【模板】轻重链剖分"></a>模板题:<a href="https://www.luogu.com.cn/problem/P3384">P3384 【模板】轻重链剖分</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给一颗节点数为$n$的带点权树,有以下几种操作:</p><ul><li><p>将树从 $x$ 到 $y$ 结点最短路径上所有节点的值都加上 $z$</p></li><li><p>求从 $x$ 到 $y$ 节点最短路径上的所有 节点值之和</p></li><li><p>以 $x$ 为根节点的子树内所有节点值都加上 $z$。</p></li><li><p>求以 $x$ 为根节点的子树内所有节点值之和</p></li></ul><p>数据范围:$1\le N\le10^5$</p><h2 id="一些定义"><a href="#一些定义" class="headerlink" title="一些定义"></a>一些定义</h2><ul><li><p>重儿子：以一个非叶子节点中的一个儿子为根的子树最大的那一个儿子称为重儿子</p></li><li><p>轻儿子：一个非叶子节点中除了重儿子以外的儿子</p></li><li><p>重边：结点与其重儿子的边称为重边</p></li><li><p>轻边：结点与其轻儿子的边称为轻边</p></li><li><p>重链：由重边组成的路径</p></li><li><p>轻链：由轻边组成的路径</p></li></ul><h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p>首先是两次$DFS$</p><p>第一次求出子树大小,父节点,深度,重儿子这些之后要用的东西</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> f,<span class="type">int</span> deep)</span></span>&#123;</span><br><span class="line">dep[u] = deep;<span class="comment">//深度</span></span><br><span class="line">fa[u] = f;<span class="comment">//父亲节点</span></span><br><span class="line">size[u] = <span class="number">1</span>;<span class="comment">//初始化子树大小</span></span><br><span class="line"><span class="type">int</span> maxson = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i = e[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = e[i].v;</span><br><span class="line"><span class="keyword">if</span>(v==f) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs1</span>(v,u,deep+<span class="number">1</span>);</span><br><span class="line">size[u]+=size[v];</span><br><span class="line">    <span class="keyword">if</span>(size[v]&gt;maxson) son[u] = v,maxson = size[v];<span class="comment">//重儿子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二次$dfs$则是将树上的节点重新编号,划分成若干条链</p><p><strong>每次都去选取自己的重儿子进行连接</strong>,这样可以尽可能的让一条链够长</p><p>其余的轻儿子则作为另一条链的开头</p><p>画成图的话大概是这样:</p><p>(ps:图中的红色节点均为重儿子)</p><p><img src="https://img2020.cnblogs.com/blog/2092833/202008/2092833-20200807180043859-1789457354.png"></p><p>代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> topf)</span></span>&#123;<span class="comment">//topf为一条链的头</span></span><br><span class="line">id[u] = ++tot;<span class="comment">//重新编号,赋值</span></span><br><span class="line">val[tot] = w[u];</span><br><span class="line">top[u] = topf;<span class="comment">//记录链头,之后有用</span></span><br><span class="line"><span class="keyword">if</span>(!son[u]) <span class="keyword">return</span>;<span class="comment">//为叶子节点</span></span><br><span class="line"><span class="built_in">dfs2</span>(son[u],topf);<span class="comment">//以重儿子向下继续连接</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;<span class="comment">//</span></span><br><span class="line"><span class="type">int</span> v = e[i].v;</span><br><span class="line"><span class="keyword">if</span>(v==fa[u]||v==son[u]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs2</span>(v,v);其余的边则作为新一条链的开头</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用线段树维护这些链</p><p>对于操作1跟操作2</p><p>每次查询和修改从u到v的路径时</p><p>只需将低的那个点跳到上条链的结尾,也就是自己所在的链的头的父节点,同时查询&#x2F;修改跳过的这段链的值即可</p><p><img src="https://img-blog.csdnimg.cn/20200807175445981.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTc0NTMw,size_16,color_FFFFFF,t_70"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">qb</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;<span class="comment">//操作1~5</span></span><br><span class="line"><span class="keyword">while</span>(top[u]!=top[v])&#123;<span class="comment">//如果不在同一条链上</span></span><br><span class="line"><span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]]) <span class="built_in">swap</span>(u,v);<span class="comment">//跳高度低的那个</span></span><br><span class="line">ans+=<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[top[u]],id[u]);<span class="comment">//查询该端的值,修改也同理</span></span><br><span class="line">ans%=mo;</span><br><span class="line">u = fa[top[u]];<span class="comment">//跳到链头的父节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dep[u]&gt;dep[v]) <span class="built_in">swap</span>(u,v);</span><br><span class="line">ans+=<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[u],id[v]);<span class="comment">//操作6</span></span><br><span class="line">ans%=mo;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于操作$3,4$,由于是$dfs$,其子树的编号也一定是连续的</p><p>直接查询&#x2F;修改区间$[id[u],id[u]+size[u]-1]$即可</p><p>($id[u]$为该节点重组后的编号,$size[u]$为子树大小)</p><p>代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson (node&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson (node&lt;&lt;1|1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mid ((l+r)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> len (r-l+1)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">200000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">e</span>&#123;</span><br><span class="line"><span class="type">int</span> u,v,next;</span><br><span class="line">&#125;edge[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> w[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> n,m,mo;</span><br><span class="line"><span class="type">int</span> head[MAXN&lt;&lt;<span class="number">2</span>],cnt = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> dep[MAXN],fa[MAXN],son[MAXN],size[MAXN];</span><br><span class="line"><span class="type">int</span> id[MAXN],val[MAXN],top[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">edge[cnt].u=u;</span><br><span class="line">    edge[cnt].v=v;</span><br><span class="line">    edge[cnt].next=head[u];</span><br><span class="line">    head[u]=cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> f,<span class="type">int</span> deep)</span></span>&#123;</span><br><span class="line">dep[x] = deep;</span><br><span class="line">fa[x] = f;</span><br><span class="line">size[x] = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> maxson = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v= edge[i].v;</span><br><span class="line"><span class="keyword">if</span>(v==f) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs1</span>(v,x,deep+<span class="number">1</span>);</span><br><span class="line">size[x]+=size[v];</span><br><span class="line"><span class="keyword">if</span>(size[v]&gt;maxson) son[x] = v,maxson = size[v];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> topf)</span></span>&#123;</span><br><span class="line">id[x] = ++tot;</span><br><span class="line">val[tot] = w[x];</span><br><span class="line">top[x] = topf;</span><br><span class="line"><span class="keyword">if</span>(!son[x]) <span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">dfs2</span>(son[x],topf);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = edge[i].v;</span><br><span class="line"><span class="keyword">if</span>(v==fa[x]||v==son[x]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs2</span>(v,v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st</span>&#123;</span><br><span class="line"><span class="type">int</span> sum;</span><br><span class="line"><span class="type">int</span> tag;</span><br><span class="line">&#125;tree[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;</span><br><span class="line">tree[node].sum = (tree[lson].sum + tree[rson].sum)%mo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">tree[node].sum = val[l];</span><br><span class="line"><span class="keyword">if</span>(tree[node].sum&gt;mo) tree[node].sum%=mo;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">build</span>(lson,l,mid);</span><br><span class="line"><span class="built_in">build</span>(rson,mid+<span class="number">1</span>,r);</span><br><span class="line"><span class="built_in">pushup</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tree[node].tag==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    tree[lson].tag+=tree[node].tag;</span><br><span class="line">    tree[rson].tag+=tree[node].tag;</span><br><span class="line">    tree[lson].sum+=tree[node].tag*(len-(len&gt;&gt;<span class="number">1</span>));</span><br><span class="line">    tree[rson].sum+=tree[node].tag*(len&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    tree[lson].tag%=mo;</span><br><span class="line">    tree[rson].tag%=mo;</span><br><span class="line">tree[lson].sum%=mo;</span><br><span class="line">tree[rson].sum%=mo;</span><br><span class="line">tree[node].tag = <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=l&amp;&amp;r&lt;=y)&#123;</span><br><span class="line">tree[node].tag+=k;</span><br><span class="line">tree[node].sum+=k*(r-l+<span class="number">1</span>);</span><br><span class="line">tree[node].tag%=mo;</span><br><span class="line">tree[node].sum%=mo;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pushdown</span>(node,l,r);</span><br><span class="line"><span class="keyword">if</span>(x&lt;=mid) <span class="built_in">change</span>(lson,l,mid,x,y,k);</span><br><span class="line"><span class="keyword">if</span>(y&gt;mid) <span class="built_in">change</span>(rson,mid+<span class="number">1</span>,r,x,y,k);</span><br><span class="line"><span class="built_in">pushup</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(x&lt;=l&amp;&amp;r&lt;=y)&#123;</span><br><span class="line"><span class="keyword">return</span> tree[node].sum%mo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pushdown</span>(node,l,r);</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=mid) res+=<span class="built_in">query</span>(lson,l,mid,x,y);</span><br><span class="line"><span class="keyword">if</span>(y&gt;mid) res+=<span class="built_in">query</span>(rson,mid+<span class="number">1</span>,r,x,y);</span><br><span class="line">res%=mo;</span><br><span class="line"><span class="keyword">return</span> res%mo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">cout&lt;&lt;tree[node].sum&lt;&lt;<span class="string">&quot;  &quot;</span>&lt;&lt;tree[node].tag&lt;&lt;endl;</span><br><span class="line"><span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">test</span>(lson,l,mid);</span><br><span class="line">    <span class="built_in">test</span>(rson,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qb</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(top[u]!=top[v])&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]]) <span class="built_in">swap</span>(u,v);</span><br><span class="line">ans+=<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[top[u]],id[u]);</span><br><span class="line">ans%=mo;</span><br><span class="line">u = fa[top[u]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dep[u]&gt;dep[v]) <span class="built_in">swap</span>(u,v);</span><br><span class="line">ans+=<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[u],id[v]);</span><br><span class="line">ans%=mo;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ub</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(top[u]!=top[v])&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]]) <span class="built_in">swap</span>(u,v);</span><br><span class="line"><span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[top[u]],id[u],k);</span><br><span class="line">u = fa[top[u]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dep[u]&gt;dep[v]) <span class="built_in">swap</span>(u,v);</span><br><span class="line"><span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[u],id[v],k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> root;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;root,&amp;mo);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="type">int</span> u,v;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">    <span class="built_in">add</span>(u,v);</span><br><span class="line">    <span class="built_in">add</span>(v,u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs1</span>(root,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">dfs2</span>(root,root);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">cout&lt;&lt;dep[i]&lt;&lt;<span class="string">&quot;  &quot;</span>&lt;&lt;val[i]&lt;&lt;<span class="string">&quot;  &quot;</span>&lt;&lt;size[i]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line"><span class="type">int</span> k,x,y,z;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k);</span><br><span class="line"><span class="keyword">if</span>(k==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line"><span class="built_in">ub</span>(x,y,z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(k==<span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">qb</span>(x,y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(k==<span class="number">3</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line"><span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[x],id[x]+size[x]<span class="number">-1</span>,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[x],id[x]+size[x]<span class="number">-1</span>)%mo);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><del>话说树剖的好多题都好裸啊</del></p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 树链剖分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础线段树</title>
      <link href="/2020/08/06/%E5%9F%BA%E7%A1%80%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
      <url>/2020/08/06/%E5%9F%BA%E7%A1%80%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><h2 id="P3373-【模板】线段树-2"><a href="#P3373-【模板】线段树-2" class="headerlink" title="P3373 【模板】线段树 2"></a><a href="https://www.luogu.com.cn/problem/P3373">P3373 【模板】线段树 2</a></h2><p>设$mtag$为乘法标记,$atag$为加法标记</p><p>对于下放后的每一个区间来说,$x&#x3D;x<em>mtag+atag</em>len$(式$1$)</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/tbtb4rli.png"></p><p>$x&#x3D;x\cdot mtag_2+len\cdot atag_2&#x3D;(x\cdot mtag_2+len\cdot atag_2)\cdot mtag_1+atag_1\cdot len$</p><p>$&#x3D;x\cdot mtag_2\cdot mtag_1+len*atag_2\cdot mtag_1+atag_1\cdot len$</p><p>$&#x3D;x\cdot (mtag_2\cdot mtag_1)+len\cdot (atag_2\cdot mtag_1+atag_1)$</p><p>再根据前面的式$1$,易得</p><p>$mtag_2 &#x3D; mtag_1\cdot mtag_2$</p><p>$atag_2&#x3D;atag_2\cdot mtag_1+atag_2$</p><p>核心(下放)代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(tree2 *tree,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tree-&gt;lazym==<span class="number">1</span>&amp;&amp;tree-&gt;lazyp==<span class="number">0</span>||tree-&gt;lson==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">tree-&gt;lson-&gt;x = (tree-&gt;lson-&gt;x*tree-&gt;lazym+(<span class="type">long</span> <span class="type">long</span>)tree-&gt;lazyp*(mid-l+<span class="number">1</span>))%mo;</span><br><span class="line">tree-&gt;rson-&gt;x = (tree-&gt;rson-&gt;x*tree-&gt;lazym+(<span class="type">long</span> <span class="type">long</span>)tree-&gt;lazyp*(r-mid))%mo;</span><br><span class="line">tree-&gt;lson-&gt;lazym = (tree-&gt;lazym*tree-&gt;lson-&gt;lazym)%mo;</span><br><span class="line">tree-&gt;rson-&gt;lazym = (tree-&gt;lazym*tree-&gt;rson-&gt;lazym)%mo;</span><br><span class="line">tree-&gt;lson-&gt;lazyp = (tree-&gt;lazym*tree-&gt;lson-&gt;lazyp+tree-&gt;lazyp)%mo;</span><br><span class="line">tree-&gt;rson-&gt;lazyp = (tree-&gt;lazym*tree-&gt;rson-&gt;lazyp+tree-&gt;lazyp)%mo;</span><br><span class="line">tree-&gt;lazym  = <span class="number">1</span>;</span><br><span class="line">tree-&gt;lazyp = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="基础练习题"><a href="#基础练习题" class="headerlink" title="基础练习题"></a>基础练习题</h1><p><strong><a href="https://www.luogu.com.cn/problem/P4145">P4145 上帝造题的七分钟2 &#x2F; 花神游历各国</a></strong></p><p><strong><a href="https://www.luogu.com.cn/problem/P6327">P6327 区间加区间sin和</a></strong></p><p><strong><a href="https://www.luogu.com.cn/problem/P1438">P1438 无聊的数列</a></strong></p><p><strong><a href="https://www.luogu.com.cn/problem/P4513">P4513 小白逛公园</a></strong></p><p><strong><a href="https://www.luogu.com.cn/problem/P4588">P4588 [TJOI2018]数学计算</a></strong></p><p><strong><a href="https://www.luogu.com.cn/problem/P2894">P2894 [USACO08FEB]Hotel G</a></strong></p><h2 id="P4145-上帝造题的七分钟2-x2F-花神游历各国"><a href="#P4145-上帝造题的七分钟2-x2F-花神游历各国" class="headerlink" title="P4145 上帝造题的七分钟2 &#x2F; 花神游历各国"></a>P4145 上帝造题的七分钟2 &#x2F; 花神游历各国</h2><p>照题里的这个数据范围来看,直接暴力开方肯定会T飞</p><p>通过观察,不难发现数据范围内最大的数也只需要$6$次开方就可以变为$1$</p><p>考虑剪枝优化：</p><p>当一个区间的最大值为$1$时,其整个区间的其他值肯定也为$1$</p><p>因此当区间内最大值等于$1$时,直接$return$掉</p><p>核心代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> L = tree[node].l,R = tree[node].r;</span><br><span class="line"><span class="keyword">if</span>(L==R)&#123;</span><br><span class="line">tree[node].sum = <span class="built_in">sqrt</span>(tree[node].sum);</span><br><span class="line">tree[node].maxn = <span class="built_in">sqrt</span>(tree[node].maxn);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid = (L+R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid&amp;&amp;tree[lson].maxn&gt;<span class="number">1</span>)&#123;<span class="comment">//最大值大于1时在进行修改操作</span></span><br><span class="line"><span class="built_in">change</span>(lson,l,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(r&gt;mid&amp;&amp;tree[rson].maxn&gt;<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">change</span>(rson,l,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pushup</span>(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P6327-区间加区间sin和"><a href="#P6327-区间加区间sin和" class="headerlink" title="P6327 区间加区间sin和"></a>P6327 区间加区间sin和</h2><p>挺好的一道题目,很适合线段树初学者练手</p><p>学过和差角公式的应该都能很快想出解法</p><p>$sin(a+x) &#x3D; sinacosx+cosasinx$</p><p>$cos(a+x) &#x3D; cosacosx-sinxsina$</p><p>只需要在线段树里维护一个$sinx$和一个$cosx$即可</p><p>核心代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update2</span><span class="params">(<span class="type">int</span> node,<span class="type">double</span> sinv,<span class="type">double</span> cosv)</span></span>&#123;<span class="comment">//和差角公式</span></span><br><span class="line"><span class="type">double</span> cosa = tree[node].cosx;</span><br><span class="line">        <span class="type">double</span> sina = tree[node].sinx;</span><br><span class="line">tree[node].cosx = cosa*cosv-sina*sinv;</span><br><span class="line">tree[node].sinx = sina*cosv+cosa*sinv;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;<span class="comment">//下放</span></span><br><span class="line"><span class="keyword">if</span>(tree[node].tag)&#123;</span><br><span class="line"><span class="type">double</span> cosa = <span class="built_in">cos</span>(tree[node].tag),sina = <span class="built_in">sin</span>(tree[node].tag);</span><br><span class="line"><span class="built_in">update2</span>(lson,sina,cosa);<span class="comment">//更新儿子的值</span></span><br><span class="line"><span class="built_in">update2</span>(rson,sina,cosa);</span><br><span class="line">tree[lson].tag+=tree[node].tag;<span class="comment">//更新儿子的tag</span></span><br><span class="line">tree[rson].tag+=tree[node].tag;</span><br><span class="line">tree[node].tag = <span class="number">0</span>;b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span>&#123;<span class="comment">//更新操作</span></span><br><span class="line"><span class="type">int</span> L = tree[node].l,R = tree[node].r;</span><br><span class="line"><span class="keyword">if</span>(R&lt;=r&amp;&amp;L&gt;=l)&#123;<span class="comment">//包围在区间内,直接修改</span></span><br><span class="line">tree[node].tag+=x;</span><br><span class="line"><span class="built_in">update2</span>(node,<span class="built_in">sin</span>(x),<span class="built_in">cos</span>(x));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pushdown</span>(node);<span class="comment">//下放</span></span><br><span class="line"><span class="type">int</span> mid = (L + R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid) <span class="built_in">change</span>(lson,l,r,x);</span><br><span class="line"><span class="keyword">if</span>(r&gt;mid) <span class="built_in">change</span>(rson,l,r,x);</span><br><span class="line"><span class="built_in">update</span>(node);<span class="comment">//上传更新</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P1438-无聊的数列"><a href="#P1438-无聊的数列" class="headerlink" title="P1438 无聊的数列"></a>P1438 无聊的数列</h2><p>利用线段树来维护差分数组。</p><p>每当进行一个操作$1$时</p><p>将点$l$加上首相$k$</p><p>如果区间不是一个点的话,则将区间$[l+1,r]$上的点都加上公差$d$</p><p>如果$r&lt;n$,则在$r+1$的位置上加上$-(k+(r-l)\cdot d))$,便于差分</p><p>查询时,将区间$[1,k]$的值都加上即可,相当于查询操作</p><p>区间查询,区间修改,直接上线段树模板即可</p><p>核心代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="type">int</span> mode,l,r,k,d;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;mode);</span><br><span class="line"><span class="keyword">if</span>(mode==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;k,&amp;d);</span><br><span class="line"><span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,l,k);<span class="comment">//修改左端点</span></span><br><span class="line"><span class="keyword">if</span>(l!=r) <span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,n,l+<span class="number">1</span>,r,d);<span class="comment">//修改区间</span></span><br><span class="line"><span class="keyword">if</span>(r+<span class="number">1</span>&lt;=n) <span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,n,r+<span class="number">1</span>,r+<span class="number">1</span>,-(k+(r-l)*d));<span class="comment">//修改右端点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;d);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,<span class="number">1</span>,d)+a[d]);<span class="comment">//差分数组的值+原值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P4513-小白逛公园"><a href="#P4513-小白逛公园" class="headerlink" title="P4513 小白逛公园"></a>P4513 小白逛公园</h2><p>线段树经典题</p><p>维护一个从区间左端点开始的区间最大子段$maxl$,从右端点开始的区间最大子段$maxr$,总区间最大子段$maxx$,和一个区间和$sum$</p><p>对于$maxl$来说,其右端点的位置有两种可能:</p><ul><li><p>在左儿子中</p></li><li><p>在右儿子中</p></li></ul><p>得到方程:$tree.maxl &#x3D; max(lson.maxl,lson.sum+rson.maxl)$</p><p>$maxr$也同理</p><p>方程:$tree.maxr &#x3D; max(rson.maxr,rson.sum+lson.maxr)$</p><p>对于$maxx$来说，其区间范围有三种可能</p><ul><li><p>只在左儿子中</p></li><li><p>只在右儿子中</p></li><li><p>既在左儿子中也在右儿子中</p></li></ul><p>得到方程:$tree.maxx &#x3D; max(lson.maxx,rson.maxx,lson.maxr+rson.maxl))$</p><p>查询时只需输出区间$[l,r]$中的$maxx$即可</p><p>核心代码:</p><p>更新操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(tree2 *tree,tree2 *lson,tree2 *rson)</span></span>&#123;</span><br><span class="line">tree-&gt;sum = lson-&gt;sum+rson-&gt;sum;</span><br><span class="line">tree-&gt;maxl = <span class="built_in">max</span>(lson-&gt;maxl,lson-&gt;sum+rson-&gt;maxl);</span><br><span class="line">tree-&gt;maxr = <span class="built_in">max</span>(rson-&gt;maxr,rson-&gt;sum+lson-&gt;maxr);</span><br><span class="line">tree-&gt;maxX = <span class="built_in">max</span>(lson-&gt;maxX,<span class="built_in">max</span>(rson-&gt;maxX,lson-&gt;maxr+rson-&gt;maxl));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">tree2 *<span class="title">query</span><span class="params">(tree2 *tree,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=l&amp;&amp;y&gt;=r)</span><br><span class="line"><span class="keyword">return</span> tree;</span><br><span class="line"><span class="type">int</span> mid = (l + r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">tree2 *t1 = <span class="literal">NULL</span>,*t2 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=mid) t1 = <span class="built_in">query</span>(tree-&gt;lson,l,mid,x,y);</span><br><span class="line"><span class="keyword">if</span>(y&gt;mid) t2 = <span class="built_in">query</span>(tree-&gt;rson,mid+<span class="number">1</span>,r,x,y);</span><br><span class="line"><span class="keyword">if</span>(t1==<span class="literal">NULL</span>) <span class="keyword">return</span> t2;</span><br><span class="line"><span class="keyword">if</span>(t2==<span class="literal">NULL</span>) <span class="keyword">return</span> t1;</span><br><span class="line">tree2 *ret = &amp;dizhi[++t];</span><br><span class="line"><span class="built_in">update</span>(ret,t1,t2);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P4588-TJOI2018-数学计算"><a href="#P4588-TJOI2018-数学计算" class="headerlink" title="P4588 [TJOI2018]数学计算"></a>P4588 [TJOI2018]数学计算</h2><p>比较简单的一道题目。</p><p>仔细观察不难发现</p><p>所谓的操作$1$跟操作$2$其实就是在进行普通的单点修改操作而已</p><p>用一个线段树在记录一段区间内的总乘积</p><p>操作$1$是把点$i$的值从$1$修改为$i$</p><p>操作$2$则是把点$pos$的值修改为$1$</p><p>核心代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;</span><br><span class="line">tree[node].val = (tree[lson].val*tree[rson].val)%mo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">tree[node].val = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> mid = (l + r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">build</span>(lson,l,mid);</span><br><span class="line"><span class="built_in">build</span>(rson,mid+<span class="number">1</span>,r);</span><br><span class="line"><span class="built_in">pushup</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">tree[node].val = y;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid = (l + r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=mid) <span class="built_in">change</span>(lson,l,mid,x,y);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">change</span>(rson,mid+<span class="number">1</span>,r,x,y);</span><br><span class="line"><span class="built_in">pushup</span>(node);</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><h2 id="P2894-USACO08FEB-Hotel-G"><a href="#P2894-USACO08FEB-Hotel-G" class="headerlink" title="P2894 [USACO08FEB]Hotel G"></a>P2894 [USACO08FEB]Hotel G</h2><p>跟<a href="https://www.luogu.com.cn/problem/P4513"><strong>P4513 小白逛公园</strong></a>大同小异的思路</p><p>只是把单点修改操作换成了区间修改罢了</p><p>要注意的是这里不存在负值的情况</p><p>因此在上传操作时转移没那么复杂,只用判断$maxl$是否等于$sum$</p><p>若等于,说明左儿子中房间全为空,直接全部加上,再加上右儿子的$maxl$</p><p>若不等于,则为左儿子的$maxl$</p><p>$maxr$也同理</p><p>同时也要注意这里的查询查的是满足长度为$x$的最左的端点</p><p>因此在查询时要满足”能左则左”</p><p>核心代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;<span class="comment">//上传</span></span><br><span class="line"><span class="keyword">if</span>(tree[lson].maxx==tree[lson].sum)&#123;<span class="comment">//如果左区间全为空房</span></span><br><span class="line">tree[node].lmax = tree[lson].sum+tree[rson].lmax;<span class="comment">//全部加上</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">tree[node].lmax = tree[lson].lmax;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(tree[rson].maxx==tree[rson].sum)&#123;</span><br><span class="line">tree[node].rmax = tree[rson].sum+tree[lson].rmax;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">tree[node].rmax = tree[rson].rmax;</span><br><span class="line">&#125;</span><br><span class="line">tree[node].maxx = <span class="built_in">max</span>(tree[lson].rmax+tree[rson].lmax,<span class="built_in">max</span>(tree[lson].maxx,tree[rson].maxx));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">tree[node].sum = tree[node].lmax = tree[node].rmax = tree[node].maxx =r-l+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">build</span>(lson,l,mid);</span><br><span class="line"><span class="built_in">build</span>(rson,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;<span class="comment">//下放</span></span><br><span class="line"><span class="keyword">if</span>(tree[node].lazy==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(tree[node].lazy==<span class="number">1</span>)&#123;<span class="comment">//退房</span></span><br><span class="line">tree[lson].maxx = tree[lson].rmax = tree[lson].lmax = <span class="number">0</span>;</span><br><span class="line">tree[rson].maxx = tree[rson].rmax = tree[rson].lmax = <span class="number">0</span>;</span><br><span class="line">tree[lson].lazy = tree[rson].lazy = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(tree[node].lazy==<span class="number">2</span>)&#123;<span class="comment">//开房</span></span><br><span class="line">tree[lson].maxx = tree[lson].rmax = tree[lson].lmax = tree[lson].sum;</span><br><span class="line">tree[rson].maxx = tree[rson].rmax = tree[rson].lmax = tree[rson].sum;</span><br><span class="line">tree[lson].lazy = tree[rson].lazy = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">tree[node].lazy = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> opt)</span></span>&#123;<span class="comment">//opt为1代表退房,为2代表开房</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(x&lt;=l&amp;&amp;y&gt;=r)&#123;</span><br><span class="line"><span class="keyword">if</span>(opt==<span class="number">1</span>) tree[node].maxx = tree[node].lmax = tree[node].rmax = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> tree[node].maxx = tree[node].lmax = tree[node].rmax = tree[node].sum;</span><br><span class="line"></span><br><span class="line">tree[node].lazy = opt;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pushdown</span>(node);</span><br><span class="line"><span class="keyword">if</span>(x&lt;=mid) <span class="built_in">change</span>(lson,l,mid,x,y,opt);</span><br><span class="line"><span class="keyword">if</span>(y&gt;mid) <span class="built_in">change</span>(rson,mid+<span class="number">1</span>,r,x,y,opt);</span><br><span class="line"><span class="built_in">pushup</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span>&#123;<span class="comment">//查询</span></span><br><span class="line"><span class="built_in">pushdown</span>(node);</span><br><span class="line"><span class="keyword">if</span>(l==r) <span class="keyword">return</span> l;</span><br><span class="line"><span class="keyword">if</span>(tree[lson].maxx&gt;=x)&#123;<span class="comment">//如果左区间的最大值大于x,直接查左边</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">query</span>(lson,l,mid,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(tree[lson].rmax+tree[rson].lmax&gt;=x)&#123;<span class="comment">//如果中间大于x</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>+mid-tree[lson].rmax;左儿子的右最大值,也就是最靠近左边的端点</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(rson,mid+<span class="number">1</span>,r,x);<span class="comment">//否则查右边</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态开点"><a href="#动态开点" class="headerlink" title="动态开点"></a>动态开点</h2><p><strong><a href="https://www.luogu.com.cn/problem/P5459">P5459 [BJOI2016]回转寿司</a></strong></p><p><strong><a href="https://www.luogu.com.cn/problem/CF915E">CF915E Physical Education Lessons</a></strong></p><p>$now ~ loading…$</p><h2 id="扫描线"><a href="#扫描线" class="headerlink" title="扫描线"></a>扫描线</h2><p><strong><a href="https://www.luogu.com.cn/problem/P5490">P5490 【模板】扫描线</a></strong></p><p><strong><a href="https://www.luogu.com.cn/problem/P1502">P1502 窗口的星星</a></strong></p><p>$now ~ loading…$</p><p>&#96;&#96;</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P5459 [BJOI2016]回转寿司</title>
      <link href="/2020/08/05/p5459/"/>
      <url>/2020/08/05/p5459/</url>
      
        <content type="html"><![CDATA[<h1 id="P5459-BJOI2016-回转寿司-题解"><a href="#P5459-BJOI2016-回转寿司-题解" class="headerlink" title="P5459 [BJOI2016]回转寿司 题解"></a>P5459 [BJOI2016]回转寿司 题解</h1><h2 id="间隙"><a href="#间隙" class="headerlink" title="间隙"></a><a href="https://www.luogu.com.cn/problem/P5459">间隙</a></h2><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><ul><li><h2 id="前缀和-权值线段树-动态开点"><a href="#前缀和-权值线段树-动态开点" class="headerlink" title="前缀和,权值线段树,动态开点"></a>前缀和,权值线段树,动态开点</h2></li></ul><p>如果您还不会权值线段树跟动态开点的话,推荐去看一下<a href="https://www.bilibili.com/video/BV1Zg4y1q7aY?t=1726"><strong>这个教程</strong></a></p><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给一个序列,现从中取出一段连续子序列,使其子序列内数值总和$a$满足$L\le a\le R$</p><p>求总方案数。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>区间求和,很容易先联想到前缀和</p><p>不妨先设$sum[i]$为前$i$个数的前缀和</p><p>易得式子:</p><p>$L \le sum[r] - sum[l-1] \le R$</p><p>移项一下</p><p>$sum[r]-L \le sum[l-1]  \le sum[r]-R $</p><p>这样原问题就转化为了<strong>在区间$[sum[r]-L,sum[r]-R]$中有多少个$sum[l-1]$($l \in[1,r]$ )</strong></p><p><strong>每一个$r$也就相当于是查询区间$[sum[r]-L,sum[r]-R]$中$sum[l-1]$的总和</strong>($l \in[1,r]$ )</p><p>可以使用权值线段树$+$动态开点来维护。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>从$1$~$n$枚举$r$的值,把每一个$r$当作一次”查询”</p><p>同时不要忘记在进行下一次”查询” 前把 $l$ 的值 “更新”(指插入新的值)</p><p>具体的注释里有讲</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> MAXN = <span class="number">1e10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> sum[N];<span class="comment">//前缀和 </span></span><br><span class="line"><span class="type">int</span> n,l,r;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st</span>&#123;</span><br><span class="line"><span class="type">int</span> l,r,sum;<span class="comment">//左儿子,右儿子,总方案数 </span></span><br><span class="line">&#125;tree[N&lt;&lt;<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;<span class="comment">//上传操作 </span></span><br><span class="line">tree[node].sum = tree[tree[node].l].sum+tree[tree[node].r].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> &amp;node,<span class="type">long</span> <span class="type">long</span> x,<span class="type">long</span> <span class="type">long</span> l = -MAXN , <span class="type">long</span> <span class="type">long</span> r = MAXN)</span></span>&#123;<span class="comment">//更新 注意,l的初始值要设成负数,一开始在这里卡了好久\kk </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!node) node = ++tot;<span class="comment">//动态开点 </span></span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;<span class="comment">//如果为根节点 </span></span><br><span class="line">tree[node].sum++;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> mid = (l + r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=mid) <span class="built_in">update</span>(tree[node].l,x,l,mid);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">update</span>(tree[node].r,x,mid+<span class="number">1</span>,r);</span><br><span class="line"><span class="built_in">pushup</span>(node);<span class="comment">//更新父节点的值 </span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">query</span><span class="params">(<span class="type">int</span> &amp;node,<span class="type">long</span> <span class="type">long</span> x,<span class="type">long</span> <span class="type">long</span> y,<span class="type">long</span> <span class="type">long</span> l =-MAXN,<span class="type">long</span> <span class="type">long</span> r = MAXN)</span></span>&#123;<span class="comment">//查询操作 </span></span><br><span class="line"><span class="keyword">if</span>(!node) node = ++tot;<span class="comment">//动态开点 </span></span><br><span class="line"><span class="keyword">if</span>(x&lt;=l&amp;&amp;y&gt;=r)&#123;<span class="comment">//包含在查询范围内 </span></span><br><span class="line"><span class="keyword">return</span> tree[node].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=mid) res+=<span class="built_in">query</span>(tree[node].l,x,y,l,mid); </span><br><span class="line"><span class="keyword">if</span>(y&gt;mid) res+=<span class="built_in">query</span>(tree[node].r,x,y,mid+<span class="number">1</span>,r); </span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> root = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;l,&amp;r);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">sum[i] = sum[i<span class="number">-1</span>] + a;<span class="comment">//前缀和 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">insert</span>(root,<span class="number">0</span>);<span class="comment">//不要忘记插入0,也就是说一个都不吃的情况 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">ans+=<span class="built_in">query</span>(root,sum[i] - r,sum[i] - l);<span class="comment">//加方案数 </span></span><br><span class="line"><span class="built_in">insert</span>(root,sum[i]);<span class="comment">//&quot;更新&quot;l的值 </span></span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P3478 [POI2008]STA-Station</title>
      <link href="/2020/08/03/p3478/"/>
      <url>/2020/08/03/p3478/</url>
      
        <content type="html"><![CDATA[<h1 id="P3478-POI2008-STA-Station题解"><a href="#P3478-POI2008-STA-Station题解" class="headerlink" title="P3478 [POI2008]STA-Station题解"></a>P3478 [POI2008]STA-Station题解</h1><h2 id="原题面"><a href="#原题面" class="headerlink" title="原题面"></a><a href="https://www.luogu.com.cn/problem/P3478">原题面</a></h2><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul><li>换根DP</li></ul><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给出一个 N 个点的树,找出一个点来,以这个点为根的树时,所有点的深度之和最大</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>换根DP的模板题。</p><p>如果您还不会换根DP的话,可以先去看看UltiMadow巨佬的文章:</p><p><a href="https://www.luogu.com.cn/discuss/show/47327">【日报#278】[学习笔记]换根dp</a>,我一开始也是从那里学的qwq</p><p>这里我们设</p><ul><li><p><strong>$size[i]$为以$1$为根节点时节点$i$的子树大小</strong></p></li><li><p><strong>$dep[i]$为以$1$为根节点时节点$i$的深度大小</strong></p></li><li><p><strong>$dp[i]$为以$i$为根节点时深度之和的大小</strong></p></li></ul><p>很明显,我们可以通过一遍DFS求出以$1$为根节点时的深度之和</p><p>如果一个个的去算的话</p><p>照这个数据范围,显然会T飞</p><p>这个时候就要用到换根DP了</p><h2 id="换根-DP-优化"><a href="#换根-DP-优化" class="headerlink" title="换根$DP$优化"></a>换根$DP$优化</h2><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/o5nj1c7o.png"></p><p>可以看出,当我们把根节点从1换到3时</p><p>对子节点3的贡献由两部分组成</p><p>1.<strong>自己子树的贡献(图中的k)</strong></p><p>2.<strong>父亲节点$1$的贡献</strong></p><hr><h2 id="如何转移"><a href="#如何转移" class="headerlink" title="如何转移"></a>如何转移</h2><ul><li><p>首先是$k$,作为自己子树所产生的贡献肯定要加上</p></li><li><p>$dp[u]$为以$u$为根节点时的深度总值,在计算时,要减去$v$的子树所产生的贡献,不然就重复计算了,同时</p></li></ul><p><strong>在以 $u$为根时,v节点及其子树内的所有节点的深度都增加了$1$</strong>,需要减去</p><p><strong>(图中红色的节点)</strong></p><p>合起来就是$dp[u]-(size[v]+k)$</p><ul><li>除v子树外的其他节点也一样</li></ul><p><strong>在以$v$为根时，除$v$节点及其子树外的其他节点的深度都增加了$1$</strong></p><p><strong>(图中蓝色的节点)</strong></p><p>合起来就是$(size[1]-size[v])$</p><p>得到转移方程</p><ul><li>$dp[v] &#x3D; k+(dp[u]-(k+size[v]))+(size[1]-size[v])$</li></ul><p>化简一下</p><ul><li>$dp[v] &#x3D; dp[u]-2size[v]+size[1]$</li></ul><p>转移方程推出来了,代码部分就不难实现了,两遍dfs,一次dfs统计子树内的节点对当前节点的贡献<br>一次dfs换根</p><p>贴个代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN  = <span class="number">100010</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> dp[MAXN],dep[MAXN],size[MAXN];</span><br><span class="line"><span class="type">int</span> vis[MAXN];</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; son[MAXN];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">size[x] = <span class="number">1</span>;</span><br><span class="line">    vis[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;son[x].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line"><span class="type">int</span> v = son[x][i];</span><br><span class="line"><span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">dep[v] = dep[x] +<span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs1</span>(v);</span><br><span class="line">size[x]+=size[v];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    vis[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;son[x].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line"><span class="type">int</span> v = son[x][i];</span><br><span class="line"><span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">dp[v] = dp[x] +size[<span class="number">1</span>] - <span class="number">2</span>*size[v];</span><br><span class="line"><span class="built_in">dfs2</span>(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="type">int</span> u,v;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">son[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">son[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs1</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dp[<span class="number">1</span>]+=dep[i];</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line"><span class="built_in">dfs2</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans = <span class="number">-0x3f</span>;</span><br><span class="line"><span class="type">int</span> jd =<span class="number">999</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(ans &lt; dp[i]) ans = dp[i], jd = i;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;jd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划-换根dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P1453 城市环路</title>
      <link href="/2020/08/03/p1453/"/>
      <url>/2020/08/03/p1453/</url>
      
        <content type="html"><![CDATA[<h1 id="P1453-城市环路-题解"><a href="#P1453-城市环路-题解" class="headerlink" title="P1453 城市环路 题解"></a>P1453 城市环路 题解</h1><h2 id="间隙"><a href="#间隙" class="headerlink" title="间隙"></a><a href="https://www.luogu.com.cn/problem/P1453">间隙</a></h2><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><ul><li><h3 id="树形dp-基环树"><a href="#树形dp-基环树" class="headerlink" title="树形dp,基环树"></a>树形dp,基环树</h3></li></ul><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给一颗含有点权的基环外向树</p><p>假如两个点之间有一条边连接,如果选择了其中一端的节点,那另一段的节点则不可选择</p><p>求:最大贡献</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>先讲一下什么是基环树。</p><p>基环树,简单来说就是多了一条边的树,产生了一个环形结构,环上的每个节点都是一颗树的根</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/g8bnch8r.png"></p><p>画成图的话大概是这个样子(基环外向树)</p><p>一般来说,这种题目的做法都是先找到环,断开环中的一条边,<br>把它当成一般的树形$DP$来做。</p><h3 id="如何找环"><a href="#如何找环" class="headerlink" title="如何找环?"></a>如何找环?</h3><p>一般有$dfs$跟并查集两种方法 , 这里我采用的是并查集的做法</p><p>一开始每个节点都是一个独立的集合</p><p>每连接一条边,就把这两个点合并到一个集合中</p><p>如果在连接一条边之前,两个节点就已经在一个集合中了,说明这<strong>两个节点已经联通了,再连接这条边必然会产生环的情况</strong></p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/53vb8z0u.png"></p><h3 id="如何转移"><a href="#如何转移" class="headerlink" title="如何转移?"></a>如何转移?</h3><p>找到了环之后,只需要将环上的这条边断开即可</p><p>这样的话就可以当作普通的树形$DP$来做了</p><p>设$f[i][0]$为选第$i$个节点产生的最大贡献</p><p>$f[i][1]$为不选第$i$个节点产生的最大贡献</p><p>如果选了第$i$个节点,那它的儿子肯定都不能选</p><p>反之,儿子可以选择选,也可以选择不选</p><p>得到转移方程:</p><p>$f[u][0] &#x3D; \sum f[v][0]$</p><p>$f[u][1] &#x3D; \sum max(f[v][1],f[v][0])$</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>思路明白了代码实现应该就不难了</p><p>要注意的是环上的两个点都可以作为树的根节点,因此在$DP$的时候要把两个点都跑一遍</p><p>具体的细节注释有写</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="comment">//存图 </span></span><br><span class="line"><span class="type">int</span> v,next;</span><br><span class="line">&#125;e[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> f[MAXN][<span class="number">2</span>],w[MAXN];<span class="comment">//dp数组,点权 </span></span><br><span class="line"><span class="type">double</span> k; </span><br><span class="line"><span class="type">int</span> fa[MAXN];</span><br><span class="line"><span class="type">int</span> head[MAXN&lt;&lt;<span class="number">1</span>],cnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> root1,root2;<span class="comment">//环上的两个点 </span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;<span class="comment">//前向星 </span></span><br><span class="line">e[++cnt].v = v;</span><br><span class="line">e[cnt].next = head[u];</span><br><span class="line">head[u] = cnt;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="comment">//查找集合 </span></span><br><span class="line"><span class="keyword">if</span>(fa[x]==x)&#123;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">circle</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;<span class="comment">//树形dp </span></span><br><span class="line">f[u][<span class="number">1</span>] = w[u],f[u][<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//初始化 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = e[i].v;</span><br><span class="line"><span class="keyword">if</span>(v!=fa)&#123; </span><br><span class="line"><span class="built_in">circle</span>(v,u);</span><br><span class="line">f[u][<span class="number">0</span>]+=<span class="built_in">max</span>(f[v][<span class="number">1</span>],f[v][<span class="number">0</span>]);<span class="comment">//转移 </span></span><br><span class="line">f[u][<span class="number">1</span>]+=f[v][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w[i]);</span><br><span class="line">fa[i] = i;<span class="comment">//初始化集合 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="type">int</span> u,v;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">u++,v++;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">find</span>(u)==<span class="built_in">find</span>(v))&#123;<span class="comment">//如果在加边前就在一个集合中了,说明找到了环 </span></span><br><span class="line">        root1 = u,root2 = v;<span class="comment">//记录环上的两个点 </span></span><br><span class="line">        <span class="keyword">continue</span>;<span class="comment">//直接跳过加边操作,相当于断开这条边 </span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="built_in">add</span>(u,v);</span><br><span class="line"><span class="built_in">add</span>(v,u);</span><br><span class="line">fa[<span class="built_in">find</span>(v)] = <span class="built_in">find</span>(u);<span class="comment">//合并集合 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;k);</span><br><span class="line"><span class="built_in">circle</span>(root1,<span class="number">0</span>);</span><br><span class="line"><span class="type">double</span> r1 = f[root1][<span class="number">0</span>];<span class="comment">//选root1 </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">circle</span>(root2,<span class="number">0</span>);</span><br><span class="line"><span class="type">double</span> r2 = f[root2][<span class="number">0</span>];<span class="comment">//选root2 </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.1lf&quot;</span>,<span class="built_in">max</span>(r1,r2)*k);<span class="comment">//取最大 </span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划-树形dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础树形dp</title>
      <link href="/2020/08/02/%E6%A0%91%E5%BD%A2dp/"/>
      <url>/2020/08/02/%E6%A0%91%E5%BD%A2dp/</url>
      
        <content type="html"><![CDATA[<p>曾经的黑历史(</p><p>有空了重构一下</p><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><h2 id="P1352-没有上司的舞会"><a href="#P1352-没有上司的舞会" class="headerlink" title="P1352 没有上司的舞会"></a>P1352 没有上司的舞会</h2><p>树状$dp$模板题。</p><p>设$f[i][0]$为第$i$个人来了的方案数</p><p>$f[i][1]$为第$i$和人没来的方案数</p><p>若第$i$个人来了,那么其下属均不回来</p><p>若不来,其下属则有来和不来两种选择</p><p>因此状态转移方程为:</p><ul><li><p>$f[i][0]+&#x3D;f[son][1]$</p></li><li><p>$f[i][1]+&#x3D;max(f[son][0],f[son][1])$</p></li></ul><h2 id="P2015-二叉苹果树"><a href="#P2015-二叉苹果树" class="headerlink" title="P2015 二叉苹果树"></a>P2015 二叉苹果树</h2><p>树上背包模板题</p><p>每一个枝条都有”剪”和”不剪”两种可能</p><p>把每一个儿子都看成一个”分组背包”</p><p>设$dp[i][j]$表示第$i$个子树保留$j$条边</p><p>每加入一个”儿子”后,枚举该”儿子”保留的边数,如图<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/bl7hi1vj.png"></p><h5 id="ps-这里i-k后面还要减1是因为还要多保留从u-gt-v这条边"><a href="#ps-这里i-k后面还要减1是因为还要多保留从u-gt-v这条边" class="headerlink" title="(ps:这里i-k后面还要减1是因为还要多保留从u-&gt;v这条边)"></a>(ps:这里i-k后面还要减1是因为还要多保留从u-&gt;v这条边)</h5><p>故状态转移方程为:</p><ul><li>$f[u][i]&#x3D;max(f[v][i-k-1]+f[u][k]+w[u][v])(i\in[1,m+1)]$</li></ul><hr><h1 id="树上背包"><a href="#树上背包" class="headerlink" title="树上背包"></a>树上背包</h1><p><strong><a href="https://www.luogu.com.cn/problem/P2014">P2014 [CTSC1997]选课</a></strong></p><p><strong><a href="https://www.luogu.com.cn/problem/P1273">P1273 有线电视网</a></strong></p><p><strong><a href="https://www.luogu.com.cn/problem/P1270">P1270 “访问”美术馆</a></strong></p><p><strong><a href="https://www.luogu.com.cn/problem/P1272">P1272 重建道路</a></strong></p><hr><h2 id="P2014-CTSC1997-选课"><a href="#P2014-CTSC1997-选课" class="headerlink" title="P2014 [CTSC1997]选课"></a>P2014 [CTSC1997]选课</h2><p>和二叉苹果树一样的套路。</p><p>把每一个子课程都看作是一个”分组背包”,倒序枚举即可</p><p>由于题目中可能有多棵树</p><p>因此多开一个节点把所有”树根”连在一起</p><p>同时,在倒序枚举时也要把这个新节点算进去</p><p>转移方程:</p><ul><li>$f[u][i]&#x3D;max(f[v][i-k-1]+f[u][k]+w[v])(i\in[1,m+1])$</li></ul><p>核心代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">vis[k]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;son[k].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[son[k][i]]!=<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">dp</span>(son[k][i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> v=m+<span class="number">1</span>;v&gt;=<span class="number">1</span>;v--)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> K=<span class="number">0</span>;K&lt;v;K++)&#123;</span><br><span class="line"> f[k][v]=<span class="built_in">max</span>(f[k][v],w[son[k][i]]+f[son[k][i]][K]+f[k][v-K<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="P1273-有线电视网"><a href="#P1273-有线电视网" class="headerlink" title="P1273 有线电视网"></a>P1273 有线电视网</h2><p>也是比较经典的一个树上背包问题</p><p>题目中要求的是在不亏本的情况下最多的观看用户个数</p><p>设$f[i][j]$表示第$i$个站传输给$j$个用户观看最终剩余的钱数</p><p>若最终剩余钱数大于等于0,则说明未亏本</p><p>反之,则说明亏本</p><p>转移方程则为:</p><ul><li>$f[u][i]&#x3D;max(f[v][k]+f[u][i-k]-w[u][v])$</li></ul><p>$dp$完后从总人数开始倒序判断是否亏本即可</p><p>贴个核心代码:</p><p>$dp部分$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">dp[x][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(val[x])&#123;<span class="comment">//如果是根节点</span></span><br><span class="line">size[x]=<span class="number">1</span>;<span class="comment">//人数加一</span></span><br><span class="line">dp[x][<span class="number">1</span>]=val[x];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;son[x].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line"><span class="built_in">dfs</span>(son[x][i]);</span><br><span class="line">size[x]+=size[son[x][i]];<span class="comment">//计算x节点下的人数总和</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=size[x];j&gt;=<span class="number">0</span>;j--)&#123;<span class="comment">//滚动数组,倒序枚举</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=size[son[x][i]];k++)&#123;<span class="comment">//枚举子树传输的观众数量</span></span><br><span class="line">dp[x][j]=<span class="built_in">max</span>(dp[x][j],dp[x][j-k]+dp[son[x][i]][k]-W[x][son[x][i]]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>$判断部分$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=m;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">if</span>(dp[<span class="number">1</span>][i]&gt;=<span class="number">0</span>)&#123;<span class="comment">//如果不亏本</span></span><br><span class="line">cout&lt;&lt;i;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="P1270-“访问”美术馆"><a href="#P1270-“访问”美术馆" class="headerlink" title="P1270 “访问”美术馆"></a>P1270 “访问”美术馆</h2><p>跟P1273 有线电视网一样的套路</p><p>设$f[i][j]$为在第$i$个节点下偷$j$幅画所需要的最小总时间</p><p>状态转移方程也就呼之欲出了</p><ul><li>$f[u][i]&#x3D;min(f[v][k]+f[u][i-k]-2w[u][v])$</li></ul><p>这里$w[u][v]$要乘2是因为要进出各一趟</p><p>核心代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(paint[x]!=<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> paint[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;son[x].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> v = son[x][i];</span><br><span class="line"><span class="type">int</span> t=<span class="built_in">dfs</span>(v);</span><br><span class="line">s+=t;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j =s;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=t;k++)&#123;</span><br><span class="line">dp[x][j] = <span class="built_in">min</span>(dp[x][j] , dp[v][k] + dp[x][j-k]+w[x][v]*<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="P1272-重建道路"><a href="#P1272-重建道路" class="headerlink" title="P1272 重建道路"></a>P1272 重建道路</h2><p>同样也是一道比较经典的树上背包问题</p><p>设$f[i][j]$为第$i$个节点断出一个大小为$j$的子树所需要的断开总数</p><p>状态转移方程:</p><ul><li>$f[u][i]&#x3D;min(f[v][k]+f[u][i-k]-1)$</li></ul><p>($v$为根的子树提供$k$个节点,$u$和其他儿子提供$j-k$个节点)</p><p>同时,由于一开始时一个子树都没有加进来</p><p>即把$u$的所有”儿子”都切断了<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/rawfxbhz.png"></p><p>因此当把$v$儿子加进来的时候要把之前那段减去的边加回来</p><p>核心代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">size[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(!is_son[x])&#123;</span><br><span class="line">dp[x][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">size[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;son[x].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line"><span class="type">int</span> v = son[x][i];</span><br><span class="line"><span class="built_in">dfs</span>(v);</span><br><span class="line">size[x]+=size[v];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = size[x];j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>;k&lt;=size[v];k++)&#123;<span class="comment">//这里题解里很多人都写成了&lt;j,问题是子树可能本身就没有这么多子节点,感觉有些问题</span></span><br><span class="line">dp[x][j] = <span class="built_in">min</span>(dp[x][j],dp[x][j-k]+dp[v][k]<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="普通树形-DP"><a href="#普通树形-DP" class="headerlink" title="普通树形$DP$"></a>普通树形$DP$</h1><p><strong><a href="https://www.luogu.com.cn/problem/P2016">P2016 战略游戏</a></strong></p><p><strong><a href="https://www.luogu.com.cn/problem/P2458">P2458 [SDOI2006]保安站岗 题解</a></strong></p><p><strong><a href="https://www.luogu.com.cn/problem/P4084">P4084 [USACO17DEC]Barn Painting G</a></strong></p><p><strong><a href="https://www.luogu.com.cn/problem/P2585">P2585 [ZJOI] 三色二叉树</a></strong></p><p><strong><a href="https://www.luogu.com.cn/problem/P2279">P2279 消防局的设立</a></strong></p><hr><h2 id="P2016-战略游戏"><a href="#P2016-战略游戏" class="headerlink" title="P2016 战略游戏"></a>P2016 战略游戏</h2><p>带了点贪心思想的树形$DP$</p><p>如果父节点放了一个守卫</p><p>那其子节点就都不用放守卫了</p><p>反之,子节点都要放一个守卫</p><p>转移方程:</p><ul><li>$f[u][0]+&#x3D;f[v][1]$</li><li>$f[u][1]+&#x3D;min(f[v][1],f[v][0])$</li></ul><p>为什么不用儿子的儿子(“孙子”)节点来看守儿子节点?</p><p><strong>如果一个节点不是叶子节点,那他的子节点数必定大于或等于$1$</strong>,因此如果<strong>用儿子节点来看守其父节点,花费的数量肯定会更多</strong>(或不变)。</p><h6 id="遗憾的是题解里似乎没人说正确性的证明-还是说太简单了都懒得证了"><a href="#遗憾的是题解里似乎没人说正确性的证明-还是说太简单了都懒得证了" class="headerlink" title="遗憾的是题解里似乎没人说正确性的证明?,还是说太简单了都懒得证了"></a>遗憾的是题解里似乎没人说正确性的证明?,<del>还是说太简单了都懒得证了</del></h6><p>核心代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(x!=<span class="number">1509</span>)</span><br><span class="line">dp[x][<span class="number">1</span>]=<span class="number">1</span>,dp[x][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;son[x].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line"><span class="built_in">dfs</span>(son[x][i]);</span><br><span class="line">dp[x][<span class="number">0</span>]+=dp[son[x][i]][<span class="number">1</span>];</span><br><span class="line">dp[x][<span class="number">1</span>]+=<span class="built_in">min</span>(dp[son[x][i]][<span class="number">1</span>],dp[son[x][i]][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于这道题目的带点权版:</p><h2 id="P2458-SDOI2006-保安站岗"><a href="#P2458-SDOI2006-保安站岗" class="headerlink" title="P2458 [SDOI2006]保安站岗"></a>P2458 [SDOI2006]保安站岗</h2><h2 id="题解链接"><a href="#题解链接" class="headerlink" title="题解链接"></a><a href="https://www.luogu.com.cn/blog/xcxc82/p2458-sdoi2006-bao-an-zhan-gang-ti-xie-yes">题解链接</a></h2><h2 id="P4084-USACO17DEC-Barn-Painting-G"><a href="#P4084-USACO17DEC-Barn-Painting-G" class="headerlink" title="P4084 [USACO17DEC]Barn Painting G"></a>P4084 [USACO17DEC]Barn Painting G</h2><p>树上$DP$求方案数。</p><p>还算是比较简单的题目吧…</p><p>设:</p><p>$f[i][0]$为第$i$个节点涂红色的方案数</p><p>$f[i][1]$为第$i$个节点涂绿色的方案数</p><p>$f[i][2]$为第$i$个节点涂蓝色的方案数</p><p>假设第$i$号节点涂了红色,那么它的上一个节点就只能涂绿色和蓝色</p><p>其他情况也同理</p><p>用乘法定理乘一下即可。</p><p>转移方程:</p><ul><li>$\begin{cases}f[u][1]&#x3D;f[u][1]<em>((f[v][2]+f[v][3]))\f[u][2]&#x3D;f[u][2]</em>((f[v][1]+f[v][3]))\f[u][3]&#x3D;f[u][3]*((f[v][1]+f[v][2]))\end{cases}$</li></ul><hr><h1 id="换根-DP"><a href="#换根-DP" class="headerlink" title="换根$DP$"></a>换根$DP$</h1><p>一种形式十分优美的树形$DP$</p><p><strong><a href="https://www.luogu.com.cn/problem/P3478">P3478 [POI2008]STA-Station</a></strong></p><p><strong><a href="https://www.luogu.com.cn/problem/P2986">P2986 [USACO10MAR]Great Cow Gathering G</a></strong></p><p><strong><a href="https://www.luogu.com.cn/problem/P3047">P3047 [Nearby Cows G]Great Cow Gathering G</a></strong></p><p><strong><a href="https://www.luogu.com.cn/problem/CF708C">CF708C Centroids</a></strong></p><p><strong><a href="https://www.luogu.com.cn/problem/CF1187E">CF1187E Tree Painting</a></strong></p><hr><h2 id="P3478-POI2008-STA-Station"><a href="#P3478-POI2008-STA-Station" class="headerlink" title="P3478 [POI2008]STA-Station"></a>P3478 [POI2008]STA-Station</h2><p>换根DP的模板题。</p><p>这里我们设</p><ul><li><p><strong>$size[i]$为以$1$为根节点时节点$i$的子树大小</strong></p></li><li><p><strong>$dep[i]$为以$1$为根节点时节点$i$的深度大小</strong></p></li><li><p><strong>$dp[i]$为以$i$为根节点时深度之和的大小</strong></p></li></ul><p>很明显,我们可以通过一遍DFS求出以$1$为根节点时的深度之和</p><p>如果一个个的去算的话</p><p>照这个数据范围,显然会T飞</p><p>这个时候就要用到换根DP了</p><h2 id="换根-DP-优化"><a href="#换根-DP-优化" class="headerlink" title="换根$DP$优化"></a>换根$DP$优化</h2><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/o5nj1c7o.png"></p><p>可以看出,当我们把根节点从1换到3时</p><p>对子节点3的贡献由两部分组成</p><p>1.<strong>自己子树的贡献(图中的k)</strong></p><p>2.<strong>父亲节点$1$的贡献</strong></p><hr><h2 id="如何转移"><a href="#如何转移" class="headerlink" title="如何转移"></a>如何转移</h2><ul><li><p>首先是$k$,作为自己子树所产生的贡献肯定要加上</p></li><li><p>$dp[u]$为以$u$为根节点时的深度总值,在计算时,要减去$v$的子树所产生的贡献,不然就重复计算了,同时</p></li></ul><p><strong>在以 $u$为根时,v节点及其子树内的所有节点的深度都增加了$1$</strong>,需要减去</p><p><strong>(图中红色的节点)</strong></p><p>合起来就是$dp[u]-(size[v]+k)$</p><ul><li>除v子树外的其他节点也一样</li></ul><p><strong>在以$v$为根时，除$v$节点及其子树外的其他节点的深度都增加了$1$</strong></p><p><strong>(图中蓝色的节点)</strong></p><p>合起来就是$(size[1]-size[v])$</p><p>得到转移方程</p><ul><li>$dp[v] &#x3D; k+(dp[u]-(k+size[v]))+(size[1]-size[v])$</li></ul><p>化简一下</p><ul><li>$dp[v] &#x3D; dp[u]-2size[v]+size[1]$</li></ul><p>核心代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">size[x] = <span class="number">1</span>;</span><br><span class="line">    vis[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;son[x].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line"><span class="type">int</span> v = son[x][i];</span><br><span class="line"><span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">dep[v] = dep[x] +<span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs1</span>(v);</span><br><span class="line">size[x]+=size[v];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    vis[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;son[x].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line"><span class="type">int</span> v = son[x][i];</span><br><span class="line"><span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">dp[v] = dp[x] +size[<span class="number">1</span>] - <span class="number">2</span>*size[v];</span><br><span class="line"><span class="built_in">dfs2</span>(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="P2986-USACO10MAR-Great-Cow-Gathering-G"><a href="#P2986-USACO10MAR-Great-Cow-Gathering-G" class="headerlink" title="P2986 [USACO10MAR]Great Cow Gathering G"></a>P2986 [USACO10MAR]Great Cow Gathering G</h2><p>前面那道题目的带权值版</p><p>一模一样的思路,只需要把状态转移方程转换一下即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].next)&#123;</span><br><span class="line">    <span class="type">int</span> v =edge[i].v;</span><br><span class="line">    <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(v,u);</span><br><span class="line">    size[u] += size[v];</span><br><span class="line">    sum[u]+=(sum[v]+edge[i].w*size[v]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].next)&#123;</span><br><span class="line">       <span class="type">int</span> v =edge[i].v;</span><br><span class="line">   <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">f[v] = <span class="number">1LL</span>*f[u] + AN*edge[i].w - <span class="number">2</span>*size[v]*edge[i].w;</span><br><span class="line">ans = <span class="built_in">min</span>(ans,f[v]);</span><br><span class="line"><span class="built_in">dp</span>(v,u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="P3047-Nearby-Cows-G"><a href="#P3047-Nearby-Cows-G" class="headerlink" title="P3047 [Nearby Cows G]"></a>P3047 [Nearby Cows G]</h2><h3 id="1-状态表示"><a href="#1-状态表示" class="headerlink" title="1.$状态表示$"></a>1.$状态表示$</h3><p>设$size[i][j]$为第i个节点向下$j$层所包含的点权和</p><p>$f[i][j]$为第$i$个点距离它不超过 $j$的所有节点权值和</p><h3 id="2-状态转移"><a href="#2-状态转移" class="headerlink" title="2.状态转移"></a>2.状态转移</h3><p>对于$size[i][j]:$</p><p>$size[u][j] &#x3D;\sum\ size[v][j-1]$ 自己向下$j$层即为儿子向下$j-1$</p><p>对于$f[i][j]:$</p><p>儿子对它的贡献:</p><p>$size[v][j]$</p><p>自己向下$j$层,儿子节点肯定也要向下$j$层</p><p>父亲对它的贡献:</p><p>$f[u][j-1]-size[v][j-2]$</p><p>父亲节点扩展$j-1$层的值减去和儿子节点的值所重复包含的$j-2$层值</p><p>转移方程:</p><p>$f[v][j] &#x3D; f[u][j-1]+size[v][j]-size[v][j-2]$</p><p>核心代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v =edge[i].v;</span><br><span class="line"><span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">dep[v]=dep[u]+<span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs</span>(v,u);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">size[u][i]+=size[v][i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v=edge[i].v;</span><br><span class="line"><span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i<span class="number">-2</span>&gt;=<span class="number">0</span>)</span><br><span class="line">f[v][i] = size[v][i]+f[u][i<span class="number">-1</span>] - size[v][i<span class="number">-2</span>];</span><br><span class="line"><span class="keyword">else</span> f[v][i] = size[v][i]+f[u][i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">dp</span>(v,u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="CF708C-Centroids"><a href="#CF708C-Centroids" class="headerlink" title="CF708C Centroids"></a>CF708C Centroids</h2><p>一道做起来比较麻烦的换根$DP$</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>首先对于一个节点来说,大小大于$n&#x2F;2$的节点肯定只有一个，这个显而易见</p><p>再来看如何改造</p><p>如果说该节点本身的重儿子就小于$n&#x2F;2$,那肯定可以成为树的重心</p><p>反之,肯定要在重儿子里找出一个重量最大的且小于等于$n&#x2F;2$的子树,并将其断开,连接到根节点上(相当于删去这颗子树)</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/c18i92y5.png"></p><p>如果重儿子的大小减去被删去儿子的大小小于等于$n&#x2F;2$,则说明可以改造</p><p>反之,无法改造</p><h3 id="如何转移-1"><a href="#如何转移-1" class="headerlink" title="如何转移"></a>如何转移</h3><p>分两种情况来讨论</p><p>$1$.该节点不是其父亲节点重儿子</p><p>其父节点的重儿子不会被改变,只需要判断该节点的重儿子是否改成其父节点即可</p><p>$2$.该节点是其父亲节点的重儿子</p><p>其父亲节点的重儿子会变为其”次大”儿子,其儿子节点的重儿子不会改变</p><p>核心代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">vis[u] = <span class="number">1</span>;</span><br><span class="line">size[u] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;son[u].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line"><span class="type">int</span> v = son[u][i];</span><br><span class="line"><span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line"><span class="built_in">dfs</span>(v);</span><br><span class="line">size[u]+=size[v];</span><br><span class="line"><span class="keyword">if</span>(size[v] &gt; size[maxson[u]])</span><br><span class="line">maxson[u] = v;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">if</span>(maxson[u]!=<span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(size[maxson[u]]&lt;=n/<span class="number">2</span>) dp[u] = size[maxson[u]]; </span><br><span class="line"><span class="keyword">else</span> dp[u] = dp[maxson[u]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exchange</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">        size[u] = size[u] - size[v];</span><br><span class="line">size[v] = size[v] + size[u];</span><br><span class="line"><span class="keyword">if</span>(v==maxson[u])&#123;</span><br><span class="line">maxson[u] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;son[u].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line"><span class="type">int</span> V = son[u][i];</span><br><span class="line"><span class="keyword">if</span>(V!=v&amp;&amp;size[V] &gt; size[maxson[u]])&#123;</span><br><span class="line">maxson[u] = V;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(maxson[u]!=<span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(size[maxson[u]]&lt;=n/<span class="number">2</span>) dp[u] = size[maxson[u]];</span><br><span class="line"><span class="keyword">else</span> dp[u] = dp[maxson[u]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(size[maxson[v]]&lt;size[u])&#123;</span><br><span class="line">maxson[v] = u;</span><br><span class="line"><span class="keyword">if</span>(maxson[v]!=<span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(size[maxson[v]]&lt;=n/<span class="number">2</span>) dp[v] = size[maxson[v]];</span><br><span class="line"><span class="keyword">else</span> dp[v] = dp[maxson[v]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">vis[u]  = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line"> <span class="keyword">if</span>(size[maxson[u]]&lt;=n/<span class="number">2</span>||size[maxson[u]] - dp[maxson[u]]&lt;=n/<span class="number">2</span>) ans[u]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;son[u].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line"><span class="type">int</span> v = son[u][i];</span><br><span class="line"><span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line"><span class="built_in">exchange</span>(u,v);</span><br><span class="line"><span class="built_in">dfs2</span>(v);</span><br><span class="line"><span class="built_in">exchange</span>(v,u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>end.</p><p>基环树部分还是先缓缓吧,暂时还未完全掌握</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 动态规划-树形dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SP2713 GSS4</title>
      <link href="/2020/08/01/sp2713/"/>
      <url>/2020/08/01/sp2713/</url>
      
        <content type="html"><![CDATA[<h1 id="SP2713-GSS4-题解"><a href="#SP2713-GSS4-题解" class="headerlink" title="SP2713 GSS4  题解"></a>SP2713 GSS4  题解</h1><h2 id="间隙"><a href="#间隙" class="headerlink" title="间隙"></a><a href="https://www.luogu.com.cn/problem/SP2713">间隙</a></h2><h2 id="双倍经验"><a href="#双倍经验" class="headerlink" title="双倍经验"></a><a href="https://www.luogu.com.cn/problem/P4145">双倍经验</a></h2><h2 id="前置知识-线段树"><a href="#前置知识-线段树" class="headerlink" title="前置知识:线段树"></a>前置知识:线段树</h2><p>如果您还不会线段树的话,推荐去看一下<a href="https://www.cnblogs.com/jason2003/p/9676729.html"><strong>这篇文章</strong></a>,我一开始也是在那里学的</p><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给一堆数,有以下两个操作:</p><ul><li><p>给出一个区间$[L,R]$,把该区间内的每个数都开平方</p></li><li><p>给出一个区间$[L,R]$,查询这个区间的每个数的和</p></li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先看一下这个数据范围,$1e18$,直接暴力的话肯定会T飞</p><p>求和操作很简单,相信学过线段树的人应该都会</p><p>难点在于这个开方操作,我们没法像线段树模板那样打个懒标记来进行下传操作</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/72ur96tc.png"></p><p>通过观察$\sqrt x$函数图像缓慢的增长率或者其他性质不难发现,很多开方操作是不必要的,考虑减枝优化:</p><ul><li>不难发现,<strong>当一个区间内的所有数都是$1$时,再对该区间进行开方操作对该区间内的总值造成不了任何改变</strong>($\sqrt{1} &#x3D; 1$)</li></ul><p>因此代码实现方面只要在区间内总值均为1的情况下加一个小剪枝即可</p><hr><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>思路理解了代码实现难度就不高了,但还是有几个坑点…具体的注释里有写</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson (node&lt;&lt;1)<span class="comment">//左儿子</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson (node&lt;&lt;1|1)<span class="comment">//右儿子</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long <span class="comment">//记得开long long</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100005</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st</span>&#123;</span><br><span class="line"><span class="type">int</span> l,r;<span class="comment">//左右端点</span></span><br><span class="line">ll sum;</span><br><span class="line">&#125;tree[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">ll a[MAXN];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;</span><br><span class="line">tree[node].sum = tree[lson].sum + tree[rson].sum;<span class="comment">//合并操作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;<span class="comment">//建树</span></span><br><span class="line">tree[node].l = l;</span><br><span class="line">tree[node].r = r;</span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">tree[node].sum = a[l];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">build</span>(lson,l,mid);</span><br><span class="line"><span class="built_in">build</span>(rson,mid+<span class="number">1</span>,r);</span><br><span class="line"><span class="built_in">pushup</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> L = tree[node].l,R = tree[node].r;</span><br><span class="line"><span class="keyword">if</span>(tree[node].sum==R-L+<span class="number">1</span>) <span class="keyword">return</span>;<span class="comment">//如果总和为区间长度,也就是所有值均为1时,直接剪枝掉</span></span><br><span class="line"><span class="keyword">if</span>(L==R)&#123;</span><br><span class="line">tree[node].sum = <span class="built_in">sqrt</span>(tree[node].sum);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid = (L+R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid)&#123;</span><br><span class="line"><span class="built_in">change</span>(lson,l,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(r&gt;mid)&#123;</span><br><span class="line"><span class="built_in">change</span>(rson,l,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pushup</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;<span class="comment">//查询</span></span><br><span class="line"><span class="type">int</span> L = tree[node].l,R = tree[node].r;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=L&amp;&amp;r&gt;=R)&#123;<span class="comment">//包含在查询区间内,直接返回sum值</span></span><br><span class="line"><span class="keyword">return</span> tree[node].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid = (L+R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid)&#123;</span><br><span class="line">ans+=<span class="built_in">query</span>(lson,l,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(r&gt;mid)&#123;</span><br><span class="line">ans+=<span class="built_in">query</span>(rson,l,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);<span class="comment">//不加貌似会TLE?</span></span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> Case=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Case #%d:\n&quot;</span>,++Case);<span class="comment">//注意,样例里那个case是要输出的,一开始被这里卡了好久...</span></span><br><span class="line"><span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));<span class="comment">//记得要先memset</span></span><br><span class="line"><span class="built_in">memset</span>(tree,<span class="number">0</span>,<span class="built_in">sizeof</span>(tree));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">cin&gt;&gt;m;</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line"><span class="type">int</span> mode,left,right;</span><br><span class="line">cin&gt;&gt;mode&gt;&gt;left&gt;&gt;right;</span><br><span class="line"><span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line"><span class="built_in">swap</span>(left,right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(mode==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">change</span>(<span class="number">1</span>,left,right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">query</span>(<span class="number">1</span>,left,right));</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);<span class="comment">//记得换行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF1187E Tree Painting</title>
      <link href="/2020/07/26/cf1187e/"/>
      <url>/2020/07/26/cf1187e/</url>
      
        <content type="html"><![CDATA[<h1 id="CF1187E-Tree-Painting-题解"><a href="#CF1187E-Tree-Painting-题解" class="headerlink" title="CF1187E Tree Painting 题解"></a>CF1187E Tree Painting 题解</h1><h2 id="原题面"><a href="#原题面" class="headerlink" title="原题面"></a><a href="https://www.luogu.com.cn/problem/CF1187E">原题面</a></h2><h2 id="前置知识-换根-DP"><a href="#前置知识-换根-DP" class="headerlink" title="前置知识: 换根$DP$"></a>前置知识: 换根$DP$</h2><p>换根$DP$模板题</p><p>如果您还不会换根$DP$的话,可以先去看看UM巨佬的日报:</p><p><a href="https://sflsrick.blog.luogu.org/note-how-to-change-root">#278[UltiMadow] [学习笔记]换根dp</a></p><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给定一棵n个点的树 初始全是白点</p><p>要求你做n步操作，每一次选定一个与一个黑点相隔一条边的白点，将它染成黑点，然后获得该白点被染色前所在的白色联通块大小的权值。</p><p>求可获得的最大权值</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>几乎是一道裸的模板题了…</p><p>和P3478几乎一摸一样,只是需要一个微小的结论</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/h4z3mf0i.png"></p><h5 id="PS-图中节点的编号有一点微小的错误-不过并不影响阅读"><a href="#PS-图中节点的编号有一点微小的错误-不过并不影响阅读" class="headerlink" title="PS:图中节点的编号有一点微小的错误,不过并不影响阅读"></a>PS:图中节点的编号有一点微小的错误,不过并不影响阅读</h5><p>假如说我们选了图中的1号节点作为第一个涂色的点（图中蓝色的点)</p><p>那下一个涂色的节点肯定就能选择它的几个儿子了(图中深红色的点)</p><p>同时,<strong>由于父亲节点已经被涂色了,其子节点不可能再和上面的”祖先”辈节点有联通了</strong><br><strong>能对其产生贡献的只有自己的子树</strong></p><p>因此当一个父亲节点被涂色后,其所有子树都是<strong>相对”独立”的</strong>，涂色顺序的变化对总贡献值无任何影响</p><p>故当<strong>第一个节点被涂色后,剩下节点的涂色顺序均无法对总贡献值产生影响</strong></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>单纯的暴力枚举每个根的位置的话照这个数据范围肯定会T飞</p><p>考虑换根DP</p><p>应该很容易状态转移方程推出:</p><ul><li>$dp[v] &#x3D; dp[u]-2size[v]+size[1]$</li></ul><p>具体这个方程怎么来的,我之前写的P3478的<a href="https://www.luogu.com.cn/blog/xcxc82/p3478-poi2008sta-station-ti-xie">题解</a>跟前面UM巨佬的日报里也有讲</p><p>套上换根$DP$的板子即可</p><p>贴上丑陋的代码:（其实只要把P3478的代码改一行就可以了）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">200010</span>;</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; son[MAXN];</span><br><span class="line"><span class="type">int</span> vis[MAXN],n;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> size[MAXN];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> f[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">size[u] = <span class="number">1</span>;</span><br><span class="line">vis[u] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;son[u].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line"><span class="type">int</span> v = son[u][i];</span><br><span class="line"><span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line"><span class="built_in">dfs</span>(v);</span><br><span class="line">size[u]+=size[v];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">vis[u] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;son[u].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line"><span class="type">int</span> v = son[u][i];</span><br><span class="line"><span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">f[v] = f[u] + size[<span class="number">1</span>] - <span class="number">2</span>*size[v];</span><br><span class="line"><span class="built_in">dp</span>(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="type">int</span> u,v;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">son[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">son[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">f[<span class="number">1</span>]+=size[i];</span><br><span class="line">&#125;</span><br><span class="line">   <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">   <span class="built_in">dp</span>(<span class="number">1</span>);</span><br><span class="line">   <span class="type">long</span> <span class="type">long</span> ans = <span class="number">-0x3f</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    ans = <span class="built_in">max</span>(ans , f[i]);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划-换根dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P2458 [SDOI2006]保安站岗</title>
      <link href="/2020/07/20/p2458/"/>
      <url>/2020/07/20/p2458/</url>
      
        <content type="html"><![CDATA[<h1 id="P2458-SDOI2006-保安站岗-题解"><a href="#P2458-SDOI2006-保安站岗-题解" class="headerlink" title="P2458 [SDOI2006]保安站岗 题解"></a><strong>P2458 [SDOI2006]保安站岗 题解</strong></h1><h2 id="间隙-原题面"><a href="#间隙-原题面" class="headerlink" title="间隙(原题面)"></a><a href="https://www.luogu.com.cn/problem/P2458">间隙(原题面)</a></h2><ul><li>前排声明:蒟蒻刚学OI没多久,讲的可能比较啰嗦,望见谅</li></ul><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给一颗树,每个点都可以花费一定的价格来放置一名”保安”</p><p>每个保安都可以看管他本身所在的点和所有与他所站的点相邻的点</p><p>求:看管所有点所需要的最小花费</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>树形dp。</p><p>先来说一种错误的做法,也是我一开始想到的做法</p><p>每个点都有”放置”和”不放置”两种选择</p><p><strong>设$dp[i][0]$为第$i$个点”不放置”保安所需要的最小花费</strong></p><p><strong>$dp[i][1]$为第$i$个点“放置”保安所需要的最小花费</strong></p><p>如果第$i$个点”放置”了保安</p><p>那它的下一个节点则可以选择”放或不放”两种决策</p><p>反之,下一个节点必须都”放置”一名保安</p><p><del>很明显是错的</del></p><p>放张图应该就明白了<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/c3ommepj.png"></p><p>(下一个节点不一定要由父亲或自己来看管,也可以由自己的”儿子”来看管)</p><p>也就是说,每个点的看管对象都有:</p><ul><li><strong>自己</strong></li><li><strong>父亲</strong></li><li><strong>儿子</strong></li></ul><p><strong>三种可能</strong></p><h2 id="如何转移"><a href="#如何转移" class="headerlink" title="如何转移"></a>如何转移</h2><p>设$dp[i][0]$为该点<strong>由自己看管</strong>所产生的最有解</p><p>$dp[i][1]$为该点<strong>由父亲看管</strong>所产生的最优解</p><p>$dp[i][2]$为该点<strong>由儿子看管</strong>所产生的最优解</p><ul><li><strong>1.由“自己”看管</strong></li></ul><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ywr3v3nc.png"></p><p>自己的位置上已经”放置了”一个点</p><p>那么它的所有儿子就都会被自己所”看管”住</p><p>显然儿子可以选择任意一种决策</p><ul><li>得到转移方程:$dp[i][0]&#x3D;\sum min(dp[son][0],dp[son][1],dp[son][2])+w[i]$</li></ul><p>($w[i]$为父亲节点”放置”守卫所需要的价值)</p><ul><li><strong>2.由“父亲”看管</strong></li></ul><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/75jddbxl.png"></p><p>自己由父亲看管,说明自己所在的点上<strong>未”放置”门卫</strong>,那儿子肯定<strong>只能由自己的儿子看管或由自己看管</strong></p><ul><li><p>得到方程:$dp[i][1]&#x3D;\sum min(dp[son][0],dp[son][2])$</p></li><li><p>3.<strong>由“儿子”看管</strong></p></li></ul><p>（图中红蓝分别为两种可能情况）</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/b7rw1758.png"></p><p>既然是由自己的儿子看管</p><p>儿子的决策也有两种可能</p><p>1.由儿子的”儿子”看管</p><p>2.由自己看管</p><ul><li>得到方程:$dp[i][2]&#x3D;\sum min(dp[son][2],dp[son][0])$</li></ul><p>有一种极端情况,如果全部都选了$dp[son][2]$</p><p>“自己”就会产生无人看管的情况</p><p>因此要在这里加一个小特判,具体代码里有解释</p><p>这里做了个简陋的gif,不懂的可以结合代码看一下</p><p><img src="https://img-blog.csdnimg.cn/20200720102214607.gif"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1510</span>;</span><br><span class="line"><span class="type">int</span> n,dp[MAXN][<span class="number">4</span>],w[MAXN];</span><br><span class="line"><span class="type">int</span> is_head[MAXN];</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; son[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="type">bool</span> is_cs = <span class="literal">false</span>;<span class="comment">//用来判断有无极端情况</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> minn = <span class="number">0x3ffffff</span>;<span class="comment">//用来求极端情况的最小值 </span></span><br><span class="line">dp[x][<span class="number">0</span>] = w[x];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;son[x].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line"><span class="type">int</span> v = son[x][i];</span><br><span class="line"><span class="built_in">dfs</span>(v);</span><br><span class="line">dp[x][<span class="number">0</span>]+=<span class="built_in">min</span>(<span class="built_in">min</span>(dp[v][<span class="number">0</span>],dp[v][<span class="number">1</span>]),dp[v][<span class="number">2</span>]);<span class="comment">//由自己看守 </span></span><br><span class="line">dp[x][<span class="number">1</span>]+=<span class="built_in">min</span>(dp[v][<span class="number">2</span>],dp[v][<span class="number">0</span>]);<span class="comment">//由父亲看守 </span></span><br><span class="line"><span class="comment">//由儿子看守 ↓ </span></span><br><span class="line"><span class="keyword">if</span>(dp[v][<span class="number">0</span>]&lt;dp[v][<span class="number">2</span>])&#123; </span><br><span class="line">dp[x][<span class="number">2</span>]+=dp[v][<span class="number">0</span>];<span class="comment">//如果儿子放置守卫花费的钱更少,那就直接在儿子的点上放置一个守卫 </span></span><br><span class="line">is_cs=<span class="literal">true</span>;<span class="comment">//既然儿子的位置上已经放置守卫了,无极端情况存在 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;<span class="comment">//否则在儿子的儿子上放置守卫 </span></span><br><span class="line">minn = <span class="built_in">min</span>( minn , dp[v][<span class="number">0</span>]-dp[v][<span class="number">2</span>]);<span class="comment">//计算最小所需值 </span></span><br><span class="line">dp[x][<span class="number">2</span>]+=dp[v][<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!is_cs) dp[x][<span class="number">2</span>]+=minn;<span class="comment">//如果存在极端情况,则加上差值,相当于是消掉dp[-][2],加上dp[-][0] </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="type">int</span> u,m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;m);</span><br><span class="line">w[u]=m;</span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line"><span class="type">int</span> v;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;v);</span><br><span class="line">is_head[v]++;</span><br><span class="line">son[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!is_head[i])&#123;</span><br><span class="line"><span class="built_in">dfs</span>(i);</span><br><span class="line">cout&lt;&lt;<span class="built_in">min</span>(dp[i][<span class="number">0</span>],dp[i][<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划-树形dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF607B Zuma</title>
      <link href="/2020/07/09/cf607b/"/>
      <url>/2020/07/09/cf607b/</url>
      
        <content type="html"><![CDATA[<h1 id="CF607B-Zuma-题解"><a href="#CF607B-Zuma-题解" class="headerlink" title="CF607B Zuma 题解"></a>CF607B Zuma 题解</h1><h2 id="间隙-原题面"><a href="#间隙-原题面" class="headerlink" title="间隙(原题面)"></a><a href="https://www.luogu.com.cn/problem/CF607B">间隙(原题面)</a></h2><ul><li>前排声明:蒟蒻刚学oi没多久,而且是自学的,写的可能会比较累赘,望见谅。</li></ul><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><ul><li>基础区间dp</li></ul><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给一个长度为n的串,每次都可以挑选一个回文的连续字串进行消除,删除后，剩余的串将连接在一起，形成一个新的串,求把串全部删除完需要的最小次数</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/k3ezz757.png"></p><p>可以看出每一个区间的的求解都可以分为更小的两个区间的求解</p><p>联想到区间dp</p><p>设$dp[l][r]$为左端点为l,右端点为r时的最优解</p><p>不难推出<del>比较套路的</del>状态转移方程</p><ul><li>$dp[l][r]&#x3D;min(dp[l][r],dp[l][k]+dp[k+1][r]).(l&lt;&#x3D;k&lt;r)$</li></ul><p>同时,这里还有一个区间的回文判断</p><p>假设我们把总区间划分为两个区间</p><p>$[1,4,5,3,4,1,3,2]$和$[3,2]$</p><p>其中$[1,4,5,3,4,1,3,2]$包含一个回文部分</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/teqq2yqh.png"></p><p>此时我们只要直接将回文部分删去即可</p><p>即$dp[l][r]&#x3D;dp[l+1][r-1]$</p><p>这其实是一个类似于预处理的东西(个人看法,可能有误)</p><p>如果一个区间包含回文部分</p><p>则先把$dp[l][r]$给预处理成它不进行划分可以产生的最小值</p><p>再去和划分成两个区间所产生的最小值进行比较</p><ul><li>即$if(a[l]&#x3D;&#x3D;a[r])$<br>$dp[l[[r]&#x3D;dp[l+1][r-1]$</li></ul><p>贴上丑陋的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">510</span>;</span><br><span class="line"><span class="type">int</span> n,a[MAXN],dp[MAXN][MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="comment">//预处理长度为1的区间</span></span><br><span class="line">dp[i][i]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">1</span>;len&lt;n;len++)&#123;<span class="comment">//枚举长度</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>;l&lt;=n&amp;&amp;l+len&lt;=n;l++)&#123;<span class="comment">//枚举左右断点</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> r=l+len;</span><br><span class="line">dp[l][r]=inf;</span><br><span class="line"><span class="keyword">if</span>(a[l]==a[r])&#123;<span class="comment">//如果包含回文部分</span></span><br><span class="line"><span class="keyword">if</span>(r==l+<span class="number">1</span>)&#123;<span class="comment">//注意,这里是区间长度为2的特判</span></span><br><span class="line">dp[l][r]=dp[l+<span class="number">1</span>][r<span class="number">-1</span>]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> dp[l][r]=dp[l+<span class="number">1</span>][r<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=l;k&lt;r;k++)&#123;<span class="comment">//枚举断点</span></span><br><span class="line">dp[l][r]=<span class="built_in">min</span>(dp[l][r],dp[l][k]+dp[k+<span class="number">1</span>][r]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;dp[<span class="number">1</span>][n];</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>如有错误欢迎大佬们指出QwQ</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划-区间dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P3800 power收集</title>
      <link href="/2020/07/07/p3800/"/>
      <url>/2020/07/07/p3800/</url>
      
        <content type="html"><![CDATA[<h1 id="P3800-Power收集-题解"><a href="#P3800-Power收集-题解" class="headerlink" title="P3800 Power收集 题解"></a>P3800 Power收集 题解</h1><h2 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a><a href="https://www.luogu.com.cn/problem/P3800">传送门</a></h2><p>前排声明:蒟蒻刚学oi没多久,写的可能比较粗糙,望谅解</p><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给一个$N×M$大小的矩阵</p><p>其中有k个点包含一个带有价值的P点</p><p>每一行中的一个格子i都可以从上一行中的第$[i-t,i+t]$个格子中转移过来</p><p>求可以获得的最大价值</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>大致思路和<a href="https://www.luogu.com.cn/problem/P1725">P1725 琪露诺</a>很像,只是换了一种形式而已</p><p>既然每一个格子$i$都可以从上一行中的第$ [i-t,i+t] $个格子中转移过来</p><p>我们<strong>设$a[i][j]$为第$i$行第$j$个点的价值大小</strong></p><p>容易得到状态转移方程:</p><ul><li><p>$dp[i][j]&#x3D;max(dp[i-1][k])+a[i][j] (j-T&lt;&#x3D;k&lt;&#x3D;j+T)$</p></li><li><p>因此,对于每一个$dp[i][j]$来说</p></li></ul><p>他的值均是由上一行中$[j-t,j+t]$区间中的最大值转移过来的</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/f400j4mf.png"></p><h6 id="懒得找城管的图了-只好拿之前cirno的图改了一下"><a href="#懒得找城管的图了-只好拿之前cirno的图改了一下" class="headerlink" title="(懒得找城管的图了,只好拿之前cirno的图改了一下)"></a>(<del>懒得找城管的图了,只好拿之前cirno的图改了一下</del>)</h6><p>可以看出这是一个滑动区间求最值的问题</p><p>可以考虑用单调队列来优化</p><p>在进行第$i$行第$j$列的转移前</p><p>利用滑动窗口将第$i-1$行中$[j-t,j+t]$的最大值来求出来</p><p>这里<del>闲着无聊</del>做了个$gif$</p><p><img src="https://img-blog.csdnimg.cn/20200707134646322.gif"></p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>开一个数组 $q$ 模拟队列,用来滑动求最值</p><p>首先初始化第一行的$dp[i][j]$</p><p>第2~n行则利用$q$来求上一行的最大值进行转移</p><ul><li><strong>swp函数</strong></li></ul><p>实现队列初始化功能</p><p>将前 $t$ 个数加入队列</p><ul><li><strong>swi函数</strong></li></ul><p>当插入新元素时</p><p>先判断队列是否在$[1,m]$的区间内(不判会RE)</p><p>如果在区间内:</p><p>$1$.调整队列单调性</p><p>$2$.入队</p><p>反之,超出范围,不入队</p><p>$3$.去掉”超时”元素</p><p>贴上丑陋的代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 4010</span></span><br><span class="line"><span class="type">int</span> tail=<span class="number">0</span>,head=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> n,m,k,t,ans; </span><br><span class="line"><span class="type">int</span> q[MAXN],a[MAXN][MAXN],dp[MAXN][MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">queue_empty</span><span class="params">()</span></span>&#123;<span class="comment">//清空窗口 </span></span><br><span class="line">tail=<span class="number">0</span>,head=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swi</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> last)</span></span>&#123;<span class="comment">//插入元素</span></span><br><span class="line">   <span class="keyword">if</span>(x+t&lt;=m)&#123;<span class="comment">//判断是否超过边界,不加会RE </span></span><br><span class="line">   <span class="keyword">while</span>(dp[last][x+t]&gt;dp[last][q[tail]]&amp;&amp;tail&gt;=head)&#123;<span class="comment">//单调队列 </span></span><br><span class="line">tail--;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">q[++tail]=x+t;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(q[head]+t&lt;x) head++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swp</span><span class="params">(<span class="type">int</span> last)</span></span>&#123;<span class="comment">//初始化窗口 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(dp[last][i]&gt;dp[last][q[tail]]&amp;&amp;tail&gt;=head)&#123;</span><br><span class="line">tail--;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">q[++tail] = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k,&amp;t);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line"><span class="type">int</span> x, y, z;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">a[x][y] = z;</span><br><span class="line">&#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="comment">//第一行初始化</span></span><br><span class="line">   dp[<span class="number">1</span>][i]=a[<span class="number">1</span>][i];</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">   <span class="built_in">swp</span>(i<span class="number">-1</span>);</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">swi</span>(j,i<span class="number">-1</span>);</span><br><span class="line">   </span><br><span class="line">  dp[i][j]=dp[i<span class="number">-1</span>][q[head]]+a[i][j]; </span><br><span class="line">  </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">queue_empty</span>();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">ans=<span class="built_in">max</span>(dp[n][i],ans);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如有错误欢迎dalao们指出qwq</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划-区间dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P5239 回忆京都</title>
      <link href="/2020/07/05/p5239/"/>
      <url>/2020/07/05/p5239/</url>
      
        <content type="html"><![CDATA[<h1 id="P5239-回忆京都题解"><a href="#P5239-回忆京都题解" class="headerlink" title="P5239 回忆京都题解"></a>P5239 回忆京都题解</h1><h2 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a><a href="https://www.luogu.com.cn/problem/P5239">传送门</a></h2><p>前排声明:题解写的比较累赘…把一些基本的恒等式都讲了一遍…(部分证明借鉴了《具体数学》一书)</p><p>如果您已经掌握了这些基础的话建议还是去看其他dalao们的题解吧qwq…</p><h2 id="1-基本恒等式"><a href="#1-基本恒等式" class="headerlink" title="1.基本恒等式"></a>1.基本恒等式</h2><p>我们把$\dbinom{n}{k}$符号读作”<strong>n选取k</strong>“</p><p>即<strong>从n个元素的集合中选取k个元素</strong>作为子集的方案总数</p><p>对于该集合的第一个元素的可能,有n种选择</p><p>对第二个元素,有n-1种选择,3,4,5…..也同理</p><p>同时,<strong>对于每k个元素组成的子集都恰好有$k!$种不同的排序</strong></p><p>根据乘法原理</p><p>得到公式</p><p>$\dbinom{n}{k}&#x3D;{\dfrac{n*(n-1)…*(n-k+1)}{k!}}$ </p><p>(<strong>基本恒等式</strong>)</p><hr><h2 id="2-对称恒等式"><a href="#2-对称恒等式" class="headerlink" title="2.对称恒等式"></a>2.对称恒等式</h2><p>先来看个图</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/a9xmsi5c.png"></p><p>观察一下不难发现规律</p><p>$\dbinom{n}{k}&#x3D;\dbinom{n}{n-k}$</p><p>(<strong>对称恒等式</strong>)</p><p>至于正确性也显而易见</p><p><strong>从n个物品中选k个物品就相当于指定的n-k种物品不被选取</strong></p><hr><h2 id="3-吸收恒等式"><a href="#3-吸收恒等式" class="headerlink" title="3.吸收恒等式"></a>3.吸收恒等式</h2><p>我们知道,二项式系数的基本恒等式为</p><p>$\dbinom{n}{k}&#x3D;{\dfrac{n*(n-1)…*(n-k+1)}{k!}}$ </p><p>可以将式子转化为</p><p>$\dbinom{n}{k}&#x3D;{\dfrac{n}{k}<em>\dfrac{(n-1)…</em>(n-k+1)}{(k-1)!}}$ </p><p>得到式子$\dbinom{n}{k}&#x3D;\dfrac{n}{k}\dbinom{n-1}{k-1}$</p><p>两边同乘k,得$k\dbinom{n}{k}&#x3D;n\dbinom{n-1}{k-1}$<strong>恒等式1</strong></p><p>根据这个式子,再利用之前的恒等式1</p><p>还可以得到式子</p><p>$(n-k)\dbinom{n}{k}&#x3D;(n-k)\dbinom{n}{n-k}$(根据对称性)</p><p>$&#x3D;n\dbinom{n-1}{n-1-k}$(根据恒等式1)</p><p>$&#x3D;n\dbinom{n-1}{k}$—(根据对称性)<strong>恒等式2</strong> </p><hr><h2 id="4-加法公式"><a href="#4-加法公式" class="headerlink" title="4.加法公式"></a>4.加法公式</h2><p>观察一下前面的那张表,不难发现一个规律:</p><p>$\dbinom{n}{k}&#x3D;\dbinom{n-1}{k-1}+\dbinom{n-1}{k}$</p><p>推导的话也很简单</p><p>根据之前吸收恒等式里的恒等式1和恒等式2</p><p>得出</p><p>$\dbinom{n}{k}&#x3D;(n-k)\dbinom{n}{k}+k\dbinom{n}{k}&#x3D;n\dbinom{n-1}{k}+n\dbinom{n-1}{k-1}$</p><hr><h2 id="5-题目"><a href="#5-题目" class="headerlink" title="5.题目"></a>5.题目</h2><h3 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意:"></a>大致题意:</h3><p>q次询问,每次都给一个m跟n,求</p><p>$\sum\limits_{i&#x3D;1}^n\sum\limits_{j&#x3D;1}^mC^i_j$</p><hr><p>根据前面的加法公式,很容易可以解出这题</p><p>一共有n次询问，如果一次一次的去加的话肯定会超时</p><p>可以考虑使用二维前缀和来优化</p><p>至于二维前缀和怎么用,前面的dalao们已经写的很清楚了,为了<del>让题解看起来不是那么的水</del>,彩笔这里就再粗糙的写一遍吧</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ez5vvkji.png"></p><p>从图中不难看出,对于每一个sum[i][j],都有</p><p>sum[i][j]&#x3D;sum[i][j-1]+sum[i-1][j]+a[i][j]-sum[i-1][j-1]</p><p>因为这里面有一个对$1926081719260817$取模操作</p><p>相减可能会产生负数</p><p>比如说我们取模后$sum[i][j-1]+sum[i-1][j]+a[i][j]&#x3D;1$</p><p>而$sum[i-1][j-1]&#x3D;1926081719260816$</p><p>很明显,相减为负</p><p>至于如何避免其实也很简单,只要再加上一个模数就可以了,相当于是加上之前那个被模掉的部分</p><hr><p>贴上丑陋的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> mo=<span class="number">19260817</span>;</span><br><span class="line"><span class="type">int</span> n,a[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="type">int</span> sum[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">      a[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">1002</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">1002</span>;j++)&#123;</span><br><span class="line">a[i][<span class="number">0</span>]=a[i][i]=<span class="number">1</span>;</span><br><span class="line">a[i][j]=(a[i<span class="number">-1</span>][j]+a[i<span class="number">-1</span>][j<span class="number">-1</span>])%mo;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">1002</span>;i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">1002</span>;j++)&#123;</span><br><span class="line">sum[i][j]=(sum[i<span class="number">-1</span>][j]+sum[i][j<span class="number">-1</span>]+a[i][j]-sum[i<span class="number">-1</span>][j<span class="number">-1</span>]+mo)%mo;</span><br><span class="line">&#125;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="type">int</span> l,r;</span><br><span class="line">cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">cout&lt;&lt;sum[r][l]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如有错误还请大佬们指出</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组合数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>p4838 P哥破解密码</title>
      <link href="/2020/06/26/p4838/"/>
      <url>/2020/06/26/p4838/</url>
      
        <content type="html"><![CDATA[<h1 id="P4838-P哥破解密码题解"><a href="#P4838-P哥破解密码题解" class="headerlink" title="P4838 P哥破解密码题解"></a>P4838 P哥破解密码题解</h1><ul><li><h2 id="原题面"><a href="#原题面" class="headerlink" title="原题面"></a><a href="https://www.luogu.com.cn/problem/P4838">原题面</a></h2></li></ul><p><strong>思路貌似跟dalao们的有点不一样</strong></p><ul><li><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2></li></ul><hr><p>给一串长度为n的字符串,<strong>当且仅当串只由A和B构成</strong>，且没有连续的3个A时,该串合法,求方案总数</p><hr><p>感觉跟P4910帕秋莉的手环那道题目差不多吧….都是线性递推,貌似dalao们都是用动态规划来做的,<del>蒟蒻不太会,所以只好用比较sb的递推来做qwq</del></p><ul><li><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2>既然每个字符只有A和B两种可能,,如果字符串没有任何限制的话,很容易看出方 案总数为 : $2^n$</li></ul><p>但这里加了一个<strong>不能有没有连续的3个A</strong>出现的限制条件</p><p>不妨先来画个图来看一下,更加直观一点<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/en3d9md2.png"><br>图中为n&#x3D;6的时候的情况</p><p>我们用$f_i$来表示长度为i的字符串的<strong>不合法方案总数</strong>(<strong>注意,是不合法方案总数</strong>)</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/axtxuhus.png"></p><p>先来看第一个字符选A情况</p><p>这里我们可以把每一个B看作是一个”<strong>断点</strong>“</p><p>不难看出,每出现一个断点后</p><p>该断点下面的情况就可以从之前的$f_i$递推过来</p><p>而当出现连续3个A时,相当于是把下面的所有情况都”<strong>截断</strong>“了</p><p>也就是$2^{n-3}$种情况</p><p>第一个字符选”B”也同理</p><p>相当于是在第一个点的时候就把该串给”<strong>截断</strong>“了</p><p>容易推出当N&#x3D;6时,合法方案总数为</p><p>$2^6-(f_{5}+f_{4}+f_{3}+2^3)$</p><p>其他n&gt;3的情况也同理</p><p>得到式子</p><p>方案总数&#x3D;$2^n-(f_{n-1}+f_{n-2}+f_{n-3}+2^{n-3})$</p><p>&#x3D;$7*2^{n-3}-(f_{n-1}+f_{n-2}+f_{n-3})$</p><p>&#x3D;$(2^{n-1}+2^{n-2}+2^{n-3})-(f_{n-1}+f_{n-2}+f_{n-3})$</p><p>设$s_i$为方案总数</p><p>则$s_i&#x3D;s_{i-1}+s_{i-2}+s_{i-3}$</p><p>得到最终式子<br>$\begin{cases}2(n&#x3D;1)\4 (n&#x3D;2)\7 (n&#x3D;3)\s_i&#x3D;s_{i-1}+s_{i-2}+s_{i-3}(n&gt;3)\end{cases}$ </p><p>贴个丑陋的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> mo=<span class="number">19260817</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n,t;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">matrix</span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="type">int</span> a[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line">&#125;ans,a;</span><br><span class="line">matrix <span class="keyword">operator</span> *(<span class="type">const</span> matrix &amp;x,<span class="type">const</span> matrix &amp;y)&#123;</span><br><span class="line">matrix z;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">3</span>;j++)&#123;</span><br><span class="line">z.a[i][j]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">3</span>;k++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">3</span>;j++)&#123;</span><br><span class="line">z.a[i][j]=(z.a[i][j]+(x.a[i][k]*y.a[k][j])%mo)%mo;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="number">2</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">2</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="number">4</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">3</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="number">7</span>&lt;&lt;endl;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">3</span>;j++)&#123;</span><br><span class="line">a.a[i][j]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(i==j) ans.a[i][j]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> ans.a[i][j]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">a.a[<span class="number">1</span>][<span class="number">1</span>]=a.a[<span class="number">1</span>][<span class="number">2</span>]=a.a[<span class="number">1</span>][<span class="number">3</span>]=a.a[<span class="number">2</span>][<span class="number">1</span>]=a.a[<span class="number">3</span>][<span class="number">2</span>]=<span class="number">1</span>; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(n)&#123;</span><br><span class="line"><span class="keyword">if</span>(n&amp;<span class="number">1</span>) ans=ans*a;</span><br><span class="line">n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">a=a*a;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;((ans.a[<span class="number">1</span>][<span class="number">1</span>]+ans.a[<span class="number">2</span>][<span class="number">1</span>])%mo+ans.a[<span class="number">3</span>][<span class="number">1</span>])%mo&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>貌似是蒟蒻的第一次不看题解做出(比较水的)紫题?</del></p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划-线性dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>p1725 琪露诺</title>
      <link href="/2020/06/25/p1725/"/>
      <url>/2020/06/25/p1725/</url>
      
        <content type="html"><![CDATA[<h1 id="P1725-琪露诺"><a href="#P1725-琪露诺" class="headerlink" title="P1725 琪露诺"></a><a href="https://www.luogu.com.cn/problem/P1725"></a>P1725 琪露诺</h1><p><a href="https://www.luogu.com.cn/problem/P1725">原题面</a></p><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给编号为0~N的N+1个数,每个格子都有一个冰冻指数ice[i]</p><p>每一个格子都可以转移到区间[i+l,i+r]上,求ice[i]总和的最大值</p><hr><p>很明显可以看出这是一道dp的题</p><p>我们不妨先把转移方程写出来</p><p>题目中说<strong>每一个格子都可以转移到区间[i+l,i+r]上</strong></p><p>不难推出转移方程:</p><ul><li><h3 id="dp-i-x3D-max-dp-i-r-dp-i-r-1-…dp-i-l-1-dp-i-l-ice-i"><a href="#dp-i-x3D-max-dp-i-r-dp-i-r-1-…dp-i-l-1-dp-i-l-ice-i" class="headerlink" title="$~~~~~~~~~~~~~~~~dp_i&#x3D;max(dp_{i-r},dp_{i-r+1},…dp_{i-l-1},dp_{i-l})+ice[i]$"></a>$~~~~~~~~~~~~~~~~dp_i&#x3D;max(dp_{i-r},dp_{i-r+1},…dp_{i-l-1},dp_{i-l})+ice[i]$</h3></li></ul><p>(放张图 样例是自造的,此图为i&#x3D;4的情况)<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/ai7jcjuq.png"><br>因此,对于每一个$dp_i$来说</p><p>他的值均是由[$dp_{i-l}$~$dp_{i-r}$]区间中的最大值转移过来的(前面方程也说了)</p><p>而且这个区间是不断滑动的</p><p>滑动区间求最值,很容易联想到<strong>单调队列</strong></p><p>照题目里的数据范围普通的dp肯定会超时</p><p>因此我们可以用单调队列来优化它</p><p>做了一个比较粗糙的过程动态图qwq<br><img src="https://img-blog.csdnimg.cn/2020062520104327.gif"><br>补几张gif跳的比较快的图</p><p>$dp_1$</p><ul><li><img src="https://cdn.luogu.com.cn/upload/image_hosting/3h0hzail.png"><br>$dp_2$</li><li><img src="https://cdn.luogu.com.cn/upload/image_hosting/9osayz2u.png"><br>以此类推,均由[$dp_{i-l}$~$dp_{i-r}$]区间中的最大值转移过来</li><li><img src="https://cdn.luogu.com.cn/upload/image_hosting/pq2le485.png"></li></ul><hr><p>写的貌似有点累赘…</p><p>如有错误还请dalao们指出qwq,<del>话说没人会来看这么辣鸡的题解吧</del></p><p>贴个丑陋的代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> ice[<span class="number">300010</span>],dp[<span class="number">300010</span>],q[<span class="number">300010</span>];</span><br><span class="line"><span class="type">int</span> l,n,r,ans=<span class="number">-1</span>&lt;&lt;<span class="number">30</span>;</span><br><span class="line"><span class="type">int</span> head=<span class="number">1</span>,tail=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">findmax</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=n;i++)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(head&lt;=tail&amp;&amp;dp[q[tail]]&lt;dp[i-l]) tail--;<span class="comment">//单调队列 </span></span><br><span class="line"><span class="keyword">while</span>(head&lt;=tail&amp;&amp;q[head]&lt;i-r) head++;<span class="comment">//滑动区间 </span></span><br><span class="line">q[++tail]=i-l;</span><br><span class="line">dp[i]=dp[q[head]]+ice[i];<span class="comment">//转移 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i&gt;=n-r+<span class="number">1</span>) ans=<span class="built_in">max</span>(ans,dp[i]);<span class="comment">//在开始移动的时候求最大值 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;l&gt;&gt;r;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;ice[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0xcf</span>,<span class="built_in">sizeof</span>(dp));dp[<span class="number">0</span>]=<span class="number">0</span>;<span class="comment">//注意,ice的值可能为负,所以要把dp跟ans的值赋为无穷小,一开始在这里卡了好久... </span></span><br><span class="line"><span class="built_in">findmax</span>();</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划-单调队列优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P6524 「Wdoi-1」托卡马克</title>
      <link href="/2020/06/20/p6524/"/>
      <url>/2020/06/20/p6524/</url>
      
        <content type="html"><![CDATA[<h1 id="P6524-「Wdoi-1」托卡马克-题解"><a href="#P6524-「Wdoi-1」托卡马克-题解" class="headerlink" title="P6524 「Wdoi-1」托卡马克 题解"></a>P6524 「Wdoi-1」托卡马克 题解</h1><p>大致思路和上面那位dalao的差不多,有个错误也是看了上面那位dalao的题解才发现的qwq</p><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a><strong>大致题意</strong></h2><p>在<strong>n</strong>个点中选<strong>m</strong>个点进行<strong>两两相连</strong>,两个点相连所产生的费用为两点距离之差的绝对值<br>求<strong>严格第k大费用值(即不存在并列情况的第 k 大方案）</strong></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先来看一下这个数据范围,<strong>k&lt;&#x3D;2</strong></p><p>也就是说只有<strong>第一大</strong>和<strong>第二大</strong>两种可能</p><p>先来看一下k&#x3D;1的时候的情况:</p><h1 id="k-x3D-1"><a href="#k-x3D-1" class="headerlink" title="k&#x3D;1"></a>k&#x3D;1</h1><p>我们假设a1~a8是递增的,且n&#x3D;8,m&#x3D;6,k&#x3D;1</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/8kfaz7oq.png"></p><p>先假设我们选取了$a_1$,$a_2$,$a_{3}$,$a_{6}$,$a_{7}$,$a_{8}$这几个数</p><p>总费用值&#x3D;$\sum\limits_{i&#x3D;1,j&#x3D;i+1}^{n-1,n}a_j-a_i$ </p><p>通过观察可以发现有些值是可以进行拼接的</p><p>如$a_1$<del>$a_8$&#x3D;$a_1$</del>$a_3$+$a_3$<del>$a_8$&#x3D;$a_1$</del>$a_6$+$a_6$~$a_8$&#x3D;…</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/d2lcgwxn.png"></p><p>我们可以把这个拼接看成是在这一段的<strong>哪个位置断开</strong></p><p>这样一轮下来就相当于把开头为1和结尾为8的所有段数全部加完了 这样我们就不用再考虑1和8了<br>可以将图简化成下面这个样子</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/7xhv1f3q.png"></p><p>(如图)</p><p>同样<br>$a_2$~$a_7$这段也一样,以此类推,直到缩小到不能再缩的时候停下就可以了</p><p>(大致过程)<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/chk50fh5.png"></p><p>根据断点数量的规律</p><p>不难推出费用值&#x3D;$\sum\limits_{i&#x3D;1}^\frac{m}{2}(m-2(i-1)-1)*(a_{n-i+1}*a_i)$</p><p>把$(m-2(i-1)-1)<em>(a_{n-i+1}<em>a_i)$看成一个**组</em></em></p><p>根据贪心原则</p><p>当k&#x3D;1时</p><p>每次只需要分别取原数列排序后<strong>最大和最小的两个值形成的组</strong>,即可</p><p>如图(n&#x3D;8,m&#x3D;6)</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ycwc66og.png"></p><p>这样k&#x3D;1的情况就做完了</p><p>下面来看k&#x3D;2的情况</p><h1 id="k-x3D-2"><a href="#k-x3D-2" class="headerlink" title="k&#x3D;2"></a>k&#x3D;2</h1><p>也就是次大的费用值</p><p>根据前面那个式子</p><p>很明显可以看出,如果要得到次小费用值,就要取改变最靠近中间的那个点</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/i0frh7yc.png"><br>(左右两种方向)</p><p>但从图中的数据明显可以看出,当中间的所有值和最靠近中间的那个值相等时,是无法改变总数值的</p><p>因此在最靠中间的那个值无法对总数值进行改变时</p><p>就只能去考虑改变第二靠近中间的值了,以此类推</p><p>如果不管怎么移动都无法改变总数值</p><p>即各项均相等或n&#x3D;&#x3D;m时</p><p>输出-1</p><p>贴上丑陋不堪的代码和大致流程图<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/7h357q80.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n,m,k,a[<span class="number">300010</span>],ans,ansL,ansR;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>); </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m/<span class="number">2</span>;i++)&#123;</span><br><span class="line">ans+=(m<span class="number">-2</span>(i<span class="number">-1</span>)<span class="number">-1</span>)*(a[n-i+<span class="number">1</span>]-a[i]);<span class="comment">//求第1大和</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(k==<span class="number">1</span>) cout&lt;&lt;ans;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n==m||a[<span class="number">1</span>]==a[n])&#123;</span><br><span class="line">cout&lt;&lt;<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=m/<span class="number">2</span>+<span class="number">1</span>;i&lt;=n-m/<span class="number">2</span>;i++)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a[i]!=a[m/<span class="number">2</span>])&#123;</span><br><span class="line">ansL=a[i]-a[m/<span class="number">2</span>];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i==n-m/<span class="number">2</span>)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=m/<span class="number">2</span><span class="number">-1</span>;j&gt;=<span class="number">1</span>;j--) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (a[j]!=a[m/<span class="number">2</span>])&#123;</span><br><span class="line">                    ansL=(m<span class="number">-2</span>*j+<span class="number">1</span>)*(a[m/<span class="number">2</span>]-a[j]);<span class="comment">//算差值</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n-m/<span class="number">2</span>;i&gt;=m/<span class="number">2</span>+<span class="number">1</span>;i--)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a[i]!=a[n-m/<span class="number">2</span>+<span class="number">1</span>])&#123;</span><br><span class="line">ansR=a[n-m/<span class="number">2</span>+<span class="number">1</span>]-a[i];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i==m/<span class="number">2</span>+<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=m/<span class="number">2</span>+<span class="number">2</span>;j&lt;=n;j++)&#123;</span><br><span class="line"><span class="keyword">if</span> (a[j]!=a[n-m/<span class="number">2</span>+<span class="number">1</span>])&#123;</span><br><span class="line"></span><br><span class="line">                    ansR=(<span class="number">2</span>*(j-n)+m<span class="number">-1</span>)*(a[j]-a[n-m/<span class="number">2</span>+<span class="number">1</span>]);<span class="comment">//化简了一下 </span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="built_in">max</span>(ans-ansL,ans-ansR);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P4910 帕秋莉的手环</title>
      <link href="/2020/06/11/p4910/"/>
      <url>/2020/06/11/p4910/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="f2e352b6c25ad8d0163baee160506d2ce4b78df10de609f6c2171d9f958485d5">4630436162ade97ba2718b7d0c4b3b6351ade09e539dfebeb5402828e29e64b0e35b2270b7c9522b7d2ba447f92dd73275edc844eead7eb2fe320821d818921744a104a4173fd9bdb6fd42295b62a016bdc513417d2e3d09c7bd5c8c222b44e2e5db7852fe43c0c61eb0d15f1c51075c16455be7d2dfd06ce6d38b46e7de9e5cb820be760433fdfb681aed60e471cf4e09e40054ceb96ad347e287b444ebe718adf70ea79b0ae4028544947a0133e1213a54cab7c5cb94dd1f79c19de5ebd332c9cb1292b4bf0356cc12e68e24718a47c450ef0561e64433d46ce8561859740fabce3e39ab88efb216b2580a2925b21e163c216c7d5b4b8debed660dcd4bf85f921ff470cef42bf24aa51bfa4dc4845694bd1daad5a97aec0ccf6ad093e0588b5a2699e22ee7cbdf43431c36fe8d8f4e87fb80471a4e412a9e09213edead1efe3aa32d1d3ebba98422fb0bdc36220c08dc21acf2a365e6b37af194c9fdcc9b15559d40a3c0082745858fa92fa2417451516d0f279ef47d86b890af30a072f62d3dcf8bdf2dc3ebca4ffb59abb1eeaf2d02cae775c4e7294b47c7dba5fc84918f8b684f815b5bb8a13dfe8d4945e7212e7d7a510949806734b2bed1338bb2c8bfa38e5b3046ccaae1cc8515b0bddec3dc2c29d08efe06abcb3722fa01713215904954c0848a9203ea1a32698988cabb7544c0c3dabd030d9ca455ea401948c3f94a2492f20ab2dff28c720c80559eb1d1e26ac493d0c14b80fc4b2cba8cc027ef9f678c46d0a93ad5336c28950c61eb204d9dd041cf796a780250c013f7912455379b744a3237531825481b5b9798676bb7af6f4797be100c7d22b651e4d10df24eb5665bfec539b350995e1a9ba6a7cf76a20713d6f1b4dc9331cb000c56e2ee108c38542f42a4370deeef3dff132872eb11860802107531fde3d332f5cc8f395d117504676c5d5d77c6dbc3ff2a8d05afdb9909c85a98efddc40f669c64b6e40804714916fb9ae5cf3216b1ea1b556b8991d42a5fb9ceaca5c35a32b0f1b9cdd32e9330c8a74bcb36779c23506bdfe025e254a94a8e448c5bd8fc47ee0c270f0e3b849a1c5e15e405fb9b4cbd720f439aa09d06f7e8c2b10a27eb69e5ef6093dc0e41422cb053dd0051fc22836b48195db9196bb1153329113b14ecff217813103d42b1811efb85b2207a155f15d5ec5395447247339f655aeff92eb99d68f8b9a5e3cb9ae18c2561bb244453512d2fdc302ca4998a39c7692323e99bd780b22b21e9bb116a6b714c971b5b950519223e69c7e405eb915baa5690ad4968064bb7d968924a680b4e60de627108d6ab5b5dadd6a9c525a09b4b6383edb796d7cb580f0a2e95212fb02126d0704f38b1bad008664c76e09c348bb3b5660e73803d76f596b0b69ab4b90f0221e291f117a507f93deb9ab051685b44f81251c6e82990484aeef4f39ea70c3fc938e4cc8b6fc5f6eec4537fbbdc48f6e317c4e25971858b41c3f5077ccf8404e55adc849e2c4d7e80d16bc582e36e75d5ff883fa5200a80c30d561040e4799cb2c938aa22ed12bacf10ffe21047e7a50c12dd5396218bb27b9fee984d298f20d5ef56dff9752cbd362a2d9723aef5a66c35e8312deeed30b7a75608492fd4956f54be5269ba35b74202236de3988b4d4bfa87ecba6ddb5d0acfe3e34add6a6314c579596ad3952d87c0f387a7ac62e564ef71c9ab9ac3182a4e8f72566ea6b3f94101bbd154456e3eb11e9b3c0d1321a56be8a4c20c9910e3c86019e27be91410bba2cb83ac3b7b6470ea2805b6300cb9956cf0e6a6a9de9123fdb61ac5413ead39979762c8c04d2baec563ef7c26b056a03f4acf4cf6f0fa33a720f79b5253de4cb43e0658a2e595d6917e70e12dab2bfbd220ce172daee763092ceb03ca435d0143fed8205725f69b082da0a9302e1f67fe897e4a7c84daafabaca9fd3248709e2150c4952f93b2232d70092213b0579b8f3b7575ea266171242fd41344d60c613404ef7ec66ac691bf948c526463e857eabf697e65dcc1c2b0ec69857099f7abca97e84c29015c006971c01ed5260c628f5d91a2d24204ee8df00168e32000fe96bff3c25621c287ec7fb62c7067e4b8618279dfe4d0fdbcf5e8c13f47a880fb60f18a9eae4056fc126c7b8cbea34f3875961376ad5c623ce4baf4d947a12e552810ce13e614e601e37a461662ad5795eb64be375f7a063d939a89017e2c39efca769cbb7fd0c1a51b430626110fe3ec22ae6e89eb82f410801dbf9b12d7b414e2ced6a23ad530364802d98308593066c142262320c4026d0dcee2c8d151b3df7b42dd35c94be2583576ec7c8f52b24e9ce245f836cc1c569245d5ec81ea156ba6e3192e0dcb3e95b09d496387167348347864c67a3e25dda82ae73e20206753cd277deec391e76eafe91e8f617f6170a59043409f81de93a68151cbb1d787f70df3a3c103d903cbf30f99efac48b6389cceddee3c2c2ffbf7c4d240ba95d1f5bf2de60b5e29d16cdd4f53faba04862a194e51f1d8d309c4f345541ec9de6420788bf87a8113c12717f58cc69bc166b0e028c252fdd9ba23227f566df025906382346e54fbf89f50151def4bfbe409401c55677d12e6f1416d9bb53665b2b46be3cf0a6ebdf8b741f9ceb2d6ad8aeefd9cfd96c40a056b60cdf5b07884a9f498857500b197c564c92780855a2f5b101bacae406d15aaeebddf339ad93af76a4e73ea72d54aceb8f818678cab5db0484f86eb5c88c9c3d565448b146e62850e1a699f146e892afe52f1e90ba73b9566858791388c648dc75e267dd8f06cc4a1793f74442f01bc170677f08987ee8a611d1c6856da0d6697571f00789484597f3572a929ee6c2346b302d594787505b2906549d13b0414f8151333e84adb05b3d6a0e318f3bf8250d3ffef03f32c3867577a48c6180e6064e24c9501399a04b0dfd33c2f4bdc45be8d367ad39f23c43648f3779ed5c8b836927eae5053b5ce0988a64d1bb272f21cffc6dd36103fcd6df099e3bb313082fa1e5db5e2976e405fe2bd5af73bf8d0ab4e028a9572041f3005383a755b968f390d652d6c2a3b66fd3b9ec0bb652a45d9061d9d9b55cd41ddd378cd2df0f4abdf2d31d14035d02b8db907282a8e1f7b16f10fff28a8b15cdac18c234077132a96d113b6b44f48a351ffe0f9b6992c186061ef603c92f428981b30c2c390d25cf85442bb26faa878bc8cbc3870a125f42ae372c8ddf811d5c5002a879d67970443713e44a7f5e0366e4d0932d140b5eb5f061a8c95bae1f34c5021100f5e25fcb04d18d75d4ceb5e98da4af8c04509ed02d9eec5e0a4d7e02f1baba3c9fafebf025fe8f871eee0f8ca1b2c25ffc6917b559b38e34a3d15aa226bbb917aa2e4108f27997f1667d10c655d89b5aac19f972123830c72e7be0606c0e78f7d572fba90a62e475c16ffb4762e46649f8a06554210c1e2c8271bffb26b257841d83a41b641a912f21c201b22665487232de43ddad5e2f1e3334ec69646e33d87d0302270c8a48f16e5224fe2f70ff81c71fb3df4af170c17e0576f5b4b36ace3b1b4eeb3b30eaa0296ed5149d132897ecc9eaf4329171220ff3129b9010b2f4cfc93007ece404c4b6b8e59e5b602dd87e6261732e6735f94f85972412fcc2792d256172f71cf212400d2481cc6c2421b5894dad72848d4d722a78d2b620f8a92bd285c8ac2bce0b0078c915ff1ee2db281e66ebc4e5a7f41f803cd9a87642e6c4098cf5310fddb0fae32d3a51b95ff0f109feba1e044ddff5c19767dd88bf047ac927231a1fde52ce5417971dc6cdb0b555301f2d8d1b14014916ce27916b13be3a678d077a809cbbaf3efe8846b964772dc4d968cffa2ad994f4a6e48983ef356810b644de79cac13a4ccd18328d1b370d6f5528c7f9f50c9a60ce243af75c3242e777bf7704472118648d7f3c1ffbe2fd79aa3714820fa4f1368ac584db0a7250565acb90ecb69b585c6a2a9af27871b3747a594978e7cbf93d5441ab66906dba8e66a6ec2b8b6fe2be855926800af9098a64cc150131633816b43bd6a41b54eefb0e9443b3204d61e6614b4d76dca7b34da50ae8947ad5d4283aeb4cf8f06051663f6d121a5ba3b57abc9e75fd2089d3debd32963a102fdfeb2f62ffc26045abfec772b69728ec18f0a53f030b25c6fcc5033f3fc938a55c439e9ae019cccef120226a251482863fbf361ccf459a28047d5c5c78531e058165103e2d892e78ad15ee4690032e1526ba7ede2193ffeca959ddb658114b553bf169c79bfeef21116b0eef4668dfa617853f6b0155b4617b81916de4884e783ae5c15d4f4513819bde26fab0db901ba72c85fc0a5ea9842d4d2a7b663e4a10cee4b689389a03f33acf2af2a301faf0c172b5da4c1ea8e3bdf970741928017199952b4d84f0deefb052b5765265fbb8e2d15a9aca47547449452b7121c9db210c63a53c137fbeb2a3c5878427cebb589679c8b812c81a3968019ea17323ddce420a1e7882a740d0499e9b61579e57cd30f187af592f2bb054b9baefcee035c0c76c38ed738b69a23d179c9eb24f219cf6ab27ab4c74ff274ec817f0554ac47431e8cbfdb62c8b0060b628762b5ba8125c6e292385a451cf00f5aa66c49cc677d30294523f9a17459b9bb4bc74acf51071d841e228b63c5b42112f1aba2ba55d0760cb188a13a867f2b16a1f907eeaf4c77459e71cb20c766766a4186754cb65d523c6c86280bc878ca357f4aac2f4c43537fa03aaec4306e17d210166b27573e23b9129693952c5faa5825dc90b045101885b675bafaf1e079440cc0f36e3f64d941f2510fc02c36644cbbd296451d504091fc45065b5db1f9245b2b158a98fe44cd72a2cc62bd3b257c62f90b0dd377e9195db5194a7ad0e406c598e22e1654c6a7c644d324d6bc324fde3bda1d204c9d13eb5f530800919be626a7ce440d6b90f3172c8a6efe47391a0dde8f2693116b859bacf6ddaac55eacc3d2b75a59f037382d61723a52f06b8a2ce538515d7d8acc69f0009f022e3c4a34eaf238dc44368f81a7a845e039a1625b3fc31b4a1150f2fc379d32f0fc93a62cfeb7c23e42d8587f09b4fc4f1a563e8350e0c405044a60f03e1462fede0abd91578cdf6229621aef87d1288346848a4947c26a5fae45dbacc56dc014ace17d35afb2d423829c1cbaec490643bec16df5a14e1c6f53b5036a8e19d33896c3a82c28a12f556a3f2b19443ae3ee123465ae805ccd6c23151a63615537fbe9bc7fedf1c39b5ca396c50dd992f97344473a422ab1a65fa270fbb6806d2c1e3909632a2f4e5bb286e0c7b27d1d011fed9665dc2cf9b6a8bd2aa7544c5c4e69f71dbbfd486d1ab56c73b0dfc30f2e071a7178e236530341b303077e8e1926db0631ab0d016dcf70fcd42b1a977c0c65fb60bf16ea53873fd8587024f73de35f05a52fc14c9c2735deb928256a3a8721d73460a026643e0be32384095dcb870bff73572f06157de16179f105e5efebca7b71cf7ec158e65b8a11c6d332c1abf29c4a4945e580719e92894927ec17b6cf97d49926d9afba60a0d15304817456b2a9664b6ee06a3efd27d77f5d3882b17d88a7ae867f144d5db702b5cdfe5b4449d339c88beac386693870f161111eb35758e7a61b016adb07b1fabc54bab6502d9e3a68e32040de1aecbd5cfd16adefba275196caa8746ec0b5c9f04f31ae6bcd790f2c89a527eb2b41ad97bb4f739c98427cc8bc764095ac542b38294905d7dc3335cf7ea93c1c570fdf4720f5c338c49f8a96ea15fd81704fc038793ba40d8ee7e0377672cba1d11963a7b0cb9e6b92d9056c32daa9a91bd2f9e843427e0b74b74f251153f869a18ae51cb0cb590defdc266299a359a9385b5f8bc215f0c348034e1c64057f30fdfb545659b476c0d3144c45661b3ad0dbbe5e96ea54c714c0785944f3f74235adcf4f615308334f0ef2f5653a664c8d0ac8a860ba6e7996233d80697190282550b73c9c1179acbb077d68e3cc44ac0b3ea82c5d512563ef3f361639cc7626943b676879b4ca0bdf272a91bb0636f28f359543219eeb89f948dca9c00c131659060cf680590a1fe4083505a051efa2a9d344fced3df7a3bc0552340bf08ed658bd9ffb0d4449c20a7f4be810f4e30a10eaccb17dca504e1b035899bbcc91a8b4738499a0e4bc0b30a523881cdbeb71fd394ab0a5dd052d311df4b4a84a93ce91dfc5fa8a686db25392e7893ee54e52a1b08b0a742cbb040ecb38ebbe088307fcbd96a4834e334c44c28f4787feaa9be606f5ed5d8e32257d720bc209b761cb4f54ecc43b832d4630ba9b35e155fee1eb90e36702c5a3c8e680e0b280b4bca434a8a26f0701b294f14debebcba9c2bf831ecf2de591b1399ab20e486af25e754c7b6775c05b3d8de50bda9e0d423eb4d0435696f09257967764249abb509d38c125b2a324f6157045b5f0bd389ebbdc7f0063947c2a97d9892cae38b24584c436135cd97f3d9f53e1dda5664468755075143d65c1d00aae4726affe1b5f9595b8e348e2178dae9fc9f4494bbaeedb9dd14bbad25c438d22cc3a4da594c7a37acc3c5f2cbda4551adc27e87f34e102c4ddc312cf14e4d1f92682e5016a71cefd0d264a142235573c183e6d97a8951b4a4c7e51ff5115f79a68442bfc5f9c809e855037fd45dd68b46e739a695ee167846e53eb3ded47a92dab259971e5a85ddbdbd0dae12ef0d1aa647220e5cbfd8041a0a5fd7ac111045708b96fd423d7b9009847e9d51ecefcd52fc22723752f6216ae3d6c4f9d066b0056d63204efaeb358cec2bbd4dbf90b98eac77d14e6f0c4c5a47991820e67a927113061394e513d6587caa1017cb79a8c98b209fabcfcaa6c0acb12fe1c9ae6f6e24b7aaaf74ef5e3e9b7c341dbffaa7582f5c67488ae6be45112e64fb82149661952aaf013052d2bcbb3a49d628915cb1c855ed08dc893087f86ac037b9fa08d102ce78ef64fadb3fdd67192425b044b4b44fcdc2ac0191c5293f7bfd839ef15893a87fefbbe793469befe14edfad3ef00b3d777e016bd97a6c0b420d58db052bab4a3eb06dc6c1988fe73668b4cec7c866bf55756141ca854a4b4b8f51e628b756ed559e029029186f1519c264adc3c6e2aa55d21554c3da8a909379825266f20aa217ed73896800d85e3c1497f2b1a319a26e529de27b4ba2a31d511f555151cc0279edebcda215814c1ad49217a50d3f6ba8e67927566484ff1ed50def4c6cba7b52d48968583e0b2f696a0607622c61a8826d0e8b2f2d89a2e8de71940f4cb75cde341e6ceac543827d317c01a3cbc7e9162e1eed4f82d404cbb954939138a15adc055ba10db27bf32121c8141ada9b9971800e8bd7adf03e1d3a28406965483ddb7fa1a3a5c4cf43edec8aadcc54ad9676a811bf476c5fdd3708bfe37c6376ba949f702dc6050d190cc9970a5896c3ee7ddf91395a921fa583d24b2ca475f2cf840e6ed97f02c20abf868811a6cf77ec86889a6914e758260596168b1918c9d6c4650efc624960cb4bd43d10598443a8230c2d092b2df7af6c4dbe54bb23c50d3180212602728dbbd1d8b561bbf8f7e2bb6098d809c03348db005027a1eed36901e361ef3789ee8f3a19be449446f0dfa358d403312710d1e18708cb37acc4181b7739c51c4db74816a0c9f6dab3515ec0908d1a5dab96d8259722544b89565c5f1f744c16750cf87e5e24b62ab1f57f379afddcd3c1d944dffb8570a3967dd7ae0bdc369cfdb7aa92c19c489192de6a38f605fb92cb38a6c1ae2a499ae2dd546c30f648dd4da817c5c62b9603f3181eaa8cb06e4545053bfeaafaf0308455daa7e3f6eef544d33f0cb8f8c76b6e75616e5e0557a4052cf430d2550696549de3e82312529985b05f5c9c52d6b54556f7d52c10fec4bebcbfb0610ba369146dbf8ad96661b36fc051529ac576c09b837677d79b231830bce3abfa914e7abd10fa79023275a8665f990653b8b2f6d4dbffd949dcb65999fb2cc8c85d39f78721afbdaa8fd17d9514206446fca68d53431dd9a19cbce68b1880f7addb30feeb4809a69831b6e6b49a8cc7d6c78d894438bbca8a8b452a3b9fe595742acdd41442c4863fd49a7d0f34ee796571fc2b4c0212b770bb671b391f6b0428671637b1028f69927c8e5d1ecf2a75044848a64480c20147503a01671d472729fc2ff2c51c0e04b701b7f7f3fe9a202005958e213d2b7bdd4c7e211b58b0dd91685b20b14151ed46cc9ed9b5df4191bfb5c09f51ce2451525977f1cbfad125b51ddf4a3c5a66bfaef844de556272c35549ff99eb1e98f6afc536b2a18bccac82413807992c108fae5fba08c680dd3e862e441e4f6372122299272c659edf72c2030651481ebc5ab23c7625a9affe360501ca3237208a66cac0a3aea846f4b022b1f67861a7f55dfe066fe23721d53bc6803a456370dc064bf73f81da5ee27d2e90c29f067a9c66fc40a3f7c291406c57221e4bba4cc50cb3d12101b682218e7a14d84e01fcb1b058ee5666b86b5c9539586dc5f3b0fa6d8e0ae57e42066ba5cd0ae839875734000cf05722bb37cacab9e2b25aa7c5642745723de73f57cf19c2c9496257c5ba1491dbc10007558efbfbe1aebe470cb0cb784a00e6b36c1e0e65d407d6d20d5660b840b4b7a7e2db080bb3ab381d4fda67b64f062e08668cede98c798cbb95098efde4af327d930a408152c786346308f496b574161900d271f3e9cde01106c706665ea3038d20e01517ae7a04ea77b50b5f284d4a86d04b1b3dca4c4d877ee86fc91195fe25c3d040b19c4b58ed0450dc449afcbe3df120c34d609228c527f5b4a392391de015bec1db39ef942d4dbc9e6eaa3267be5a953264784f8d74e929fe48ab6a602541733249f2d47b817f4a1d47da25510443429ac53ced70684c95023c30b074dd143a0d82927eca78c13460fca84f18f6a5239cb2e5de264a51156d45a9d2b1bc25cf7f099cc113ed2f1ec04f7128c741995fcdc80ffc9d0cdf2d4d1fe14fed46121fa4de0315c6ec471442e999ffd6dc907a019df325e1c885a8ed5b572e5ce091f9e3a62be53d8a5594f1f7404a5ab31e7e3cc0c3b4b90dfabc7690ad7961f02ea6a0197cf30caa8188c4e3ea5a9763fb12cf47b8c139ae156d7d54b0dec88b600a45eee912115df6d74518c4a4201534be62ecf315daa54f5ef16c6089512667eac12876206d148456be1d41847f4aa1baba4686348df337c07a2131f7526ba71a0bfcc40d50ed917d7c32a52b08bec2ad02ac333885745dbf85c69ac4e18dc4f68d484f80501fdc7a5c847c66432ad00c5bef7f01f19338ef72f7c89de2933c151c3a1d8d45b3da023633498f39265593553f5f93221581ba15b99249a00c97295dcac9d196d7648eae136d43275e195d0363c58c8b8b0e58220775a98e6bfe8a30fb1895433decb25359cacb3e3788d276ed7e6699cbfa1bd501e136a2b24daeba33aed3b3c38df458647df9e733c53a5339f13fa756be22514ecabb191d0d20ade960d2fd728e786d255ecfa2c37439b4f1228838e22892314de08a80bbc4f3207dd3593e7cbc12adbccaae075a8172dacb7030e9c5b444128954fcdc5cc2957ad8778e1625f7437de461f6b35393bee44e940d42571bc2fe4f5e1b826449fcf4d3fca4bc23978e6e84af86c120a10bce2754c5eac8c3f7f0d7acdab50f0903b9985e0e407847be664fd9871ee613adb19384223825430335decc5bc6690eb5aad0c551104d653593f65dd1ecaa9caa7ac3f493bb6b91f9e8e73352a1fd05a8c116fc9a796d60f8fec29ebaeb5968aefef712254c99b91187ff45ad739a3b97b53d15a6fef457fc7e869baedb08371a148712591b14179bb0a03793b8c49eaaad1071900f53ed7e6c381500b7623bb0985bb87a12dd1bfe1da60d642186ae5b4fcdf36bbcd9e08ac44773b4439f6fb99cc149f835bf10cc4cacb9d6203476af2e855266f1c88bc18f649e8e4df9c37b3a2304893a248fa49b4675ddc10efb95008b6408a31b1708c86a110a9db99dd17c3db71b58d7eed3e86cd9f6141515ff216c67e3733ccc3e456e356c520eca29a065623b79e616037915f5f69df4fee2a105ea568fc63595acff4db97848b3d1d54d5bda6647db14d9167909e5b7cfeb26e7eda205fc95794e2620bd3bdb4436239db9caacde610479f8b67580aa7c663d216d5c3fb2106be57c6c7e9526a98c852300698fc68347d8655a4345ddf303fd04a51e62d70bcd24033c55992444e16249da97571b3e0e1befd986aa811540cbca02ea3559591711bc4343dcb0b0471d7b82df9d78d5f37a410ab16f09a599bb63b5b0522ba2c72fa86174de00a0723f54753047bbc1b4fdb3841d1cee4770e6a5dc17a921739d5242d065a602f2c4e6e4184444249f578ff518448401df77c541e87b1f6b7b6da33367a70edbe587a41802ebf5368b84ee136b778464e5cde35130bef714656c38a49312547808a27e00566f4ec0414c584e290c015f88c71e229c95578a00765cd9dff6f53196ef2bcdda3f02ea27ae8f63b4c19f231715afd5a04980efcd7e785ba0d06cef12eb36fb78133f31964aa8dd6e48afe2c51a4749a96c4b56d5bfc5c9c037e84b8c618e900aff5ff631100a03e6d601ca5b8f0d7a2acdc1751a58fa2e1636ce5703c2a44efeab2d218ded7d311654c18aabf1562b89aaf7897178ba60b6c067c4b590eb9613c84ae2cf4df7b39080990f3df1e8b4fa1c9bf087723cbb7ce5aa6f45dd2650766c1e0cbd2705408f2679ab8a862b8b98262fc1ebadc3228749c87200e54eee66b9268132af2e67e015f26d838f51a68d2fabd5fca86272be4b6f818445de7dd35e8e54f453c050dc6dba4c1ca515817ea1d756725d36c2e24ad1de7c3af0914cdda65ec1559824c709e3ea95f0b45930067d08463482dbb51a60dcb213bcfd2a105c9df97325cfee35da9486541ef8a4f4daa34858caf973340caa84dc372e7d20e0adb1c362c003ddf10a364d4b2037f2a4e3aebed445ac991597c36f133bc26ae0585ad4e25988df1629d69cdbdf7a33a0eb96578bd6516893d5ec032b0d260b242fc044f24f607e2180a537a869f24e808e4e241b92d5cc7851e64a78db02922661204aa9e8046e340548921831004d2e3e865dbea7ce46f9d9963eeffea75f1bc3f2829a7f4e268cbb95f88042683a4a487b1bace6368e6a64d9525cd0781a4c7365f8ea7cbb78b48852cb1b2ce2ff9b9659659af364b95c728f202c4082a849252ea768ec5de5f43794b0587d66afe7b87bdc7b3147f0153fd3da37842fa73e53592afdc64affd3b2afbd942875ed2331c74b56687e6f7057fb1af470535e3088c0f0d19d4eb1f4a18e77cd08b5df8a452e6dd2337211d1c92edec65361315f756c9b474ad122f83243f451acff94d7a55e419ce7c0d61a887f7822ae0da112bef2f815cdb13ff488fd8d5196eed2548057140911824612ca62d5ca9fed0ada4eec8328617779bfb69bd3602ace0bc9cf03183d52ebdf97395600425ef9823e337d1c411faf808bcc1732e0427407f98a6119bef92b4b9edf3512abdca2ca2e80c175df6061f270f65a38f87111a65bdd5851b387bd709724871c388c8afb3ec6542cbd4b97680ce167fb1057a8d98629af68abf33569e887899ddd641df5e53b15444359dc2fe760e7a054a13d9030c613f619bf88fe2ff1e1c1a551a723e06ce91e1c0e51c6f7dae7d892b644cc94403997bac7f38263a4b10f675b6046affc7683bd270a0ef2e3881cf37cf0ac1a109cb55bfca3b201ac11a45b7b5e0478659cd3037d7e86446e9802edb45c6a5fc0ba6a071f8f1c084950377cb47bb03f4b88a11deb8fb4ffcb69c372a6b6f37b37a5bc8d58ef975c4dc61d9377a2e87977d121fe8177a390297a4e9d111b040270867408b6f4e04e2daba619639f16075bdeb5e1e40969efef6d4dc57bcd5e42bec15ef01f609f9786c8ede0844545f333e5e6148b23658fc20a80a0a0184bc9cda46aaaba12a641d8a2421424347db3a1ca6714381cabb62e45f3368fe436c6a4bb2aef963fc93baf946e3e5c113215f47f7eb80bb5b029d715fd6c7301b57a6fe571bc66ea43b8e3dca4ab065c7adbebb3b77e7486519bb0a1271faf68b135e43355672d4a50db3a4ab393eb84b120963e2402d3d5356d108a96f2ff9f8b831cbdd42f8fe921a1b696360c4b6c7d96e8b26e0f05cc03da10468c4cf11ba7dc70a9da8d0c3ddf04bb53fa904dd707856022a14a24c44002e05a8d4c8eeabe3afe27656a4529b0bc41bf54ed0e85fe11516f46e014bf983f596940d49c8e2259f3fef8765e04838ff2681783d18458b772dfc66d283be6058c4413d4c688164ca24b25c73b436a505e6c749b97cab2016974a04e712fbaa5c67842d68b5545620d1365f1240ad83d0e7ede04ccc4304b57e4835975bd8a2b3bc931840a02fc7f7efcc08bb150ff3247b927dc987ba66c729536c71f2612da13b64b3cc82fe6d7c82e610ee257b0d6aee2162ba7309fb50aa50b445646772d2657a50382f89b12f67e22078e45b6b148f88237efce470fc5122ae789c1382d8482b2b5032cf64fcee9f682264aceb495295324936abf026ec0006ff4ed124a9e78c782eb0f918034faf02c3d6ac7b6f9552fd98ed4ab289bc3a48da93140fec7c16d3edb20fcae7f7a465ee3723cbd01a36eade7926e1b5603c35a2725d4b6c2109cf2acc1f0239517581fb9f9dd5b86295351c37e254a4e4f2ebd31a7a371363311188698fc971624572afedae0a00ee13221c001cf97bf51159afa33d887afd094b4a0f167b49338e8e9b511e15ec7083f2c8c1692ae8909fc817f09494405682a5b364256b99e3e98afe55a8978129949fd6839d54beb30aa5639136df0a29962119b04100e1f77e928544ea74324e978d51a4e855810f1054b015ba7b3f525622ff0fae40ce8e30e736414d31f39a3127099f01c65caaca30dee7d304c594f4d76402c1accbddfe82f641e2c3533272c812fcbcc684eec28d44f614feda3887835d4cdb300219d233d9b9e34bc53da5f028d07ce6ab2e74b1d6848d4bfed9408a9b8b856b4370a2029a2accfc7daf50f8cb1d8a98a554a99f067b1d46b6b8497bebf20fdb7b502f1a6a426c96572041b05d8b46d431ac5d709f527be393852ae3bbcf9ff0bc44804eea931a16894198debbb46293cabaf1f6db969c15409ef0e4d43d644bda786610</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划-线性dp </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
