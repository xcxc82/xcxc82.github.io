<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>树上启发式合并</title>
      <link href="/2020/08/16/%E6%A0%91%E4%B8%8A%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/"/>
      <url>/2020/08/16/%E6%A0%91%E4%B8%8A%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="模板题-CF600E-Lomsat-gelral"><a href="#模板题-CF600E-Lomsat-gelral" class="headerlink" title="模板题: CF600E Lomsat gelral"></a>模板题: <a href="https://www.luogu.com.cn/problem/CF600E">CF600E Lomsat gelral</a></h1><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>一棵树有n个结点，每个结点都是一种颜色，每个颜色有一个编号，求树中每个子树的最多的颜色编号的和。</p><h1 id="一些定义"><a href="#一些定义" class="headerlink" title="一些定义"></a>一些定义</h1><ul><li>启发式算法:启发式算法是指基于经验和直观感觉，从而对一些算法的优化。</li></ul><p>举例:并查集的按秩合并</p><p>在并查集的按秩合并中,我们将小的集合往大的集合上合并,这样明显有利于加快并查集的祖先查找</p><h1 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h1><ul><li>首先是一次$bfs$,求出每个节点的重儿子</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">size[u] = <span class="number">1</span> ;<span class="comment">//子树大小</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = head[u];i;i = edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs1</span>(v,u);</span><br><span class="line">size[u]+=size[v];</span><br><span class="line"><span class="keyword">if</span>(size[v]&gt;size[son[u]]) son[u] = v;<span class="comment">//找重儿子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来定义两个数组$cnt[]$和$c[]$,分别代表存放的某颜色在“<strong>当前</strong>”子树中的数量和存放某节点的颜色</p><p>这里的”当前”指的就是目前正在处理的节点(如果给每个节点都开一个$cnt$的话则会$MLE$)</p><ul><li><p>如果目前正在处理的节点是轻儿子,就把它的答案计入并删除其贡献</p></li><li><p>反之,如果是重儿子,也把它的答案计入,但不删除其贡献</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">cunt</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">c[color[u]]+=val;<span class="comment">//val为1代表计入贡献,为-1代表删除贡献</span></span><br><span class="line"><span class="keyword">if</span>(c[color[u]] &gt; maxn)&#123;<span class="comment">//最多的颜色</span></span><br><span class="line">maxn = c[color[u]];</span><br><span class="line">sum = color[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(c[color[u]] == maxn)&#123;</span><br><span class="line">sum+=color[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(v==maxson||v==fa) <span class="keyword">continue</span>;<span class="comment">//如果是u的重儿子,直接跳过</span></span><br><span class="line"><span class="built_in">cunt</span>(v,u,val);<span class="comment">//dfs暴力计贡献</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa,<span class="type">int</span> keep)</span></span>&#123;<span class="comment">//keep代表是否保留该贡献</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(v==son[u]||v==fa) <span class="keyword">continue</span>;<span class="comment">//是重儿子直接跳过</span></span><br><span class="line"><span class="built_in">dfs2</span>(v,u,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span>(son[u])&#123;<span class="comment">//如果有重儿子</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">dfs2</span>(son[u],u,<span class="number">1</span>);<span class="comment">//keep为1,保留其贡献</span></span><br><span class="line">maxson = son[u];<span class="comment">//记u节点的重儿子</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cunt</span>(u,fa,<span class="number">1</span>);<span class="comment">//暴力统计其非子树贡献</span></span><br><span class="line">maxson = <span class="number">0</span>;</span><br><span class="line">ans[u] = sum;<span class="comment">//记录答案</span></span><br><span class="line"><span class="keyword">if</span>(!keep)&#123;<span class="comment">//如果不是重儿子,则将其贡献删除</span></span><br><span class="line"><span class="built_in">cunt</span>(u,fa,<span class="number">-1</span>); </span><br><span class="line">sum = maxn = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个$dfs$大致可以分为下面四个流程:</p><ul><li><p>记录轻儿子及其子树的答案且删除其贡献</p></li><li><p>记录重儿子及其子树的答案且不删除其贡献</p></li><li><p>暴力统计$u$及其所有轻儿子的贡献合并到刚算出的重儿子信息里</p></li><li><p>删除该删除的贡献</p></li></ul><p><img src="https://img2020.cnblogs.com/blog/2092833/202008/2092833-20200816183326748-1026754225.png"></p><p>这样一轮下来相当于是遍历了两遍轻儿子,一遍重儿子,显然效率是较高的</p><p>时间复杂度为$O(nlogn)$,<del>具体怎么证还不太清楚</del></p><p>$code:$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">e</span>&#123;</span><br><span class="line"><span class="type">int</span> next,to;</span><br><span class="line">&#125;edge[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> size[MAXN],son[MAXN];</span><br><span class="line"><span class="type">int</span> color[MAXN],c[MAXN];</span><br><span class="line"><span class="type">int</span> maxn , sum;</span><br><span class="line"><span class="type">int</span> head[MAXN&lt;&lt;<span class="number">1</span>],n,cnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> ans[MAXN] , maxson;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">      cnt++;</span><br><span class="line">      edge[cnt].to = v;</span><br><span class="line">      edge[cnt].next=head[u];</span><br><span class="line">      head[u]=cnt;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">size[u] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = head[u];i;i = edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs1</span>(v,u);</span><br><span class="line">size[u]+=size[v];</span><br><span class="line"><span class="keyword">if</span>(size[v]&gt;size[son[u]]) son[u] = v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cunt</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa,<span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">c[color[u]]+=val;</span><br><span class="line"><span class="keyword">if</span>(c[color[u]] &gt; maxn)&#123;</span><br><span class="line">maxn = c[color[u]];</span><br><span class="line">sum = color[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(c[color[u]] == maxn)&#123;</span><br><span class="line">sum+=color[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(v==maxson||v==fa) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">cunt</span>(v,u,val);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa,<span class="type">int</span> keep)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(v==son[u]||v==fa) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs2</span>(v,u,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(son[u])&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">dfs2</span>(son[u],u,<span class="number">1</span>);</span><br><span class="line">maxson = son[u];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cunt</span>(u,fa,<span class="number">1</span>);</span><br><span class="line">maxson = <span class="number">0</span>;</span><br><span class="line">ans[u] = sum;</span><br><span class="line"><span class="keyword">if</span>(!keep)&#123;</span><br><span class="line"><span class="built_in">cunt</span>(u,fa,<span class="number">-1</span>); </span><br><span class="line">sum = maxn = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>,&amp;color[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="type">int</span> u,v;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>,&amp;u,&amp;v);</span><br><span class="line"><span class="built_in">add</span>(u,v);</span><br><span class="line"><span class="built_in">add</span>(v,u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs1</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">dfs2</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><del>最近沉迷stg无法自拔了</del></p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tarjan算法学习笔记</title>
      <link href="/2020/08/12/tarjan%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/08/12/tarjan%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><h1 id="缩点"><a href="#缩点" class="headerlink" title="缩点"></a><a href="https://www.luogu.com.cn/problem/P3387">缩点</a></h1><h2 id="一些定义"><a href="#一些定义" class="headerlink" title="一些定义"></a>一些定义</h2><ul><li><p>强连通：如果两个顶点可以相互通达，则称两个顶点强连通。</p></li><li><p>如果有向图$G$的每两个顶点都 强连通，称$G$是一个强连通图。</p></li><li><p>非强连通图有向图的极大强连通子图，称为强连通分量。</p></li></ul><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><p>定义两个数组,$dfn[ ]$和$low[]$</p><p>$dfn[u]$表示$u$节点第一次被$bfs$到的时间戳</p><p>$low[u]$表示$u$节点能”回溯”到的最早时间 </p><p>如果一个节点$u$的儿子$v$的$low[]$小于自己的$low[]$,说明该节点可以”回溯”到$u$之前,会产生一个强连通分量,记录这些点,将其合并成一个新点即可</p><h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><ul><li><p>每$dfs$一个点$u$时,先把该点的$low[u]$和$dfn[u]$初始化成该点的时间戳,同时把这个点压入一个栈中</p></li><li><p>遍历其所有儿子,如果一个儿子没有被访问过,继续向下$dfs$,同时更新节点$u$的$low[u]$</p></li><li><p>反之,说明该儿子出现在$u$之前,无需再次$dfs$,直接更新节点$u$的$low[u]$即可</p></li><li><p>最后,如果一个节点的$dfn[]$跟$low$相等,说明该点是一个强连通分量中的起点,将栈中的所有该节点前的值全部取出,合并成一个新的节点</p></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">dfn[u] = low[u] = ++Time;<span class="comment">//初始化</span></span><br><span class="line">s[++top] = u;<span class="comment">//压入栈</span></span><br><span class="line">vis[u] = <span class="number">1</span>;<span class="comment">//被访问过</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].next)&#123;<span class="comment">//遍历所有儿子</span></span><br><span class="line"><span class="type">int</span> v = edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line"><span class="built_in">tarjan</span>(v);<span class="comment">//向下遍历</span></span><br><span class="line">low[u] = <span class="built_in">min</span>(low[v] , low[u]);<span class="comment">//更新low</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(vis[v])&#123;<span class="comment">//节点被访问过,直接更新</span></span><br><span class="line">low[u] = <span class="built_in">min</span>(low[v] , low[u]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(low[u]==dfn[u])&#123;<span class="comment">//如果是一个强连通分量的起点</span></span><br><span class="line"><span class="type">int</span> v;</span><br><span class="line"><span class="keyword">while</span>(v = s[top--])&#123;</span><br><span class="line">vis[v] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(v==u) <span class="keyword">break</span>;<span class="comment">//将u前面的值全部取出</span></span><br><span class="line">w[u]+=w[v];<span class="comment">//合并点权</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="割点"><a href="#割点" class="headerlink" title="割点"></a><a href="https://www.luogu.com.cn/problem/P3388">割点</a></h1><h2 id="一些定义-1"><a href="#一些定义-1" class="headerlink" title="一些定义"></a>一些定义</h2><ul><li>割点:将一个无向图中的一个节点及与其相连的所有的边都删去后,整个图不再联通,则成该点为该图的一个割点</li></ul><h2 id="算法思路-1"><a href="#算法思路-1" class="headerlink" title="算法思路"></a>算法思路</h2><p>跟缩点大同小异的思路。</p><p>既然去除该点可以让整个图不再联通,说明其儿子与其上面的节点都无连接,也就是无法”回溯”到该点之前的点</p><p>直接用跟缩点一样的思路去写即可。</p><p>要注意的是 $:$ 这里的$low[u]$不再是直接更新成$low[v]$,而是更新为$dfn[v]$,在无向图中,每个点都有一条”返祖”边,这时把子节点的$low[]$值赋为父节点的$low[]$，就可能导致其$low[]&#x3D;&#x3D;$其父节点$low[]&lt;$其父节点$dfn[]$</p><h2 id="算法流程-1"><a href="#算法流程-1" class="headerlink" title="算法流程"></a>算法流程</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">dfn[u] = low[u] = ++Time;<span class="comment">//初始化</span></span><br><span class="line"><span class="type">int</span> child = <span class="number">0</span>;<span class="comment">//根节点的儿子数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = e[i].to;</span><br><span class="line"><span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line"><span class="built_in">tarjan</span>(v,fa);</span><br><span class="line">low[u] = <span class="built_in">min</span>(low[u] , low[v]);<span class="comment">//更新</span></span><br><span class="line"><span class="keyword">if</span>(low[v]&gt;=dfn[u]&amp;&amp;u!=fa)&#123;<span class="comment">//有一个子节点满足条件即可</span></span><br><span class="line">cut[u]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(u==fa) child++;<span class="comment">//如果是根节点,增加儿子数</span></span><br><span class="line">&#125;</span><br><span class="line">low[u] = <span class="built_in">min</span>(low[u],dfn[v]);<span class="comment">//更新</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(u==fa&amp;&amp;child&gt;=<span class="number">2</span>) cut[u]=<span class="number">1</span>;<span class="comment">//如果根节点数量大于2,说明根节点可以成为割点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="缩点练习"><a href="#缩点练习" class="headerlink" title="缩点练习"></a>缩点练习</h1><p><a href="https://www.luogu.com.cn/problem/P2341">P2341 [USACO03FALL][HAOI2006]受欢迎的牛 G</a></p><p><a href="https://www.luogu.com.cn/problem/P2863">P2863 [USACO06JAN]The Cow Prom S</a></p><p><a href="https://www.luogu.com.cn/problem/P2746">P2746 [USACO5.3]校园网Network of Schools</a></p><p><a href="https://www.luogu.com.cn/problem/P1726">P1726 上白泽慧音</a></p><p><a href="https://www.luogu.com.cn/problem/P1262">P1262 间谍网络</a></p><p><a href="https://www.luogu.com.cn/problem/P5676">P5676 [GZOI2017]小z玩游戏</a></p><h2 id="P2341-USACO03FALL-受欢迎的牛-G"><a href="#P2341-USACO03FALL-受欢迎的牛-G" class="headerlink" title="P2341 [USACO03FALL]受欢迎的牛 G"></a>P2341 [USACO03FALL]受欢迎的牛 G</h2><p>$tarjan$经典题。</p><p>首先是缩点,将每个强联通分量都分成一个组,并记录这个组的出度和大小,如果只有一个组的出度为$0$,则说明该组中的所有奶牛都可以成为神犇(如果有两个组的出度均为零的话则说明%无法完全传递)</p><p>$code:$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">dfn[u] = low[u] = ++Time;</span><br><span class="line">vis[u] = <span class="number">1</span>,s[++top] = u;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = e[i].to;</span><br><span class="line"><span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line"><span class="built_in">tarjan</span>(v);</span><br><span class="line">low[u] = <span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(vis[v])&#123;</span><br><span class="line">low[u] = <span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dfn[u]==low[u])&#123;</span><br><span class="line"><span class="type">int</span> v;</span><br><span class="line">scc[u] = ++k;<span class="comment">//记录分组</span></span><br><span class="line"><span class="keyword">while</span>(v=s[top--])&#123;</span><br><span class="line">vis[v] = <span class="number">0</span>;</span><br><span class="line">scc[v] = k;<span class="comment">//记录分组</span></span><br><span class="line">size[k]++;<span class="comment">//记录大小</span></span><br><span class="line"><span class="keyword">if</span>(v==u) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P2863-USACO06JAN-The-Cow-Prom-S"><a href="#P2863-USACO06JAN-The-Cow-Prom-S" class="headerlink" title="[P2863 [USACO06JAN]The Cow Prom S]"></a>[P2863 [USACO06JAN]The Cow Prom S]</h2><p>简单的$tarjan$模板题。</p><p><del>实际上比模板题还要简单</del></p><p>判断栈头是否为$u$,若不为$u$,则说明有两个及以上的节点,若是,说明只有$u$一个节点</p><p>$code:$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">dfn[u] = low[u] = ++Time;</span><br><span class="line">vis[u] = <span class="number">1</span>,s[++top] = u;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = e[i].to;</span><br><span class="line"><span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line"><span class="built_in">tarjan</span>(v);</span><br><span class="line">low[u] = <span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(vis[v])&#123;</span><br><span class="line">low[u] = <span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dfn[u]==low[u])&#123;</span><br><span class="line"><span class="keyword">if</span>(s[top]!=u) ans++;<span class="comment">//特判</span></span><br><span class="line"><span class="type">int</span> v;</span><br><span class="line"><span class="keyword">while</span>(v=s[top--])&#123;</span><br><span class="line">vis[v] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(v==u) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2 id="P2746-USACO5-3-校园网Network-of-Schools"><a href="#P2746-USACO5-3-校园网Network-of-Schools" class="headerlink" title="[P2746 [USACO5.3]校园网Network of Schools]"></a>[P2746 [USACO5.3]校园网Network of Schools]</h2><p> 给一张图,求:</p><ul><li><p>图中入度为零的点的个数</p></li><li><p>把整张图变成强连通图的最少添边值</p></li></ul><p> 第一问很简单,直接统计一下即可,对于第二问,由于强连通图中每个点的入度和出度都不为零,感性理解一下,可以先将那些出度为0的点和入度为0的点互补,由于出度为0的点的数量和入度为0的点数量可能不一致,因此最后还要将那些剩余的点和其他任意一个点相连</p><p> 最后的答案即为出度为零的点的数量和入读为零的点的数量中的最大值。</p><p> $code:$<br> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=head[i];j;j=e[j].next)&#123;</span><br><span class="line"><span class="type">int</span> v = e[j].to;</span><br><span class="line"><span class="keyword">if</span>(scc[i]!=scc[v])&#123;</span><br><span class="line">in[scc[v]]++;<span class="comment">//记录入度</span></span><br><span class="line">out[scc[i]]++;<span class="comment">//记录出度</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ansin = <span class="number">0</span>,ansout = <span class="number">0</span>;<span class="comment">//出度数和入度数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(in[i]==<span class="number">0</span>)&#123;<span class="comment">//记录入度</span></span><br><span class="line">ansin++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(out[i]==<span class="number">0</span>)&#123;<span class="comment">//记录出度</span></span><br><span class="line">ansout++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">1</span>)&#123;<span class="comment">//特判,如果该图已经是一个强连通图了,直接输出1和0即可</span></span><br><span class="line">    cout&lt;&lt;<span class="number">1</span>&lt;&lt;endl&lt;&lt;<span class="number">0</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;ansin&lt;&lt;endl&lt;&lt;<span class="built_in">max</span>(ansin,ansout);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="P1726-上白泽慧音"><a href="#P1726-上白泽慧音" class="headerlink" title="P1726 上白泽慧音"></a>P1726 上白泽慧音</h2><p>车万题面好评</p><p>也是一道挺模板的题。</p><p>大致题意就是说求最大且字典序最小的那个强联通分量。</p><p>直接跑一遍$tarjan$记录每个点所在的强连通分量和该强联通分量的大小,然后一遍$for$循环求出最大的那个组,再将在那个组中的节点输出即可</p><p>$code:$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">dfn[u] = low[u] = ++Time;</span><br><span class="line">vis[u] = <span class="number">1</span>,s[++top] = u;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = e[i].to;</span><br><span class="line"><span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line"><span class="built_in">tarjan</span>(v);</span><br><span class="line">low[u] = <span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(vis[v])&#123;</span><br><span class="line">low[u] = <span class="built_in">min</span>(low[u],low[v]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dfn[u]==low[u])&#123;</span><br><span class="line"><span class="type">int</span> v;</span><br><span class="line"><span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line">scc[u] = ++k;<span class="comment">//新分组</span></span><br><span class="line"><span class="keyword">while</span>(v=s[top--])&#123;</span><br><span class="line">vis[v] = <span class="number">0</span>;</span><br><span class="line">scc[v] = k;<span class="comment">//记录每个点所在的组</span></span><br><span class="line">size[k]++;<span class="comment">//记录该组的大小</span></span><br><span class="line"><span class="keyword">if</span>(v==u) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P1262-间谍网络"><a href="#P1262-间谍网络" class="headerlink" title="P1262 间谍网络"></a>P1262 间谍网络</h2><p>直接跑一遍缩点，由于强连通分量中的每个点都是互相联通的,一个强联通分量中的最少花费资金也就是那个环里罪犯所需资金最小的</p><p>最后检查一下有无未访问的点,若有,直接输出$NO$,$return$,若无,那就接着记录每个点的入度,将入度为0的组的权值全部加起来即可</p><p>$code:$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">dfn[u] = low[u] = ++Time;</span><br><span class="line">s[++top] = u;</span><br><span class="line">vis[u] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line"><span class="built_in">tarjan</span>(v);</span><br><span class="line">low[u] = <span class="built_in">min</span>(low[v] , low[u]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(vis[v])&#123;</span><br><span class="line">low[u] = <span class="built_in">min</span>(low[v] , low[u]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(low[u]==dfn[u])&#123;</span><br><span class="line"><span class="type">int</span> v;</span><br><span class="line">tot++;</span><br><span class="line"><span class="keyword">while</span>(v = s[top--])&#123;</span><br><span class="line">vis[v] = <span class="number">0</span>;</span><br><span class="line">c[v] = tot;</span><br><span class="line">sum[tot] = <span class="built_in">min</span>(sum[tot],w[v]);<span class="comment">//取min</span></span><br><span class="line"><span class="keyword">if</span>(v==u) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P5676-GZOI2017-小z玩游戏"><a href="#P5676-GZOI2017-小z玩游戏" class="headerlink" title="P5676 [GZOI2017]小z玩游戏"></a>P5676 [GZOI2017]小z玩游戏</h2><p>对于这道题,首先想到的肯定是直接$n^2$建边</p><p>但会发现数据太大,复杂度接受不了</p><p>所以要考虑更优秀的建边方法</p><ul><li><p>建一个由有趣程度到游戏的边</p></li><li><p>建一个由游戏到兴趣程度的边</p></li><li><p>建立一个兴趣程度整数倍的边</p></li></ul><p>$code:$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="comment">//从有趣程度到该游戏</span></span><br><span class="line"><span class="type">int</span> u;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;u);</span><br><span class="line"><span class="built_in">add</span>(n+u,i);</span><br><span class="line">maxn = <span class="built_in">max</span>(maxn , u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="comment">//从该游戏到兴趣程度</span></span><br><span class="line"><span class="type">int</span> u;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;u);</span><br><span class="line"><span class="built_in">add</span>(i,n+u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=maxn;i++)&#123;<span class="comment">//兴趣程度的整数倍</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j*i&lt;=maxn;j++)&#123;</span><br><span class="line"><span class="built_in">add</span>(n+i,n+j*i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于那些存在兴趣程度整数倍的游戏,相当于是连上了两个游戏</p><p>而对于那些不存在的游戏,相当于是连了一个虚点,$rt$</p><p><img src="https://img2020.cnblogs.com/blog/2092833/202008/2092833-20200812155727508-655328923.png"></p><h1 id="割点练习"><a href="#割点练习" class="headerlink" title="割点练习"></a>割点练习</h1><p><a href="https://www.luogu.com.cn/problem/P5058">P5058 [ZJOI2004]嗅探器</a></p><p><a href="https://www.luogu.com.cn/problem/P3225">P3225 [HNOI2012]矿场搭建</a></p><h2 id="P5058-ZJOI2004-嗅探器"><a href="#P5058-ZJOI2004-嗅探器" class="headerlink" title="P5058 [ZJOI2004]嗅探器"></a><a href="https://www.luogu.com.cn/problem/P5058">P5058 [ZJOI2004]嗅探器</a></h2><p>要满足同时能收到$A$和$B$的信息的话要满足两个条件:</p><ul><li><p>$u$是割点</p></li><li><p>$A$或$B$在$v$子树内（包括$v$)且$B$或$A$不在$v$子树内(这样才能把$A$,$B$两个点的信号都收集到)</p></li></ul><p>因此,如果要成为满足条件的点,必须要满足:</p><ul><li>$dfn[v]&lt;&#x3D;dfn[a]$&amp;&amp;$dfn[v]&gt;dfn[b]$ ($A$在子树内,$B$不在)</li></ul><p>或</p><ul><li>$dfn[v]&lt;&#x3D;dfn[b]$&amp;&amp;dfn$[v]&gt;dfn[a]$($B$在子树内,$A$不在)</li></ul><p>$code:$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">dfn[u] = low[u] = ++Time;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = edge[i].to;</span><br><span class="line"><span class="keyword">if</span>(!dfn[v])&#123;</span><br><span class="line"><span class="built_in">tarjan</span>(v,u);</span><br><span class="line">low[u] = <span class="built_in">min</span>(low[v] , low[u]);</span><br><span class="line"><span class="keyword">if</span>(low[v]&gt;=dfn[u]&amp;&amp;u!=a&amp;&amp;u!=b&amp;&amp;dfn[v]&lt;=dfn[a]&amp;&amp;dfn[v]&gt;dfn[b])&#123;<span class="comment">//第一种情况</span></span><br><span class="line">ans = <span class="built_in">min</span>(ans , u);<span class="comment">//取最小的点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(low[v]&gt;=dfn[u]&amp;&amp;u!=a&amp;&amp;u!=b&amp;&amp;dfn[v]&lt;=dfn[b]&amp;&amp;dfn[v]&gt;dfn[a])&#123;<span class="comment">//第二种情况</span></span><br><span class="line">ans = <span class="built_in">min</span>(ans , u);<span class="comment">//取最小的点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(v!=fa) low[u] = <span class="built_in">min</span>(low[u] , dfn[v]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树链剖分学习笔记</title>
      <link href="/2020/08/07/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/08/07/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p> 树链剖分，就是将一颗树分成若干个编号连续的链,将树上问题转换为线性问题,降低问题的处理难度。</p><h2 id="模板题-P3384-【模板】轻重链剖分"><a href="#模板题-P3384-【模板】轻重链剖分" class="headerlink" title="模板题:P3384 【模板】轻重链剖分"></a>模板题:<a href="https://www.luogu.com.cn/problem/P3384">P3384 【模板】轻重链剖分</a></h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给一颗节点数为$n$的带点权树,有以下几种操作:</p><ul><li><p>将树从 $x$ 到 $y$ 结点最短路径上所有节点的值都加上 $z$</p></li><li><p>求从 $x$ 到 $y$ 节点最短路径上的所有 节点值之和</p></li><li><p>以 $x$ 为根节点的子树内所有节点值都加上 $z$。</p></li><li><p>求以 $x$ 为根节点的子树内所有节点值之和</p></li></ul><p>数据范围:$1\le N\le10^5$</p><h2 id="一些定义"><a href="#一些定义" class="headerlink" title="一些定义"></a>一些定义</h2><ul><li><p>重儿子：以一个非叶子节点中的一个儿子为根的子树最大的那一个儿子称为重儿子</p></li><li><p>轻儿子：一个非叶子节点中除了重儿子以外的儿子</p></li><li><p>重边：结点与其重儿子的边称为重边</p></li><li><p>轻边：结点与其轻儿子的边称为轻边</p></li><li><p>重链：由重边组成的路径</p></li><li><p>轻链：由轻边组成的路径</p></li></ul><h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><p>首先是两次$DFS$</p><p>第一次求出子树大小,父节点,深度,重儿子这些之后要用的东西</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> f,<span class="type">int</span> deep)</span></span>&#123;</span><br><span class="line">dep[u] = deep;<span class="comment">//深度</span></span><br><span class="line">fa[u] = f;<span class="comment">//父亲节点</span></span><br><span class="line">size[u] = <span class="number">1</span>;<span class="comment">//初始化子树大小</span></span><br><span class="line"><span class="type">int</span> maxson = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i = e[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = e[i].v;</span><br><span class="line"><span class="keyword">if</span>(v==f) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs1</span>(v,u,deep+<span class="number">1</span>);</span><br><span class="line">size[u]+=size[v];</span><br><span class="line">    <span class="keyword">if</span>(size[v]&gt;maxson) son[u] = v,maxson = size[v];<span class="comment">//重儿子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二次$dfs$则是将树上的节点重新编号,划分成若干条链</p><p><strong>每次都去选取自己的重儿子进行连接</strong>,这样可以尽可能的让一条链够长</p><p>其余的轻儿子则作为另一条链的开头</p><p>画成图的话大概是这样:</p><p>(ps:图中的红色节点均为重儿子)</p><p><img src="https://img2020.cnblogs.com/blog/2092833/202008/2092833-20200807180043859-1789457354.png"></p><p>代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> topf)</span></span>&#123;<span class="comment">//topf为一条链的头</span></span><br><span class="line">id[u] = ++tot;<span class="comment">//重新编号,赋值</span></span><br><span class="line">val[tot] = w[u];</span><br><span class="line">top[u] = topf;<span class="comment">//记录链头,之后有用</span></span><br><span class="line"><span class="keyword">if</span>(!son[u]) <span class="keyword">return</span>;<span class="comment">//为叶子节点</span></span><br><span class="line"><span class="built_in">dfs2</span>(son[u],topf);<span class="comment">//以重儿子向下继续连接</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;<span class="comment">//</span></span><br><span class="line"><span class="type">int</span> v = e[i].v;</span><br><span class="line"><span class="keyword">if</span>(v==fa[u]||v==son[u]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs2</span>(v,v);其余的边则作为新一条链的开头</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用线段树维护这些链</p><p>对于操作1跟操作2</p><p>每次查询和修改从u到v的路径时</p><p>只需将低的那个点跳到上条链的结尾,也就是自己所在的链的头的父节点,同时查询&#x2F;修改跳过的这段链的值即可</p><p><img src="https://img-blog.csdnimg.cn/20200807175445981.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTc0NTMw,size_16,color_FFFFFF,t_70"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">qb</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;<span class="comment">//操作1~5</span></span><br><span class="line"><span class="keyword">while</span>(top[u]!=top[v])&#123;<span class="comment">//如果不在同一条链上</span></span><br><span class="line"><span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]]) <span class="built_in">swap</span>(u,v);<span class="comment">//跳高度低的那个</span></span><br><span class="line">ans+=<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[top[u]],id[u]);<span class="comment">//查询该端的值,修改也同理</span></span><br><span class="line">ans%=mo;</span><br><span class="line">u = fa[top[u]];<span class="comment">//跳到链头的父节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dep[u]&gt;dep[v]) <span class="built_in">swap</span>(u,v);</span><br><span class="line">ans+=<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[u],id[v]);<span class="comment">//操作6</span></span><br><span class="line">ans%=mo;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于操作$3,4$,由于是$dfs$,其子树的编号也一定是连续的</p><p>直接查询&#x2F;修改区间$[id[u],id[u]+size[u]-1]$即可</p><p>($id[u]$为该节点重组后的编号,$size[u]$为子树大小)</p><p>代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson (node&lt;&lt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson (node&lt;&lt;1|1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mid ((l+r)&gt;&gt;1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> len (r-l+1)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">200000</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">e</span>&#123;</span><br><span class="line"><span class="type">int</span> u,v,next;</span><br><span class="line">&#125;edge[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> w[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> n,m,mo;</span><br><span class="line"><span class="type">int</span> head[MAXN&lt;&lt;<span class="number">2</span>],cnt = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> dep[MAXN],fa[MAXN],son[MAXN],size[MAXN];</span><br><span class="line"><span class="type">int</span> id[MAXN],val[MAXN],top[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">edge[cnt].u=u;</span><br><span class="line">    edge[cnt].v=v;</span><br><span class="line">    edge[cnt].next=head[u];</span><br><span class="line">    head[u]=cnt++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> f,<span class="type">int</span> deep)</span></span>&#123;</span><br><span class="line">dep[x] = deep;</span><br><span class="line">fa[x] = f;</span><br><span class="line">size[x] = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> maxson = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v= edge[i].v;</span><br><span class="line"><span class="keyword">if</span>(v==f) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs1</span>(v,x,deep+<span class="number">1</span>);</span><br><span class="line">size[x]+=size[v];</span><br><span class="line"><span class="keyword">if</span>(size[v]&gt;maxson) son[x] = v,maxson = size[v];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> topf)</span></span>&#123;</span><br><span class="line">id[x] = ++tot;</span><br><span class="line">val[tot] = w[x];</span><br><span class="line">top[x] = topf;</span><br><span class="line"><span class="keyword">if</span>(!son[x]) <span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">dfs2</span>(son[x],topf);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = edge[i].v;</span><br><span class="line"><span class="keyword">if</span>(v==fa[x]||v==son[x]) <span class="keyword">continue</span>;</span><br><span class="line"><span class="built_in">dfs2</span>(v,v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st</span>&#123;</span><br><span class="line"><span class="type">int</span> sum;</span><br><span class="line"><span class="type">int</span> tag;</span><br><span class="line">&#125;tree[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;</span><br><span class="line">tree[node].sum = (tree[lson].sum + tree[rson].sum)%mo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">tree[node].sum = val[l];</span><br><span class="line"><span class="keyword">if</span>(tree[node].sum&gt;mo) tree[node].sum%=mo;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">build</span>(lson,l,mid);</span><br><span class="line"><span class="built_in">build</span>(rson,mid+<span class="number">1</span>,r);</span><br><span class="line"><span class="built_in">pushup</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tree[node].tag==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    tree[lson].tag+=tree[node].tag;</span><br><span class="line">    tree[rson].tag+=tree[node].tag;</span><br><span class="line">    tree[lson].sum+=tree[node].tag*(len-(len&gt;&gt;<span class="number">1</span>));</span><br><span class="line">    tree[rson].sum+=tree[node].tag*(len&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    tree[lson].tag%=mo;</span><br><span class="line">    tree[rson].tag%=mo;</span><br><span class="line">tree[lson].sum%=mo;</span><br><span class="line">tree[rson].sum%=mo;</span><br><span class="line">tree[node].tag = <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=l&amp;&amp;r&lt;=y)&#123;</span><br><span class="line">tree[node].tag+=k;</span><br><span class="line">tree[node].sum+=k*(r-l+<span class="number">1</span>);</span><br><span class="line">tree[node].tag%=mo;</span><br><span class="line">tree[node].sum%=mo;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pushdown</span>(node,l,r);</span><br><span class="line"><span class="keyword">if</span>(x&lt;=mid) <span class="built_in">change</span>(lson,l,mid,x,y,k);</span><br><span class="line"><span class="keyword">if</span>(y&gt;mid) <span class="built_in">change</span>(rson,mid+<span class="number">1</span>,r,x,y,k);</span><br><span class="line"><span class="built_in">pushup</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(x&lt;=l&amp;&amp;r&lt;=y)&#123;</span><br><span class="line"><span class="keyword">return</span> tree[node].sum%mo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pushdown</span>(node,l,r);</span><br><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=mid) res+=<span class="built_in">query</span>(lson,l,mid,x,y);</span><br><span class="line"><span class="keyword">if</span>(y&gt;mid) res+=<span class="built_in">query</span>(rson,mid+<span class="number">1</span>,r,x,y);</span><br><span class="line">res%=mo;</span><br><span class="line"><span class="keyword">return</span> res%mo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">cout&lt;&lt;tree[node].sum&lt;&lt;<span class="string">&quot;  &quot;</span>&lt;&lt;tree[node].tag&lt;&lt;endl;</span><br><span class="line"><span class="keyword">if</span>(l==r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">test</span>(lson,l,mid);</span><br><span class="line">    <span class="built_in">test</span>(rson,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">qb</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(top[u]!=top[v])&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]]) <span class="built_in">swap</span>(u,v);</span><br><span class="line">ans+=<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[top[u]],id[u]);</span><br><span class="line">ans%=mo;</span><br><span class="line">u = fa[top[u]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dep[u]&gt;dep[v]) <span class="built_in">swap</span>(u,v);</span><br><span class="line">ans+=<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[u],id[v]);</span><br><span class="line">ans%=mo;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ub</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(top[u]!=top[v])&#123;</span><br><span class="line"><span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]]) <span class="built_in">swap</span>(u,v);</span><br><span class="line"><span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[top[u]],id[u],k);</span><br><span class="line">u = fa[top[u]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(dep[u]&gt;dep[v]) <span class="built_in">swap</span>(u,v);</span><br><span class="line"><span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[u],id[v],k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> root;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;root,&amp;mo);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w[i]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="type">int</span> u,v;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">    <span class="built_in">add</span>(u,v);</span><br><span class="line">    <span class="built_in">add</span>(v,u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs1</span>(root,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">dfs2</span>(root,root);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">cout&lt;&lt;dep[i]&lt;&lt;<span class="string">&quot;  &quot;</span>&lt;&lt;val[i]&lt;&lt;<span class="string">&quot;  &quot;</span>&lt;&lt;size[i]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line"><span class="type">int</span> k,x,y,z;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k);</span><br><span class="line"><span class="keyword">if</span>(k==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line"><span class="built_in">ub</span>(x,y,z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(k==<span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">qb</span>(x,y));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(k==<span class="number">3</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y);</span><br><span class="line"><span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[x],id[x]+size[x]<span class="number">-1</span>,y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,id[x],id[x]+size[x]<span class="number">-1</span>)%mo);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><del>话说树剖的好多题都好裸啊</del></p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础线段树</title>
      <link href="/2020/08/06/%E5%9F%BA%E7%A1%80%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
      <url>/2020/08/06/%E5%9F%BA%E7%A1%80%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><h2 id="P3373-【模板】线段树-2"><a href="#P3373-【模板】线段树-2" class="headerlink" title="P3373 【模板】线段树 2"></a><a href="https://www.luogu.com.cn/problem/P3373">P3373 【模板】线段树 2</a></h2><p>设$mtag$为乘法标记,$atag$为加法标记</p><p>对于下放后的每一个区间来说,$x&#x3D;x<em>mtag+atag</em>len$(式$1$)</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/tbtb4rli.png"></p><p>$x&#x3D;x\cdot mtag_2+len\cdot atag_2&#x3D;(x\cdot mtag_2+len\cdot atag_2)\cdot mtag_1+atag_1\cdot len$</p><p>$&#x3D;x\cdot mtag_2\cdot mtag_1+len*atag_2\cdot mtag_1+atag_1\cdot len$</p><p>$&#x3D;x\cdot (mtag_2\cdot mtag_1)+len\cdot (atag_2\cdot mtag_1+atag_1)$</p><p>再根据前面的式$1$,易得</p><p>$mtag_2 &#x3D; mtag_1\cdot mtag_2$</p><p>$atag_2&#x3D;atag_2\cdot mtag_1+atag_2$</p><p>核心(下放)代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(tree2 *tree,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(tree-&gt;lazym==<span class="number">1</span>&amp;&amp;tree-&gt;lazyp==<span class="number">0</span>||tree-&gt;lson==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">tree-&gt;lson-&gt;x = (tree-&gt;lson-&gt;x*tree-&gt;lazym+(<span class="type">long</span> <span class="type">long</span>)tree-&gt;lazyp*(mid-l+<span class="number">1</span>))%mo;</span><br><span class="line">tree-&gt;rson-&gt;x = (tree-&gt;rson-&gt;x*tree-&gt;lazym+(<span class="type">long</span> <span class="type">long</span>)tree-&gt;lazyp*(r-mid))%mo;</span><br><span class="line">tree-&gt;lson-&gt;lazym = (tree-&gt;lazym*tree-&gt;lson-&gt;lazym)%mo;</span><br><span class="line">tree-&gt;rson-&gt;lazym = (tree-&gt;lazym*tree-&gt;rson-&gt;lazym)%mo;</span><br><span class="line">tree-&gt;lson-&gt;lazyp = (tree-&gt;lazym*tree-&gt;lson-&gt;lazyp+tree-&gt;lazyp)%mo;</span><br><span class="line">tree-&gt;rson-&gt;lazyp = (tree-&gt;lazym*tree-&gt;rson-&gt;lazyp+tree-&gt;lazyp)%mo;</span><br><span class="line">tree-&gt;lazym  = <span class="number">1</span>;</span><br><span class="line">tree-&gt;lazyp = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="基础练习题"><a href="#基础练习题" class="headerlink" title="基础练习题"></a>基础练习题</h1><p><strong><a href="https://www.luogu.com.cn/problem/P4145">P4145 上帝造题的七分钟2 &#x2F; 花神游历各国</a></strong></p><p><strong><a href="https://www.luogu.com.cn/problem/P6327">P6327 区间加区间sin和</a></strong></p><p><strong><a href="https://www.luogu.com.cn/problem/P1438">P1438 无聊的数列</a></strong></p><p><strong><a href="https://www.luogu.com.cn/problem/P4513">P4513 小白逛公园</a></strong></p><p><strong><a href="https://www.luogu.com.cn/problem/P4588">P4588 [TJOI2018]数学计算</a></strong></p><p><strong><a href="https://www.luogu.com.cn/problem/P2894">P2894 [USACO08FEB]Hotel G</a></strong></p><h2 id="P4145-上帝造题的七分钟2-x2F-花神游历各国"><a href="#P4145-上帝造题的七分钟2-x2F-花神游历各国" class="headerlink" title="P4145 上帝造题的七分钟2 &#x2F; 花神游历各国"></a>P4145 上帝造题的七分钟2 &#x2F; 花神游历各国</h2><p>照题里的这个数据范围来看,直接暴力开方肯定会T飞</p><p>通过观察,不难发现数据范围内最大的数也只需要$6$次开方就可以变为$1$</p><p>考虑剪枝优化：</p><p>当一个区间的最大值为$1$时,其整个区间的其他值肯定也为$1$</p><p>因此当区间内最大值等于$1$时,直接$return$掉</p><p>核心代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> L = tree[node].l,R = tree[node].r;</span><br><span class="line"><span class="keyword">if</span>(L==R)&#123;</span><br><span class="line">tree[node].sum = <span class="built_in">sqrt</span>(tree[node].sum);</span><br><span class="line">tree[node].maxn = <span class="built_in">sqrt</span>(tree[node].maxn);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid = (L+R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid&amp;&amp;tree[lson].maxn&gt;<span class="number">1</span>)&#123;<span class="comment">//最大值大于1时在进行修改操作</span></span><br><span class="line"><span class="built_in">change</span>(lson,l,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(r&gt;mid&amp;&amp;tree[rson].maxn&gt;<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">change</span>(rson,l,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pushup</span>(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P6327-区间加区间sin和"><a href="#P6327-区间加区间sin和" class="headerlink" title="P6327 区间加区间sin和"></a>P6327 区间加区间sin和</h2><p>挺好的一道题目,很适合线段树初学者练手</p><p>学过和差角公式的应该都能很快想出解法</p><p>$sin(a+x) &#x3D; sinacosx+cosasinx$</p><p>$cos(a+x) &#x3D; cosacosx-sinxsina$</p><p>只需要在线段树里维护一个$sinx$和一个$cosx$即可</p><p>核心代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update2</span><span class="params">(<span class="type">int</span> node,<span class="type">double</span> sinv,<span class="type">double</span> cosv)</span></span>&#123;<span class="comment">//和差角公式</span></span><br><span class="line"><span class="type">double</span> cosa = tree[node].cosx;</span><br><span class="line">        <span class="type">double</span> sina = tree[node].sinx;</span><br><span class="line">tree[node].cosx = cosa*cosv-sina*sinv;</span><br><span class="line">tree[node].sinx = sina*cosv+cosa*sinv;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;<span class="comment">//下放</span></span><br><span class="line"><span class="keyword">if</span>(tree[node].tag)&#123;</span><br><span class="line"><span class="type">double</span> cosa = <span class="built_in">cos</span>(tree[node].tag),sina = <span class="built_in">sin</span>(tree[node].tag);</span><br><span class="line"><span class="built_in">update2</span>(lson,sina,cosa);<span class="comment">//更新儿子的值</span></span><br><span class="line"><span class="built_in">update2</span>(rson,sina,cosa);</span><br><span class="line">tree[lson].tag+=tree[node].tag;<span class="comment">//更新儿子的tag</span></span><br><span class="line">tree[rson].tag+=tree[node].tag;</span><br><span class="line">tree[node].tag = <span class="number">0</span>;b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span>&#123;<span class="comment">//更新操作</span></span><br><span class="line"><span class="type">int</span> L = tree[node].l,R = tree[node].r;</span><br><span class="line"><span class="keyword">if</span>(R&lt;=r&amp;&amp;L&gt;=l)&#123;<span class="comment">//包围在区间内,直接修改</span></span><br><span class="line">tree[node].tag+=x;</span><br><span class="line"><span class="built_in">update2</span>(node,<span class="built_in">sin</span>(x),<span class="built_in">cos</span>(x));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pushdown</span>(node);<span class="comment">//下放</span></span><br><span class="line"><span class="type">int</span> mid = (L + R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid) <span class="built_in">change</span>(lson,l,r,x);</span><br><span class="line"><span class="keyword">if</span>(r&gt;mid) <span class="built_in">change</span>(rson,l,r,x);</span><br><span class="line"><span class="built_in">update</span>(node);<span class="comment">//上传更新</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P1438-无聊的数列"><a href="#P1438-无聊的数列" class="headerlink" title="P1438 无聊的数列"></a>P1438 无聊的数列</h2><p>利用线段树来维护差分数组。</p><p>每当进行一个操作$1$时</p><p>将点$l$加上首相$k$</p><p>如果区间不是一个点的话,则将区间$[l+1,r]$上的点都加上公差$d$</p><p>如果$r&lt;n$,则在$r+1$的位置上加上$-(k+(r-l)\cdot d))$,便于差分</p><p>查询时,将区间$[1,k]$的值都加上即可,相当于查询操作</p><p>区间查询,区间修改,直接上线段树模板即可</p><p>核心代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="type">int</span> mode,l,r,k,d;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;mode);</span><br><span class="line"><span class="keyword">if</span>(mode==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;l,&amp;r,&amp;k,&amp;d);</span><br><span class="line"><span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,n,l,l,k);<span class="comment">//修改左端点</span></span><br><span class="line"><span class="keyword">if</span>(l!=r) <span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,n,l+<span class="number">1</span>,r,d);<span class="comment">//修改区间</span></span><br><span class="line"><span class="keyword">if</span>(r+<span class="number">1</span>&lt;=n) <span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,n,r+<span class="number">1</span>,r+<span class="number">1</span>,-(k+(r-l)*d));<span class="comment">//修改右端点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;d);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">query</span>(<span class="number">1</span>,<span class="number">1</span>,n,<span class="number">1</span>,d)+a[d]);<span class="comment">//差分数组的值+原值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P4513-小白逛公园"><a href="#P4513-小白逛公园" class="headerlink" title="P4513 小白逛公园"></a>P4513 小白逛公园</h2><p>线段树经典题</p><p>维护一个从区间左端点开始的区间最大子段$maxl$,从右端点开始的区间最大子段$maxr$,总区间最大子段$maxx$,和一个区间和$sum$</p><p>对于$maxl$来说,其右端点的位置有两种可能:</p><ul><li><p>在左儿子中</p></li><li><p>在右儿子中</p></li></ul><p>得到方程:$tree.maxl &#x3D; max(lson.maxl,lson.sum+rson.maxl)$</p><p>$maxr$也同理</p><p>方程:$tree.maxr &#x3D; max(rson.maxr,rson.sum+lson.maxr)$</p><p>对于$maxx$来说，其区间范围有三种可能</p><ul><li><p>只在左儿子中</p></li><li><p>只在右儿子中</p></li><li><p>既在左儿子中也在右儿子中</p></li></ul><p>得到方程:$tree.maxx &#x3D; max(lson.maxx,rson.maxx,lson.maxr+rson.maxl))$</p><p>查询时只需输出区间$[l,r]$中的$maxx$即可</p><p>核心代码:</p><p>更新操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(tree2 *tree,tree2 *lson,tree2 *rson)</span></span>&#123;</span><br><span class="line">tree-&gt;sum = lson-&gt;sum+rson-&gt;sum;</span><br><span class="line">tree-&gt;maxl = <span class="built_in">max</span>(lson-&gt;maxl,lson-&gt;sum+rson-&gt;maxl);</span><br><span class="line">tree-&gt;maxr = <span class="built_in">max</span>(rson-&gt;maxr,rson-&gt;sum+lson-&gt;maxr);</span><br><span class="line">tree-&gt;maxX = <span class="built_in">max</span>(lson-&gt;maxX,<span class="built_in">max</span>(rson-&gt;maxX,lson-&gt;maxr+rson-&gt;maxl));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查询操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">tree2 *<span class="title">query</span><span class="params">(tree2 *tree,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=l&amp;&amp;y&gt;=r)</span><br><span class="line"><span class="keyword">return</span> tree;</span><br><span class="line"><span class="type">int</span> mid = (l + r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">tree2 *t1 = <span class="literal">NULL</span>,*t2 = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=mid) t1 = <span class="built_in">query</span>(tree-&gt;lson,l,mid,x,y);</span><br><span class="line"><span class="keyword">if</span>(y&gt;mid) t2 = <span class="built_in">query</span>(tree-&gt;rson,mid+<span class="number">1</span>,r,x,y);</span><br><span class="line"><span class="keyword">if</span>(t1==<span class="literal">NULL</span>) <span class="keyword">return</span> t2;</span><br><span class="line"><span class="keyword">if</span>(t2==<span class="literal">NULL</span>) <span class="keyword">return</span> t1;</span><br><span class="line">tree2 *ret = &amp;dizhi[++t];</span><br><span class="line"><span class="built_in">update</span>(ret,t1,t2);</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="P4588-TJOI2018-数学计算"><a href="#P4588-TJOI2018-数学计算" class="headerlink" title="P4588 [TJOI2018]数学计算"></a>P4588 [TJOI2018]数学计算</h2><p>比较简单的一道题目。</p><p>仔细观察不难发现</p><p>所谓的操作$1$跟操作$2$其实就是在进行普通的单点修改操作而已</p><p>用一个线段树在记录一段区间内的总乘积</p><p>操作$1$是把点$i$的值从$1$修改为$i$</p><p>操作$2$则是把点$pos$的值修改为$1$</p><p>核心代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;</span><br><span class="line">tree[node].val = (tree[lson].val*tree[rson].val)%mo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">tree[node].val = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> mid = (l + r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">build</span>(lson,l,mid);</span><br><span class="line"><span class="built_in">build</span>(rson,mid+<span class="number">1</span>,r);</span><br><span class="line"><span class="built_in">pushup</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">tree[node].val = y;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid = (l + r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=mid) <span class="built_in">change</span>(lson,l,mid,x,y);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">change</span>(rson,mid+<span class="number">1</span>,r,x,y);</span><br><span class="line"><span class="built_in">pushup</span>(node);</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><h2 id="P2894-USACO08FEB-Hotel-G"><a href="#P2894-USACO08FEB-Hotel-G" class="headerlink" title="P2894 [USACO08FEB]Hotel G"></a>P2894 [USACO08FEB]Hotel G</h2><p>跟<a href="https://www.luogu.com.cn/problem/P4513"><strong>P4513 小白逛公园</strong></a>大同小异的思路</p><p>只是把单点修改操作换成了区间修改罢了</p><p>要注意的是这里不存在负值的情况</p><p>因此在上传操作时转移没那么复杂,只用判断$maxl$是否等于$sum$</p><p>若等于,说明左儿子中房间全为空,直接全部加上,再加上右儿子的$maxl$</p><p>若不等于,则为左儿子的$maxl$</p><p>$maxr$也同理</p><p>同时也要注意这里的查询查的是满足长度为$x$的最左的端点</p><p>因此在查询时要满足”能左则左”</p><p>核心代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;<span class="comment">//上传</span></span><br><span class="line"><span class="keyword">if</span>(tree[lson].maxx==tree[lson].sum)&#123;<span class="comment">//如果左区间全为空房</span></span><br><span class="line">tree[node].lmax = tree[lson].sum+tree[rson].lmax;<span class="comment">//全部加上</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">tree[node].lmax = tree[lson].lmax;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(tree[rson].maxx==tree[rson].sum)&#123;</span><br><span class="line">tree[node].rmax = tree[rson].sum+tree[lson].rmax;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">tree[node].rmax = tree[rson].rmax;</span><br><span class="line">&#125;</span><br><span class="line">tree[node].maxx = <span class="built_in">max</span>(tree[lson].rmax+tree[rson].lmax,<span class="built_in">max</span>(tree[lson].maxx,tree[rson].maxx));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">tree[node].sum = tree[node].lmax = tree[node].rmax = tree[node].maxx =r-l+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">build</span>(lson,l,mid);</span><br><span class="line"><span class="built_in">build</span>(rson,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;<span class="comment">//下放</span></span><br><span class="line"><span class="keyword">if</span>(tree[node].lazy==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span>(tree[node].lazy==<span class="number">1</span>)&#123;<span class="comment">//退房</span></span><br><span class="line">tree[lson].maxx = tree[lson].rmax = tree[lson].lmax = <span class="number">0</span>;</span><br><span class="line">tree[rson].maxx = tree[rson].rmax = tree[rson].lmax = <span class="number">0</span>;</span><br><span class="line">tree[lson].lazy = tree[rson].lazy = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(tree[node].lazy==<span class="number">2</span>)&#123;<span class="comment">//开房</span></span><br><span class="line">tree[lson].maxx = tree[lson].rmax = tree[lson].lmax = tree[lson].sum;</span><br><span class="line">tree[rson].maxx = tree[rson].rmax = tree[rson].lmax = tree[rson].sum;</span><br><span class="line">tree[lson].lazy = tree[rson].lazy = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">tree[node].lazy = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> opt)</span></span>&#123;<span class="comment">//opt为1代表退房,为2代表开房</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(x&lt;=l&amp;&amp;y&gt;=r)&#123;</span><br><span class="line"><span class="keyword">if</span>(opt==<span class="number">1</span>) tree[node].maxx = tree[node].lmax = tree[node].rmax = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> tree[node].maxx = tree[node].lmax = tree[node].rmax = tree[node].sum;</span><br><span class="line"></span><br><span class="line">tree[node].lazy = opt;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pushdown</span>(node);</span><br><span class="line"><span class="keyword">if</span>(x&lt;=mid) <span class="built_in">change</span>(lson,l,mid,x,y,opt);</span><br><span class="line"><span class="keyword">if</span>(y&gt;mid) <span class="built_in">change</span>(rson,mid+<span class="number">1</span>,r,x,y,opt);</span><br><span class="line"><span class="built_in">pushup</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x)</span></span>&#123;<span class="comment">//查询</span></span><br><span class="line"><span class="built_in">pushdown</span>(node);</span><br><span class="line"><span class="keyword">if</span>(l==r) <span class="keyword">return</span> l;</span><br><span class="line"><span class="keyword">if</span>(tree[lson].maxx&gt;=x)&#123;<span class="comment">//如果左区间的最大值大于x,直接查左边</span></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">query</span>(lson,l,mid,x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(tree[lson].rmax+tree[rson].lmax&gt;=x)&#123;<span class="comment">//如果中间大于x</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>+mid-tree[lson].rmax;左儿子的右最大值,也就是最靠近左边的端点</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">query</span>(rson,mid+<span class="number">1</span>,r,x);<span class="comment">//否则查右边</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态开点"><a href="#动态开点" class="headerlink" title="动态开点"></a>动态开点</h2><p><strong><a href="https://www.luogu.com.cn/problem/P5459">P5459 [BJOI2016]回转寿司</a></strong></p><p><strong><a href="https://www.luogu.com.cn/problem/CF915E">CF915E Physical Education Lessons</a></strong></p><p>$now ~ loading…$</p><h2 id="扫描线"><a href="#扫描线" class="headerlink" title="扫描线"></a>扫描线</h2><p><strong><a href="https://www.luogu.com.cn/problem/P5490">P5490 【模板】扫描线</a></strong></p><p><strong><a href="https://www.luogu.com.cn/problem/P1502">P1502 窗口的星星</a></strong></p><p>$now ~ loading…$</p><p>&#96;&#96;</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P5459 [BJOI2016]回转寿司</title>
      <link href="/2020/08/05/p5459/"/>
      <url>/2020/08/05/p5459/</url>
      
        <content type="html"><![CDATA[<h1 id="P5459-BJOI2016-回转寿司-题解"><a href="#P5459-BJOI2016-回转寿司-题解" class="headerlink" title="P5459 [BJOI2016]回转寿司 题解"></a>P5459 [BJOI2016]回转寿司 题解</h1><h2 id="间隙"><a href="#间隙" class="headerlink" title="间隙"></a><a href="https://www.luogu.com.cn/problem/P5459">间隙</a></h2><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><ul><li><h2 id="前缀和-权值线段树-动态开点"><a href="#前缀和-权值线段树-动态开点" class="headerlink" title="前缀和,权值线段树,动态开点"></a>前缀和,权值线段树,动态开点</h2></li></ul><p>如果您还不会权值线段树跟动态开点的话,推荐去看一下<a href="https://www.bilibili.com/video/BV1Zg4y1q7aY?t=1726"><strong>这个教程</strong></a></p><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给一个序列,现从中取出一段连续子序列,使其子序列内数值总和$a$满足$L\le a\le R$</p><p>求总方案数。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>区间求和,很容易先联想到前缀和</p><p>不妨先设$sum[i]$为前$i$个数的前缀和</p><p>易得式子:</p><p>$L \le sum[r] - sum[l-1] \le R$</p><p>移项一下</p><p>$sum[r]-L \le sum[l-1]  \le sum[r]-R $</p><p>这样原问题就转化为了<strong>在区间$[sum[r]-L,sum[r]-R]$中有多少个$sum[l-1]$($l \in[1,r]$ )</strong></p><p><strong>每一个$r$也就相当于是查询区间$[sum[r]-L,sum[r]-R]$中$sum[l-1]$的总和</strong>($l \in[1,r]$ )</p><p>可以使用权值线段树$+$动态开点来维护。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>从$1$~$n$枚举$r$的值,把每一个$r$当作一次”查询”</p><p>同时不要忘记在进行下一次”查询” 前把 $l$ 的值 “更新”(指插入新的值)</p><p>具体的注释里有讲</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> MAXN = <span class="number">1e10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> sum[N];<span class="comment">//前缀和 </span></span><br><span class="line"><span class="type">int</span> n,l,r;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> tot = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st</span>&#123;</span><br><span class="line"><span class="type">int</span> l,r,sum;<span class="comment">//左儿子,右儿子,总方案数 </span></span><br><span class="line">&#125;tree[N&lt;&lt;<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;<span class="comment">//上传操作 </span></span><br><span class="line">tree[node].sum = tree[tree[node].l].sum+tree[tree[node].r].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> &amp;node,<span class="type">long</span> <span class="type">long</span> x,<span class="type">long</span> <span class="type">long</span> l = -MAXN , <span class="type">long</span> <span class="type">long</span> r = MAXN)</span></span>&#123;<span class="comment">//更新 注意,l的初始值要设成负数,一开始在这里卡了好久\kk </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!node) node = ++tot;<span class="comment">//动态开点 </span></span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;<span class="comment">//如果为根节点 </span></span><br><span class="line">tree[node].sum++;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> mid = (l + r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=mid) <span class="built_in">update</span>(tree[node].l,x,l,mid);</span><br><span class="line"><span class="keyword">else</span> <span class="built_in">update</span>(tree[node].r,x,mid+<span class="number">1</span>,r);</span><br><span class="line"><span class="built_in">pushup</span>(node);<span class="comment">//更新父节点的值 </span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">query</span><span class="params">(<span class="type">int</span> &amp;node,<span class="type">long</span> <span class="type">long</span> x,<span class="type">long</span> <span class="type">long</span> y,<span class="type">long</span> <span class="type">long</span> l =-MAXN,<span class="type">long</span> <span class="type">long</span> r = MAXN)</span></span>&#123;<span class="comment">//查询操作 </span></span><br><span class="line"><span class="keyword">if</span>(!node) node = ++tot;<span class="comment">//动态开点 </span></span><br><span class="line"><span class="keyword">if</span>(x&lt;=l&amp;&amp;y&gt;=r)&#123;<span class="comment">//包含在查询范围内 </span></span><br><span class="line"><span class="keyword">return</span> tree[node].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(x&lt;=mid) res+=<span class="built_in">query</span>(tree[node].l,x,y,l,mid); </span><br><span class="line"><span class="keyword">if</span>(y&gt;mid) res+=<span class="built_in">query</span>(tree[node].r,x,y,mid+<span class="number">1</span>,r); </span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> root = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;l,&amp;r);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">sum[i] = sum[i<span class="number">-1</span>] + a;<span class="comment">//前缀和 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">insert</span>(root,<span class="number">0</span>);<span class="comment">//不要忘记插入0,也就是说一个都不吃的情况 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">ans+=<span class="built_in">query</span>(root,sum[i] - r,sum[i] - l);<span class="comment">//加方案数 </span></span><br><span class="line"><span class="built_in">insert</span>(root,sum[i]);<span class="comment">//&quot;更新&quot;l的值 </span></span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P3478 [POI2008]STA-Station</title>
      <link href="/2020/08/03/p3478/"/>
      <url>/2020/08/03/p3478/</url>
      
        <content type="html"><![CDATA[<h1 id="P3478-POI2008-STA-Station题解"><a href="#P3478-POI2008-STA-Station题解" class="headerlink" title="P3478 [POI2008]STA-Station题解"></a>P3478 [POI2008]STA-Station题解</h1><h2 id="原题面"><a href="#原题面" class="headerlink" title="原题面"></a><a href="https://www.luogu.com.cn/problem/P3478">原题面</a></h2><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul><li>换根DP</li></ul><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给出一个 N 个点的树,找出一个点来,以这个点为根的树时,所有点的深度之和最大</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>换根DP的模板题。</p><p>如果您还不会换根DP的话,可以先去看看UltiMadow巨佬的文章:</p><p><a href="https://www.luogu.com.cn/discuss/show/47327">【日报#278】[学习笔记]换根dp</a>,我一开始也是从那里学的qwq</p><p>这里我们设</p><ul><li><p><strong>$size[i]$为以$1$为根节点时节点$i$的子树大小</strong></p></li><li><p><strong>$dep[i]$为以$1$为根节点时节点$i$的深度大小</strong></p></li><li><p><strong>$dp[i]$为以$i$为根节点时深度之和的大小</strong></p></li></ul><p>很明显,我们可以通过一遍DFS求出以$1$为根节点时的深度之和</p><p>如果一个个的去算的话</p><p>照这个数据范围,显然会T飞</p><p>这个时候就要用到换根DP了</p><h2 id="换根-DP-优化"><a href="#换根-DP-优化" class="headerlink" title="换根$DP$优化"></a>换根$DP$优化</h2><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/o5nj1c7o.png"></p><p>可以看出,当我们把根节点从1换到3时</p><p>对子节点3的贡献由两部分组成</p><p>1.<strong>自己子树的贡献(图中的k)</strong></p><p>2.<strong>父亲节点$1$的贡献</strong></p><hr><h2 id="如何转移"><a href="#如何转移" class="headerlink" title="如何转移"></a>如何转移</h2><ul><li><p>首先是$k$,作为自己子树所产生的贡献肯定要加上</p></li><li><p>$dp[u]$为以$u$为根节点时的深度总值,在计算时,要减去$v$的子树所产生的贡献,不然就重复计算了,同时</p></li></ul><p><strong>在以 $u$为根时,v节点及其子树内的所有节点的深度都增加了$1$</strong>,需要减去</p><p><strong>(图中红色的节点)</strong></p><p>合起来就是$dp[u]-(size[v]+k)$</p><ul><li>除v子树外的其他节点也一样</li></ul><p><strong>在以$v$为根时，除$v$节点及其子树外的其他节点的深度都增加了$1$</strong></p><p><strong>(图中蓝色的节点)</strong></p><p>合起来就是$(size[1]-size[v])$</p><p>得到转移方程</p><ul><li>$dp[v] &#x3D; k+(dp[u]-(k+size[v]))+(size[1]-size[v])$</li></ul><p>化简一下</p><ul><li>$dp[v] &#x3D; dp[u]-2size[v]+size[1]$</li></ul><p>转移方程推出来了,代码部分就不难实现了,两遍dfs,一次dfs统计子树内的节点对当前节点的贡献<br>一次dfs换根</p><p>贴个代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN  = <span class="number">100010</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> dp[MAXN],dep[MAXN],size[MAXN];</span><br><span class="line"><span class="type">int</span> vis[MAXN];</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; son[MAXN];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">size[x] = <span class="number">1</span>;</span><br><span class="line">    vis[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;son[x].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line"><span class="type">int</span> v = son[x][i];</span><br><span class="line"><span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">dep[v] = dep[x] +<span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs1</span>(v);</span><br><span class="line">size[x]+=size[v];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    vis[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;son[x].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line"><span class="type">int</span> v = son[x][i];</span><br><span class="line"><span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">dp[v] = dp[x] +size[<span class="number">1</span>] - <span class="number">2</span>*size[v];</span><br><span class="line"><span class="built_in">dfs2</span>(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="type">int</span> u,v;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">son[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">son[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs1</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) dp[<span class="number">1</span>]+=dep[i];</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line"><span class="built_in">dfs2</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans = <span class="number">-0x3f</span>;</span><br><span class="line"><span class="type">int</span> jd =<span class="number">999</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(ans &lt; dp[i]) ans = dp[i], jd = i;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;jd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划-换根dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P1453 城市环路</title>
      <link href="/2020/08/03/p1453/"/>
      <url>/2020/08/03/p1453/</url>
      
        <content type="html"><![CDATA[<h1 id="P1453-城市环路-题解"><a href="#P1453-城市环路-题解" class="headerlink" title="P1453 城市环路 题解"></a>P1453 城市环路 题解</h1><h2 id="间隙"><a href="#间隙" class="headerlink" title="间隙"></a><a href="https://www.luogu.com.cn/problem/P1453">间隙</a></h2><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><ul><li><h3 id="树形dp-基环树"><a href="#树形dp-基环树" class="headerlink" title="树形dp,基环树"></a>树形dp,基环树</h3></li></ul><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给一颗含有点权的基环外向树</p><p>假如两个点之间有一条边连接,如果选择了其中一端的节点,那另一段的节点则不可选择</p><p>求:最大贡献</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>先讲一下什么是基环树。</p><p>基环树,简单来说就是多了一条边的树,产生了一个环形结构,环上的每个节点都是一颗树的根</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/g8bnch8r.png"></p><p>画成图的话大概是这个样子(基环外向树)</p><p>一般来说,这种题目的做法都是先找到环,断开环中的一条边,<br>把它当成一般的树形$DP$来做。</p><h3 id="如何找环"><a href="#如何找环" class="headerlink" title="如何找环?"></a>如何找环?</h3><p>一般有$dfs$跟并查集两种方法 , 这里我采用的是并查集的做法</p><p>一开始每个节点都是一个独立的集合</p><p>每连接一条边,就把这两个点合并到一个集合中</p><p>如果在连接一条边之前,两个节点就已经在一个集合中了,说明这<strong>两个节点已经联通了,再连接这条边必然会产生环的情况</strong></p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/53vb8z0u.png"></p><h3 id="如何转移"><a href="#如何转移" class="headerlink" title="如何转移?"></a>如何转移?</h3><p>找到了环之后,只需要将环上的这条边断开即可</p><p>这样的话就可以当作普通的树形$DP$来做了</p><p>设$f[i][0]$为选第$i$个节点产生的最大贡献</p><p>$f[i][1]$为不选第$i$个节点产生的最大贡献</p><p>如果选了第$i$个节点,那它的儿子肯定都不能选</p><p>反之,儿子可以选择选,也可以选择不选</p><p>得到转移方程:</p><p>$f[u][0] &#x3D; \sum f[v][0]$</p><p>$f[u][1] &#x3D; \sum max(f[v][1],f[v][0])$</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>思路明白了代码实现应该就不难了</p><p>要注意的是环上的两个点都可以作为树的根节点,因此在$DP$的时候要把两个点都跑一遍</p><p>具体的细节注释有写</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;<span class="comment">//存图 </span></span><br><span class="line"><span class="type">int</span> v,next;</span><br><span class="line">&#125;e[MAXN&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> f[MAXN][<span class="number">2</span>],w[MAXN];<span class="comment">//dp数组,点权 </span></span><br><span class="line"><span class="type">double</span> k; </span><br><span class="line"><span class="type">int</span> fa[MAXN];</span><br><span class="line"><span class="type">int</span> head[MAXN&lt;&lt;<span class="number">1</span>],cnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> root1,root2;<span class="comment">//环上的两个点 </span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;<span class="comment">//前向星 </span></span><br><span class="line">e[++cnt].v = v;</span><br><span class="line">e[cnt].next = head[u];</span><br><span class="line">head[u] = cnt;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="comment">//查找集合 </span></span><br><span class="line"><span class="keyword">if</span>(fa[x]==x)&#123;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">circle</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;<span class="comment">//树形dp </span></span><br><span class="line">f[u][<span class="number">1</span>] = w[u],f[u][<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//初始化 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=e[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v = e[i].v;</span><br><span class="line"><span class="keyword">if</span>(v!=fa)&#123; </span><br><span class="line"><span class="built_in">circle</span>(v,u);</span><br><span class="line">f[u][<span class="number">0</span>]+=<span class="built_in">max</span>(f[v][<span class="number">1</span>],f[v][<span class="number">0</span>]);<span class="comment">//转移 </span></span><br><span class="line">f[u][<span class="number">1</span>]+=f[v][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;w[i]);</span><br><span class="line">fa[i] = i;<span class="comment">//初始化集合 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="type">int</span> u,v;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">u++,v++;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">find</span>(u)==<span class="built_in">find</span>(v))&#123;<span class="comment">//如果在加边前就在一个集合中了,说明找到了环 </span></span><br><span class="line">        root1 = u,root2 = v;<span class="comment">//记录环上的两个点 </span></span><br><span class="line">        <span class="keyword">continue</span>;<span class="comment">//直接跳过加边操作,相当于断开这条边 </span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="built_in">add</span>(u,v);</span><br><span class="line"><span class="built_in">add</span>(v,u);</span><br><span class="line">fa[<span class="built_in">find</span>(v)] = <span class="built_in">find</span>(u);<span class="comment">//合并集合 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;k);</span><br><span class="line"><span class="built_in">circle</span>(root1,<span class="number">0</span>);</span><br><span class="line"><span class="type">double</span> r1 = f[root1][<span class="number">0</span>];<span class="comment">//选root1 </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">circle</span>(root2,<span class="number">0</span>);</span><br><span class="line"><span class="type">double</span> r2 = f[root2][<span class="number">0</span>];<span class="comment">//选root2 </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.1lf&quot;</span>,<span class="built_in">max</span>(r1,r2)*k);<span class="comment">//取最大 </span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划-树形dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础树形dp</title>
      <link href="/2020/08/02/%E6%A0%91%E5%BD%A2dp/"/>
      <url>/2020/08/02/%E6%A0%91%E5%BD%A2dp/</url>
      
        <content type="html"><![CDATA[<p>曾经的黑历史(</p><p>有空了重构一下</p><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><h2 id="P1352-没有上司的舞会"><a href="#P1352-没有上司的舞会" class="headerlink" title="P1352 没有上司的舞会"></a>P1352 没有上司的舞会</h2><p>树状$dp$模板题。</p><p>设$f[i][0]$为第$i$个人来了的方案数</p><p>$f[i][1]$为第$i$和人没来的方案数</p><p>若第$i$个人来了,那么其下属均不回来</p><p>若不来,其下属则有来和不来两种选择</p><p>因此状态转移方程为:</p><ul><li><p>$f[i][0]+&#x3D;f[son][1]$</p></li><li><p>$f[i][1]+&#x3D;max(f[son][0],f[son][1])$</p></li></ul><h2 id="P2015-二叉苹果树"><a href="#P2015-二叉苹果树" class="headerlink" title="P2015 二叉苹果树"></a>P2015 二叉苹果树</h2><p>树上背包模板题</p><p>每一个枝条都有”剪”和”不剪”两种可能</p><p>把每一个儿子都看成一个”分组背包”</p><p>设$dp[i][j]$表示第$i$个子树保留$j$条边</p><p>每加入一个”儿子”后,枚举该”儿子”保留的边数,如图<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/bl7hi1vj.png"></p><h5 id="ps-这里i-k后面还要减1是因为还要多保留从u-gt-v这条边"><a href="#ps-这里i-k后面还要减1是因为还要多保留从u-gt-v这条边" class="headerlink" title="(ps:这里i-k后面还要减1是因为还要多保留从u-&gt;v这条边)"></a>(ps:这里i-k后面还要减1是因为还要多保留从u-&gt;v这条边)</h5><p>故状态转移方程为:</p><ul><li>$f[u][i]&#x3D;max(f[v][i-k-1]+f[u][k]+w[u][v])(i\in[1,m+1)]$</li></ul><hr><h1 id="树上背包"><a href="#树上背包" class="headerlink" title="树上背包"></a>树上背包</h1><p><strong><a href="https://www.luogu.com.cn/problem/P2014">P2014 [CTSC1997]选课</a></strong></p><p><strong><a href="https://www.luogu.com.cn/problem/P1273">P1273 有线电视网</a></strong></p><p><strong><a href="https://www.luogu.com.cn/problem/P1270">P1270 “访问”美术馆</a></strong></p><p><strong><a href="https://www.luogu.com.cn/problem/P1272">P1272 重建道路</a></strong></p><hr><h2 id="P2014-CTSC1997-选课"><a href="#P2014-CTSC1997-选课" class="headerlink" title="P2014 [CTSC1997]选课"></a>P2014 [CTSC1997]选课</h2><p>和二叉苹果树一样的套路。</p><p>把每一个子课程都看作是一个”分组背包”,倒序枚举即可</p><p>由于题目中可能有多棵树</p><p>因此多开一个节点把所有”树根”连在一起</p><p>同时,在倒序枚举时也要把这个新节点算进去</p><p>转移方程:</p><ul><li>$f[u][i]&#x3D;max(f[v][i-k-1]+f[u][k]+w[v])(i\in[1,m+1])$</li></ul><p>核心代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">vis[k]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;son[k].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(vis[son[k][i]]!=<span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">dp</span>(son[k][i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> v=m+<span class="number">1</span>;v&gt;=<span class="number">1</span>;v--)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> K=<span class="number">0</span>;K&lt;v;K++)&#123;</span><br><span class="line"> f[k][v]=<span class="built_in">max</span>(f[k][v],w[son[k][i]]+f[son[k][i]][K]+f[k][v-K<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="P1273-有线电视网"><a href="#P1273-有线电视网" class="headerlink" title="P1273 有线电视网"></a>P1273 有线电视网</h2><p>也是比较经典的一个树上背包问题</p><p>题目中要求的是在不亏本的情况下最多的观看用户个数</p><p>设$f[i][j]$表示第$i$个站传输给$j$个用户观看最终剩余的钱数</p><p>若最终剩余钱数大于等于0,则说明未亏本</p><p>反之,则说明亏本</p><p>转移方程则为:</p><ul><li>$f[u][i]&#x3D;max(f[v][k]+f[u][i-k]-w[u][v])$</li></ul><p>$dp$完后从总人数开始倒序判断是否亏本即可</p><p>贴个核心代码:</p><p>$dp部分$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">dp[x][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(val[x])&#123;<span class="comment">//如果是根节点</span></span><br><span class="line">size[x]=<span class="number">1</span>;<span class="comment">//人数加一</span></span><br><span class="line">dp[x][<span class="number">1</span>]=val[x];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;son[x].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line"><span class="built_in">dfs</span>(son[x][i]);</span><br><span class="line">size[x]+=size[son[x][i]];<span class="comment">//计算x节点下的人数总和</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=size[x];j&gt;=<span class="number">0</span>;j--)&#123;<span class="comment">//滚动数组,倒序枚举</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=size[son[x][i]];k++)&#123;<span class="comment">//枚举子树传输的观众数量</span></span><br><span class="line">dp[x][j]=<span class="built_in">max</span>(dp[x][j],dp[x][j-k]+dp[son[x][i]][k]-W[x][son[x][i]]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>$判断部分$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=m;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line"><span class="keyword">if</span>(dp[<span class="number">1</span>][i]&gt;=<span class="number">0</span>)&#123;<span class="comment">//如果不亏本</span></span><br><span class="line">cout&lt;&lt;i;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="P1270-“访问”美术馆"><a href="#P1270-“访问”美术馆" class="headerlink" title="P1270 “访问”美术馆"></a>P1270 “访问”美术馆</h2><p>跟P1273 有线电视网一样的套路</p><p>设$f[i][j]$为在第$i$个节点下偷$j$幅画所需要的最小总时间</p><p>状态转移方程也就呼之欲出了</p><ul><li>$f[u][i]&#x3D;min(f[v][k]+f[u][i-k]-2w[u][v])$</li></ul><p>这里$w[u][v]$要乘2是因为要进出各一趟</p><p>核心代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(paint[x]!=<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> paint[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;son[x].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> v = son[x][i];</span><br><span class="line"><span class="type">int</span> t=<span class="built_in">dfs</span>(v);</span><br><span class="line">s+=t;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j =s;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=t;k++)&#123;</span><br><span class="line">dp[x][j] = <span class="built_in">min</span>(dp[x][j] , dp[v][k] + dp[x][j-k]+w[x][v]*<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="P1272-重建道路"><a href="#P1272-重建道路" class="headerlink" title="P1272 重建道路"></a>P1272 重建道路</h2><p>同样也是一道比较经典的树上背包问题</p><p>设$f[i][j]$为第$i$个节点断出一个大小为$j$的子树所需要的断开总数</p><p>状态转移方程:</p><ul><li>$f[u][i]&#x3D;min(f[v][k]+f[u][i-k]-1)$</li></ul><p>($v$为根的子树提供$k$个节点,$u$和其他儿子提供$j-k$个节点)</p><p>同时,由于一开始时一个子树都没有加进来</p><p>即把$u$的所有”儿子”都切断了<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/rawfxbhz.png"></p><p>因此当把$v$儿子加进来的时候要把之前那段减去的边加回来</p><p>核心代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">size[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(!is_son[x])&#123;</span><br><span class="line">dp[x][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">size[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;son[x].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line"><span class="type">int</span> v = son[x][i];</span><br><span class="line"><span class="built_in">dfs</span>(v);</span><br><span class="line">size[x]+=size[v];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = size[x];j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>;k&lt;=size[v];k++)&#123;<span class="comment">//这里题解里很多人都写成了&lt;j,问题是子树可能本身就没有这么多子节点,感觉有些问题</span></span><br><span class="line">dp[x][j] = <span class="built_in">min</span>(dp[x][j],dp[x][j-k]+dp[v][k]<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="普通树形-DP"><a href="#普通树形-DP" class="headerlink" title="普通树形$DP$"></a>普通树形$DP$</h1><p><strong><a href="https://www.luogu.com.cn/problem/P2016">P2016 战略游戏</a></strong></p><p><strong><a href="https://www.luogu.com.cn/problem/P2458">P2458 [SDOI2006]保安站岗 题解</a></strong></p><p><strong><a href="https://www.luogu.com.cn/problem/P4084">P4084 [USACO17DEC]Barn Painting G</a></strong></p><p><strong><a href="https://www.luogu.com.cn/problem/P2585">P2585 [ZJOI] 三色二叉树</a></strong></p><p><strong><a href="https://www.luogu.com.cn/problem/P2279">P2279 消防局的设立</a></strong></p><hr><h2 id="P2016-战略游戏"><a href="#P2016-战略游戏" class="headerlink" title="P2016 战略游戏"></a>P2016 战略游戏</h2><p>带了点贪心思想的树形$DP$</p><p>如果父节点放了一个守卫</p><p>那其子节点就都不用放守卫了</p><p>反之,子节点都要放一个守卫</p><p>转移方程:</p><ul><li>$f[u][0]+&#x3D;f[v][1]$</li><li>$f[u][1]+&#x3D;min(f[v][1],f[v][0])$</li></ul><p>为什么不用儿子的儿子(“孙子”)节点来看守儿子节点?</p><p><strong>如果一个节点不是叶子节点,那他的子节点数必定大于或等于$1$</strong>,因此如果<strong>用儿子节点来看守其父节点,花费的数量肯定会更多</strong>(或不变)。</p><h6 id="遗憾的是题解里似乎没人说正确性的证明-还是说太简单了都懒得证了"><a href="#遗憾的是题解里似乎没人说正确性的证明-还是说太简单了都懒得证了" class="headerlink" title="遗憾的是题解里似乎没人说正确性的证明?,还是说太简单了都懒得证了"></a>遗憾的是题解里似乎没人说正确性的证明?,<del>还是说太简单了都懒得证了</del></h6><p>核心代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(x!=<span class="number">1509</span>)</span><br><span class="line">dp[x][<span class="number">1</span>]=<span class="number">1</span>,dp[x][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;son[x].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line"><span class="built_in">dfs</span>(son[x][i]);</span><br><span class="line">dp[x][<span class="number">0</span>]+=dp[son[x][i]][<span class="number">1</span>];</span><br><span class="line">dp[x][<span class="number">1</span>]+=<span class="built_in">min</span>(dp[son[x][i]][<span class="number">1</span>],dp[son[x][i]][<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于这道题目的带点权版:</p><h2 id="P2458-SDOI2006-保安站岗"><a href="#P2458-SDOI2006-保安站岗" class="headerlink" title="P2458 [SDOI2006]保安站岗"></a>P2458 [SDOI2006]保安站岗</h2><h2 id="题解链接"><a href="#题解链接" class="headerlink" title="题解链接"></a><a href="https://www.luogu.com.cn/blog/xcxc82/p2458-sdoi2006-bao-an-zhan-gang-ti-xie-yes">题解链接</a></h2><h2 id="P4084-USACO17DEC-Barn-Painting-G"><a href="#P4084-USACO17DEC-Barn-Painting-G" class="headerlink" title="P4084 [USACO17DEC]Barn Painting G"></a>P4084 [USACO17DEC]Barn Painting G</h2><p>树上$DP$求方案数。</p><p>还算是比较简单的题目吧…</p><p>设:</p><p>$f[i][0]$为第$i$个节点涂红色的方案数</p><p>$f[i][1]$为第$i$个节点涂绿色的方案数</p><p>$f[i][2]$为第$i$个节点涂蓝色的方案数</p><p>假设第$i$号节点涂了红色,那么它的上一个节点就只能涂绿色和蓝色</p><p>其他情况也同理</p><p>用乘法定理乘一下即可。</p><p>转移方程:</p><ul><li>$\begin{cases}f[u][1]&#x3D;f[u][1]<em>((f[v][2]+f[v][3]))\f[u][2]&#x3D;f[u][2]</em>((f[v][1]+f[v][3]))\f[u][3]&#x3D;f[u][3]*((f[v][1]+f[v][2]))\end{cases}$</li></ul><hr><h1 id="换根-DP"><a href="#换根-DP" class="headerlink" title="换根$DP$"></a>换根$DP$</h1><p>一种形式十分优美的树形$DP$</p><p><strong><a href="https://www.luogu.com.cn/problem/P3478">P3478 [POI2008]STA-Station</a></strong></p><p><strong><a href="https://www.luogu.com.cn/problem/P2986">P2986 [USACO10MAR]Great Cow Gathering G</a></strong></p><p><strong><a href="https://www.luogu.com.cn/problem/P3047">P3047 [Nearby Cows G]Great Cow Gathering G</a></strong></p><p><strong><a href="https://www.luogu.com.cn/problem/CF708C">CF708C Centroids</a></strong></p><p><strong><a href="https://www.luogu.com.cn/problem/CF1187E">CF1187E Tree Painting</a></strong></p><hr><h2 id="P3478-POI2008-STA-Station"><a href="#P3478-POI2008-STA-Station" class="headerlink" title="P3478 [POI2008]STA-Station"></a>P3478 [POI2008]STA-Station</h2><p>换根DP的模板题。</p><p>这里我们设</p><ul><li><p><strong>$size[i]$为以$1$为根节点时节点$i$的子树大小</strong></p></li><li><p><strong>$dep[i]$为以$1$为根节点时节点$i$的深度大小</strong></p></li><li><p><strong>$dp[i]$为以$i$为根节点时深度之和的大小</strong></p></li></ul><p>很明显,我们可以通过一遍DFS求出以$1$为根节点时的深度之和</p><p>如果一个个的去算的话</p><p>照这个数据范围,显然会T飞</p><p>这个时候就要用到换根DP了</p><h2 id="换根-DP-优化"><a href="#换根-DP-优化" class="headerlink" title="换根$DP$优化"></a>换根$DP$优化</h2><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/o5nj1c7o.png"></p><p>可以看出,当我们把根节点从1换到3时</p><p>对子节点3的贡献由两部分组成</p><p>1.<strong>自己子树的贡献(图中的k)</strong></p><p>2.<strong>父亲节点$1$的贡献</strong></p><hr><h2 id="如何转移"><a href="#如何转移" class="headerlink" title="如何转移"></a>如何转移</h2><ul><li><p>首先是$k$,作为自己子树所产生的贡献肯定要加上</p></li><li><p>$dp[u]$为以$u$为根节点时的深度总值,在计算时,要减去$v$的子树所产生的贡献,不然就重复计算了,同时</p></li></ul><p><strong>在以 $u$为根时,v节点及其子树内的所有节点的深度都增加了$1$</strong>,需要减去</p><p><strong>(图中红色的节点)</strong></p><p>合起来就是$dp[u]-(size[v]+k)$</p><ul><li>除v子树外的其他节点也一样</li></ul><p><strong>在以$v$为根时，除$v$节点及其子树外的其他节点的深度都增加了$1$</strong></p><p><strong>(图中蓝色的节点)</strong></p><p>合起来就是$(size[1]-size[v])$</p><p>得到转移方程</p><ul><li>$dp[v] &#x3D; k+(dp[u]-(k+size[v]))+(size[1]-size[v])$</li></ul><p>化简一下</p><ul><li>$dp[v] &#x3D; dp[u]-2size[v]+size[1]$</li></ul><p>核心代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">size[x] = <span class="number">1</span>;</span><br><span class="line">    vis[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;son[x].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line"><span class="type">int</span> v = son[x][i];</span><br><span class="line"><span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">dep[v] = dep[x] +<span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs1</span>(v);</span><br><span class="line">size[x]+=size[v];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    vis[x] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;son[x].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line"><span class="type">int</span> v = son[x][i];</span><br><span class="line"><span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">dp[v] = dp[x] +size[<span class="number">1</span>] - <span class="number">2</span>*size[v];</span><br><span class="line"><span class="built_in">dfs2</span>(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="P2986-USACO10MAR-Great-Cow-Gathering-G"><a href="#P2986-USACO10MAR-Great-Cow-Gathering-G" class="headerlink" title="P2986 [USACO10MAR]Great Cow Gathering G"></a>P2986 [USACO10MAR]Great Cow Gathering G</h2><p>前面那道题目的带权值版</p><p>一模一样的思路,只需要把状态转移方程转换一下即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].next)&#123;</span><br><span class="line">    <span class="type">int</span> v =edge[i].v;</span><br><span class="line">    <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(v,u);</span><br><span class="line">    size[u] += size[v];</span><br><span class="line">    sum[u]+=(sum[v]+edge[i].w*size[v]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].next)&#123;</span><br><span class="line">       <span class="type">int</span> v =edge[i].v;</span><br><span class="line">   <span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">f[v] = <span class="number">1LL</span>*f[u] + AN*edge[i].w - <span class="number">2</span>*size[v]*edge[i].w;</span><br><span class="line">ans = <span class="built_in">min</span>(ans,f[v]);</span><br><span class="line"><span class="built_in">dp</span>(v,u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="P3047-Nearby-Cows-G"><a href="#P3047-Nearby-Cows-G" class="headerlink" title="P3047 [Nearby Cows G]"></a>P3047 [Nearby Cows G]</h2><h3 id="1-状态表示"><a href="#1-状态表示" class="headerlink" title="1.$状态表示$"></a>1.$状态表示$</h3><p>设$size[i][j]$为第i个节点向下$j$层所包含的点权和</p><p>$f[i][j]$为第$i$个点距离它不超过 $j$的所有节点权值和</p><h3 id="2-状态转移"><a href="#2-状态转移" class="headerlink" title="2.状态转移"></a>2.状态转移</h3><p>对于$size[i][j]:$</p><p>$size[u][j] &#x3D;\sum\ size[v][j-1]$ 自己向下$j$层即为儿子向下$j-1$</p><p>对于$f[i][j]:$</p><p>儿子对它的贡献:</p><p>$size[v][j]$</p><p>自己向下$j$层,儿子节点肯定也要向下$j$层</p><p>父亲对它的贡献:</p><p>$f[u][j-1]-size[v][j-2]$</p><p>父亲节点扩展$j-1$层的值减去和儿子节点的值所重复包含的$j-2$层值</p><p>转移方程:</p><p>$f[v][j] &#x3D; f[u][j-1]+size[v][j]-size[v][j-2]$</p><p>核心代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v =edge[i].v;</span><br><span class="line"><span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line">dep[v]=dep[u]+<span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs</span>(v,u);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line">size[u][i]+=size[v][i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[u];i;i=edge[i].next)&#123;</span><br><span class="line"><span class="type">int</span> v=edge[i].v;</span><br><span class="line"><span class="keyword">if</span>(v==fa) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i<span class="number">-2</span>&gt;=<span class="number">0</span>)</span><br><span class="line">f[v][i] = size[v][i]+f[u][i<span class="number">-1</span>] - size[v][i<span class="number">-2</span>];</span><br><span class="line"><span class="keyword">else</span> f[v][i] = size[v][i]+f[u][i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">dp</span>(v,u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="CF708C-Centroids"><a href="#CF708C-Centroids" class="headerlink" title="CF708C Centroids"></a>CF708C Centroids</h2><p>一道做起来比较麻烦的换根$DP$</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>首先对于一个节点来说,大小大于$n&#x2F;2$的节点肯定只有一个，这个显而易见</p><p>再来看如何改造</p><p>如果说该节点本身的重儿子就小于$n&#x2F;2$,那肯定可以成为树的重心</p><p>反之,肯定要在重儿子里找出一个重量最大的且小于等于$n&#x2F;2$的子树,并将其断开,连接到根节点上(相当于删去这颗子树)</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/c18i92y5.png"></p><p>如果重儿子的大小减去被删去儿子的大小小于等于$n&#x2F;2$,则说明可以改造</p><p>反之,无法改造</p><h3 id="如何转移-1"><a href="#如何转移-1" class="headerlink" title="如何转移"></a>如何转移</h3><p>分两种情况来讨论</p><p>$1$.该节点不是其父亲节点重儿子</p><p>其父节点的重儿子不会被改变,只需要判断该节点的重儿子是否改成其父节点即可</p><p>$2$.该节点是其父亲节点的重儿子</p><p>其父亲节点的重儿子会变为其”次大”儿子,其儿子节点的重儿子不会改变</p><p>核心代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">vis[u] = <span class="number">1</span>;</span><br><span class="line">size[u] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;son[u].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line"><span class="type">int</span> v = son[u][i];</span><br><span class="line"><span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line"><span class="built_in">dfs</span>(v);</span><br><span class="line">size[u]+=size[v];</span><br><span class="line"><span class="keyword">if</span>(size[v] &gt; size[maxson[u]])</span><br><span class="line">maxson[u] = v;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">if</span>(maxson[u]!=<span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(size[maxson[u]]&lt;=n/<span class="number">2</span>) dp[u] = size[maxson[u]]; </span><br><span class="line"><span class="keyword">else</span> dp[u] = dp[maxson[u]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exchange</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span>&#123;</span><br><span class="line">        size[u] = size[u] - size[v];</span><br><span class="line">size[v] = size[v] + size[u];</span><br><span class="line"><span class="keyword">if</span>(v==maxson[u])&#123;</span><br><span class="line">maxson[u] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;son[u].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line"><span class="type">int</span> V = son[u][i];</span><br><span class="line"><span class="keyword">if</span>(V!=v&amp;&amp;size[V] &gt; size[maxson[u]])&#123;</span><br><span class="line">maxson[u] = V;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(maxson[u]!=<span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(size[maxson[u]]&lt;=n/<span class="number">2</span>) dp[u] = size[maxson[u]];</span><br><span class="line"><span class="keyword">else</span> dp[u] = dp[maxson[u]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(size[maxson[v]]&lt;size[u])&#123;</span><br><span class="line">maxson[v] = u;</span><br><span class="line"><span class="keyword">if</span>(maxson[v]!=<span class="number">0</span>)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(size[maxson[v]]&lt;=n/<span class="number">2</span>) dp[v] = size[maxson[v]];</span><br><span class="line"><span class="keyword">else</span> dp[v] = dp[maxson[v]];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">vis[u]  = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line"> <span class="keyword">if</span>(size[maxson[u]]&lt;=n/<span class="number">2</span>||size[maxson[u]] - dp[maxson[u]]&lt;=n/<span class="number">2</span>) ans[u]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;son[u].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line"><span class="type">int</span> v = son[u][i];</span><br><span class="line"><span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line"><span class="built_in">exchange</span>(u,v);</span><br><span class="line"><span class="built_in">dfs2</span>(v);</span><br><span class="line"><span class="built_in">exchange</span>(v,u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>end.</p><p>基环树部分还是先缓缓吧,暂时还未完全掌握</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SP2713 GSS4</title>
      <link href="/2020/08/01/sp2713/"/>
      <url>/2020/08/01/sp2713/</url>
      
        <content type="html"><![CDATA[<h1 id="SP2713-GSS4-题解"><a href="#SP2713-GSS4-题解" class="headerlink" title="SP2713 GSS4  题解"></a>SP2713 GSS4  题解</h1><h2 id="间隙"><a href="#间隙" class="headerlink" title="间隙"></a><a href="https://www.luogu.com.cn/problem/SP2713">间隙</a></h2><h2 id="双倍经验"><a href="#双倍经验" class="headerlink" title="双倍经验"></a><a href="https://www.luogu.com.cn/problem/P4145">双倍经验</a></h2><h2 id="前置知识-线段树"><a href="#前置知识-线段树" class="headerlink" title="前置知识:线段树"></a>前置知识:线段树</h2><p>如果您还不会线段树的话,推荐去看一下<a href="https://www.cnblogs.com/jason2003/p/9676729.html"><strong>这篇文章</strong></a>,我一开始也是在那里学的</p><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给一堆数,有以下两个操作:</p><ul><li><p>给出一个区间$[L,R]$,把该区间内的每个数都开平方</p></li><li><p>给出一个区间$[L,R]$,查询这个区间的每个数的和</p></li></ul><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先看一下这个数据范围,$1e18$,直接暴力的话肯定会T飞</p><p>求和操作很简单,相信学过线段树的人应该都会</p><p>难点在于这个开方操作,我们没法像线段树模板那样打个懒标记来进行下传操作</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/72ur96tc.png"></p><p>通过观察$\sqrt x$函数图像缓慢的增长率或者其他性质不难发现,很多开方操作是不必要的,考虑减枝优化:</p><ul><li>不难发现,<strong>当一个区间内的所有数都是$1$时,再对该区间进行开方操作对该区间内的总值造成不了任何改变</strong>($\sqrt{1} &#x3D; 1$)</li></ul><p>因此代码实现方面只要在区间内总值均为1的情况下加一个小剪枝即可</p><hr><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>思路理解了代码实现难度就不高了,但还是有几个坑点…具体的注释里有写</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lson (node&lt;&lt;1)<span class="comment">//左儿子</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rson (node&lt;&lt;1|1)<span class="comment">//右儿子</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long <span class="comment">//记得开long long</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100005</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">st</span>&#123;</span><br><span class="line"><span class="type">int</span> l,r;<span class="comment">//左右端点</span></span><br><span class="line">ll sum;</span><br><span class="line">&#125;tree[MAXN&lt;&lt;<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">ll a[MAXN];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> node)</span></span>&#123;</span><br><span class="line">tree[node].sum = tree[lson].sum + tree[rson].sum;<span class="comment">//合并操作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;<span class="comment">//建树</span></span><br><span class="line">tree[node].l = l;</span><br><span class="line">tree[node].r = r;</span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;</span><br><span class="line">tree[node].sum = a[l];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">build</span>(lson,l,mid);</span><br><span class="line"><span class="built_in">build</span>(rson,mid+<span class="number">1</span>,r);</span><br><span class="line"><span class="built_in">pushup</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> L = tree[node].l,R = tree[node].r;</span><br><span class="line"><span class="keyword">if</span>(tree[node].sum==R-L+<span class="number">1</span>) <span class="keyword">return</span>;<span class="comment">//如果总和为区间长度,也就是所有值均为1时,直接剪枝掉</span></span><br><span class="line"><span class="keyword">if</span>(L==R)&#123;</span><br><span class="line">tree[node].sum = <span class="built_in">sqrt</span>(tree[node].sum);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid = (L+R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid)&#123;</span><br><span class="line"><span class="built_in">change</span>(lson,l,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(r&gt;mid)&#123;</span><br><span class="line"><span class="built_in">change</span>(rson,l,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">pushup</span>(node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">query</span><span class="params">(<span class="type">int</span> node,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;<span class="comment">//查询</span></span><br><span class="line"><span class="type">int</span> L = tree[node].l,R = tree[node].r;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=L&amp;&amp;r&gt;=R)&#123;<span class="comment">//包含在查询区间内,直接返回sum值</span></span><br><span class="line"><span class="keyword">return</span> tree[node].sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid = (L+R)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(l&lt;=mid)&#123;</span><br><span class="line">ans+=<span class="built_in">query</span>(lson,l,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(r&gt;mid)&#123;</span><br><span class="line">ans+=<span class="built_in">query</span>(rson,l,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);<span class="comment">//不加貌似会TLE?</span></span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> Case=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(cin&gt;&gt;n)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Case #%d:\n&quot;</span>,++Case);<span class="comment">//注意,样例里那个case是要输出的,一开始被这里卡了好久...</span></span><br><span class="line"><span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));<span class="comment">//记得要先memset</span></span><br><span class="line"><span class="built_in">memset</span>(tree,<span class="number">0</span>,<span class="built_in">sizeof</span>(tree));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">cin&gt;&gt;m;</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line"><span class="type">int</span> mode,left,right;</span><br><span class="line">cin&gt;&gt;mode&gt;&gt;left&gt;&gt;right;</span><br><span class="line"><span class="keyword">if</span>(left &gt; right)&#123;</span><br><span class="line"><span class="built_in">swap</span>(left,right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(mode==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">change</span>(<span class="number">1</span>,left,right);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,<span class="built_in">query</span>(<span class="number">1</span>,left,right));</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);<span class="comment">//记得换行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF1187E Tree Painting</title>
      <link href="/2020/07/26/cf1187e/"/>
      <url>/2020/07/26/cf1187e/</url>
      
        <content type="html"><![CDATA[<h1 id="CF1187E-Tree-Painting-题解"><a href="#CF1187E-Tree-Painting-题解" class="headerlink" title="CF1187E Tree Painting 题解"></a>CF1187E Tree Painting 题解</h1><h2 id="原题面"><a href="#原题面" class="headerlink" title="原题面"></a><a href="https://www.luogu.com.cn/problem/CF1187E">原题面</a></h2><h2 id="前置知识-换根-DP"><a href="#前置知识-换根-DP" class="headerlink" title="前置知识: 换根$DP$"></a>前置知识: 换根$DP$</h2><p>换根$DP$模板题</p><p>如果您还不会换根$DP$的话,可以先去看看UM巨佬的日报:</p><p><a href="https://sflsrick.blog.luogu.org/note-how-to-change-root">#278[UltiMadow] [学习笔记]换根dp</a></p><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给定一棵n个点的树 初始全是白点</p><p>要求你做n步操作，每一次选定一个与一个黑点相隔一条边的白点，将它染成黑点，然后获得该白点被染色前所在的白色联通块大小的权值。</p><p>求可获得的最大权值</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>几乎是一道裸的模板题了…</p><p>和P3478几乎一摸一样,只是需要一个微小的结论</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/h4z3mf0i.png"></p><h5 id="PS-图中节点的编号有一点微小的错误-不过并不影响阅读"><a href="#PS-图中节点的编号有一点微小的错误-不过并不影响阅读" class="headerlink" title="PS:图中节点的编号有一点微小的错误,不过并不影响阅读"></a>PS:图中节点的编号有一点微小的错误,不过并不影响阅读</h5><p>假如说我们选了图中的1号节点作为第一个涂色的点（图中蓝色的点)</p><p>那下一个涂色的节点肯定就能选择它的几个儿子了(图中深红色的点)</p><p>同时,<strong>由于父亲节点已经被涂色了,其子节点不可能再和上面的”祖先”辈节点有联通了</strong><br><strong>能对其产生贡献的只有自己的子树</strong></p><p>因此当一个父亲节点被涂色后,其所有子树都是<strong>相对”独立”的</strong>，涂色顺序的变化对总贡献值无任何影响</p><p>故当<strong>第一个节点被涂色后,剩下节点的涂色顺序均无法对总贡献值产生影响</strong></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>单纯的暴力枚举每个根的位置的话照这个数据范围肯定会T飞</p><p>考虑换根DP</p><p>应该很容易状态转移方程推出:</p><ul><li>$dp[v] &#x3D; dp[u]-2size[v]+size[1]$</li></ul><p>具体这个方程怎么来的,我之前写的P3478的<a href="https://www.luogu.com.cn/blog/xcxc82/p3478-poi2008sta-station-ti-xie">题解</a>跟前面UM巨佬的日报里也有讲</p><p>套上换根$DP$的板子即可</p><p>贴上丑陋的代码:（其实只要把P3478的代码改一行就可以了）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">200010</span>;</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; son[MAXN];</span><br><span class="line"><span class="type">int</span> vis[MAXN],n;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> size[MAXN];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> f[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">size[u] = <span class="number">1</span>;</span><br><span class="line">vis[u] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;son[u].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line"><span class="type">int</span> v = son[u][i];</span><br><span class="line"><span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line"><span class="built_in">dfs</span>(v);</span><br><span class="line">size[u]+=size[v];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">vis[u] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;son[u].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line"><span class="type">int</span> v = son[u][i];</span><br><span class="line"><span class="keyword">if</span>(!vis[v])&#123;</span><br><span class="line">f[v] = f[u] + size[<span class="number">1</span>] - <span class="number">2</span>*size[v];</span><br><span class="line"><span class="built_in">dp</span>(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="type">int</span> u,v;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;v);</span><br><span class="line">son[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">son[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">f[<span class="number">1</span>]+=size[i];</span><br><span class="line">&#125;</span><br><span class="line">   <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="built_in">sizeof</span>(vis));</span><br><span class="line">   <span class="built_in">dp</span>(<span class="number">1</span>);</span><br><span class="line">   <span class="type">long</span> <span class="type">long</span> ans = <span class="number">-0x3f</span>;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">    ans = <span class="built_in">max</span>(ans , f[i]);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划-换根dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P2458 [SDOI2006]保安站岗</title>
      <link href="/2020/07/20/p2458/"/>
      <url>/2020/07/20/p2458/</url>
      
        <content type="html"><![CDATA[<h1 id="P2458-SDOI2006-保安站岗-题解"><a href="#P2458-SDOI2006-保安站岗-题解" class="headerlink" title="P2458 [SDOI2006]保安站岗 题解"></a><strong>P2458 [SDOI2006]保安站岗 题解</strong></h1><h2 id="间隙-原题面"><a href="#间隙-原题面" class="headerlink" title="间隙(原题面)"></a><a href="https://www.luogu.com.cn/problem/P2458">间隙(原题面)</a></h2><ul><li>前排声明:蒟蒻刚学OI没多久,讲的可能比较啰嗦,望见谅</li></ul><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给一颗树,每个点都可以花费一定的价格来放置一名”保安”</p><p>每个保安都可以看管他本身所在的点和所有与他所站的点相邻的点</p><p>求:看管所有点所需要的最小花费</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>树形dp。</p><p>先来说一种错误的做法,也是我一开始想到的做法</p><p>每个点都有”放置”和”不放置”两种选择</p><p><strong>设$dp[i][0]$为第$i$个点”不放置”保安所需要的最小花费</strong></p><p><strong>$dp[i][1]$为第$i$个点“放置”保安所需要的最小花费</strong></p><p>如果第$i$个点”放置”了保安</p><p>那它的下一个节点则可以选择”放或不放”两种决策</p><p>反之,下一个节点必须都”放置”一名保安</p><p><del>很明显是错的</del></p><p>放张图应该就明白了<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/c3ommepj.png"></p><p>(下一个节点不一定要由父亲或自己来看管,也可以由自己的”儿子”来看管)</p><p>也就是说,每个点的看管对象都有:</p><ul><li><strong>自己</strong></li><li><strong>父亲</strong></li><li><strong>儿子</strong></li></ul><p><strong>三种可能</strong></p><h2 id="如何转移"><a href="#如何转移" class="headerlink" title="如何转移"></a>如何转移</h2><p>设$dp[i][0]$为该点<strong>由自己看管</strong>所产生的最有解</p><p>$dp[i][1]$为该点<strong>由父亲看管</strong>所产生的最优解</p><p>$dp[i][2]$为该点<strong>由儿子看管</strong>所产生的最优解</p><ul><li><strong>1.由“自己”看管</strong></li></ul><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ywr3v3nc.png"></p><p>自己的位置上已经”放置了”一个点</p><p>那么它的所有儿子就都会被自己所”看管”住</p><p>显然儿子可以选择任意一种决策</p><ul><li>得到转移方程:$dp[i][0]&#x3D;\sum min(dp[son][0],dp[son][1],dp[son][2])+w[i]$</li></ul><p>($w[i]$为父亲节点”放置”守卫所需要的价值)</p><ul><li><strong>2.由“父亲”看管</strong></li></ul><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/75jddbxl.png"></p><p>自己由父亲看管,说明自己所在的点上<strong>未”放置”门卫</strong>,那儿子肯定<strong>只能由自己的儿子看管或由自己看管</strong></p><ul><li><p>得到方程:$dp[i][1]&#x3D;\sum min(dp[son][0],dp[son][2])$</p></li><li><p>3.<strong>由“儿子”看管</strong></p></li></ul><p>（图中红蓝分别为两种可能情况）</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/b7rw1758.png"></p><p>既然是由自己的儿子看管</p><p>儿子的决策也有两种可能</p><p>1.由儿子的”儿子”看管</p><p>2.由自己看管</p><ul><li>得到方程:$dp[i][2]&#x3D;\sum min(dp[son][2],dp[son][0])$</li></ul><p>有一种极端情况,如果全部都选了$dp[son][2]$</p><p>“自己”就会产生无人看管的情况</p><p>因此要在这里加一个小特判,具体代码里有解释</p><p>这里做了个简陋的gif,不懂的可以结合代码看一下</p><p><img src="https://img-blog.csdnimg.cn/20200720102214607.gif"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1510</span>;</span><br><span class="line"><span class="type">int</span> n,dp[MAXN][<span class="number">4</span>],w[MAXN];</span><br><span class="line"><span class="type">int</span> is_head[MAXN];</span><br><span class="line">vector &lt;<span class="type">int</span>&gt; son[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="type">bool</span> is_cs = <span class="literal">false</span>;<span class="comment">//用来判断有无极端情况</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> minn = <span class="number">0x3ffffff</span>;<span class="comment">//用来求极端情况的最小值 </span></span><br><span class="line">dp[x][<span class="number">0</span>] = w[x];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;son[x].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line"><span class="type">int</span> v = son[x][i];</span><br><span class="line"><span class="built_in">dfs</span>(v);</span><br><span class="line">dp[x][<span class="number">0</span>]+=<span class="built_in">min</span>(<span class="built_in">min</span>(dp[v][<span class="number">0</span>],dp[v][<span class="number">1</span>]),dp[v][<span class="number">2</span>]);<span class="comment">//由自己看守 </span></span><br><span class="line">dp[x][<span class="number">1</span>]+=<span class="built_in">min</span>(dp[v][<span class="number">2</span>],dp[v][<span class="number">0</span>]);<span class="comment">//由父亲看守 </span></span><br><span class="line"><span class="comment">//由儿子看守 ↓ </span></span><br><span class="line"><span class="keyword">if</span>(dp[v][<span class="number">0</span>]&lt;dp[v][<span class="number">2</span>])&#123; </span><br><span class="line">dp[x][<span class="number">2</span>]+=dp[v][<span class="number">0</span>];<span class="comment">//如果儿子放置守卫花费的钱更少,那就直接在儿子的点上放置一个守卫 </span></span><br><span class="line">is_cs=<span class="literal">true</span>;<span class="comment">//既然儿子的位置上已经放置守卫了,无极端情况存在 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;<span class="comment">//否则在儿子的儿子上放置守卫 </span></span><br><span class="line">minn = <span class="built_in">min</span>( minn , dp[v][<span class="number">0</span>]-dp[v][<span class="number">2</span>]);<span class="comment">//计算最小所需值 </span></span><br><span class="line">dp[x][<span class="number">2</span>]+=dp[v][<span class="number">2</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!is_cs) dp[x][<span class="number">2</span>]+=minn;<span class="comment">//如果存在极端情况,则加上差值,相当于是消掉dp[-][2],加上dp[-][0] </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="type">int</span> u,m;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;u,&amp;m);</span><br><span class="line">w[u]=m;</span><br><span class="line"><span class="type">int</span> k;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)&#123;</span><br><span class="line"><span class="type">int</span> v;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;v);</span><br><span class="line">is_head[v]++;</span><br><span class="line">son[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!is_head[i])&#123;</span><br><span class="line"><span class="built_in">dfs</span>(i);</span><br><span class="line">cout&lt;&lt;<span class="built_in">min</span>(dp[i][<span class="number">0</span>],dp[i][<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划-树形dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CF607B Zuma</title>
      <link href="/2020/07/09/cf607b/"/>
      <url>/2020/07/09/cf607b/</url>
      
        <content type="html"><![CDATA[<h1 id="CF607B-Zuma-题解"><a href="#CF607B-Zuma-题解" class="headerlink" title="CF607B Zuma 题解"></a>CF607B Zuma 题解</h1><h2 id="间隙-原题面"><a href="#间隙-原题面" class="headerlink" title="间隙(原题面)"></a><a href="https://www.luogu.com.cn/problem/CF607B">间隙(原题面)</a></h2><ul><li>前排声明:蒟蒻刚学oi没多久,而且是自学的,写的可能会比较累赘,望见谅。</li></ul><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><ul><li>基础区间dp</li></ul><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>给一个长度为n的串,每次都可以挑选一个回文的连续字串进行消除,删除后，剩余的串将连接在一起，形成一个新的串,求把串全部删除完需要的最小次数</p><hr><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/k3ezz757.png"></p><p>可以看出每一个区间的的求解都可以分为更小的两个区间的求解</p><p>联想到区间dp</p><p>设$dp[l][r]$为左端点为l,右端点为r时的最优解</p><p>不难推出<del>比较套路的</del>状态转移方程</p><ul><li>$dp[l][r]&#x3D;min(dp[l][r],dp[l][k]+dp[k+1][r]).(l&lt;&#x3D;k&lt;r)$</li></ul><p>同时,这里还有一个区间的回文判断</p><p>假设我们把总区间划分为两个区间</p><p>$[1,4,5,3,4,1,3,2]$和$[3,2]$</p><p>其中$[1,4,5,3,4,1,3,2]$包含一个回文部分</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/teqq2yqh.png"></p><p>此时我们只要直接将回文部分删去即可</p><p>即$dp[l][r]&#x3D;dp[l+1][r-1]$</p><p>这其实是一个类似于预处理的东西(个人看法,可能有误)</p><p>如果一个区间包含回文部分</p><p>则先把$dp[l][r]$给预处理成它不进行划分可以产生的最小值</p><p>再去和划分成两个区间所产生的最小值进行比较</p><ul><li>即$if(a[l]&#x3D;&#x3D;a[r])$<br>$dp[l[[r]&#x3D;dp[l+1][r-1]$</li></ul><p>贴上丑陋的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">510</span>;</span><br><span class="line"><span class="type">int</span> n,a[MAXN],dp[MAXN][MAXN];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="comment">//预处理长度为1的区间</span></span><br><span class="line">dp[i][i]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> len=<span class="number">1</span>;len&lt;n;len++)&#123;<span class="comment">//枚举长度</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> l=<span class="number">1</span>;l&lt;=n&amp;&amp;l+len&lt;=n;l++)&#123;<span class="comment">//枚举左右断点</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> r=l+len;</span><br><span class="line">dp[l][r]=inf;</span><br><span class="line"><span class="keyword">if</span>(a[l]==a[r])&#123;<span class="comment">//如果包含回文部分</span></span><br><span class="line"><span class="keyword">if</span>(r==l+<span class="number">1</span>)&#123;<span class="comment">//注意,这里是区间长度为2的特判</span></span><br><span class="line">dp[l][r]=dp[l+<span class="number">1</span>][r<span class="number">-1</span>]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> dp[l][r]=dp[l+<span class="number">1</span>][r<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=l;k&lt;r;k++)&#123;<span class="comment">//枚举断点</span></span><br><span class="line">dp[l][r]=<span class="built_in">min</span>(dp[l][r],dp[l][k]+dp[k+<span class="number">1</span>][r]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;dp[<span class="number">1</span>][n];</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>如有错误欢迎大佬们指出QwQ</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划-区间dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P3800 power收集</title>
      <link href="/2020/07/07/p3800/"/>
      <url>/2020/07/07/p3800/</url>
      
        <content type="html"><![CDATA[<h1 id="P3800-Power收集-题解"><a href="#P3800-Power收集-题解" class="headerlink" title="P3800 Power收集 题解"></a>P3800 Power收集 题解</h1><h2 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a><a href="https://www.luogu.com.cn/problem/P3800">传送门</a></h2><p>前排声明:蒟蒻刚学oi没多久,写的可能比较粗糙,望谅解</p><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给一个$N×M$大小的矩阵</p><p>其中有k个点包含一个带有价值的P点</p><p>每一行中的一个格子i都可以从上一行中的第$[i-t,i+t]$个格子中转移过来</p><p>求可以获得的最大价值</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>大致思路和<a href="https://www.luogu.com.cn/problem/P1725">P1725 琪露诺</a>很像,只是换了一种形式而已</p><p>既然每一个格子$i$都可以从上一行中的第$ [i-t,i+t] $个格子中转移过来</p><p>我们<strong>设$a[i][j]$为第$i$行第$j$个点的价值大小</strong></p><p>容易得到状态转移方程:</p><ul><li><p>$dp[i][j]&#x3D;max(dp[i-1][k])+a[i][j] (j-T&lt;&#x3D;k&lt;&#x3D;j+T)$</p></li><li><p>因此,对于每一个$dp[i][j]$来说</p></li></ul><p>他的值均是由上一行中$[j-t,j+t]$区间中的最大值转移过来的</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/f400j4mf.png"></p><h6 id="懒得找城管的图了-只好拿之前cirno的图改了一下"><a href="#懒得找城管的图了-只好拿之前cirno的图改了一下" class="headerlink" title="(懒得找城管的图了,只好拿之前cirno的图改了一下)"></a>(<del>懒得找城管的图了,只好拿之前cirno的图改了一下</del>)</h6><p>可以看出这是一个滑动区间求最值的问题</p><p>可以考虑用单调队列来优化</p><p>在进行第$i$行第$j$列的转移前</p><p>利用滑动窗口将第$i-1$行中$[j-t,j+t]$的最大值来求出来</p><p>这里<del>闲着无聊</del>做了个$gif$</p><p><img src="https://img-blog.csdnimg.cn/20200707134646322.gif"></p><h2 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h2><p>开一个数组 $q$ 模拟队列,用来滑动求最值</p><p>首先初始化第一行的$dp[i][j]$</p><p>第2~n行则利用$q$来求上一行的最大值进行转移</p><ul><li><strong>swp函数</strong></li></ul><p>实现队列初始化功能</p><p>将前 $t$ 个数加入队列</p><ul><li><strong>swi函数</strong></li></ul><p>当插入新元素时</p><p>先判断队列是否在$[1,m]$的区间内(不判会RE)</p><p>如果在区间内:</p><p>$1$.调整队列单调性</p><p>$2$.入队</p><p>反之,超出范围,不入队</p><p>$3$.去掉”超时”元素</p><p>贴上丑陋的代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 4010</span></span><br><span class="line"><span class="type">int</span> tail=<span class="number">0</span>,head=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> n,m,k,t,ans; </span><br><span class="line"><span class="type">int</span> q[MAXN],a[MAXN][MAXN],dp[MAXN][MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">queue_empty</span><span class="params">()</span></span>&#123;<span class="comment">//清空窗口 </span></span><br><span class="line">tail=<span class="number">0</span>,head=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swi</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> last)</span></span>&#123;<span class="comment">//插入元素</span></span><br><span class="line">   <span class="keyword">if</span>(x+t&lt;=m)&#123;<span class="comment">//判断是否超过边界,不加会RE </span></span><br><span class="line">   <span class="keyword">while</span>(dp[last][x+t]&gt;dp[last][q[tail]]&amp;&amp;tail&gt;=head)&#123;<span class="comment">//单调队列 </span></span><br><span class="line">tail--;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">q[++tail]=x+t;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(q[head]+t&lt;x) head++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swp</span><span class="params">(<span class="type">int</span> last)</span></span>&#123;<span class="comment">//初始化窗口 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=t;i++)&#123;</span><br><span class="line"><span class="keyword">while</span>(dp[last][i]&gt;dp[last][q[tail]]&amp;&amp;tail&gt;=head)&#123;</span><br><span class="line">tail--;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">q[++tail] = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;k,&amp;t);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line"><span class="type">int</span> x, y, z;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;z);</span><br><span class="line">a[x][y] = z;</span><br><span class="line">&#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;<span class="comment">//第一行初始化</span></span><br><span class="line">   dp[<span class="number">1</span>][i]=a[<span class="number">1</span>][i];</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)&#123;</span><br><span class="line">   <span class="built_in">swp</span>(i<span class="number">-1</span>);</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=m;j++)&#123;</span><br><span class="line">   </span><br><span class="line">   <span class="built_in">swi</span>(j,i<span class="number">-1</span>);</span><br><span class="line">   </span><br><span class="line">  dp[i][j]=dp[i<span class="number">-1</span>][q[head]]+a[i][j]; </span><br><span class="line">  </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">queue_empty</span>();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">ans=<span class="built_in">max</span>(dp[n][i],ans);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如有错误欢迎dalao们指出qwq</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划-区间dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P5239 回忆京都</title>
      <link href="/2020/07/05/p5239/"/>
      <url>/2020/07/05/p5239/</url>
      
        <content type="html"><![CDATA[<h1 id="P5239-回忆京都题解"><a href="#P5239-回忆京都题解" class="headerlink" title="P5239 回忆京都题解"></a>P5239 回忆京都题解</h1><h2 id="传送门"><a href="#传送门" class="headerlink" title="传送门"></a><a href="https://www.luogu.com.cn/problem/P5239">传送门</a></h2><p>前排声明:题解写的比较累赘…把一些基本的恒等式都讲了一遍…(部分证明借鉴了《具体数学》一书)</p><p>如果您已经掌握了这些基础的话建议还是去看其他dalao们的题解吧qwq…</p><h2 id="1-基本恒等式"><a href="#1-基本恒等式" class="headerlink" title="1.基本恒等式"></a>1.基本恒等式</h2><p>我们把$\dbinom{n}{k}$符号读作”<strong>n选取k</strong>“</p><p>即<strong>从n个元素的集合中选取k个元素</strong>作为子集的方案总数</p><p>对于该集合的第一个元素的可能,有n种选择</p><p>对第二个元素,有n-1种选择,3,4,5…..也同理</p><p>同时,<strong>对于每k个元素组成的子集都恰好有$k!$种不同的排序</strong></p><p>根据乘法原理</p><p>得到公式</p><p>$\dbinom{n}{k}&#x3D;{\dfrac{n*(n-1)…*(n-k+1)}{k!}}$ </p><p>(<strong>基本恒等式</strong>)</p><hr><h2 id="2-对称恒等式"><a href="#2-对称恒等式" class="headerlink" title="2.对称恒等式"></a>2.对称恒等式</h2><p>先来看个图</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/a9xmsi5c.png"></p><p>观察一下不难发现规律</p><p>$\dbinom{n}{k}&#x3D;\dbinom{n}{n-k}$</p><p>(<strong>对称恒等式</strong>)</p><p>至于正确性也显而易见</p><p><strong>从n个物品中选k个物品就相当于指定的n-k种物品不被选取</strong></p><hr><h2 id="3-吸收恒等式"><a href="#3-吸收恒等式" class="headerlink" title="3.吸收恒等式"></a>3.吸收恒等式</h2><p>我们知道,二项式系数的基本恒等式为</p><p>$\dbinom{n}{k}&#x3D;{\dfrac{n*(n-1)…*(n-k+1)}{k!}}$ </p><p>可以将式子转化为</p><p>$\dbinom{n}{k}&#x3D;{\dfrac{n}{k}<em>\dfrac{(n-1)…</em>(n-k+1)}{(k-1)!}}$ </p><p>得到式子$\dbinom{n}{k}&#x3D;\dfrac{n}{k}\dbinom{n-1}{k-1}$</p><p>两边同乘k,得$k\dbinom{n}{k}&#x3D;n\dbinom{n-1}{k-1}$<strong>恒等式1</strong></p><p>根据这个式子,再利用之前的恒等式1</p><p>还可以得到式子</p><p>$(n-k)\dbinom{n}{k}&#x3D;(n-k)\dbinom{n}{n-k}$(根据对称性)</p><p>$&#x3D;n\dbinom{n-1}{n-1-k}$(根据恒等式1)</p><p>$&#x3D;n\dbinom{n-1}{k}$—(根据对称性)<strong>恒等式2</strong> </p><hr><h2 id="4-加法公式"><a href="#4-加法公式" class="headerlink" title="4.加法公式"></a>4.加法公式</h2><p>观察一下前面的那张表,不难发现一个规律:</p><p>$\dbinom{n}{k}&#x3D;\dbinom{n-1}{k-1}+\dbinom{n-1}{k}$</p><p>推导的话也很简单</p><p>根据之前吸收恒等式里的恒等式1和恒等式2</p><p>得出</p><p>$\dbinom{n}{k}&#x3D;(n-k)\dbinom{n}{k}+k\dbinom{n}{k}&#x3D;n\dbinom{n-1}{k}+n\dbinom{n-1}{k-1}$</p><hr><h2 id="5-题目"><a href="#5-题目" class="headerlink" title="5.题目"></a>5.题目</h2><h3 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意:"></a>大致题意:</h3><p>q次询问,每次都给一个m跟n,求</p><p>$\sum\limits_{i&#x3D;1}^n\sum\limits_{j&#x3D;1}^mC^i_j$</p><hr><p>根据前面的加法公式,很容易可以解出这题</p><p>一共有n次询问，如果一次一次的去加的话肯定会超时</p><p>可以考虑使用二维前缀和来优化</p><p>至于二维前缀和怎么用,前面的dalao们已经写的很清楚了,为了<del>让题解看起来不是那么的水</del>,彩笔这里就再粗糙的写一遍吧</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ez5vvkji.png"></p><p>从图中不难看出,对于每一个sum[i][j],都有</p><p>sum[i][j]&#x3D;sum[i][j-1]+sum[i-1][j]+a[i][j]-sum[i-1][j-1]</p><p>因为这里面有一个对$1926081719260817$取模操作</p><p>相减可能会产生负数</p><p>比如说我们取模后$sum[i][j-1]+sum[i-1][j]+a[i][j]&#x3D;1$</p><p>而$sum[i-1][j-1]&#x3D;1926081719260816$</p><p>很明显,相减为负</p><p>至于如何避免其实也很简单,只要再加上一个模数就可以了,相当于是加上之前那个被模掉的部分</p><hr><p>贴上丑陋的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> mo=<span class="number">19260817</span>;</span><br><span class="line"><span class="type">int</span> n,a[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="type">int</span> sum[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">      a[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">1002</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">1002</span>;j++)&#123;</span><br><span class="line">a[i][<span class="number">0</span>]=a[i][i]=<span class="number">1</span>;</span><br><span class="line">a[i][j]=(a[i<span class="number">-1</span>][j]+a[i<span class="number">-1</span>][j<span class="number">-1</span>])%mo;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">1002</span>;i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">1002</span>;j++)&#123;</span><br><span class="line">sum[i][j]=(sum[i<span class="number">-1</span>][j]+sum[i][j<span class="number">-1</span>]+a[i][j]-sum[i<span class="number">-1</span>][j<span class="number">-1</span>]+mo)%mo;</span><br><span class="line">&#125;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="type">int</span> l,r;</span><br><span class="line">cin&gt;&gt;l&gt;&gt;r;</span><br><span class="line">cout&lt;&lt;sum[r][l]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如有错误还请大佬们指出</p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组合数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>p4838 P哥破解密码</title>
      <link href="/2020/06/26/p4838/"/>
      <url>/2020/06/26/p4838/</url>
      
        <content type="html"><![CDATA[<h1 id="P4838-P哥破解密码题解"><a href="#P4838-P哥破解密码题解" class="headerlink" title="P4838 P哥破解密码题解"></a>P4838 P哥破解密码题解</h1><ul><li><h2 id="原题面"><a href="#原题面" class="headerlink" title="原题面"></a><a href="https://www.luogu.com.cn/problem/P4838">原题面</a></h2></li></ul><p><strong>思路貌似跟dalao们的有点不一样</strong></p><ul><li><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2></li></ul><hr><p>给一串长度为n的字符串,<strong>当且仅当串只由A和B构成</strong>，且没有连续的3个A时,该串合法,求方案总数</p><hr><p>感觉跟P4910帕秋莉的手环那道题目差不多吧….都是线性递推,貌似dalao们都是用动态规划来做的,<del>蒟蒻不太会,所以只好用比较sb的递推来做qwq</del></p><ul><li><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2>既然每个字符只有A和B两种可能,,如果字符串没有任何限制的话,很容易看出方 案总数为 : $2^n$</li></ul><p>但这里加了一个<strong>不能有没有连续的3个A</strong>出现的限制条件</p><p>不妨先来画个图来看一下,更加直观一点<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/en3d9md2.png"><br>图中为n&#x3D;6的时候的情况</p><p>我们用$f_i$来表示长度为i的字符串的<strong>不合法方案总数</strong>(<strong>注意,是不合法方案总数</strong>)</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/axtxuhus.png"></p><p>先来看第一个字符选A情况</p><p>这里我们可以把每一个B看作是一个”<strong>断点</strong>“</p><p>不难看出,每出现一个断点后</p><p>该断点下面的情况就可以从之前的$f_i$递推过来</p><p>而当出现连续3个A时,相当于是把下面的所有情况都”<strong>截断</strong>“了</p><p>也就是$2^{n-3}$种情况</p><p>第一个字符选”B”也同理</p><p>相当于是在第一个点的时候就把该串给”<strong>截断</strong>“了</p><p>容易推出当N&#x3D;6时,合法方案总数为</p><p>$2^6-(f_{5}+f_{4}+f_{3}+2^3)$</p><p>其他n&gt;3的情况也同理</p><p>得到式子</p><p>方案总数&#x3D;$2^n-(f_{n-1}+f_{n-2}+f_{n-3}+2^{n-3})$</p><p>&#x3D;$7*2^{n-3}-(f_{n-1}+f_{n-2}+f_{n-3})$</p><p>&#x3D;$(2^{n-1}+2^{n-2}+2^{n-3})-(f_{n-1}+f_{n-2}+f_{n-3})$</p><p>设$s_i$为方案总数</p><p>则$s_i&#x3D;s_{i-1}+s_{i-2}+s_{i-3}$</p><p>得到最终式子<br>$\begin{cases}2(n&#x3D;1)\4 (n&#x3D;2)\7 (n&#x3D;3)\s_i&#x3D;s_{i-1}+s_{i-2}+s_{i-3}(n&gt;3)\end{cases}$ </p><p>贴个丑陋的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> mo=<span class="number">19260817</span>;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n,t;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">matrix</span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="type">int</span> a[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line">&#125;ans,a;</span><br><span class="line">matrix <span class="keyword">operator</span> *(<span class="type">const</span> matrix &amp;x,<span class="type">const</span> matrix &amp;y)&#123;</span><br><span class="line">matrix z;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">3</span>;j++)&#123;</span><br><span class="line">z.a[i][j]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">3</span>;k++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">3</span>;j++)&#123;</span><br><span class="line">z.a[i][j]=(z.a[i][j]+(x.a[i][k]*y.a[k][j])%mo)%mo;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="number">2</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">2</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="number">4</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">3</span>)&#123;</span><br><span class="line">cout&lt;&lt;<span class="number">7</span>&lt;&lt;endl;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">3</span>;j++)&#123;</span><br><span class="line">a.a[i][j]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(i==j) ans.a[i][j]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> ans.a[i][j]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">a.a[<span class="number">1</span>][<span class="number">1</span>]=a.a[<span class="number">1</span>][<span class="number">2</span>]=a.a[<span class="number">1</span>][<span class="number">3</span>]=a.a[<span class="number">2</span>][<span class="number">1</span>]=a.a[<span class="number">3</span>][<span class="number">2</span>]=<span class="number">1</span>; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(n)&#123;</span><br><span class="line"><span class="keyword">if</span>(n&amp;<span class="number">1</span>) ans=ans*a;</span><br><span class="line">n&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">a=a*a;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;((ans.a[<span class="number">1</span>][<span class="number">1</span>]+ans.a[<span class="number">2</span>][<span class="number">1</span>])%mo+ans.a[<span class="number">3</span>][<span class="number">1</span>])%mo&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>貌似是蒟蒻的第一次不看题解做出(比较水的)紫题?</del></p>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划-线性dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>p1725 琪露诺</title>
      <link href="/2020/06/25/p1725/"/>
      <url>/2020/06/25/p1725/</url>
      
        <content type="html"><![CDATA[<h1 id="P1725-琪露诺"><a href="#P1725-琪露诺" class="headerlink" title="P1725 琪露诺"></a><a href="https://www.luogu.com.cn/problem/P1725"></a>P1725 琪露诺</h1><p><a href="https://www.luogu.com.cn/problem/P1725">原题面</a></p><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h2><p>给编号为0~N的N+1个数,每个格子都有一个冰冻指数ice[i]</p><p>每一个格子都可以转移到区间[i+l,i+r]上,求ice[i]总和的最大值</p><hr><p>很明显可以看出这是一道dp的题</p><p>我们不妨先把转移方程写出来</p><p>题目中说<strong>每一个格子都可以转移到区间[i+l,i+r]上</strong></p><p>不难推出转移方程:</p><ul><li><h3 id="dp-i-x3D-max-dp-i-r-dp-i-r-1-…dp-i-l-1-dp-i-l-ice-i"><a href="#dp-i-x3D-max-dp-i-r-dp-i-r-1-…dp-i-l-1-dp-i-l-ice-i" class="headerlink" title="$~~~~~~~~~~~~~~~~dp_i&#x3D;max(dp_{i-r},dp_{i-r+1},…dp_{i-l-1},dp_{i-l})+ice[i]$"></a>$~~~~~~~~~~~~~~~~dp_i&#x3D;max(dp_{i-r},dp_{i-r+1},…dp_{i-l-1},dp_{i-l})+ice[i]$</h3></li></ul><p>(放张图 样例是自造的,此图为i&#x3D;4的情况)<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/ai7jcjuq.png"><br>因此,对于每一个$dp_i$来说</p><p>他的值均是由[$dp_{i-l}$~$dp_{i-r}$]区间中的最大值转移过来的(前面方程也说了)</p><p>而且这个区间是不断滑动的</p><p>滑动区间求最值,很容易联想到<strong>单调队列</strong></p><p>照题目里的数据范围普通的dp肯定会超时</p><p>因此我们可以用单调队列来优化它</p><p>做了一个比较粗糙的过程动态图qwq<br><img src="https://img-blog.csdnimg.cn/2020062520104327.gif"><br>补几张gif跳的比较快的图</p><p>$dp_1$</p><ul><li><img src="https://cdn.luogu.com.cn/upload/image_hosting/3h0hzail.png"><br>$dp_2$</li><li><img src="https://cdn.luogu.com.cn/upload/image_hosting/9osayz2u.png"><br>以此类推,均由[$dp_{i-l}$~$dp_{i-r}$]区间中的最大值转移过来</li><li><img src="https://cdn.luogu.com.cn/upload/image_hosting/pq2le485.png"></li></ul><hr><p>写的貌似有点累赘…</p><p>如有错误还请dalao们指出qwq,<del>话说没人会来看这么辣鸡的题解吧</del></p><p>贴个丑陋的代码:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> ice[<span class="number">300010</span>],dp[<span class="number">300010</span>],q[<span class="number">300010</span>];</span><br><span class="line"><span class="type">int</span> l,n,r,ans=<span class="number">-1</span>&lt;&lt;<span class="number">30</span>;</span><br><span class="line"><span class="type">int</span> head=<span class="number">1</span>,tail=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">findmax</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=l;i&lt;=n;i++)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(head&lt;=tail&amp;&amp;dp[q[tail]]&lt;dp[i-l]) tail--;<span class="comment">//单调队列 </span></span><br><span class="line"><span class="keyword">while</span>(head&lt;=tail&amp;&amp;q[head]&lt;i-r) head++;<span class="comment">//滑动区间 </span></span><br><span class="line">q[++tail]=i-l;</span><br><span class="line">dp[i]=dp[q[head]]+ice[i];<span class="comment">//转移 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i&gt;=n-r+<span class="number">1</span>) ans=<span class="built_in">max</span>(ans,dp[i]);<span class="comment">//在开始移动的时候求最大值 </span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;l&gt;&gt;r;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;ice[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memset</span>(dp,<span class="number">0xcf</span>,<span class="built_in">sizeof</span>(dp));dp[<span class="number">0</span>]=<span class="number">0</span>;<span class="comment">//注意,ice的值可能为负,所以要把dp跟ans的值赋为无穷小,一开始在这里卡了好久... </span></span><br><span class="line"><span class="built_in">findmax</span>();</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划-单调队列优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P6524 「Wdoi-1」托卡马克</title>
      <link href="/2020/06/20/p6524/"/>
      <url>/2020/06/20/p6524/</url>
      
        <content type="html"><![CDATA[<h1 id="P6524-「Wdoi-1」托卡马克-题解"><a href="#P6524-「Wdoi-1」托卡马克-题解" class="headerlink" title="P6524 「Wdoi-1」托卡马克 题解"></a>P6524 「Wdoi-1」托卡马克 题解</h1><p>大致思路和上面那位dalao的差不多,有个错误也是看了上面那位dalao的题解才发现的qwq</p><h2 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a><strong>大致题意</strong></h2><p>在<strong>n</strong>个点中选<strong>m</strong>个点进行<strong>两两相连</strong>,两个点相连所产生的费用为两点距离之差的绝对值<br>求<strong>严格第k大费用值(即不存在并列情况的第 k 大方案）</strong></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先来看一下这个数据范围,<strong>k&lt;&#x3D;2</strong></p><p>也就是说只有<strong>第一大</strong>和<strong>第二大</strong>两种可能</p><p>先来看一下k&#x3D;1的时候的情况:</p><h1 id="k-x3D-1"><a href="#k-x3D-1" class="headerlink" title="k&#x3D;1"></a>k&#x3D;1</h1><p>我们假设a1~a8是递增的,且n&#x3D;8,m&#x3D;6,k&#x3D;1</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/8kfaz7oq.png"></p><p>先假设我们选取了$a_1$,$a_2$,$a_{3}$,$a_{6}$,$a_{7}$,$a_{8}$这几个数</p><p>总费用值&#x3D;$\sum\limits_{i&#x3D;1,j&#x3D;i+1}^{n-1,n}a_j-a_i$ </p><p>通过观察可以发现有些值是可以进行拼接的</p><p>如$a_1$<del>$a_8$&#x3D;$a_1$</del>$a_3$+$a_3$<del>$a_8$&#x3D;$a_1$</del>$a_6$+$a_6$~$a_8$&#x3D;…</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/d2lcgwxn.png"></p><p>我们可以把这个拼接看成是在这一段的<strong>哪个位置断开</strong></p><p>这样一轮下来就相当于把开头为1和结尾为8的所有段数全部加完了 这样我们就不用再考虑1和8了<br>可以将图简化成下面这个样子</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/7xhv1f3q.png"></p><p>(如图)</p><p>同样<br>$a_2$~$a_7$这段也一样,以此类推,直到缩小到不能再缩的时候停下就可以了</p><p>(大致过程)<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/chk50fh5.png"></p><p>根据断点数量的规律</p><p>不难推出费用值&#x3D;$\sum\limits_{i&#x3D;1}^\frac{m}{2}(m-2(i-1)-1)*(a_{n-i+1}*a_i)$</p><p>把$(m-2(i-1)-1)<em>(a_{n-i+1}<em>a_i)$看成一个**组</em></em></p><p>根据贪心原则</p><p>当k&#x3D;1时</p><p>每次只需要分别取原数列排序后<strong>最大和最小的两个值形成的组</strong>,即可</p><p>如图(n&#x3D;8,m&#x3D;6)</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ycwc66og.png"></p><p>这样k&#x3D;1的情况就做完了</p><p>下面来看k&#x3D;2的情况</p><h1 id="k-x3D-2"><a href="#k-x3D-2" class="headerlink" title="k&#x3D;2"></a>k&#x3D;2</h1><p>也就是次大的费用值</p><p>根据前面那个式子</p><p>很明显可以看出,如果要得到次小费用值,就要取改变最靠近中间的那个点</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/i0frh7yc.png"><br>(左右两种方向)</p><p>但从图中的数据明显可以看出,当中间的所有值和最靠近中间的那个值相等时,是无法改变总数值的</p><p>因此在最靠中间的那个值无法对总数值进行改变时</p><p>就只能去考虑改变第二靠近中间的值了,以此类推</p><p>如果不管怎么移动都无法改变总数值</p><p>即各项均相等或n&#x3D;&#x3D;m时</p><p>输出-1</p><p>贴上丑陋不堪的代码和大致流程图<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/7h357q80.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n,m,k,a[<span class="number">300010</span>],ans,ansL,ansR;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>); </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m/<span class="number">2</span>;i++)&#123;</span><br><span class="line">ans+=(m<span class="number">-2</span>(i<span class="number">-1</span>)<span class="number">-1</span>)*(a[n-i+<span class="number">1</span>]-a[i]);<span class="comment">//求第1大和</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(k==<span class="number">1</span>) cout&lt;&lt;ans;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n==m||a[<span class="number">1</span>]==a[n])&#123;</span><br><span class="line">cout&lt;&lt;<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=m/<span class="number">2</span>+<span class="number">1</span>;i&lt;=n-m/<span class="number">2</span>;i++)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a[i]!=a[m/<span class="number">2</span>])&#123;</span><br><span class="line">ansL=a[i]-a[m/<span class="number">2</span>];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i==n-m/<span class="number">2</span>)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=m/<span class="number">2</span><span class="number">-1</span>;j&gt;=<span class="number">1</span>;j--) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (a[j]!=a[m/<span class="number">2</span>])&#123;</span><br><span class="line">                    ansL=(m<span class="number">-2</span>*j+<span class="number">1</span>)*(a[m/<span class="number">2</span>]-a[j]);<span class="comment">//算差值</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">                &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n-m/<span class="number">2</span>;i&gt;=m/<span class="number">2</span>+<span class="number">1</span>;i--)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a[i]!=a[n-m/<span class="number">2</span>+<span class="number">1</span>])&#123;</span><br><span class="line">ansR=a[n-m/<span class="number">2</span>+<span class="number">1</span>]-a[i];</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i==m/<span class="number">2</span>+<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=m/<span class="number">2</span>+<span class="number">2</span>;j&lt;=n;j++)&#123;</span><br><span class="line"><span class="keyword">if</span> (a[j]!=a[n-m/<span class="number">2</span>+<span class="number">1</span>])&#123;</span><br><span class="line"></span><br><span class="line">                    ansR=(<span class="number">2</span>*(j-n)+m<span class="number">-1</span>)*(a[j]-a[n-m/<span class="number">2</span>+<span class="number">1</span>]);<span class="comment">//化简了一下 </span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="built_in">max</span>(ans-ansL,ans-ansR);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 贪心 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>P4910 帕秋莉的手环</title>
      <link href="/2020/06/11/p4910/"/>
      <url>/2020/06/11/p4910/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="f2e352b6c25ad8d0163baee160506d2ce4b78df10de609f6c2171d9f958485d5">4630436162ade97ba2718b7d0c4b3b6351ade09e539dfebeb5402828e29e64b0e35b2270b7c9522b7d2ba447f92dd73275edc844eead7eb2fe320821d818921744a104a4173fd9bdb6fd42295b62a016bdc513417d2e3d09c7bd5c8c222b44e2e5db7852fe43c0c61eb0d15f1c51075c16455be7d2dfd06ce6d38b46e7de9e5cb820be760433fdfb681aed60e471cf4e09e40054ceb96ad347e287b444ebe718adf70ea79b0ae4028544947a0133e1213a54cab7c5cb94dd1f79c19de5ebd332c9cb1292b4bf0356cc12e68e24718a47c450ef0561e64433d46ce8561859740fabce3e39ab88efb216b2580a2925b21e163c216c7d5b4b8debed660dcd4bf85f921ff470cef42bf24aa51bfa4dc4845694bd1daad5a97aec0ccf6ad093e0588b5a2699e22ee7cbdf43431c36fe8d8f4e87fb80471a4e412a9e09213edead1efe3aa32d1d3ebba98422fb0bdc36220c08dc21acf2a365e6b37af194c9fdcc9b15559d40a3c0082745858fa92fa2417451516d0f279ef47d86b890af30a072f62d3dcf8bdf2dc3ebca4ffb59abb1eeaf2d02cae775c4e7294b47c7dba5fc84918f8b684f815b5bb8a13dfe8d4945e7212e7d7a510949806734b2bed1338bb2c8bfa38e5b3046ccaae1cc8515b0bddec3dc2c29d08efe06abcb3722fa01713215904954c0848a9203ea1a32698988cabb7544c0c3dabd030d9ca455ea401948c3f94a2492f20ab2dff28c720c80559eb1d1e26ac493d0c14b80fc4b2cba8cc027ef9f678c46d0a93ad5336c28950c61eb204d9dd041cf796a780250c013f7912455379b744a3237531825481b5b9798676bb7af6f4797be100c7d22b651e4d10df24eb5665bfec539b350995e1a9ba6a7cf76a20713d6f1b4dc9331cb000c56e2ee108c38542f42a4370deeef3dff132872eb11860802107531fde3d332f5cc8f395d117504676c5d5d77c6dbc3ff2a8d05afdb9909c85a98efddc40f669c64b6e40804714916fb9ae5cf3216b1ea1b556b8991d42a5fb9ceaca5c35a32b0f1b9cdd32e9330c8a74bcb36779c23506bdfe025e254a94a8e448c5bd8fc47ee0c270f0e3b849a1c5e15e405fb9b4cbd720f439aa09d06f7e8c2b10a27eb69e5ef6093dc0e41422cb053dd0051fc22836b48195db9196bb1153329113b14ecff217813103d42b1811efb85b2207a155f15d5ec5395447247339f655aeff92eb99d68f8b9a5e3cb9ae18c2561bb244453512d2fdc302ca4998a39c7692323e99bd780b22b21e9bb116a6b714c971b5b950519223e69c7e405eb915baa5690ad4968064bb7d968924a680b4e60de627108d6ab5b5dadd6a9c525a09b4b6383edb796d7cb580f0a2e95212fb02126d0704f38b1bad008664c76e09c348bb3b5660e73803d76f596b0b69ab4b90f0221e291f117a507f93deb9ab051685b44f81251c6e82990484aeef4f39ea70c3fc938e4cc8b6fc5f6eec4537fbbdc48f6e317c4e25971858b41c3f5077ccf8404e55adc849e2c4d7e80d16bc582e36e75d5ff883fa5200a80c30d561040e4799cb2c938aa22ed12bacf10ffe21047e7a50c12dd5396218bb27b9fee984d298f20d5ef56dff9752cbd362a2d9723aef5a66c35e8312deeed30b7a75608492fd4956f54be5269ba35b74202236de3988b4d4bfa87ecba6ddb5d0acfe3e34add6a6314c579596ad3952d87c0f387a7ac62e564ef71c9ab9ac3182a4e8f72566ea6b3f94101bbd154456e3eb11e9b3c0d1321a56be8a4c20c9910e3c86019e27be91410bba2cb83ac3b7b6470ea2805b6300cb9956cf0e6a6a9de9123fdb61ac5413ead39979762c8c04d2baec563ef7c26b056a03f4acf4cf6f0fa33a720f79b5253de4cb43e0658a2e595d6917e70e12dab2bfbd220ce172daee763092ceb03ca435d0143fed8205725f69b082da0a9302e1f67fe897e4a7c84daafabaca9fd3248709e2150c4952f93b2232d70092213b0579b8f3b7575ea266171242fd41344d60c613404ef7ec66ac691bf948c526463e857eabf697e65dcc1c2b0ec69857099f7abca97e84c29015c006971c01ed5260c628f5d91a2d24204ee8df00168e32000fe96bff3c25621c287ec7fb62c7067e4b8618279dfe4d0fdbcf5e8c13f47a880fb60f18a9eae4056fc126c7b8cbea34f3875961376ad5c623ce4baf4d947a12e552810ce13e614e601e37a461662ad5795eb64be375f7a063d939a89017e2c39efca769cbb7fd0c1a51b430626110fe3ec22ae6e89eb82f410801dbf9b12d7b414e2ced6a23ad530364802d98308593066c142262320c4026d0dcee2c8d151b3df7b42dd35c94be2583576ec7c8f52b24e9ce245f836cc1c569245d5ec81ea156ba6e3192e0dcb3e95b09d496387167348347864c67a3e25dda82ae73e20206753cd277deec391e76eafe91e8f617f6170a59043409f81de93a68151cbb1d787f70df3a3c103d903cbf30f99efac48b6389cceddee3c2c2ffbf7c4d240ba95d1f5bf2de60b5e29d16cdd4f53faba04862a194e51f1d8d309c4f345541ec9de6420788bf87a8113c12717f58cc69bc166b0e028c252fdd9ba23227f566df025906382346e54fbf89f50151def4bfbe409401c55677d12e6f1416d9bb53665b2b46be3cf0a6ebdf8b741f9ceb2d6ad8aeefd9cfd96c40a056b60cdf5b07884a9f498857500b197c564c92780855a2f5b101bacae406d15aaeebddf339ad93af76a4e73ea72d54aceb8f818678cab5db0484f86eb5c88c9c3d565448b146e62850e1a699f146e892afe52f1e90ba73b9566858791388c648dc75e267dd8f06cc4a1793f74442f01bc170677f08987ee8a611d1c6856da0d6697571f00789484597f3572a929ee6c2346b302d594787505b2906549d13b0414f8151333e84adb05b3d6a0e318f3bf8250d3ffef03f32c3867577a48c6180e6064e24c9501399a04b0dfd33c2f4bdc45be8d367ad39f23c43648f3779ed5c8b836927eae5053b5ce0988a64d1bb272f21cffc6dd36103fcd6df099e3bb313082fa1e5db5e2976e405fe2bd5af73bf8d0ab4e028a9572041f3005383a755b968f390d652d6c2a3b66fd3b9ec0bb652a45d9061d9d9b55cd41ddd378cd2df0f4abdf2d31d14035d02b8db907282a8e1f7b16f10fff28a8b15cdac18c234077132a96d113b6b44f48a351ffe0f9b6992c186061ef603c92f428981b30c2c390d25cf85442bb26faa878bc8cbc3870a125f42ae372c8ddf811d5c5002a879d67970443713e44a7f5e0366e4d0932d140b5eb5f061a8c95bae1f34c5021100f5e25fcb04d18d75d4ceb5e98da4af8c04509ed02d9eec5e0a4d7e02f1baba3c9fafebf025fe8f871eee0f8ca1b2c25ffc6917b559b38e34a3d15aa226bbb917aa2e4108f27997f1667d10c655d89b5aac19f972123830c72e7be0606c0e78f7d572fba90a62e475c16ffb4762e46649f8a06554210c1e2c8271bffb26b257841d83a41b641a912f21c201b22665487232de43ddad5e2f1e3334ec69646e33d87d0302270c8a48f16e5224fe2f70ff81c71fb3df4af170c17e0576f5b4b36ace3b1b4eeb3b30eaa0296ed5149d132897ecc9eaf4329171220ff3129b9010b2f4cfc93007ece404c4b6b8e59e5b602dd87e6261732e6735f94f85972412fcc2792d256172f71cf212400d2481cc6c2421b5894dad72848d4d722a78d2b620f8a92bd285c8ac2bce0b0078c915ff1ee2db281e66ebc4e5a7f41f803cd9a87642e6c4098cf5310fddb0fae32d3a51b95ff0f109feba1e044ddff5c19767dd88bf047ac927231a1fde52ce5417971dc6cdb0b555301f2d8d1b14014916ce27916b13be3a678d077a809cbbaf3efe8846b964772dc4d968cffa2ad994f4a6e48983ef356810b644de79cac13a4ccd18328d1b370d6f5528c7f9f50c9a60ce243af75c3242e777bf7704472118648d7f3c1ffbe2fd79aa3714820fa4f1368ac584db0a7250565acb90ecb69b585c6a2a9af27871b3747a594978e7cbf93d5441ab66906dba8e66a6ec2b8b6fe2be855926800af9098a64cc150131633816b43bd6a41b54eefb0e9443b3204d61e6614b4d76dca7b34da50ae8947ad5d4283aeb4cf8f06051663f6d121a5ba3b57abc9e75fd2089d3debd32963a102fdfeb2f62ffc26045abfec772b69728ec18f0a53f030b25c6fcc5033f3fc938a55c439e9ae019cccef120226a251482863fbf361ccf459a28047d5c5c78531e058165103e2d892e78ad15ee4690032e1526ba7ede2193ffeca959ddb658114b553bf169c79bfeef21116b0eef4668dfa617853f6b0155b4617b81916de4884e783ae5c15d4f4513819bde26fab0db901ba72c85fc0a5ea9842d4d2a7b663e4a10cee4b689389a03f33acf2af2a301faf0c172b5da4c1ea8e3bdf970741928017199952b4d84f0deefb052b5765265fbb8e2d15a9aca47547449452b7121c9db210c63a53c137fbeb2a3c5878427cebb589679c8b812c81a3968019ea17323ddce420a1e7882a740d0499e9b61579e57cd30f187af592f2bb054b9baefcee035c0c76c38ed738b69a23d179c9eb24f219cf6ab27ab4c74ff274ec817f0554ac47431e8cbfdb62c8b0060b628762b5ba8125c6e292385a451cf00f5aa66c49cc677d30294523f9a17459b9bb4bc74acf51071d841e228b63c5b42112f1aba2ba55d0760cb188a13a867f2b16a1f907eeaf4c77459e71cb20c766766a4186754cb65d523c6c86280bc878ca357f4aac2f4c43537fa03aaec4306e17d210166b27573e23b9129693952c5faa5825dc90b045101885b675bafaf1e079440cc0f36e3f64d941f2510fc02c36644cbbd296451d504091fc45065b5db1f9245b2b158a98fe44cd72a2cc62bd3b257c62f90b0dd377e9195db5194a7ad0e406c598e22e1654c6a7c644d324d6bc324fde3bda1d204c9d13eb5f530800919be626a7ce440d6b90f3172c8a6efe47391a0dde8f2693116b859bacf6ddaac55eacc3d2b75a59f037382d61723a52f06b8a2ce538515d7d8acc69f0009f022e3c4a34eaf238dc44368f81a7a845e039a1625b3fc31b4a1150f2fc379d32f0fc93a62cfeb7c23e42d8587f09b4fc4f1a563e8350e0c405044a60f03e1462fede0abd91578cdf6229621aef87d1288346848a4947c26a5fae45dbacc56dc014ace17d35afb2d423829c1cbaec490643bec16df5a14e1c6f53b5036a8e19d33896c3a82c28a12f556a3f2b19443ae3ee123465ae805ccd6c23151a63615537fbe9bc7fedf1c39b5ca396c50dd992f97344473a422ab1a65fa270fbb6806d2c1e3909632a2f4e5bb286e0c7b27d1d011fed9665dc2cf9b6a8bd2aa7544c5c4e69f71dbbfd486d1ab56c73b0dfc30f2e071a7178e236530341b303077e8e1926db0631ab0d016dcf70fcd42b1a977c0c65fb60bf16ea53873fd8587024f73de35f05a52fc14c9c2735deb928256a3a8721d73460a026643e0be32384095dcb870bff73572f06157de16179f105e5efebca7b71cf7ec158e65b8a11c6d332c1abf29c4a4945e580719e92894927ec17b6cf97d49926d9afba60a0d15304817456b2a9664b6ee06a3efd27d77f5d3882b17d88a7ae867f144d5db702b5cdfe5b4449d339c88beac386693870f161111eb35758e7a61b016adb07b1fabc54bab6502d9e3a68e32040de1aecbd5cfd16adefba275196caa8746ec0b5c9f04f31ae6bcd790f2c89a527eb2b41ad97bb4f739c98427cc8bc764095ac542b38294905d7dc3335cf7ea93c1c570fdf4720f5c338c49f8a96ea15fd81704fc038793ba40d8ee7e0377672cba1d11963a7b0cb9e6b92d9056c32daa9a91bd2f9e843427e0b74b74f251153f869a18ae51cb0cb590defdc266299a359a9385b5f8bc215f0c348034e1c64057f30fdfb545659b476c0d3144c45661b3ad0dbbe5e96ea54c714c0785944f3f74235adcf4f615308334f0ef2f5653a664c8d0ac8a860ba6e7996233d80697190282550b73c9c1179acbb077d68e3cc44ac0b3ea82c5d512563ef3f361639cc7626943b676879b4ca0bdf272a91bb0636f28f359543219eeb89f948dca9c00c131659060cf680590a1fe4083505a051efa2a9d344fced3df7a3bc0552340bf08ed658bd9ffb0d4449c20a7f4be810f4e30a10eaccb17dca504e1b035899bbcc91a8b4738499a0e4bc0b30a523881cdbeb71fd394ab0a5dd052d311df4b4a84a93ce91dfc5fa8a686db25392e7893ee54e52a1b08b0a742cbb040ecb38ebbe088307fcbd96a4834e334c44c28f4787feaa9be606f5ed5d8e32257d720bc209b761cb4f54ecc43b832d4630ba9b35e155fee1eb90e36702c5a3c8e680e0b280b4bca434a8a26f0701b294f14debebcba9c2bf831ecf2de591b1399ab20e486af25e754c7b6775c05b3d8de50bda9e0d423eb4d0435696f09257967764249abb509d38c125b2a324f6157045b5f0bd389ebbdc7f0063947c2a97d9892cae38b24584c436135cd97f3d9f53e1dda5664468755075143d65c1d00aae4726affe1b5f9595b8e348e2178dae9fc9f4494bbaeedb9dd14bbad25c438d22cc3a4da594c7a37acc3c5f2cbda4551adc27e87f34e102c4ddc312cf14e4d1f92682e5016a71cefd0d264a142235573c183e6d97a8951b4a4c7e51ff5115f79a68442bfc5f9c809e855037fd45dd68b46e739a695ee167846e53eb3ded47a92dab259971e5a85ddbdbd0dae12ef0d1aa647220e5cbfd8041a0a5fd7ac111045708b96fd423d7b9009847e9d51ecefcd52fc22723752f6216ae3d6c4f9d066b0056d63204efaeb358cec2bbd4dbf90b98eac77d14e6f0c4c5a47991820e67a927113061394e513d6587caa1017cb79a8c98b209fabcfcaa6c0acb12fe1c9ae6f6e24b7aaaf74ef5e3e9b7c341dbffaa7582f5c67488ae6be45112e64fb82149661952aaf013052d2bcbb3a49d628915cb1c855ed08dc893087f86ac037b9fa08d102ce78ef64fadb3fdd67192425b044b4b44fcdc2ac0191c5293f7bfd839ef15893a87fefbbe793469befe14edfad3ef00b3d777e016bd97a6c0b420d58db052bab4a3eb06dc6c1988fe73668b4cec7c866bf55756141ca854a4b4b8f51e628b756ed559e029029186f1519c264adc3c6e2aa55d21554c3da8a909379825266f20aa217ed73896800d85e3c1497f2b1a319a26e529de27b4ba2a31d511f555151cc0279edebcda215814c1ad49217a50d3f6ba8e67927566484ff1ed50def4c6cba7b52d48968583e0b2f696a0607622c61a8826d0e8b2f2d89a2e8de71940f4cb75cde341e6ceac543827d317c01a3cbc7e9162e1eed4f82d404cbb954939138a15adc055ba10db27bf32121c8141ada9b9971800e8bd7adf03e1d3a28406965483ddb7fa1a3a5c4cf43edec8aadcc54ad9676a811bf476c5fdd3708bfe37c6376ba949f702dc6050d190cc9970a5896c3ee7ddf91395a921fa583d24b2ca475f2cf840e6ed97f02c20abf868811a6cf77ec86889a6914e758260596168b1918c9d6c4650efc624960cb4bd43d10598443a8230c2d092b2df7af6c4dbe54bb23c50d3180212602728dbbd1d8b561bbf8f7e2bb6098d809c03348db005027a1eed36901e361ef3789ee8f3a19be449446f0dfa358d403312710d1e18708cb37acc4181b7739c51c4db74816a0c9f6dab3515ec0908d1a5dab96d8259722544b89565c5f1f744c16750cf87e5e24b62ab1f57f379afddcd3c1d944dffb8570a3967dd7ae0bdc369cfdb7aa92c19c489192de6a38f605fb92cb38a6c1ae2a499ae2dd546c30f648dd4da817c5c62b9603f3181eaa8cb06e4545053bfeaafaf0308455daa7e3f6eef544d33f0cb8f8c76b6e75616e5e0557a4052cf430d2550696549de3e82312529985b05f5c9c52d6b54556f7d52c10fec4bebcbfb0610ba369146dbf8ad96661b36fc051529ac576c09b837677d79b231830bce3abfa914e7abd10fa79023275a8665f990653b8b2f6d4dbffd949dcb65999fb2cc8c85d39f78721afbdaa8fd17d9514206446fca68d53431dd9a19cbce68b1880f7addb30feeb4809a69831b6e6b49a8cc7d6c78d894438bbca8a8b452a3b9fe595742acdd41442c4863fd49a7d0f34ee796571fc2b4c0212b770bb671b391f6b0428671637b1028f69927c8e5d1ecf2a75044848a64480c20147503a01671d472729fc2ff2c51c0e04b701b7f7f3fe9a202005958e213d2b7bdd4c7e211b58b0dd91685b20b14151ed46cc9ed9b5df4191bfb5c09f51ce2451525977f1cbfad125b51ddf4a3c5a66bfaef844de556272c35549ff99eb1e98f6afc536b2a18bccac82413807992c108fae5fba08c680dd3e862e441e4f6372122299272c659edf72c2030651481ebc5ab23c7625a9affe360501ca3237208a66cac0a3aea846f4b022b1f67861a7f55dfe066fe23721d53bc6803a456370dc064bf73f81da5ee27d2e90c29f067a9c66fc40a3f7c291406c57221e4bba4cc50cb3d12101b682218e7a14d84e01fcb1b058ee5666b86b5c9539586dc5f3b0fa6d8e0ae57e42066ba5cd0ae839875734000cf05722bb37cacab9e2b25aa7c5642745723de73f57cf19c2c9496257c5ba1491dbc10007558efbfbe1aebe470cb0cb784a00e6b36c1e0e65d407d6d20d5660b840b4b7a7e2db080bb3ab381d4fda67b64f062e08668cede98c798cbb95098efde4af327d930a408152c786346308f496b574161900d271f3e9cde01106c706665ea3038d20e01517ae7a04ea77b50b5f284d4a86d04b1b3dca4c4d877ee86fc91195fe25c3d040b19c4b58ed0450dc449afcbe3df120c34d609228c527f5b4a392391de015bec1db39ef942d4dbc9e6eaa3267be5a953264784f8d74e929fe48ab6a602541733249f2d47b817f4a1d47da25510443429ac53ced70684c95023c30b074dd143a0d82927eca78c13460fca84f18f6a5239cb2e5de264a51156d45a9d2b1bc25cf7f099cc113ed2f1ec04f7128c741995fcdc80ffc9d0cdf2d4d1fe14fed46121fa4de0315c6ec471442e999ffd6dc907a019df325e1c885a8ed5b572e5ce091f9e3a62be53d8a5594f1f7404a5ab31e7e3cc0c3b4b90dfabc7690ad7961f02ea6a0197cf30caa8188c4e3ea5a9763fb12cf47b8c139ae156d7d54b0dec88b600a45eee912115df6d74518c4a4201534be62ecf315daa54f5ef16c6089512667eac12876206d148456be1d41847f4aa1baba4686348df337c07a2131f7526ba71a0bfcc40d50ed917d7c32a52b08bec2ad02ac333885745dbf85c69ac4e18dc4f68d484f80501fdc7a5c847c66432ad00c5bef7f01f19338ef72f7c89de2933c151c3a1d8d45b3da023633498f39265593553f5f93221581ba15b99249a00c97295dcac9d196d7648eae136d43275e195d0363c58c8b8b0e58220775a98e6bfe8a30fb1895433decb25359cacb3e3788d276ed7e6699cbfa1bd501e136a2b24daeba33aed3b3c38df458647df9e733c53a5339f13fa756be22514ecabb191d0d20ade960d2fd728e786d255ecfa2c37439b4f1228838e22892314de08a80bbc4f3207dd3593e7cbc12adbccaae075a8172dacb7030e9c5b444128954fcdc5cc2957ad8778e1625f7437de461f6b35393bee44e940d42571bc2fe4f5e1b826449fcf4d3fca4bc23978e6e84af86c120a10bce2754c5eac8c3f7f0d7acdab50f0903b9985e0e407847be664fd9871ee613adb19384223825430335decc5bc6690eb5aad0c551104d653593f65dd1ecaa9caa7ac3f493bb6b91f9e8e73352a1fd05a8c116fc9a796d60f8fec29ebaeb5968aefef712254c99b91187ff45ad739a3b97b53d15a6fef457fc7e869baedb08371a148712591b14179bb0a03793b8c49eaaad1071900f53ed7e6c381500b7623bb0985bb87a12dd1bfe1da60d642186ae5b4fcdf36bbcd9e08ac44773b4439f6fb99cc149f835bf10cc4cacb9d6203476af2e855266f1c88bc18f649e8e4df9c37b3a2304893a248fa49b4675ddc10efb95008b6408a31b1708c86a110a9db99dd17c3db71b58d7eed3e86cd9f6141515ff216c67e3733ccc3e456e356c520eca29a065623b79e616037915f5f69df4fee2a105ea568fc63595acff4db97848b3d1d54d5bda6647db14d9167909e5b7cfeb26e7eda205fc95794e2620bd3bdb4436239db9caacde610479f8b67580aa7c663d216d5c3fb2106be57c6c7e9526a98c852300698fc68347d8655a4345ddf303fd04a51e62d70bcd24033c55992444e16249da97571b3e0e1befd986aa811540cbca02ea3559591711bc4343dcb0b0471d7b82df9d78d5f37a410ab16f09a599bb63b5b0522ba2c72fa86174de00a0723f54753047bbc1b4fdb3841d1cee4770e6a5dc17a921739d5242d065a602f2c4e6e4184444249f578ff518448401df77c541e87b1f6b7b6da33367a70edbe587a41802ebf5368b84ee136b778464e5cde35130bef714656c38a49312547808a27e00566f4ec0414c584e290c015f88c71e229c95578a00765cd9dff6f53196ef2bcdda3f02ea27ae8f63b4c19f231715afd5a04980efcd7e785ba0d06cef12eb36fb78133f31964aa8dd6e48afe2c51a4749a96c4b56d5bfc5c9c037e84b8c618e900aff5ff631100a03e6d601ca5b8f0d7a2acdc1751a58fa2e1636ce5703c2a44efeab2d218ded7d311654c18aabf1562b89aaf7897178ba60b6c067c4b590eb9613c84ae2cf4df7b39080990f3df1e8b4fa1c9bf087723cbb7ce5aa6f45dd2650766c1e0cbd2705408f2679ab8a862b8b98262fc1ebadc3228749c87200e54eee66b9268132af2e67e015f26d838f51a68d2fabd5fca86272be4b6f818445de7dd35e8e54f453c050dc6dba4c1ca515817ea1d756725d36c2e24ad1de7c3af0914cdda65ec1559824c709e3ea95f0b45930067d08463482dbb51a60dcb213bcfd2a105c9df97325cfee35da9486541ef8a4f4daa34858caf973340caa84dc372e7d20e0adb1c362c003ddf10a364d4b2037f2a4e3aebed445ac991597c36f133bc26ae0585ad4e25988df1629d69cdbdf7a33a0eb96578bd6516893d5ec032b0d260b242fc044f24f607e2180a537a869f24e808e4e241b92d5cc7851e64a78db02922661204aa9e8046e340548921831004d2e3e865dbea7ce46f9d9963eeffea75f1bc3f2829a7f4e268cbb95f88042683a4a487b1bace6368e6a64d9525cd0781a4c7365f8ea7cbb78b48852cb1b2ce2ff9b9659659af364b95c728f202c4082a849252ea768ec5de5f43794b0587d66afe7b87bdc7b3147f0153fd3da37842fa73e53592afdc64affd3b2afbd942875ed2331c74b56687e6f7057fb1af470535e3088c0f0d19d4eb1f4a18e77cd08b5df8a452e6dd2337211d1c92edec65361315f756c9b474ad122f83243f451acff94d7a55e419ce7c0d61a887f7822ae0da112bef2f815cdb13ff488fd8d5196eed2548057140911824612ca62d5ca9fed0ada4eec8328617779bfb69bd3602ace0bc9cf03183d52ebdf97395600425ef9823e337d1c411faf808bcc1732e0427407f98a6119bef92b4b9edf3512abdca2ca2e80c175df6061f270f65a38f87111a65bdd5851b387bd709724871c388c8afb3ec6542cbd4b97680ce167fb1057a8d98629af68abf33569e887899ddd641df5e53b15444359dc2fe760e7a054a13d9030c613f619bf88fe2ff1e1c1a551a723e06ce91e1c0e51c6f7dae7d892b644cc94403997bac7f38263a4b10f675b6046affc7683bd270a0ef2e3881cf37cf0ac1a109cb55bfca3b201ac11a45b7b5e0478659cd3037d7e86446e9802edb45c6a5fc0ba6a071f8f1c084950377cb47bb03f4b88a11deb8fb4ffcb69c372a6b6f37b37a5bc8d58ef975c4dc61d9377a2e87977d121fe8177a390297a4e9d111b040270867408b6f4e04e2daba619639f16075bdeb5e1e40969efef6d4dc57bcd5e42bec15ef01f609f9786c8ede0844545f333e5e6148b23658fc20a80a0a0184bc9cda46aaaba12a641d8a2421424347db3a1ca6714381cabb62e45f3368fe436c6a4bb2aef963fc93baf946e3e5c113215f47f7eb80bb5b029d715fd6c7301b57a6fe571bc66ea43b8e3dca4ab065c7adbebb3b77e7486519bb0a1271faf68b135e43355672d4a50db3a4ab393eb84b120963e2402d3d5356d108a96f2ff9f8b831cbdd42f8fe921a1b696360c4b6c7d96e8b26e0f05cc03da10468c4cf11ba7dc70a9da8d0c3ddf04bb53fa904dd707856022a14a24c44002e05a8d4c8eeabe3afe27656a4529b0bc41bf54ed0e85fe11516f46e014bf983f596940d49c8e2259f3fef8765e04838ff2681783d18458b772dfc66d283be6058c4413d4c688164ca24b25c73b436a505e6c749b97cab2016974a04e712fbaa5c67842d68b5545620d1365f1240ad83d0e7ede04ccc4304b57e4835975bd8a2b3bc931840a02fc7f7efcc08bb150ff3247b927dc987ba66c729536c71f2612da13b64b3cc82fe6d7c82e610ee257b0d6aee2162ba7309fb50aa50b445646772d2657a50382f89b12f67e22078e45b6b148f88237efce470fc5122ae789c1382d8482b2b5032cf64fcee9f682264aceb495295324936abf026ec0006ff4ed124a9e78c782eb0f918034faf02c3d6ac7b6f9552fd98ed4ab289bc3a48da93140fec7c16d3edb20fcae7f7a465ee3723cbd01a36eade7926e1b5603c35a2725d4b6c2109cf2acc1f0239517581fb9f9dd5b86295351c37e254a4e4f2ebd31a7a371363311188698fc971624572afedae0a00ee13221c001cf97bf51159afa33d887afd094b4a0f167b49338e8e9b511e15ec7083f2c8c1692ae8909fc817f09494405682a5b364256b99e3e98afe55a8978129949fd6839d54beb30aa5639136df0a29962119b04100e1f77e928544ea74324e978d51a4e855810f1054b015ba7b3f525622ff0fae40ce8e30e736414d31f39a3127099f01c65caaca30dee7d304c594f4d76402c1accbddfe82f641e2c3533272c812fcbcc684eec28d44f614feda3887835d4cdb300219d233d9b9e34bc53da5f028d07ce6ab2e74b1d6848d4bfed9408a9b8b856b4370a2029a2accfc7daf50f8cb1d8a98a554a99f067b1d46b6b8497bebf20fdb7b502f1a6a426c96572041b05d8b46d431ac5d709f527be393852ae3bbcf9ff0bc44804eea931a16894198debbb46293cabaf1f6db969c15409ef0e4d43d644bda786610</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> OI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划-线性dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试</title>
      <link href="/2018/01/05/hello-world/"/>
      <url>/2018/01/05/hello-world/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="8a0d4dd5c597967ad94b1e2154a7074f8e43f43a1e81a1c3c932ff646a44c1d4">0ab621055c6f9ff13bf87c95a3287a2dc09a18c7e7a3cc4a7af19ca5c300815fe57efc34b18eedbd9ede76004dcd043b27a7ac31c9f4c0ed8207f9c64c7a04139a199a04192a7a0f77efd4746075d710c285dcbf63c4d4b8a0d931f08b874f529b069809b497e4a5c6204410518ce6b7e6ffafebd993783c9d5104db2e90067231d06affa04e8a72f11fbf7826b78dc51d0200b66e7687b4d26127823003119a996f980b92a53cfa34a3f950b14740c5b5a4f78cc1d3ceda40e51ec4e792fbca552aaeef033e896fa19e158668cba76d9c401978cfe2f0621eccede203ca4584628635969cd842d99f1925bdf9347134dfbcd573c1d1923996251781b2c3b1e15bf54b0c0dcb60aebc25f6cf2a0c9f80cd0e31bc0335c32d2be639fce3acb691b7ce9153476960476c97902ecedfe725d3250b1aea3ded241b8cbb4828edc7aa1381587cfa768df85c48886120b885dc2b17aada22fbf20e599cc5dbab31e6e535d500922ae8ca9405e52182428e034b4af8bcbfd39e2845e7d4e72171fdb76d131a4839cc64ee23dad1dc5abe9f7d27367784ae57d35e1b218067fd511542398b2b1ac1e32493fa1926211e6ff210a2a3875eeb038be4b745504587de1e2aaf64d6fcf6eca96a19904f9e7a3b6d1a009aa4a03f07be1ef847bc73c894f5faa12b2ecfa5d6162c630712d42c799d037c0d821fb528736f088a721232daca17ebc3af71a5fb7f6a261080f197b8d571e9b3c43a20ca83f4354b7bea51d95bfc71b65c41466385515945a8225ca4739a7f32d84fb78d071bb382de17e9fe92f2337d3a7e5e844b4fd46080f464fd9e4ea1fa7ee72943f91de46ff07c22e3d8e0e25dfc7304af4e2174498a8b55657fdc137b18f30960385112cc726cf7c24f01073c60436fa45126146ea675d451dc96dfa245a979347ad1388a3d108533a0ce616166a2a4af707893f34d9a54747e526533dc19cff868b51a96b82036a814d0369a3e8e3a02f3e7c3fd5c67bd9706856176355165e5b76402017f6c0f7fcbd5b8edcc056062277bf17ebcaef285c682a39ffb8a7239c662f8aa904387119cf7e0b3f3bc7cae37775aaaa722224a0d9126db5920ea6d635d8085c001851ab6fb027bd67e9fd5d20ef0342c7b271bb1df11bd1a2475aaa8a3483337c1bda4de8e255b85d002e951d88c470e2a2693f041bfe0cb9b389587c5bf84e47020a6f79c28271bfe3a3863be2d0e3c3da070f3c83ef2ac84e3484b25db5e8afdc7c9614c4c82153340e05138d175fecbf393a22bb78abc90a2038dfd8a536c2d57a98e35195bea04b8cbdc291181c00f5564cba54b883ff96789a0accfedb9f5e01fb2de9c72f43bab491dcb452beef60852e7b76c639854344f6d0d27d0234d2b7b40863a55e4e05d1f0184e1ca34f73f1ddc82fb31729b00fe8009077bca9a74cfc85257e9eb94bd1af2f8153d01a53032690181cc4cceb18cf637ebb99c270bd36563fe6379e7aa4a666286ca6bb7164d2b3b42048bb60430717223e2e605808569800a84659eeab566baf05e1f797d1618721d80f2ad3e19e5b7b9d1f50598fc72f646d2fa010853453b88c7ff18eb2a333994894b414a440fa2c3c7e1f3a340d9a428ea4bb6b64392ddfaae813243e55a0ce7147ca5272d2d82bd9bf8c7f32843127d6b42ed4565b5b364109b9202438754dd5eebc31fcba125755168f76ded8ae8e599745d70ea061a52857d020f781968e11cd1d4302f2b48a7c0ec8b9e7ab5a9bb1c89208742161a2d495a16714aa8b3dc6c7cbcafb7ea2f296d30ed3f9aef5783f83dfd632f3a4b19bc68ec897a07de00e53f542db38275ecca8b80b35bab839f50241f36c1a9d4997d149bf13200cfb1aaaea338d7afecdbcd08d94d9e053320a4d23f30bee6a815cb430b3febe49effb49488a3b1cc17cb3eee7fe07d6a822e7b4d1545bed26f1029e4e640d1162856ee0be1c8143fb1e3da27e9cc32cc1c25ef04c749adc7a33f9b06367873881ee86ab163cb3c14632b18df48f12dfeca05d66f2e4c577789238f46d1ec176f4483966709bad95b1cdd8f0894034de1b15c4f11e5e6e29a8a49de61084d1b2f227e5923431f4e3bb8ab8499ea1c846abc07222c2d7b8289857ca8848308b813fa23c9896020f04ff49474ffb60f2477aeae002ba483daf6e17d377a8957f259dd104ee7cad0f100ac2b2dc45fe46948f655a8427649ecd73ab8632c9048821bbca4c719f3e627307f79c3c59b6e7d8589bdb4415c894ef0bdb268ea4622f9435df9d8764d1a6738ebff4a02c934fdb55a2667aa0d23ba986bbe97bdd6f3b6960050bf0749e28fd040ea9c48afdd08ef1c7be0fd0870c8058e024f00af262d3082015447ea1f1687447ac8b076904fd223e0bb9e72d13d37758c973ff506c655aa6a4c7b1988bf332df8892d3bcfc5dcb0f7cc961871c5b04a91b6797075b31d650c3abb0e1c8faf96eaa6fedc1d31d8f52ef1781c65a3af0d0776f06f0721186f44af3f14852a9558c12a028b62138146f7895ba46339431e81920c70941b78f3a688a642feec7f8d3a5822b463cd77b7e3e7ab5e23ae7f11fd5c3e10af1163d2af3b11ccc4349b580a7d90a4f9bdacf7996a97269c66ad9d84b69e3e8bb8c12588deb80aa588468f880c5508dc6700837457ac4d20b3ea6bbc98a6c20d00fe3c62f1c7d5c07c146e9e6285ecd483cc352da77523fe9224edf4f99cf242bc81b55f469eb9c51ad627c64087ffd00c825cb08eca9ddd1508a5b4f016c7519fb0273c67fbe2d2f0462dd02ad584b8917b57a2dc16194e8a1c256cc7b82b279151c9e2d18fad517e553c9cf2b582ac8ae315eee2223d05630fb112fe8444e7a27011fb45c8d6d73c1ddb66ee77e4c44cb38474aaaefcc0e06ff288b550ed8e6518e57986c3670b0027fc0f173e9027072719827cd1aeac4bf87259b3019964e6b675540b37f2827d83f302e7e55a32385bd8c9ba20e7291ace4d7b8f70fdd8ccf716d115e7be64d01a4d09d332069dcf9c355bdc3d0694258db91f25d7fe86569a7d3bb39c01294d4ace8541c18b58a1cf3dcb7d5a574e424c49a1c0e4cdabf97332ece805074510f8255eb63e182ae6f24d690393fc5cfabe23a983143f43cda6da4fd6c11d34fb7f6c1eaf79f7c22d07106f30e46e95115af531eb497e887c317ba2bd4640902a4ae45ec73d0f9c4cd75c8f0a96f8ec8bdb474909f583aadb204fb7f7dc8be2503df29bfb0f4fbdb26474b7699d0beda28ca086f828de20fe9994f2cb14f814a858f62ac30288262f58e88ff191600e0c8175ca03a53531779ccd21df17b4b153211800c0ccf817b65c8f88857aa522bfc7473fb81951f8688221f2da100a96e565947bd290b28e566371031984c74244d9f6c95334fa5b819989443627531149edab1f5fa9b90a997e527423ab3bbc4ba2eda02c2eff4823fadcd154432f3a74ff9a15b0da18f20134c4ade8fcf8bb36c8a575ef711c282da4b4b756066466100bdc6980051232d6c8295cc442e6a418d1ecad5a08982fecb6bde5131003ca70b752eb58bf104ca126dd45862a0cd56d80f47a942a74022cc6e3b3ef704a2697a64dffe7c5d1ac723139533086e9a7c454318dade70f685f4b4838043dc1778e15142d610376def103b5de02da256b2d699e1a4a908fa53724f5969c7253815f6bbfa47db609ea7ef4647566c11b96c76fd963b3870424878ee9f0aba94b25161475d6a33069ae1a1bc09b4110fb0eca3ca2b66542efce170674c79b6cec71fb7507f25b17aaa65dafc70558b1c46f200ccfe6475523b4e5466aef2e4fd3b61a8ceee987b96cd4e027032255370e65560705e4f1cd6ccbf7b1216c6fe4e96b9f2a43f6e9846a7a9231da1b2cd8ebf26d49cf4e5614281383920e82c1ce13fc7cd15e646f155699488b4811a750627bc03d1bee02f50d72976ee318b095aa5b590997b1d37f7e7fdc990804adec026993cb5d4954dd192782a31387b5410c62e014be1866373355b0749beb50e491c158e40347d01881028baf2b34c8d9055c6e0bf620f9c245b14fd4bc32baccc05ac24b802688d72b7889f9aec6dfeffa261b00aa8aa98b441a6104434996a08e1f5d1f10e69c63bacc5fcf2e9b62cf6db1d04ea0adaf85a1f77bb37cdda5da6af0008ef3679b0e386fa507530b6c7049a09c66db661c8d93eb934b345138aa6382ad90eedad9fe951e98f1c7048b6f5cfbfb82fdd3a61525702fd1b63b60fa638e1d6c3e16e935046ffbf3e12501b9a42fffbea325fbabb5a76d3bc683f14d5b659420d6c7e18b45d6f01f7e3171eefae41859473bcd3314645ea094f15ce6e47e3fd6f775a2ad54ce0b758df6fc99f93734de62a9b051144e91c85de94d040036ecd9ecb3707f7dd40f2d3a710b341c109b5df7757de4b6d4e6ca2fdb19b8a6f38f2f5a1db3276f381418c0fa4e782691eadd2ef9d841af4a908c9eec6cf893441c8e37a8f2ca34d94af301fcad8248211d56268a29e28218bb0d4ab800514aa55ee8ebd2bbe4498766a1fc06b48087f76fae2a439078616585eb68594c6ea28194e73a04533f58fe4cb52fbc2d53c493699216da9ba21aaf0efcc3bf3791ecb8a0d45ed3ceaa91cebde00eafb1c3d57fe3284231374d73ad2f7b395160b59685c550c763212be366c425d72a40ca3172e5e0bc83f6585dfc0ad90a16f26c43f299429ca7dedcddec6a4199aadfe1718e6e8f65313e46547b6e45dc257c0875808170137c5ff2fd8c712ec305c1f610bdbe4a2f1a7585334b6eb9a2500a6d7d047135fe0345cc1e8f8d75886b6a0a7aab60bb696a5da6f531fb0302af720f243537806fa271e62154ad14be0e08fb89560a5dd611c44a2967784c6f354f5e359b4e9c95bfe7991c52f37d781fb2e1971bcd13ac01bd40d8ef9975f3b91c361e50bab9d339555e6ba42f8ed150c8e195e3390a0d7b5a1db74a54937995e3198190d66c73d463d75dc41c1bed854a89e5c109b949bb482d49891eb8ea2908c2e2b21160a06232ab60b70eb079fbebce284c44487bdfacbf699f549654f5ba34683d58ba4c7567796941e5bb4378224df24e4155f7b763da92cc0c91849e9b1eb2a817a280f0ff2d42240bc18228cfc8b3148d8d9e735473302d27468f0b4ebc89eb04739622f5e1d792e64a3bb11d074d1bb53a0875ef69c64cd0b001b9abbe57201c5027d70fd8633a64887c54b2d0a61665a29c9d17d1a503d859fb9d29301b016d2f70b861685e2a18effd74845844fc3f4cf498b40917047867bf30e0056f31effdd24c626afc9e7cc8f22c54fdbaa4f9d3971e59f016f7fc2ef1c7ff4eea5e7494d4ccc37aacd9cdae497413af94b3df340fe1692e633ce2a8fec582d8ccd7f9256ff7382baa4913c4dc3798839bdedc4b5cc06cee2b5fc4a97b74aa8acd38076c400cde04388985f18bf206b28bbabd95ffe99b3dcab23bae66937a68670fceb711df0d8bb4d81f471617a5d0f4476fdc60a802324139934226b6bbe31176d36a09ef9a5cc3d978b1bf4d116068cbda8bf4e471b893a42b740e37f2180c5d6f4175697c51d24a626f6c9ebe20e2956c74d3943199fd8c2b8ea5ef84eef3dd12faba90b97e7538bfdbaa771df221c95863343863106660f864d1100818cc7076f1176ddda56e838ab764a557253fc23c3efad83ffa816894a631635ad6b781ab374bbc2c654d321497aaa6cbc34ce04f9a94b652e209802b13e63a5fa1306e964e1c8d09ff7143c761827e3d4f2f6381ef86be7ef8191bda8d7a032e26145c1febf9eb1e6f17be88d27f1590979fe599d1875ea63e4b40252601e6d19cd9b2d4df393d209eb0c70965e0e51a13066ef0fbeb5cd6e44f075cd44bac5c3eba1c681fe4aeefacb3ca82e26070d89bacdf5c34504638c1bc5d840be5f567cdb22127d5d786023d82bb404306c3a43c6e9edf8a5ab1f1a969828193ee4c566a0ea3706545d20006e7a08b110070516d70645a3d6d79b6ba730ba28c73d7552bb2b093476233592f704b21fc7e90dbf81528c1f0e3c0d21e2996173c8b1f693c1407d9aa40fd8349b94e186ed84dd76612425562bb4c1d3e917106119f92a299eaebcdc590d0d9db813da30234e69ea4e02393352cc500d550fac9ea93b0f87ba7214388e7c77c63490e023a27b442f8824b387430cbba28fc662dc809e18d9c8c6923eb538865925ac0dca23f681024738a1078e1853f1143419c3a3014d3240bf7b44331cf4c113b1210eb4f68154a2265138c38b74e5d4471f71fdc96ea711b2e8df96eae6f3150d96c32aa3e161db705b33601f91d09886024f8013f165930ca9e7dbc422094133020ec7192d90a332cb7979f329d06c12846939080f96c9ffd8027455ba24dce475ca7c90ca9c58cd00bb331d91f9f6959bc1b70dddd9c4c888661e16b4ef80d6eef9d78f0523bba25d3a91bcb37042185c81d43c3ebaf73c1ef329b8d96dc556a157e74218c54daa7341e2ae9f240718c982337829004bb31b6c7bc155ea9e98ad6d0f7c30e18286afc7f3c024298844989379af7cd9ab27482fe9d1f336a6f452ca8831e36af35bfeddf2f7fc28dd86a2a203fb03efc50bc91472be9403ec40edf98c6d54cfc3204d38fb596c637aa22d0ddee9762939c3b1450057aa8b9ca40172964b300f3e63da9e19d24b4bfaf66eb7b5889e407fc3647c76562b83fc27099e748f47255e2d9e85829bb7da416f7d8a8a438168d3b1d269f182bf245c01d069a7a9f627af2ffe6576ce64ba5217737886740755b01c505d7c7d8d041481ae823efa3b4c4f051764eed55b03262d2bb8caaa1b0810f2a5f9f1ae359ec8c31caf852bb9f1908535d2efc43f2c600a1b15e481adc7e4c783dcd30704a0b3861c7602a7178f7fcef496ff4d32ca7cb4b9a14969f854100b8b99505f73cbd9be634de7eccbd3d494dd97334f7c32de1f032c1a34a088f05cf9c079a376382fd46e108e31acbbe1a6cb1348e07f5e6386bac1854c1631fb5b3a3e69e9b5436345316add60a8df6ea4557e9b13a3852e6274f0181fa3d8cf6b732ab229e8fce3e1e7e8b9f3b2fe08b604174f2723c083c7060d535d0b543b44fd25672861ebade99c9a08edb0c07ba420eff319b96dbeecc9096dd7665bb3eb70de32c42e59c7ea64ab475e84a0e6d58a4606397faea694628ce3c2eb8660a07df269982b01e49e753f5f79e5837920b31ad50200a2c8d16283be3c1195a71c1e12ce1802dc7b231e37cab3bae42063f7591d571bb0f7d87d278daa52d48bf390a84ffc6f71f4c29c55de31d49e6f8f0e414f438cae9dfadc0404a70a7e40872bc869dfcda3f9ac1e5e34139e7595a9678077ad094d734e6a1b1ac2d0ae3f7c7f64885cbca76530413fec814ccf1fae0d26f149d90794f082158e16257d09905c717d5a9e97dc2493d4114e4ac3148d975809e1adb848ed928286b0f17aac68e8c4561e9454662ead5bc3fb9d50df202f6cced315678c7e976e2badcf8a530a3bcc3fd178a6ce95914c6e8211b7d246d07e60096764f7e47db584dd23202b4bd1eeb55cf1971cde45204dac3fd5f89c71a1051a24c61b2f41b1e52072a85647efd09e35f8945c349bbd590b588b504c96ae59ea53f5537c7745c9fbf4cd8415e11fb8243fa1a6a16ce1243a195e18ed4056f4d3c64da30158e4a4594a285857742ef42f4df15fb341a74b6c65217bff833d4e2732b36159fb6e184b65167d9ccf1a91c6bbe5194afd0ddac3225604c6961ce77c5242e2d6bda1e7077218f2c52b078974103595679a95834ab8c714ff6048eddcef81cabd338b2daafb97836ec80aba53864a660ed9f8ca70a98b75aa790579ec702eab8729b06c1805cf3ae4473c8b2a07878bcdf58852fa1e67d4f2047d3f452840ecae6d1aed8233fdbbf4657687291625dd762881ccba86b01949183b3d8c0ca8aa8c48bf6a54a8bc2ccce7eb8291b0ebbe26c75154118191f9737f6253ff288399af73cb64168cd4d0d63b28ff1c5584e342a91e7962307abcc1a15b29a1e4210e14296af09ffad59963756e9599788d88803d5a089c0f61847e2acd90a92e052cc0cd65d64579d2dc45d73c33d9de9d8ab4684f62976737b7b75b9e3b0cb5986b8f673a5fd2ef484792d19b40ab154e095c6b53e576679e9efaa34470ee87ef7889fcb15da73efce7c7286f987175b6640ff40fd9e4e12db247170c31a871463e3d780c12ef7d367390453686226047c9aba5e1a877625c2c70c9a9356309b3e803105081e34e6e58db76a0cf6e3998fbdd0d33ad8e76ceea0b28fe5272cc7b67d1c6c6bcba4f918baba66cc25bb9b6eee619885f3ed9c0ff65661d33749e402b3b7872b9c2ca581b5a44707a84f8f132ab88bd8962a3b2703a43c6d164ba1deadee06b535333d77d53d86987cbae41f444abe3219d51e7208318c3a0f5d8d28adda82cc96016303e4e7ac3f4930df91cdff115a4cac0a43007c03cd119435b36b3b441033c530afa44755728a7c747a8c45ac526a9d4678175e624b29dcd810c7ed25953fb5fd5006a2fc0a4b2251147ca84787df0c65ca5d771a69c50c8263402694f13e59aefae6d916ce047e2c72313e727a7c5df3825e8f3541a3c69ff55369b1067fa8c37afb92a2c97adc006799c04ed8a696e36da4b3c7ad7ffbfd9937b9308461d47fa0049ebc1c85143eda1058b30cbb905729dfbbc2708de1c525cd814b22d8928561a8837cb25a0e71127a67bf07a6c9271893bd7b587324f00339ef0356616ed5bba42cb11448736e97d2dfcbd78193c273d858908a115321fdf5a7dec7eb4b045575bc45f48b85a376a3047b49814442ced01856e7a32a4e17bd78a3d9722d95401cb3434ade7f8766658ba6c0c8dcd4dfd55ca538a8081c579602fe5b554c3de2dafb4771e8c95aae57e2cd74b631f8805722319208b65bed45f7bd2b18398de0168d8da4527cd9ecf220ee82cd49f809e721591d86ed913c6c2f150024c1ac2e3f74e00944cadaa16557231609d1bf4f2f3a385809439a6d27fb38e79adc22ba9c17b3858112fde0b22ddb2350170fd3dc08577ec747852bb6c11928801190d7aea58c1fe3f78e73bb8f435e6fb7fbc64686acaa4f4a12350b1a70e2904168e56adb24bfa74a599f7d24f42a2dc63191457ab84f3d3d2d22d7a36b53f6f5178ef07dcbcc71f0e58115803535353da8f0337835e0f6fc69c82ce7f6c7b43a2df2dc4738737104f0917d78f2b1ccf8ed0ba4543cb4aa4c2771a4518cf69df2a52a3de91cc65aa0851d66a486a4fe523c536cf1a8810d2ec3c4db9d17a7bb1ed801fa0f8b3b92c70229741a7b3872b3a3a9e8c7c0869ffe308e4d69ab0f0e7cfc40bddf4fa756019080affacb48110c666b9aa9cf7c6d1aaf1f8663fd8f7771347aee48052966892ca753c003845f76c487dcb2e99bc8be0892a6178f01f5f6171772e19f6023773d3eac03274fe80f1ae437742194d4cea6712de6bc11b1957773d8c9d7c80b79ce86ada15c0d69117244f64a94242e479c667d62c72878c4b2fdbcb8d99df0ac3e8370a882ab986d425a62f9f52b0738838338e6fea0acc9d86a749af68a5395be402875b14abf8128dd6f86f161915d6cca4183a98b42e6beb7a73ae4c151acd33bfad4d70b85268f55c0febdc3822813ac67b516f8722877c577bf608f7f34e34152937d0a70269cf4d4a13f0e393cb2ab33b5be80df96b9ca8a139e23b77e7c45b56f9c3bf7700b4bdbe73cfb1a6ed6517cbfd41328e82865f92daf9671071c71e02d9087b2abeb2c86109ec9eef5d0d268367189e8a3d0be19e90e6aa7c89e48212546a17d5cdef98968adb4a6253861d085c2f6703ccd7bd5fa83e7b658cfb3844336b739574acc0c133d7557c696483e893e81b65b83fd065707f5f22879b82095955e21bd30c4e168945ffca09698d1c410b74126b1a42ccaf845625917140013ac8af0ffd6824de49e0d61649f47cbe2f4a7e89ec0438bbf5a860f1feedbb1885cbb7de6184d0f087161a983d26efa7602d8794fcdf68a607f4a778a10f3f1f6426f3ed88c6c2ca87fec25139ade582d8b702662015d2180663ef28b7d6135b306513bda4a27ae07675f1025110583f14ceb56356fae04ba41d2f11edbace55fe40030389e4e45d0e98c0a2417df38e97e2916775e87cb35abed8afad22ebf73415e87ded87d0e6b6263034d4edd49fbe330dedc8217f8559b4313932d43b28e866f81b828b56217e7e60fb9fe7c931c4b4c8e8867c48750004345299947e8729eba4d7a5c3343ec1a73f413686ec7ec8ff6146085f8de90d42d30aff1965756ffc6b434a6c965d55b0a77828f46706ea82375237420c011d7886edffe4742253ed3deeb701527c38ead6ecd328f55e40947d2cab7b11656b328b869c71491d75cbec99c72f7f4a4a95cfd25edc45dd8c3573fac371d5f391d2910d23d837daae25e17762e46aeb8e203ac6acca4b0648a57b52b4a204f3e341d1ccab03a57341cfdaf2e6deed86bc2599c25f1c9b867873c70391f162029ed8ed98a6c3e420d3be703d4101b94909b82b659c29a188bb023347504b2fc3baed81e5a4ca2cf6962a76d47e08e8a8bcd9d66cb3ae85abae7e21afff9f5d638893cbc09ab7fa2e56cecfac70ed5cbe18f3f85ba12f694414ce4bf0bce4e00dfb34599b74d704eccf19fe824e6a2aae26d36e11db5b475970283905ee90b481366aab2988c63c437d8caee318ea1d243e2ca0990da6b9accfaa61299c66e9e40d18307873bed6c49db33a70b4ad764cabdccf7186cb8d93475c7cf8d26f77c455ec5eb17fd0006ca2c36196c3a8095c813a68d70578aa4e785b356093ce84ed478e38975a6203388faf35ab5a37a6995a5f5fbc0c274d380a0afd812f6add90b7647ec21b954f0649b6e8a3ae84c76dc8a2b253e3119d6216841ff57</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">请输入密码</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
